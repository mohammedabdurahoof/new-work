var sn = Object.defineProperty,
    un = Object.defineProperties;
var cn = Object.getOwnPropertyDescriptors;
var Ur = Object.getOwnPropertySymbols;
var _r = Object.prototype.hasOwnProperty,
    en = Object.prototype.propertyIsEnumerable;
var Jr = (_, _e, et) => _e in _ ? sn(_, _e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: et
    }) : _[_e] = et,
    kt = (_, _e) => {
        for (var et in _e || (_e = {})) _r.call(_e, et) && Jr(_, et, _e[et]);
        if (Ur)
            for (var et of Ur(_e)) en.call(_e, et) && Jr(_, et, _e[et]);
        return _
    },
    Bt = (_, _e) => un(_, cn(_e));
var Wt = (_, _e) => {
    var et = {};
    for (var tt in _) _r.call(_, tt) && _e.indexOf(tt) < 0 && (et[tt] = _[tt]);
    if (_ != null && Ur)
        for (var tt of Ur(_)) _e.indexOf(tt) < 0 && en.call(_, tt) && (et[tt] = _[tt]);
    return et
};
import {
    _ as __vitePreload
} from "./chunk-cf010ec4.js";
let baseIsMatch, baseGetAllKeys, getTag$1, nodeUtil$1, baseUnary, isBuffer$3, Stack, getAllKeys, arrayMap, baseIteratee, isTypedArray$2, isArguments$1, isFunction$1, SetCache, cacheHas, baseSlice, mapToArray, basePropertyOf, arrayFilter, Symbol$2, hasPath, Uint8Array$2, toFinite, WeakMap$2, baseGet, castPath, baseKeys, baseIsEqual, app, camelToDash, getMatchData, coreJsData$1, stubFalse, baseIsNative, baseMatches, baseMatchesProperty, setToArray, arraySome, baseProperty, hasIn, useForceUpdate$1, mix, moveItem, motion, motionValue, interpolate, useIsomorphicLayoutEffect$2, cancelFrame, frame, collectMotionValues, isMotionValue, createDomVisualElement, animations, gestureAnimations, drag, layout, animateValue, frameData, millisecondsToSeconds, invariant$1, progress, velocityPerSecond, defaultOffset, warning$1, MotionValue, transformProps, isCSSVariableName, baseSortedIndexBy, baseTimes, stringToPath$1, baseTrim, trimmedEndIndex, Set$2, chunk, sortedIndexBy, now$1, before, debounce, memoize$1, once$1, throttle, isLength, unescape$2, property, createMotionProxy, createDomMotionConfig, loadExternalIsValidProp, reactExports, MotionConfigContext, useConstant, loadFeatures, LazyContext, LayoutGroupContext, baseToString, easeInOut, addUniqueItem, removeItem, hasReducedMotionListener, initPrefersReducedMotion, prefersReducedMotion, memo, isSVGElement, SVGVisualElement, HTMLVisualElement, visualElementStore, DragControls, FlatTree, PresenceContext, SwitchLayoutGroupContext, addPointerEvent, addPointerInfo, addScaleCorrector, animationControls, anticipate, backIn, backInOut, backOut, buildTransform, calcLength, circIn, circInOut, circOut, clamp, color, complex, createDomMotionComponent, createMotionComponent, cubicBezier, delay$1, distance, distance2D, easeIn, spring, calcGeneratorDuration, maxGeneratorDuration, isEasingArray, fillOffset, secondsToMilliseconds, animateSingleValue, animateTarget, useUnmountEffect, addDomEvent, motionComponentSymbol, rootProjectionNode, instantAnimationState, optimizedAppearDataId, animateStyle, noop$4, makeUseVisualState, animateVisualElement, VisualElement, createBox, getOrigin, checkTargetForNewValues, MotionContext, easingDefinitionToFunction, stepsOrder, AnimatePresence, identity, Dialog, easeOut, filterProps, isBrowser$1, isDragActive, isValidMotionProp, mirrorEasing, optimizedAppearDataAttribute, pipe, px, resolveMotionValue, bc_ui, react_dom, ReactDOM, react, react_jsx_runtime, jsxRuntime, gsap, gsapWithCSS, react_router_dom, accountStore, systemStore, walletStore, settingStore, SuspenseSource, usePageContext, Empty, I18n, Link, useIsMobile, useLayoutSize, useMountedState, useLocalCurrency, useSetState, notify, Decimal$1, BC, Icon, reverseEasing, steps, useAnimation, useAnimationControls, useDragControls, useIsPresent, usePresence, reactDomExports, useI18n, useNavigate, Lottie, CloseIcon, Button2, lazyLoad, React, useAsync, AppProvider, WithOutSsr, useIsomorphicEffect, index$1, env, useIsDarken, http, HttpResponseError, socket, pop, isObject$2, howler, Loading$1, ScrollView, dialog, ErrorBoundary, ToggleView, useAccount, usePageProps, useSetting, Select$1, Pagination, Routes, Route, parsePath, Action, Router, createPath, useParams, CircleCountdown, createMemoryHistory, EventEmitter$3, Badge, commonjsGlobal$1, getDefaultExportFromCjs$1, Textarea, useIsActive, Linear, useAnimatedFrames, useLocation$1, valtio, LocationContext, DragDialog, I18nManager, I18nItem, getNative, getAugmentedNamespace$1, PQueue, F, Input, useOnClickOutside, Countdown$1, Pop, usePop, useDialog, Tabs$1, useResize, Portal, useSmoothList, Imgix, useForceUpdate, UpdateInView$1, Table, InputNumber, useWallet, Tooltip, DialogHeader, Breadcrumb, useAsyncNode, useIsFirstRender, DialogTable, InputPassword, useChangeLang, Switch$1, isObjectLike, minimal$3, userSocket, User, useToggleDarken, Radio, useDelayHover, TooltipBase, useAsyncFn, useRootClassName, useWindowSize, Overlayer, SuspenseData, useDisableBodyScroll, useInView, SelectBase, FlatList$1, LayoutSizeProvider, pickLazyComponent, useQrcode, useActiveMemo, Content, formateContent, AnimatedNumber, RadioBase, FileSelect, InputWrap, Slider, useLinkIntercept, isIndex, eq, isIterateeCall, isSymbol, jsxRuntimeExports, isPrototype, isArrayLike, keys$1, n0, arrayLikeKeys, get$1, overArg, root$1, baseGetTag, toInteger, toKey, toNumber, toString$5, getSymbols$1, stubArray, arrayPush, __tla = (async () => {
    function _mergeNamespaces(_, _e) {
        for (var et = 0; et < _e.length; et++) {
            const tt = _e[et];
            if (typeof tt != "string" && !Array.isArray(tt)) {
                for (const nt in tt)
                    if (nt !== "default" && !(nt in _)) {
                        const ot = Object.getOwnPropertyDescriptor(tt, nt);
                        ot && Object.defineProperty(_, nt, ot.get ? ot : {
                            enumerable: !0,
                            get: () => tt[nt]
                        })
                    }
            }
        }
        return Object.freeze(Object.defineProperty(_, Symbol.toStringTag, {
            value: "Module"
        }))
    }
    commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, getDefaultExportFromCjs$1 = function(_) {
        return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
    }, getAugmentedNamespace$1 = function(_) {
        if (_.__esModule) return _;
        var _e = _.default;
        if (typeof _e == "function") {
            var et = function tt() {
                return this instanceof tt ? Reflect.construct(_e, arguments, this.constructor) : _e.apply(this, arguments)
            };
            et.prototype = _e.prototype
        } else et = {};
        return Object.defineProperty(et, "__esModule", {
            value: !0
        }), Object.keys(_).forEach(function(tt) {
            var nt = Object.getOwnPropertyDescriptor(_, tt);
            Object.defineProperty(et, tt, nt.get ? nt : {
                enumerable: !0,
                get: function() {
                    return _[tt]
                }
            })
        }), et
    };
    var jsxRuntime$1 = {
            exports: {}
        },
        reactJsxRuntime_production_min = {},
        react$1 = {
            exports: {}
        },
        react_production_min = {},
        l$3 = Symbol.for("react.element"),
        n$3 = Symbol.for("react.portal"),
        p$4 = Symbol.for("react.fragment"),
        q$2 = Symbol.for("react.strict_mode"),
        r$3 = Symbol.for("react.profiler"),
        t$2 = Symbol.for("react.provider"),
        u$2 = Symbol.for("react.context"),
        v$2 = Symbol.for("react.forward_ref"),
        w$1 = Symbol.for("react.suspense"),
        x$1 = Symbol.for("react.memo"),
        y$5 = Symbol.for("react.lazy"),
        z$1 = Symbol.iterator;

    function A$1(_) {
        return _ === null || typeof _ != "object" ? null : (_ = z$1 && _[z$1] || _["@@iterator"], typeof _ == "function" ? _ : null)
    }
    var B$2 = {
            isMounted: function() {
                return !1
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        },
        C$2 = Object.assign,
        D$2 = {};

    function E$2(_, _e, et) {
        this.props = _, this.context = _e, this.refs = D$2, this.updater = et || B$2
    }
    E$2.prototype.isReactComponent = {}, E$2.prototype.setState = function(_, _e) {
        if (typeof _ != "object" && typeof _ != "function" && _ != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, _, _e, "setState")
    }, E$2.prototype.forceUpdate = function(_) {
        this.updater.enqueueForceUpdate(this, _, "forceUpdate")
    };

    function F$1() {}
    F$1.prototype = E$2.prototype;

    function G$1(_, _e, et) {
        this.props = _, this.context = _e, this.refs = D$2, this.updater = et || B$2
    }
    var H$1 = G$1.prototype = new F$1;
    H$1.constructor = G$1, C$2(H$1, E$2.prototype), H$1.isPureReactComponent = !0;
    var I$1 = Array.isArray,
        J = Object.prototype.hasOwnProperty,
        K$1 = {
            current: null
        },
        L$1 = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
        };

    function M$1(_, _e, et) {
        var tt, nt = {},
            ot = null,
            at = null;
        if (_e != null)
            for (tt in _e.ref !== void 0 && (at = _e.ref), _e.key !== void 0 && (ot = "" + _e.key), _e) J.call(_e, tt) && !L$1.hasOwnProperty(tt) && (nt[tt] = _e[tt]);
        var st = arguments.length - 2;
        if (st === 1) nt.children = et;
        else if (1 < st) {
            for (var lt = Array(st), ut = 0; ut < st; ut++) lt[ut] = arguments[ut + 2];
            nt.children = lt
        }
        if (_ && _.defaultProps)
            for (tt in st = _.defaultProps, st) nt[tt] === void 0 && (nt[tt] = st[tt]);
        return {
            $$typeof: l$3,
            type: _,
            key: ot,
            ref: at,
            props: nt,
            _owner: K$1.current
        }
    }

    function N$1(_, _e) {
        return {
            $$typeof: l$3,
            type: _.type,
            key: _e,
            ref: _.ref,
            props: _.props,
            _owner: _._owner
        }
    }

    function O$2(_) {
        return typeof _ == "object" && _ !== null && _.$$typeof === l$3
    }

    function escape$1(_) {
        var _e = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + _.replace(/[=:]/g, function(et) {
            return _e[et]
        })
    }
    var P$3 = /\/+/g;

    function Q$1(_, _e) {
        return typeof _ == "object" && _ !== null && _.key != null ? escape$1("" + _.key) : _e.toString(36)
    }

    function R$2(_, _e, et, tt, nt) {
        var ot = typeof _;
        (ot === "undefined" || ot === "boolean") && (_ = null);
        var at = !1;
        if (_ === null) at = !0;
        else switch (ot) {
            case "string":
            case "number":
                at = !0;
                break;
            case "object":
                switch (_.$$typeof) {
                    case l$3:
                    case n$3:
                        at = !0
                }
        }
        if (at) return at = _, nt = nt(at), _ = tt === "" ? "." + Q$1(at, 0) : tt, I$1(nt) ? (et = "", _ != null && (et = _.replace(P$3, "$&/") + "/"), R$2(nt, _e, et, "", function(ut) {
            return ut
        })) : nt != null && (O$2(nt) && (nt = N$1(nt, et + (!nt.key || at && at.key === nt.key ? "" : ("" + nt.key).replace(P$3, "$&/") + "/") + _)), _e.push(nt)), 1;
        if (at = 0, tt = tt === "" ? "." : tt + ":", I$1(_))
            for (var st = 0; st < _.length; st++) {
                ot = _[st];
                var lt = tt + Q$1(ot, st);
                at += R$2(ot, _e, et, lt, nt)
            } else if (lt = A$1(_), typeof lt == "function")
                for (_ = lt.call(_), st = 0; !(ot = _.next()).done;) ot = ot.value, lt = tt + Q$1(ot, st++), at += R$2(ot, _e, et, lt, nt);
            else if (ot === "object") throw _e = String(_), Error("Objects are not valid as a React child (found: " + (_e === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : _e) + "). If you meant to render a collection of children, use an array instead.");
        return at
    }

    function S$2(_, _e, et) {
        if (_ == null) return _;
        var tt = [],
            nt = 0;
        return R$2(_, tt, "", "", function(ot) {
            return _e.call(et, ot, nt++)
        }), tt
    }

    function T$2(_) {
        if (_._status === -1) {
            var _e = _._result;
            _e = _e(), _e.then(function(et) {
                (_._status === 0 || _._status === -1) && (_._status = 1, _._result = et)
            }, function(et) {
                (_._status === 0 || _._status === -1) && (_._status = 2, _._result = et)
            }), _._status === -1 && (_._status = 0, _._result = _e)
        }
        if (_._status === 1) return _._result.default;
        throw _._result
    }
    var U$2 = {
            current: null
        },
        V$2 = {
            transition: null
        },
        W$1 = {
            ReactCurrentDispatcher: U$2,
            ReactCurrentBatchConfig: V$2,
            ReactCurrentOwner: K$1
        };
    react_production_min.Children = {
        map: S$2,
        forEach: function(_, _e, et) {
            S$2(_, function() {
                _e.apply(this, arguments)
            }, et)
        },
        count: function(_) {
            var _e = 0;
            return S$2(_, function() {
                _e++
            }), _e
        },
        toArray: function(_) {
            return S$2(_, function(_e) {
                return _e
            }) || []
        },
        only: function(_) {
            if (!O$2(_)) throw Error("React.Children.only expected to receive a single React element child.");
            return _
        }
    }, react_production_min.Component = E$2, react_production_min.Fragment = p$4, react_production_min.Profiler = r$3, react_production_min.PureComponent = G$1, react_production_min.StrictMode = q$2, react_production_min.Suspense = w$1, react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1, react_production_min.cloneElement = function(_, _e, et) {
        if (_ == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + _ + ".");
        var tt = C$2({}, _.props),
            nt = _.key,
            ot = _.ref,
            at = _._owner;
        if (_e != null) {
            if (_e.ref !== void 0 && (ot = _e.ref, at = K$1.current), _e.key !== void 0 && (nt = "" + _e.key), _.type && _.type.defaultProps) var st = _.type.defaultProps;
            for (lt in _e) J.call(_e, lt) && !L$1.hasOwnProperty(lt) && (tt[lt] = _e[lt] === void 0 && st !== void 0 ? st[lt] : _e[lt])
        }
        var lt = arguments.length - 2;
        if (lt === 1) tt.children = et;
        else if (1 < lt) {
            st = Array(lt);
            for (var ut = 0; ut < lt; ut++) st[ut] = arguments[ut + 2];
            tt.children = st
        }
        return {
            $$typeof: l$3,
            type: _.type,
            key: nt,
            ref: ot,
            props: tt,
            _owner: at
        }
    }, react_production_min.createContext = function(_) {
        return _ = {
            $$typeof: u$2,
            _currentValue: _,
            _currentValue2: _,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        }, _.Provider = {
            $$typeof: t$2,
            _context: _
        }, _.Consumer = _
    }, react_production_min.createElement = M$1, react_production_min.createFactory = function(_) {
        var _e = M$1.bind(null, _);
        return _e.type = _, _e
    }, react_production_min.createRef = function() {
        return {
            current: null
        }
    }, react_production_min.forwardRef = function(_) {
        return {
            $$typeof: v$2,
            render: _
        }
    }, react_production_min.isValidElement = O$2, react_production_min.lazy = function(_) {
        return {
            $$typeof: y$5,
            _payload: {
                _status: -1,
                _result: _
            },
            _init: T$2
        }
    }, react_production_min.memo = function(_, _e) {
        return {
            $$typeof: x$1,
            type: _,
            compare: _e === void 0 ? null : _e
        }
    }, react_production_min.startTransition = function(_) {
        var _e = V$2.transition;
        V$2.transition = {};
        try {
            _()
        } finally {
            V$2.transition = _e
        }
    }, react_production_min.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.")
    }, react_production_min.useCallback = function(_, _e) {
        return U$2.current.useCallback(_, _e)
    }, react_production_min.useContext = function(_) {
        return U$2.current.useContext(_)
    }, react_production_min.useDebugValue = function() {}, react_production_min.useDeferredValue = function(_) {
        return U$2.current.useDeferredValue(_)
    }, react_production_min.useEffect = function(_, _e) {
        return U$2.current.useEffect(_, _e)
    }, react_production_min.useId = function() {
        return U$2.current.useId()
    }, react_production_min.useImperativeHandle = function(_, _e, et) {
        return U$2.current.useImperativeHandle(_, _e, et)
    }, react_production_min.useInsertionEffect = function(_, _e) {
        return U$2.current.useInsertionEffect(_, _e)
    }, react_production_min.useLayoutEffect = function(_, _e) {
        return U$2.current.useLayoutEffect(_, _e)
    }, react_production_min.useMemo = function(_, _e) {
        return U$2.current.useMemo(_, _e)
    }, react_production_min.useReducer = function(_, _e, et) {
        return U$2.current.useReducer(_, _e, et)
    }, react_production_min.useRef = function(_) {
        return U$2.current.useRef(_)
    }, react_production_min.useState = function(_) {
        return U$2.current.useState(_)
    }, react_production_min.useSyncExternalStore = function(_, _e, et) {
        return U$2.current.useSyncExternalStore(_, _e, et)
    }, react_production_min.useTransition = function() {
        return U$2.current.useTransition()
    }, react_production_min.version = "18.2.0", react$1.exports = react_production_min, reactExports = react$1.exports, React = getDefaultExportFromCjs$1(reactExports), react = _mergeNamespaces({
        __proto__: null,
        default: React
    }, [reactExports]);
    var f$3 = reactExports,
        k = Symbol.for("react.element"),
        l$2 = Symbol.for("react.fragment"),
        m$4 = Object.prototype.hasOwnProperty,
        n$2 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
        p$3 = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
        };

    function q$1(_, _e, et) {
        var tt, nt = {},
            ot = null,
            at = null;
        et !== void 0 && (ot = "" + et), _e.key !== void 0 && (ot = "" + _e.key), _e.ref !== void 0 && (at = _e.ref);
        for (tt in _e) m$4.call(_e, tt) && !p$3.hasOwnProperty(tt) && (nt[tt] = _e[tt]);
        if (_ && _.defaultProps)
            for (tt in _e = _.defaultProps, _e) nt[tt] === void 0 && (nt[tt] = _e[tt]);
        return {
            $$typeof: k,
            type: _,
            key: ot,
            ref: at,
            props: nt,
            _owner: n$2.current
        }
    }
    reactJsxRuntime_production_min.Fragment = l$2, reactJsxRuntime_production_min.jsx = q$1, reactJsxRuntime_production_min.jsxs = q$1, jsxRuntime$1.exports = reactJsxRuntime_production_min, jsxRuntimeExports = jsxRuntime$1.exports, jsxRuntime = getDefaultExportFromCjs$1(jsxRuntimeExports), react_jsx_runtime = _mergeNamespaces({
        __proto__: null,
        default: jsxRuntime
    }, [jsxRuntimeExports]);

    function _assertThisInitialized(_) {
        if (_ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return _
    }

    function _inheritsLoose(_, _e) {
        _.prototype = Object.create(_e.prototype), _.prototype.constructor = _, _.__proto__ = _e
    }
    var _config = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        _defaults = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        _suppressOverwrites, _reverting$1, _context, _bigNum$1 = 1e8,
        _tinyNum = 1 / _bigNum$1,
        _2PI = Math.PI * 2,
        _HALF_PI = _2PI / 4,
        _gsID = 0,
        _sqrt = Math.sqrt,
        _cos = Math.cos,
        _sin = Math.sin,
        _isString = function(_) {
            return typeof _ == "string"
        },
        _isFunction = function(_) {
            return typeof _ == "function"
        },
        _isNumber = function(_) {
            return typeof _ == "number"
        },
        _isUndefined = function(_) {
            return typeof _ > "u"
        },
        _isObject = function(_) {
            return typeof _ == "object"
        },
        _isNotFalse = function(_) {
            return _ !== !1
        },
        _windowExists$1 = function() {
            return typeof window < "u"
        },
        _isFuncOrString = function(_) {
            return _isFunction(_) || _isString(_)
        },
        _isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
        _isArray = Array.isArray,
        _strictNumExp = /(?:-?\.?\d|\.)+/gi,
        _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        _relExp = /[+-]=-?[.\d]+/,
        _delimitedValueExp = /[^,'"\[\]\s]+/gi,
        _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        _globalTimeline, _win$1, _coreInitted, _doc$1, _globals = {},
        _installScope = {},
        _coreReady, _install = function(_) {
            return (_installScope = _merge(_, _globals)) && gsap$1
        },
        _missingPlugin = function(_, _e) {
            return console.warn("Invalid property", _, "set to", _e, "Missing plugin? gsap.registerPlugin()")
        },
        _warn = function(_, _e) {
            return !_e && console.warn(_)
        },
        _addGlobal = function(_, _e) {
            return _ && (_globals[_] = _e) && _installScope && (_installScope[_] = _e) || _globals
        },
        _emptyFunc = function() {
            return 0
        },
        _startAtRevertConfig = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        },
        _revertConfigNoKill = {
            suppressEvents: !0,
            kill: !1
        },
        _revertConfig = {
            suppressEvents: !0
        },
        _reservedProps = {},
        _lazyTweens = [],
        _lazyLookup = {},
        _lastRenderedFrame, _plugins = {},
        _effects = {},
        _nextGCFrame = 30,
        _harnessPlugins = [],
        _callbackNames = "",
        _harness = function(_) {
            var _e = _[0],
                et, tt;
            if (_isObject(_e) || _isFunction(_e) || (_ = [_]), !(et = (_e._gsap || {}).harness)) {
                for (tt = _harnessPlugins.length; tt-- && !_harnessPlugins[tt].targetTest(_e););
                et = _harnessPlugins[tt]
            }
            for (tt = _.length; tt--;) _[tt] && (_[tt]._gsap || (_[tt]._gsap = new GSCache(_[tt], et))) || _.splice(tt, 1);
            return _
        },
        _getCache = function(_) {
            return _._gsap || _harness(toArray$2(_))[0]._gsap
        },
        _getProperty = function(_, _e, et) {
            return (et = _[_e]) && _isFunction(et) ? _[_e]() : _isUndefined(et) && _.getAttribute && _.getAttribute(_e) || et
        },
        _forEachName = function(_, _e) {
            return (_ = _.split(",")).forEach(_e) || _
        },
        _round = function(_) {
            return Math.round(_ * 1e5) / 1e5 || 0
        },
        _roundPrecise = function(_) {
            return Math.round(_ * 1e7) / 1e7 || 0
        },
        _parseRelative = function(_, _e) {
            var et = _e.charAt(0),
                tt = parseFloat(_e.substr(2));
            return _ = parseFloat(_), et === "+" ? _ + tt : et === "-" ? _ - tt : et === "*" ? _ * tt : _ / tt
        },
        _arrayContainsAny = function(_, _e) {
            for (var et = _e.length, tt = 0; _.indexOf(_e[tt]) < 0 && ++tt < et;);
            return tt < et
        },
        _lazyRender = function() {
            var _ = _lazyTweens.length,
                _e = _lazyTweens.slice(0),
                et, tt;
            for (_lazyLookup = {}, _lazyTweens.length = 0, et = 0; et < _; et++) tt = _e[et], tt && tt._lazy && (tt.render(tt._lazy[0], tt._lazy[1], !0)._lazy = 0)
        },
        _lazySafeRender = function(_, _e, et, tt) {
            _lazyTweens.length && !_reverting$1 && _lazyRender(), _.render(_e, et, tt || _reverting$1 && _e < 0 && (_._initted || _._startAt)), _lazyTweens.length && !_reverting$1 && _lazyRender()
        },
        _numericIfPossible = function(_) {
            var _e = parseFloat(_);
            return (_e || _e === 0) && (_ + "").match(_delimitedValueExp).length < 2 ? _e : _isString(_) ? _.trim() : _
        },
        _passThrough = function(_) {
            return _
        },
        _setDefaults = function(_, _e) {
            for (var et in _e) et in _ || (_[et] = _e[et]);
            return _
        },
        _setKeyframeDefaults = function(_) {
            return function(_e, et) {
                for (var tt in et) tt in _e || tt === "duration" && _ || tt === "ease" || (_e[tt] = et[tt])
            }
        },
        _merge = function(_, _e) {
            for (var et in _e) _[et] = _e[et];
            return _
        },
        _mergeDeep = function _(_e, et) {
            for (var tt in et) tt !== "__proto__" && tt !== "constructor" && tt !== "prototype" && (_e[tt] = _isObject(et[tt]) ? _(_e[tt] || (_e[tt] = {}), et[tt]) : et[tt]);
            return _e
        },
        _copyExcluding = function(_, _e) {
            var et = {},
                tt;
            for (tt in _) tt in _e || (et[tt] = _[tt]);
            return et
        },
        _inheritDefaults = function(_) {
            var _e = _.parent || _globalTimeline,
                et = _.keyframes ? _setKeyframeDefaults(_isArray(_.keyframes)) : _setDefaults;
            if (_isNotFalse(_.inherit))
                for (; _e;) et(_, _e.vars.defaults), _e = _e.parent || _e._dp;
            return _
        },
        _arraysMatch = function(_, _e) {
            for (var et = _.length, tt = et === _e.length; tt && et-- && _[et] === _e[et];);
            return et < 0
        },
        _addLinkedListItem = function(_, _e, et, tt, nt) {
            et === void 0 && (et = "_first"), tt === void 0 && (tt = "_last");
            var ot = _[tt],
                at;
            if (nt)
                for (at = _e[nt]; ot && ot[nt] > at;) ot = ot._prev;
            return ot ? (_e._next = ot._next, ot._next = _e) : (_e._next = _[et], _[et] = _e), _e._next ? _e._next._prev = _e : _[tt] = _e, _e._prev = ot, _e.parent = _e._dp = _, _e
        },
        _removeLinkedListItem = function(_, _e, et, tt) {
            et === void 0 && (et = "_first"), tt === void 0 && (tt = "_last");
            var nt = _e._prev,
                ot = _e._next;
            nt ? nt._next = ot : _[et] === _e && (_[et] = ot), ot ? ot._prev = nt : _[tt] === _e && (_[tt] = nt), _e._next = _e._prev = _e.parent = null
        },
        _removeFromParent = function(_, _e) {
            _.parent && (!_e || _.parent.autoRemoveChildren) && _.parent.remove && _.parent.remove(_), _._act = 0
        },
        _uncache = function(_, _e) {
            if (_ && (!_e || _e._end > _._dur || _e._start < 0))
                for (var et = _; et;) et._dirty = 1, et = et.parent;
            return _
        },
        _recacheAncestors = function(_) {
            for (var _e = _.parent; _e && _e.parent;) _e._dirty = 1, _e.totalDuration(), _e = _e.parent;
            return _
        },
        _rewindStartAt = function(_, _e, et, tt) {
            return _._startAt && (_reverting$1 ? _._startAt.revert(_revertConfigNoKill) : _.vars.immediateRender && !_.vars.autoRevert || _._startAt.render(_e, !0, tt))
        },
        _hasNoPausedAncestors = function _(_e) {
            return !_e || _e._ts && _(_e.parent)
        },
        _elapsedCycleDuration = function(_) {
            return _._repeat ? _animationCycle(_._tTime, _ = _.duration() + _._rDelay) * _ : 0
        },
        _animationCycle = function(_, _e) {
            var et = Math.floor(_ /= _e);
            return _ && et === _ ? et - 1 : et
        },
        _parentToChildTotalTime = function(_, _e) {
            return (_ - _e._start) * _e._ts + (_e._ts >= 0 ? 0 : _e._dirty ? _e.totalDuration() : _e._tDur)
        },
        _setEnd = function(_) {
            return _._end = _roundPrecise(_._start + (_._tDur / Math.abs(_._ts || _._rts || _tinyNum) || 0))
        },
        _alignPlayhead = function(_, _e) {
            var et = _._dp;
            return et && et.smoothChildTiming && _._ts && (_._start = _roundPrecise(et._time - (_._ts > 0 ? _e / _._ts : ((_._dirty ? _.totalDuration() : _._tDur) - _e) / -_._ts)), _setEnd(_), et._dirty || _uncache(et, _)), _
        },
        _postAddChecks = function(_, _e) {
            var et;
            if ((_e._time || !_e._dur && _e._initted || _e._start < _._time && (_e._dur || !_e.add)) && (et = _parentToChildTotalTime(_.rawTime(), _e), (!_e._dur || _clamp(0, _e.totalDuration(), et) - _e._tTime > _tinyNum) && _e.render(et, !0)), _uncache(_, _e)._dp && _._initted && _._time >= _._dur && _._ts) {
                if (_._dur < _.duration())
                    for (et = _; et._dp;) et.rawTime() >= 0 && et.totalTime(et._tTime), et = et._dp;
                _._zTime = -_tinyNum
            }
        },
        _addToTimeline = function(_, _e, et, tt) {
            return _e.parent && _removeFromParent(_e), _e._start = _roundPrecise((_isNumber(et) ? et : et || _ !== _globalTimeline ? _parsePosition(_, et, _e) : _._time) + _e._delay), _e._end = _roundPrecise(_e._start + (_e.totalDuration() / Math.abs(_e.timeScale()) || 0)), _addLinkedListItem(_, _e, "_first", "_last", _._sort ? "_start" : 0), _isFromOrFromStart(_e) || (_._recent = _e), tt || _postAddChecks(_, _e), _._ts < 0 && _alignPlayhead(_, _._tTime), _
        },
        _scrollTrigger = function(_, _e) {
            return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", _e)) && _globals.ScrollTrigger.create(_e, _)
        },
        _attemptInitTween = function(_, _e, et, tt, nt) {
            if (_initTween(_, _e, nt), !_._initted) return 1;
            if (!et && _._pt && !_reverting$1 && (_._dur && _.vars.lazy !== !1 || !_._dur && _.vars.lazy) && _lastRenderedFrame !== _ticker.frame) return _lazyTweens.push(_), _._lazy = [nt, tt], 1
        },
        _parentPlayheadIsBeforeStart = function _(_e) {
            var et = _e.parent;
            return et && et._ts && et._initted && !et._lock && (et.rawTime() < 0 || _(et))
        },
        _isFromOrFromStart = function(_) {
            var _e = _.data;
            return _e === "isFromStart" || _e === "isStart"
        },
        _renderZeroDurationTween = function(_, _e, et, tt) {
            var nt = _.ratio,
                ot = _e < 0 || !_e && (!_._start && _parentPlayheadIsBeforeStart(_) && !(!_._initted && _isFromOrFromStart(_)) || (_._ts < 0 || _._dp._ts < 0) && !_isFromOrFromStart(_)) ? 0 : 1,
                at = _._rDelay,
                st = 0,
                lt, ut, dt;
            if (at && _._repeat && (st = _clamp(0, _._tDur, _e), ut = _animationCycle(st, at), _._yoyo && ut & 1 && (ot = 1 - ot), ut !== _animationCycle(_._tTime, at) && (nt = 1 - ot, _.vars.repeatRefresh && _._initted && _.invalidate())), ot !== nt || _reverting$1 || tt || _._zTime === _tinyNum || !_e && _._zTime) {
                if (!_._initted && _attemptInitTween(_, _e, tt, et, st)) return;
                for (dt = _._zTime, _._zTime = _e || (et ? _tinyNum : 0), et || (et = _e && !dt), _.ratio = ot, _._from && (ot = 1 - ot), _._time = 0, _._tTime = st, lt = _._pt; lt;) lt.r(ot, lt.d), lt = lt._next;
                _e < 0 && _rewindStartAt(_, _e, et, !0), _._onUpdate && !et && _callback(_, "onUpdate"), st && _._repeat && !et && _.parent && _callback(_, "onRepeat"), (_e >= _._tDur || _e < 0) && _.ratio === ot && (ot && _removeFromParent(_, 1), !et && !_reverting$1 && (_callback(_, ot ? "onComplete" : "onReverseComplete", !0), _._prom && _._prom()))
            } else _._zTime || (_._zTime = _e)
        },
        _findNextPauseTween = function(_, _e, et) {
            var tt;
            if (et > _e)
                for (tt = _._first; tt && tt._start <= et;) {
                    if (tt.data === "isPause" && tt._start > _e) return tt;
                    tt = tt._next
                } else
                    for (tt = _._last; tt && tt._start >= et;) {
                        if (tt.data === "isPause" && tt._start < _e) return tt;
                        tt = tt._prev
                    }
        },
        _setDuration = function(_, _e, et, tt) {
            var nt = _._repeat,
                ot = _roundPrecise(_e) || 0,
                at = _._tTime / _._tDur;
            return at && !tt && (_._time *= ot / _._dur), _._dur = ot, _._tDur = nt ? nt < 0 ? 1e10 : _roundPrecise(ot * (nt + 1) + _._rDelay * nt) : ot, at > 0 && !tt && _alignPlayhead(_, _._tTime = _._tDur * at), _.parent && _setEnd(_), et || _uncache(_.parent, _), _
        },
        _onUpdateTotalDuration = function(_) {
            return _ instanceof Timeline ? _uncache(_) : _setDuration(_, _._dur)
        },
        _zeroPosition = {
            _start: 0,
            endTime: _emptyFunc,
            totalDuration: _emptyFunc
        },
        _parsePosition = function _(_e, et, tt) {
            var nt = _e.labels,
                ot = _e._recent || _zeroPosition,
                at = _e.duration() >= _bigNum$1 ? ot.endTime(!1) : _e._dur,
                st, lt, ut;
            return _isString(et) && (isNaN(et) || et in nt) ? (lt = et.charAt(0), ut = et.substr(-1) === "%", st = et.indexOf("="), lt === "<" || lt === ">" ? (st >= 0 && (et = et.replace(/=/, "")), (lt === "<" ? ot._start : ot.endTime(ot._repeat >= 0)) + (parseFloat(et.substr(1)) || 0) * (ut ? (st < 0 ? ot : tt).totalDuration() / 100 : 1)) : st < 0 ? (et in nt || (nt[et] = at), nt[et]) : (lt = parseFloat(et.charAt(st - 1) + et.substr(st + 1)), ut && tt && (lt = lt / 100 * (_isArray(tt) ? tt[0] : tt).totalDuration()), st > 1 ? _(_e, et.substr(0, st - 1), tt) + lt : at + lt)) : et == null ? at : +et
        },
        _createTweenType = function(_, _e, et) {
            var tt = _isNumber(_e[1]),
                nt = (tt ? 2 : 1) + (_ < 2 ? 0 : 1),
                ot = _e[nt],
                at, st;
            if (tt && (ot.duration = _e[1]), ot.parent = et, _) {
                for (at = ot, st = et; st && !("immediateRender" in at);) at = st.vars.defaults || {}, st = _isNotFalse(st.vars.inherit) && st.parent;
                ot.immediateRender = _isNotFalse(at.immediateRender), _ < 2 ? ot.runBackwards = 1 : ot.startAt = _e[nt - 1]
            }
            return new Tween(_e[0], ot, _e[nt + 1])
        },
        _conditionalReturn = function(_, _e) {
            return _ || _ === 0 ? _e(_) : _e
        },
        _clamp = function(_, _e, et) {
            return et < _ ? _ : et > _e ? _e : et
        },
        getUnit = function(_, _e) {
            return !_isString(_) || !(_e = _unitExp.exec(_)) ? "" : _e[1]
        },
        clamp$1 = function(_, _e, et) {
            return _conditionalReturn(et, function(tt) {
                return _clamp(_, _e, tt)
            })
        },
        _slice = [].slice,
        _isArrayLike = function(_, _e) {
            return _ && _isObject(_) && "length" in _ && (!_e && !_.length || _.length - 1 in _ && _isObject(_[0])) && !_.nodeType && _ !== _win$1
        },
        _flatten = function(_, _e, et) {
            return et === void 0 && (et = []), _.forEach(function(tt) {
                var nt;
                return _isString(tt) && !_e || _isArrayLike(tt, 1) ? (nt = et).push.apply(nt, toArray$2(tt)) : et.push(tt)
            }) || et
        },
        toArray$2 = function(_, _e, et) {
            return _context && !_e && _context.selector ? _context.selector(_) : _isString(_) && !et && (_coreInitted || !_wake()) ? _slice.call((_e || _doc$1).querySelectorAll(_), 0) : _isArray(_) ? _flatten(_, et) : _isArrayLike(_) ? _slice.call(_, 0) : _ ? [_] : []
        },
        selector = function(_) {
            return _ = toArray$2(_)[0] || _warn("Invalid scope") || {},
                function(_e) {
                    var et = _.current || _.nativeElement || _;
                    return toArray$2(_e, et.querySelectorAll ? et : et === _ ? _warn("Invalid scope") || _doc$1.createElement("div") : _)
                }
        },
        shuffle = function(_) {
            return _.sort(function() {
                return .5 - Math.random()
            })
        },
        distribute = function(_) {
            if (_isFunction(_)) return _;
            var _e = _isObject(_) ? _ : {
                    each: _
                },
                et = _parseEase(_e.ease),
                tt = _e.from || 0,
                nt = parseFloat(_e.base) || 0,
                ot = {},
                at = tt > 0 && tt < 1,
                st = isNaN(tt) || at,
                lt = _e.axis,
                ut = tt,
                dt = tt;
            return _isString(tt) ? ut = dt = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[tt] || 0 : !at && st && (ut = tt[0], dt = tt[1]),
                function(ct, pt, ft) {
                    var ht = (ft || _e).length,
                        mt = ot[ht],
                        bt, gt, vt, xt, yt, Et, wt, St, $t;
                    if (!mt) {
                        if ($t = _e.grid === "auto" ? 0 : (_e.grid || [1, _bigNum$1])[1], !$t) {
                            for (wt = -_bigNum$1; wt < (wt = ft[$t++].getBoundingClientRect().left) && $t < ht;);
                            $t < ht && $t--
                        }
                        for (mt = ot[ht] = [], bt = st ? Math.min($t, ht) * ut - .5 : tt % $t, gt = $t === _bigNum$1 ? 0 : st ? ht * dt / $t - .5 : tt / $t | 0, wt = 0, St = _bigNum$1, Et = 0; Et < ht; Et++) vt = Et % $t - bt, xt = gt - (Et / $t | 0), mt[Et] = yt = lt ? Math.abs(lt === "y" ? xt : vt) : _sqrt(vt * vt + xt * xt), yt > wt && (wt = yt), yt < St && (St = yt);
                        tt === "random" && shuffle(mt), mt.max = wt - St, mt.min = St, mt.v = ht = (parseFloat(_e.amount) || parseFloat(_e.each) * ($t > ht ? ht - 1 : lt ? lt === "y" ? ht / $t : $t : Math.max($t, ht / $t)) || 0) * (tt === "edges" ? -1 : 1), mt.b = ht < 0 ? nt - ht : nt, mt.u = getUnit(_e.amount || _e.each) || 0, et = et && ht < 0 ? _invertEase(et) : et
                    }
                    return ht = (mt[ct] - mt.min) / mt.max || 0, _roundPrecise(mt.b + (et ? et(ht) : ht) * mt.v) + mt.u
                }
        },
        _roundModifier = function(_) {
            var _e = Math.pow(10, ((_ + "").split(".")[1] || "").length);
            return function(et) {
                var tt = _roundPrecise(Math.round(parseFloat(et) / _) * _ * _e);
                return (tt - tt % 1) / _e + (_isNumber(et) ? 0 : getUnit(et))
            }
        },
        snap = function(_, _e) {
            var et = _isArray(_),
                tt, nt;
            return !et && _isObject(_) && (tt = et = _.radius || _bigNum$1, _.values ? (_ = toArray$2(_.values), (nt = !_isNumber(_[0])) && (tt *= tt)) : _ = _roundModifier(_.increment)), _conditionalReturn(_e, et ? _isFunction(_) ? function(ot) {
                return nt = _(ot), Math.abs(nt - ot) <= tt ? nt : ot
            } : function(ot) {
                for (var at = parseFloat(nt ? ot.x : ot), st = parseFloat(nt ? ot.y : 0), lt = _bigNum$1, ut = 0, dt = _.length, ct, pt; dt--;) nt ? (ct = _[dt].x - at, pt = _[dt].y - st, ct = ct * ct + pt * pt) : ct = Math.abs(_[dt] - at), ct < lt && (lt = ct, ut = dt);
                return ut = !tt || lt <= tt ? _[ut] : ot, nt || ut === ot || _isNumber(ot) ? ut : ut + getUnit(ot)
            } : _roundModifier(_))
        },
        random$1 = function(_, _e, et, tt) {
            return _conditionalReturn(_isArray(_) ? !_e : et === !0 ? !!(et = 0) : !tt, function() {
                return _isArray(_) ? _[~~(Math.random() * _.length)] : (et = et || 1e-5) && (tt = et < 1 ? Math.pow(10, (et + "").length - 2) : 1) && Math.floor(Math.round((_ - et / 2 + Math.random() * (_e - _ + et * .99)) / et) * et * tt) / tt
            })
        },
        pipe$1 = function() {
            for (var _ = arguments.length, _e = new Array(_), et = 0; et < _; et++) _e[et] = arguments[et];
            return function(tt) {
                return _e.reduce(function(nt, ot) {
                    return ot(nt)
                }, tt)
            }
        },
        unitize = function(_, _e) {
            return function(et) {
                return _(parseFloat(et)) + (_e || getUnit(et))
            }
        },
        normalize = function(_, _e, et) {
            return mapRange(_, _e, 0, 1, et)
        },
        _wrapArray = function(_, _e, et) {
            return _conditionalReturn(et, function(tt) {
                return _[~~_e(tt)]
            })
        },
        wrap = function _(_e, et, tt) {
            var nt = et - _e;
            return _isArray(_e) ? _wrapArray(_e, _(0, _e.length), et) : _conditionalReturn(tt, function(ot) {
                return (nt + (ot - _e) % nt) % nt + _e
            })
        },
        wrapYoyo = function _(_e, et, tt) {
            var nt = et - _e,
                ot = nt * 2;
            return _isArray(_e) ? _wrapArray(_e, _(0, _e.length - 1), et) : _conditionalReturn(tt, function(at) {
                return at = (ot + (at - _e) % ot) % ot || 0, _e + (at > nt ? ot - at : at)
            })
        },
        _replaceRandom = function(_) {
            for (var _e = 0, et = "", tt, nt, ot, at; ~(tt = _.indexOf("random(", _e));) ot = _.indexOf(")", tt), at = _.charAt(tt + 7) === "[", nt = _.substr(tt + 7, ot - tt - 7).match(at ? _delimitedValueExp : _strictNumExp), et += _.substr(_e, tt - _e) + random$1(at ? nt : +nt[0], at ? 0 : +nt[1], +nt[2] || 1e-5), _e = ot + 1;
            return et + _.substr(_e, _.length - _e)
        },
        mapRange = function(_, _e, et, tt, nt) {
            var ot = _e - _,
                at = tt - et;
            return _conditionalReturn(nt, function(st) {
                return et + ((st - _) / ot * at || 0)
            })
        },
        interpolate$1 = function _(_e, et, tt, nt) {
            var ot = isNaN(_e + et) ? 0 : function(ft) {
                return (1 - ft) * _e + ft * et
            };
            if (!ot) {
                var at = _isString(_e),
                    st = {},
                    lt, ut, dt, ct, pt;
                if (tt === !0 && (nt = 1) && (tt = null), at) _e = {
                    p: _e
                }, et = {
                    p: et
                };
                else if (_isArray(_e) && !_isArray(et)) {
                    for (dt = [], ct = _e.length, pt = ct - 2, ut = 1; ut < ct; ut++) dt.push(_(_e[ut - 1], _e[ut]));
                    ct--, ot = function(ft) {
                        ft *= ct;
                        var ht = Math.min(pt, ~~ft);
                        return dt[ht](ft - ht)
                    }, tt = et
                } else nt || (_e = _merge(_isArray(_e) ? [] : {}, _e));
                if (!dt) {
                    for (lt in et) _addPropTween.call(st, _e, lt, "get", et[lt]);
                    ot = function(ft) {
                        return _renderPropTweens(ft, st) || (at ? _e.p : _e)
                    }
                }
            }
            return _conditionalReturn(tt, ot)
        },
        _getLabelInDirection = function(_, _e, et) {
            var tt = _.labels,
                nt = _bigNum$1,
                ot, at, st;
            for (ot in tt) at = tt[ot] - _e, at < 0 == !!et && at && nt > (at = Math.abs(at)) && (st = ot, nt = at);
            return st
        },
        _callback = function(_, _e, et) {
            var tt = _.vars,
                nt = tt[_e],
                ot = _context,
                at = _._ctx,
                st, lt, ut;
            if (nt) return st = tt[_e + "Params"], lt = tt.callbackScope || _, et && _lazyTweens.length && _lazyRender(), at && (_context = at), ut = st ? nt.apply(lt, st) : nt.call(lt), _context = ot, ut
        },
        _interrupt = function(_) {
            return _removeFromParent(_), _.scrollTrigger && _.scrollTrigger.kill(!!_reverting$1), _.progress() < 1 && _callback(_, "onInterrupt"), _
        },
        _quickTween, _registerPluginQueue = [],
        _createPlugin = function(_) {
            if (_windowExists$1() && _) {
                _ = !_.name && _.default || _;
                var _e = _.name,
                    et = _isFunction(_),
                    tt = _e && !et && _.init ? function() {
                        this._props = []
                    } : _,
                    nt = {
                        init: _emptyFunc,
                        render: _renderPropTweens,
                        add: _addPropTween,
                        kill: _killPropTweensOf,
                        modifier: _addPluginModifier,
                        rawVars: 0
                    },
                    ot = {
                        targetTest: 0,
                        get: 0,
                        getSetter: _getSetter,
                        aliases: {},
                        register: 0
                    };
                if (_wake(), _ !== tt) {
                    if (_plugins[_e]) return;
                    _setDefaults(tt, _setDefaults(_copyExcluding(_, nt), ot)), _merge(tt.prototype, _merge(nt, _copyExcluding(_, ot))), _plugins[tt.prop = _e] = tt, _.targetTest && (_harnessPlugins.push(tt), _reservedProps[_e] = 1), _e = (_e === "css" ? "CSS" : _e.charAt(0).toUpperCase() + _e.substr(1)) + "Plugin"
                }
                _addGlobal(_e, tt), _.register && _.register(gsap$1, tt, PropTween)
            } else _ && _registerPluginQueue.push(_)
        },
        _255 = 255,
        _colorLookup = {
            aqua: [0, _255, _255],
            lime: [0, _255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, _255],
            navy: [0, 0, 128],
            white: [_255, _255, _255],
            olive: [128, 128, 0],
            yellow: [_255, _255, 0],
            orange: [_255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [_255, 0, 0],
            pink: [_255, 192, 203],
            cyan: [0, _255, _255],
            transparent: [_255, _255, _255, 0]
        },
        _hue = function(_, _e, et) {
            return _ += _ < 0 ? 1 : _ > 1 ? -1 : 0, (_ * 6 < 1 ? _e + (et - _e) * _ * 6 : _ < .5 ? et : _ * 3 < 2 ? _e + (et - _e) * (2 / 3 - _) * 6 : _e) * _255 + .5 | 0
        },
        splitColor$1 = function(_, _e, et) {
            var tt = _ ? _isNumber(_) ? [_ >> 16, _ >> 8 & _255, _ & _255] : 0 : _colorLookup.black,
                nt, ot, at, st, lt, ut, dt, ct, pt, ft;
            if (!tt) {
                if (_.substr(-1) === "," && (_ = _.substr(0, _.length - 1)), _colorLookup[_]) tt = _colorLookup[_];
                else if (_.charAt(0) === "#") {
                    if (_.length < 6 && (nt = _.charAt(1), ot = _.charAt(2), at = _.charAt(3), _ = "#" + nt + nt + ot + ot + at + at + (_.length === 5 ? _.charAt(4) + _.charAt(4) : "")), _.length === 9) return tt = parseInt(_.substr(1, 6), 16), [tt >> 16, tt >> 8 & _255, tt & _255, parseInt(_.substr(7), 16) / 255];
                    _ = parseInt(_.substr(1), 16), tt = [_ >> 16, _ >> 8 & _255, _ & _255]
                } else if (_.substr(0, 3) === "hsl") {
                    if (tt = ft = _.match(_strictNumExp), !_e) st = +tt[0] % 360 / 360, lt = +tt[1] / 100, ut = +tt[2] / 100, ot = ut <= .5 ? ut * (lt + 1) : ut + lt - ut * lt, nt = ut * 2 - ot, tt.length > 3 && (tt[3] *= 1), tt[0] = _hue(st + 1 / 3, nt, ot), tt[1] = _hue(st, nt, ot), tt[2] = _hue(st - 1 / 3, nt, ot);
                    else if (~_.indexOf("=")) return tt = _.match(_numExp), et && tt.length < 4 && (tt[3] = 1), tt
                } else tt = _.match(_strictNumExp) || _colorLookup.transparent;
                tt = tt.map(Number)
            }
            return _e && !ft && (nt = tt[0] / _255, ot = tt[1] / _255, at = tt[2] / _255, dt = Math.max(nt, ot, at), ct = Math.min(nt, ot, at), ut = (dt + ct) / 2, dt === ct ? st = lt = 0 : (pt = dt - ct, lt = ut > .5 ? pt / (2 - dt - ct) : pt / (dt + ct), st = dt === nt ? (ot - at) / pt + (ot < at ? 6 : 0) : dt === ot ? (at - nt) / pt + 2 : (nt - ot) / pt + 4, st *= 60), tt[0] = ~~(st + .5), tt[1] = ~~(lt * 100 + .5), tt[2] = ~~(ut * 100 + .5)), et && tt.length < 4 && (tt[3] = 1), tt
        },
        _colorOrderData = function(_) {
            var _e = [],
                et = [],
                tt = -1;
            return _.split(_colorExp).forEach(function(nt) {
                var ot = nt.match(_numWithUnitExp) || [];
                _e.push.apply(_e, ot), et.push(tt += ot.length + 1)
            }), _e.c = et, _e
        },
        _formatColors = function(_, _e, et) {
            var tt = "",
                nt = (_ + tt).match(_colorExp),
                ot = _e ? "hsla(" : "rgba(",
                at = 0,
                st, lt, ut, dt;
            if (!nt) return _;
            if (nt = nt.map(function(ct) {
                    return (ct = splitColor$1(ct, _e, 1)) && ot + (_e ? ct[0] + "," + ct[1] + "%," + ct[2] + "%," + ct[3] : ct.join(",")) + ")"
                }), et && (ut = _colorOrderData(_), st = et.c, st.join(tt) !== ut.c.join(tt)))
                for (lt = _.replace(_colorExp, "1").split(_numWithUnitExp), dt = lt.length - 1; at < dt; at++) tt += lt[at] + (~st.indexOf(at) ? nt.shift() || ot + "0,0,0,0)" : (ut.length ? ut : nt.length ? nt : et).shift());
            if (!lt)
                for (lt = _.split(_colorExp), dt = lt.length - 1; at < dt; at++) tt += lt[at] + nt[at];
            return tt + lt[dt]
        },
        _colorExp = function() {
            var _ = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                _e;
            for (_e in _colorLookup) _ += "|" + _e + "\\b";
            return new RegExp(_ + ")", "gi")
        }(),
        _hslExp = /hsl[a]?\(/,
        _colorStringFilter = function(_) {
            var _e = _.join(" "),
                et;
            if (_colorExp.lastIndex = 0, _colorExp.test(_e)) return et = _hslExp.test(_e), _[1] = _formatColors(_[1], et), _[0] = _formatColors(_[0], et, _colorOrderData(_[1])), !0
        },
        _tickerActive, _ticker = function() {
            var _ = Date.now,
                _e = 500,
                et = 33,
                tt = _(),
                nt = tt,
                ot = 1e3 / 240,
                at = ot,
                st = [],
                lt, ut, dt, ct, pt, ft, ht = function mt(bt) {
                    var gt = _() - nt,
                        vt = bt === !0,
                        xt, yt, Et, wt;
                    if (gt > _e && (tt += gt - et), nt += gt, Et = nt - tt, xt = Et - at, (xt > 0 || vt) && (wt = ++ct.frame, pt = Et - ct.time * 1e3, ct.time = Et = Et / 1e3, at += xt + (xt >= ot ? 4 : ot - xt), yt = 1), vt || (lt = ut(mt)), yt)
                        for (ft = 0; ft < st.length; ft++) st[ft](Et, pt, wt, bt)
                };
            return ct = {
                time: 0,
                frame: 0,
                tick: function() {
                    ht(!0)
                },
                deltaRatio: function(mt) {
                    return pt / (1e3 / (mt || 60))
                },
                wake: function() {
                    _coreReady && (!_coreInitted && _windowExists$1() && (_win$1 = _coreInitted = window, _doc$1 = _win$1.document || {}, _globals.gsap = gsap$1, (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(gsap$1.version), _install(_installScope || _win$1.GreenSockGlobals || !_win$1.gsap && _win$1 || {}), dt = _win$1.requestAnimationFrame, _registerPluginQueue.forEach(_createPlugin)), lt && ct.sleep(), ut = dt || function(mt) {
                        return setTimeout(mt, at - ct.time * 1e3 + 1 | 0)
                    }, _tickerActive = 1, ht(2))
                },
                sleep: function() {
                    (dt ? _win$1.cancelAnimationFrame : clearTimeout)(lt), _tickerActive = 0, ut = _emptyFunc
                },
                lagSmoothing: function(mt, bt) {
                    _e = mt || 1 / 0, et = Math.min(bt || 33, _e)
                },
                fps: function(mt) {
                    ot = 1e3 / (mt || 240), at = ct.time * 1e3 + ot
                },
                add: function(mt, bt, gt) {
                    var vt = bt ? function(xt, yt, Et, wt) {
                        mt(xt, yt, Et, wt), ct.remove(vt)
                    } : mt;
                    return ct.remove(mt), st[gt ? "unshift" : "push"](vt), _wake(), vt
                },
                remove: function(mt, bt) {
                    ~(bt = st.indexOf(mt)) && st.splice(bt, 1) && ft >= bt && ft--
                },
                _listeners: st
            }, ct
        }(),
        _wake = function() {
            return !_tickerActive && _ticker.wake()
        },
        _easeMap = {},
        _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
        _quotesExp = /["']/g,
        _parseObjectInString = function(_) {
            for (var _e = {}, et = _.substr(1, _.length - 3).split(":"), tt = et[0], nt = 1, ot = et.length, at, st, lt; nt < ot; nt++) st = et[nt], at = nt !== ot - 1 ? st.lastIndexOf(",") : st.length, lt = st.substr(0, at), _e[tt] = isNaN(lt) ? lt.replace(_quotesExp, "").trim() : +lt, tt = st.substr(at + 1).trim();
            return _e
        },
        _valueInParentheses = function(_) {
            var _e = _.indexOf("(") + 1,
                et = _.indexOf(")"),
                tt = _.indexOf("(", _e);
            return _.substring(_e, ~tt && tt < et ? _.indexOf(")", et + 1) : et)
        },
        _configEaseFromString = function(_) {
            var _e = (_ + "").split("("),
                et = _easeMap[_e[0]];
            return et && _e.length > 1 && et.config ? et.config.apply(null, ~_.indexOf("{") ? [_parseObjectInString(_e[1])] : _valueInParentheses(_).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(_) ? _easeMap._CE("", _) : et
        },
        _invertEase = function(_) {
            return function(_e) {
                return 1 - _(1 - _e)
            }
        },
        _propagateYoyoEase = function _(_e, et) {
            for (var tt = _e._first, nt; tt;) tt instanceof Timeline ? _(tt, et) : tt.vars.yoyoEase && (!tt._yoyo || !tt._repeat) && tt._yoyo !== et && (tt.timeline ? _(tt.timeline, et) : (nt = tt._ease, tt._ease = tt._yEase, tt._yEase = nt, tt._yoyo = et)), tt = tt._next
        },
        _parseEase = function(_, _e) {
            return _ && (_isFunction(_) ? _ : _easeMap[_] || _configEaseFromString(_)) || _e
        },
        _insertEase = function(_, _e, et, tt) {
            et === void 0 && (et = function(at) {
                return 1 - _e(1 - at)
            }), tt === void 0 && (tt = function(at) {
                return at < .5 ? _e(at * 2) / 2 : 1 - _e((1 - at) * 2) / 2
            });
            var nt = {
                    easeIn: _e,
                    easeOut: et,
                    easeInOut: tt
                },
                ot;
            return _forEachName(_, function(at) {
                _easeMap[at] = _globals[at] = nt, _easeMap[ot = at.toLowerCase()] = et;
                for (var st in nt) _easeMap[ot + (st === "easeIn" ? ".in" : st === "easeOut" ? ".out" : ".inOut")] = _easeMap[at + "." + st] = nt[st]
            }), nt
        },
        _easeInOutFromOut = function(_) {
            return function(_e) {
                return _e < .5 ? (1 - _(1 - _e * 2)) / 2 : .5 + _((_e - .5) * 2) / 2
            }
        },
        _configElastic = function _(_e, et, tt) {
            var nt = et >= 1 ? et : 1,
                ot = (tt || (_e ? .3 : .45)) / (et < 1 ? et : 1),
                at = ot / _2PI * (Math.asin(1 / nt) || 0),
                st = function(ut) {
                    return ut === 1 ? 1 : nt * Math.pow(2, -10 * ut) * _sin((ut - at) * ot) + 1
                },
                lt = _e === "out" ? st : _e === "in" ? function(ut) {
                    return 1 - st(1 - ut)
                } : _easeInOutFromOut(st);
            return ot = _2PI / ot, lt.config = function(ut, dt) {
                return _(_e, ut, dt)
            }, lt
        },
        _configBack = function _(_e, et) {
            et === void 0 && (et = 1.70158);
            var tt = function(ot) {
                    return ot ? --ot * ot * ((et + 1) * ot + et) + 1 : 0
                },
                nt = _e === "out" ? tt : _e === "in" ? function(ot) {
                    return 1 - tt(1 - ot)
                } : _easeInOutFromOut(tt);
            return nt.config = function(ot) {
                return _(_e, ot)
            }, nt
        };
    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(_, _e) {
            var et = _e < 5 ? _e + 1 : _e;
            _insertEase(_ + ",Power" + (et - 1), _e ? function(tt) {
                return Math.pow(tt, et)
            } : function(tt) {
                return tt
            }, function(tt) {
                return 1 - Math.pow(1 - tt, et)
            }, function(tt) {
                return tt < .5 ? Math.pow(tt * 2, et) / 2 : 1 - Math.pow((1 - tt) * 2, et) / 2
            })
        }), _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn, _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic()),
        function(_, _e) {
            var et = 1 / _e,
                tt = 2 * et,
                nt = 2.5 * et,
                ot = function(at) {
                    return at < et ? _ * at * at : at < tt ? _ * Math.pow(at - 1.5 / _e, 2) + .75 : at < nt ? _ * (at -= 2.25 / _e) * at + .9375 : _ * Math.pow(at - 2.625 / _e, 2) + .984375
                };
            _insertEase("Bounce", function(at) {
                return 1 - ot(1 - at)
            }, ot)
        }(7.5625, 2.75), _insertEase("Expo", function(_) {
            return _ ? Math.pow(2, 10 * (_ - 1)) : 0
        }), _insertEase("Circ", function(_) {
            return -(_sqrt(1 - _ * _) - 1)
        }), _insertEase("Sine", function(_) {
            return _ === 1 ? 1 : -_cos(_ * _HALF_PI) + 1
        }), _insertEase("Back", _configBack("in"), _configBack("out"), _configBack()), _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
            config: function(_, _e) {
                _ === void 0 && (_ = 1);
                var et = 1 / _,
                    tt = _ + (_e ? 0 : 1),
                    nt = _e ? 1 : 0,
                    ot = 1 - _tinyNum;
                return function(at) {
                    return ((tt * _clamp(0, ot, at) | 0) + nt) * et
                }
            }
        }, _defaults.ease = _easeMap["quad.out"], _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(_) {
            return _callbackNames += _ + "," + _ + "Params,"
        });
    var GSCache = function(_, _e) {
            this.id = _gsID++, _._gsap = this, this.target = _, this.harness = _e, this.get = _e ? _e.get : _getProperty, this.set = _e ? _e.getSetter : _getSetter
        },
        Animation = function() {
            function _(et) {
                this.vars = et, this._delay = +et.delay || 0, (this._repeat = et.repeat === 1 / 0 ? -2 : et.repeat || 0) && (this._rDelay = et.repeatDelay || 0, this._yoyo = !!et.yoyo || !!et.yoyoEase), this._ts = 1, _setDuration(this, +et.duration, 1, 1), this.data = et.data, _context && (this._ctx = _context, _context.data.push(this)), _tickerActive || _ticker.wake()
            }
            var _e = _.prototype;
            return _e.delay = function(et) {
                return et || et === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + et - this._delay), this._delay = et, this) : this._delay
            }, _e.duration = function(et) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? et + (et + this._rDelay) * this._repeat : et) : this.totalDuration() && this._dur
            }, _e.totalDuration = function(et) {
                return arguments.length ? (this._dirty = 0, _setDuration(this, this._repeat < 0 ? et : (et - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, _e.totalTime = function(et, tt) {
                if (_wake(), !arguments.length) return this._tTime;
                var nt = this._dp;
                if (nt && nt.smoothChildTiming && this._ts) {
                    for (_alignPlayhead(this, et), !nt._dp || nt.parent || _postAddChecks(nt, this); nt && nt.parent;) nt.parent._time !== nt._start + (nt._ts >= 0 ? nt._tTime / nt._ts : (nt.totalDuration() - nt._tTime) / -nt._ts) && nt.totalTime(nt._tTime, !0), nt = nt.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && et < this._tDur || this._ts < 0 && et > 0 || !this._tDur && !et) && _addToTimeline(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== et || !this._dur && !tt || this._initted && Math.abs(this._zTime) === _tinyNum || !et && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = et), _lazySafeRender(this, et, tt)), this
            }, _e.time = function(et, tt) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), et + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (et ? this._dur : 0), tt) : this._time
            }, _e.totalProgress = function(et, tt) {
                return arguments.length ? this.totalTime(this.totalDuration() * et, tt) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
            }, _e.progress = function(et, tt) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - et : et) + _elapsedCycleDuration(this), tt) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
            }, _e.iteration = function(et, tt) {
                var nt = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (et - 1) * nt, tt) : this._repeat ? _animationCycle(this._tTime, nt) + 1 : 1
            }, _e.timeScale = function(et, tt) {
                if (!arguments.length) return this._rts === -_tinyNum ? 0 : this._rts;
                if (this._rts === et) return this;
                var nt = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
                return this._rts = +et || 0, this._ts = this._ps || et === -_tinyNum ? 0 : this._rts, this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, nt), tt !== !1), _setEnd(this), _recacheAncestors(this)
            }, _e.paused = function(et) {
                return arguments.length ? (this._ps !== et && (this._ps = et, et ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_wake(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)))), this) : this._ps
            }, _e.startTime = function(et) {
                if (arguments.length) {
                    this._start = et;
                    var tt = this.parent || this._dp;
                    return tt && (tt._sort || !this.parent) && _addToTimeline(tt, this, et - this._delay), this
                }
                return this._start
            }, _e.endTime = function(et) {
                return this._start + (_isNotFalse(et) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }, _e.rawTime = function(et) {
                var tt = this.parent || this._dp;
                return tt ? et && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _parentToChildTotalTime(tt.rawTime(et), this) : this._tTime : this._tTime
            }, _e.revert = function(et) {
                et === void 0 && (et = _revertConfig);
                var tt = _reverting$1;
                return _reverting$1 = et, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(et), this.totalTime(-.01, et.suppressEvents)), this.data !== "nested" && et.kill !== !1 && this.kill(), _reverting$1 = tt, this
            }, _e.globalTime = function(et) {
                for (var tt = this, nt = arguments.length ? et : tt.rawTime(); tt;) nt = tt._start + nt / (Math.abs(tt._ts) || 1), tt = tt._dp;
                return !this.parent && this._sat ? this._sat.globalTime(et) : nt
            }, _e.repeat = function(et) {
                return arguments.length ? (this._repeat = et === 1 / 0 ? -2 : et, _onUpdateTotalDuration(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
            }, _e.repeatDelay = function(et) {
                if (arguments.length) {
                    var tt = this._time;
                    return this._rDelay = et, _onUpdateTotalDuration(this), tt ? this.time(tt) : this
                }
                return this._rDelay
            }, _e.yoyo = function(et) {
                return arguments.length ? (this._yoyo = et, this) : this._yoyo
            }, _e.seek = function(et, tt) {
                return this.totalTime(_parsePosition(this, et), _isNotFalse(tt))
            }, _e.restart = function(et, tt) {
                return this.play().totalTime(et ? -this._delay : 0, _isNotFalse(tt))
            }, _e.play = function(et, tt) {
                return et != null && this.seek(et, tt), this.reversed(!1).paused(!1)
            }, _e.reverse = function(et, tt) {
                return et != null && this.seek(et || this.totalDuration(), tt), this.reversed(!0).paused(!1)
            }, _e.pause = function(et, tt) {
                return et != null && this.seek(et, tt), this.paused(!0)
            }, _e.resume = function() {
                return this.paused(!1)
            }, _e.reversed = function(et) {
                return arguments.length ? (!!et !== this.reversed() && this.timeScale(-this._rts || (et ? -_tinyNum : 0)), this) : this._rts < 0
            }, _e.invalidate = function() {
                return this._initted = this._act = 0, this._zTime = -_tinyNum, this
            }, _e.isActive = function() {
                var et = this.parent || this._dp,
                    tt = this._start,
                    nt;
                return !!(!et || this._ts && this._initted && et.isActive() && (nt = et.rawTime(!0)) >= tt && nt < this.endTime(!0) - _tinyNum)
            }, _e.eventCallback = function(et, tt, nt) {
                var ot = this.vars;
                return arguments.length > 1 ? (tt ? (ot[et] = tt, nt && (ot[et + "Params"] = nt), et === "onUpdate" && (this._onUpdate = tt)) : delete ot[et], this) : ot[et]
            }, _e.then = function(et) {
                var tt = this;
                return new Promise(function(nt) {
                    var ot = _isFunction(et) ? et : _passThrough,
                        at = function() {
                            var st = tt.then;
                            tt.then = null, _isFunction(ot) && (ot = ot(tt)) && (ot.then || ot === tt) && (tt.then = st), nt(ot), tt.then = st
                        };
                    tt._initted && tt.totalProgress() === 1 && tt._ts >= 0 || !tt._tTime && tt._ts < 0 ? at() : tt._prom = at
                })
            }, _e.kill = function() {
                _interrupt(this)
            }, _
        }();
    _setDefaults(Animation.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -_tinyNum,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Timeline = function(_) {
        _inheritsLoose(_e, _);

        function _e(tt, nt) {
            var ot;
            return tt === void 0 && (tt = {}), ot = _.call(this, tt) || this, ot.labels = {}, ot.smoothChildTiming = !!tt.smoothChildTiming, ot.autoRemoveChildren = !!tt.autoRemoveChildren, ot._sort = _isNotFalse(tt.sortChildren), _globalTimeline && _addToTimeline(tt.parent || _globalTimeline, _assertThisInitialized(ot), nt), tt.reversed && ot.reverse(), tt.paused && ot.paused(!0), tt.scrollTrigger && _scrollTrigger(_assertThisInitialized(ot), tt.scrollTrigger), ot
        }
        var et = _e.prototype;
        return et.to = function(tt, nt, ot) {
            return _createTweenType(0, arguments, this), this
        }, et.from = function(tt, nt, ot) {
            return _createTweenType(1, arguments, this), this
        }, et.fromTo = function(tt, nt, ot, at) {
            return _createTweenType(2, arguments, this), this
        }, et.set = function(tt, nt, ot) {
            return nt.duration = 0, nt.parent = this, _inheritDefaults(nt).repeatDelay || (nt.repeat = 0), nt.immediateRender = !!nt.immediateRender, new Tween(tt, nt, _parsePosition(this, ot), 1), this
        }, et.call = function(tt, nt, ot) {
            return _addToTimeline(this, Tween.delayedCall(0, tt, nt), ot)
        }, et.staggerTo = function(tt, nt, ot, at, st, lt, ut) {
            return ot.duration = nt, ot.stagger = ot.stagger || at, ot.onComplete = lt, ot.onCompleteParams = ut, ot.parent = this, new Tween(tt, ot, _parsePosition(this, st)), this
        }, et.staggerFrom = function(tt, nt, ot, at, st, lt, ut) {
            return ot.runBackwards = 1, _inheritDefaults(ot).immediateRender = _isNotFalse(ot.immediateRender), this.staggerTo(tt, nt, ot, at, st, lt, ut)
        }, et.staggerFromTo = function(tt, nt, ot, at, st, lt, ut, dt) {
            return at.startAt = ot, _inheritDefaults(at).immediateRender = _isNotFalse(at.immediateRender), this.staggerTo(tt, nt, at, st, lt, ut, dt)
        }, et.render = function(tt, nt, ot) {
            var at = this._time,
                st = this._dirty ? this.totalDuration() : this._tDur,
                lt = this._dur,
                ut = tt <= 0 ? 0 : _roundPrecise(tt),
                dt = this._zTime < 0 != tt < 0 && (this._initted || !lt),
                ct, pt, ft, ht, mt, bt, gt, vt, xt, yt, Et, wt;
            if (this !== _globalTimeline && ut > st && tt >= 0 && (ut = st), ut !== this._tTime || ot || dt) {
                if (at !== this._time && lt && (ut += this._time - at, tt += this._time - at), ct = ut, xt = this._start, vt = this._ts, bt = !vt, dt && (lt || (at = this._zTime), (tt || !nt) && (this._zTime = tt)), this._repeat) {
                    if (Et = this._yoyo, mt = lt + this._rDelay, this._repeat < -1 && tt < 0) return this.totalTime(mt * 100 + tt, nt, ot);
                    if (ct = _roundPrecise(ut % mt), ut === st ? (ht = this._repeat, ct = lt) : (ht = ~~(ut / mt), ht && ht === ut / mt && (ct = lt, ht--), ct > lt && (ct = lt)), yt = _animationCycle(this._tTime, mt), !at && this._tTime && yt !== ht && this._tTime - yt * mt - this._dur <= 0 && (yt = ht), Et && ht & 1 && (ct = lt - ct, wt = 1), ht !== yt && !this._lock) {
                        var St = Et && yt & 1,
                            $t = St === (Et && ht & 1);
                        if (ht < yt && (St = !St), at = St ? 0 : ut % lt ? lt : ut, this._lock = 1, this.render(at || (wt ? 0 : _roundPrecise(ht * mt)), nt, !lt)._lock = 0, this._tTime = ut, !nt && this.parent && _callback(this, "onRepeat"), this.vars.repeatRefresh && !wt && (this.invalidate()._lock = 1), at && at !== this._time || bt !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                        if (lt = this._dur, st = this._tDur, $t && (this._lock = 2, at = St ? lt : -1e-4, this.render(at, !0), this.vars.repeatRefresh && !wt && this.invalidate()), this._lock = 0, !this._ts && !bt) return this;
                        _propagateYoyoEase(this, wt)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (gt = _findNextPauseTween(this, _roundPrecise(at), _roundPrecise(ct)), gt && (ut -= ct - (ct = gt._start))), this._tTime = ut, this._time = ct, this._act = !vt, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = tt, at = 0), !at && ct && !nt && !ht && (_callback(this, "onStart"), this._tTime !== ut)) return this;
                if (ct >= at && tt >= 0)
                    for (pt = this._first; pt;) {
                        if (ft = pt._next, (pt._act || ct >= pt._start) && pt._ts && gt !== pt) {
                            if (pt.parent !== this) return this.render(tt, nt, ot);
                            if (pt.render(pt._ts > 0 ? (ct - pt._start) * pt._ts : (pt._dirty ? pt.totalDuration() : pt._tDur) + (ct - pt._start) * pt._ts, nt, ot), ct !== this._time || !this._ts && !bt) {
                                gt = 0, ft && (ut += this._zTime = -_tinyNum);
                                break
                            }
                        }
                        pt = ft
                    } else {
                        pt = this._last;
                        for (var Ct = tt < 0 ? tt : ct; pt;) {
                            if (ft = pt._prev, (pt._act || Ct <= pt._end) && pt._ts && gt !== pt) {
                                if (pt.parent !== this) return this.render(tt, nt, ot);
                                if (pt.render(pt._ts > 0 ? (Ct - pt._start) * pt._ts : (pt._dirty ? pt.totalDuration() : pt._tDur) + (Ct - pt._start) * pt._ts, nt, ot || _reverting$1 && (pt._initted || pt._startAt)), ct !== this._time || !this._ts && !bt) {
                                    gt = 0, ft && (ut += this._zTime = Ct ? -_tinyNum : _tinyNum);
                                    break
                                }
                            }
                            pt = ft
                        }
                    }
                if (gt && !nt && (this.pause(), gt.render(ct >= at ? 0 : -_tinyNum)._zTime = ct >= at ? 1 : -1, this._ts)) return this._start = xt, _setEnd(this), this.render(tt, nt, ot);
                this._onUpdate && !nt && _callback(this, "onUpdate", !0), (ut === st && this._tTime >= this.totalDuration() || !ut && at) && (xt === this._start || Math.abs(vt) !== Math.abs(this._ts)) && (this._lock || ((tt || !lt) && (ut === st && this._ts > 0 || !ut && this._ts < 0) && _removeFromParent(this, 1), !nt && !(tt < 0 && !at) && (ut || at || !st) && (_callback(this, ut === st && tt >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(ut < st && this.timeScale() > 0) && this._prom())))
            }
            return this
        }, et.add = function(tt, nt) {
            var ot = this;
            if (_isNumber(nt) || (nt = _parsePosition(this, nt, tt)), !(tt instanceof Animation)) {
                if (_isArray(tt)) return tt.forEach(function(at) {
                    return ot.add(at, nt)
                }), this;
                if (_isString(tt)) return this.addLabel(tt, nt);
                if (_isFunction(tt)) tt = Tween.delayedCall(0, tt);
                else return this
            }
            return this !== tt ? _addToTimeline(this, tt, nt) : this
        }, et.getChildren = function(tt, nt, ot, at) {
            tt === void 0 && (tt = !0), nt === void 0 && (nt = !0), ot === void 0 && (ot = !0), at === void 0 && (at = -_bigNum$1);
            for (var st = [], lt = this._first; lt;) lt._start >= at && (lt instanceof Tween ? nt && st.push(lt) : (ot && st.push(lt), tt && st.push.apply(st, lt.getChildren(!0, nt, ot)))), lt = lt._next;
            return st
        }, et.getById = function(tt) {
            for (var nt = this.getChildren(1, 1, 1), ot = nt.length; ot--;)
                if (nt[ot].vars.id === tt) return nt[ot]
        }, et.remove = function(tt) {
            return _isString(tt) ? this.removeLabel(tt) : _isFunction(tt) ? this.killTweensOf(tt) : (_removeLinkedListItem(this, tt), tt === this._recent && (this._recent = this._last), _uncache(this))
        }, et.totalTime = function(tt, nt) {
            return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? tt / this._ts : (this.totalDuration() - tt) / -this._ts))), _.prototype.totalTime.call(this, tt, nt), this._forcing = 0, this) : this._tTime
        }, et.addLabel = function(tt, nt) {
            return this.labels[tt] = _parsePosition(this, nt), this
        }, et.removeLabel = function(tt) {
            return delete this.labels[tt], this
        }, et.addPause = function(tt, nt, ot) {
            var at = Tween.delayedCall(0, nt || _emptyFunc, ot);
            return at.data = "isPause", this._hasPause = 1, _addToTimeline(this, at, _parsePosition(this, tt))
        }, et.removePause = function(tt) {
            var nt = this._first;
            for (tt = _parsePosition(this, tt); nt;) nt._start === tt && nt.data === "isPause" && _removeFromParent(nt), nt = nt._next
        }, et.killTweensOf = function(tt, nt, ot) {
            for (var at = this.getTweensOf(tt, ot), st = at.length; st--;) _overwritingTween !== at[st] && at[st].kill(tt, nt);
            return this
        }, et.getTweensOf = function(tt, nt) {
            for (var ot = [], at = toArray$2(tt), st = this._first, lt = _isNumber(nt), ut; st;) st instanceof Tween ? _arrayContainsAny(st._targets, at) && (lt ? (!_overwritingTween || st._initted && st._ts) && st.globalTime(0) <= nt && st.globalTime(st.totalDuration()) > nt : !nt || st.isActive()) && ot.push(st) : (ut = st.getTweensOf(at, nt)).length && ot.push.apply(ot, ut), st = st._next;
            return ot
        }, et.tweenTo = function(tt, nt) {
            nt = nt || {};
            var ot = this,
                at = _parsePosition(ot, tt),
                st = nt,
                lt = st.startAt,
                ut = st.onStart,
                dt = st.onStartParams,
                ct = st.immediateRender,
                pt, ft = Tween.to(ot, _setDefaults({
                    ease: nt.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: at,
                    overwrite: "auto",
                    duration: nt.duration || Math.abs((at - (lt && "time" in lt ? lt.time : ot._time)) / ot.timeScale()) || _tinyNum,
                    onStart: function() {
                        if (ot.pause(), !pt) {
                            var ht = nt.duration || Math.abs((at - (lt && "time" in lt ? lt.time : ot._time)) / ot.timeScale());
                            ft._dur !== ht && _setDuration(ft, ht, 0, 1).render(ft._time, !0, !0), pt = 1
                        }
                        ut && ut.apply(ft, dt || [])
                    }
                }, nt));
            return ct ? ft.render(0) : ft
        }, et.tweenFromTo = function(tt, nt, ot) {
            return this.tweenTo(nt, _setDefaults({
                startAt: {
                    time: _parsePosition(this, tt)
                }
            }, ot))
        }, et.recent = function() {
            return this._recent
        }, et.nextLabel = function(tt) {
            return tt === void 0 && (tt = this._time), _getLabelInDirection(this, _parsePosition(this, tt))
        }, et.previousLabel = function(tt) {
            return tt === void 0 && (tt = this._time), _getLabelInDirection(this, _parsePosition(this, tt), 1)
        }, et.currentLabel = function(tt) {
            return arguments.length ? this.seek(tt, !0) : this.previousLabel(this._time + _tinyNum)
        }, et.shiftChildren = function(tt, nt, ot) {
            ot === void 0 && (ot = 0);
            for (var at = this._first, st = this.labels, lt; at;) at._start >= ot && (at._start += tt, at._end += tt), at = at._next;
            if (nt)
                for (lt in st) st[lt] >= ot && (st[lt] += tt);
            return _uncache(this)
        }, et.invalidate = function(tt) {
            var nt = this._first;
            for (this._lock = 0; nt;) nt.invalidate(tt), nt = nt._next;
            return _.prototype.invalidate.call(this, tt)
        }, et.clear = function(tt) {
            tt === void 0 && (tt = !0);
            for (var nt = this._first, ot; nt;) ot = nt._next, this.remove(nt), nt = ot;
            return this._dp && (this._time = this._tTime = this._pTime = 0), tt && (this.labels = {}), _uncache(this)
        }, et.totalDuration = function(tt) {
            var nt = 0,
                ot = this,
                at = ot._last,
                st = _bigNum$1,
                lt, ut, dt;
            if (arguments.length) return ot.timeScale((ot._repeat < 0 ? ot.duration() : ot.totalDuration()) / (ot.reversed() ? -tt : tt));
            if (ot._dirty) {
                for (dt = ot.parent; at;) lt = at._prev, at._dirty && at.totalDuration(), ut = at._start, ut > st && ot._sort && at._ts && !ot._lock ? (ot._lock = 1, _addToTimeline(ot, at, ut - at._delay, 1)._lock = 0) : st = ut, ut < 0 && at._ts && (nt -= ut, (!dt && !ot._dp || dt && dt.smoothChildTiming) && (ot._start += ut / ot._ts, ot._time -= ut, ot._tTime -= ut), ot.shiftChildren(-ut, !1, -1 / 0), st = 0), at._end > nt && at._ts && (nt = at._end), at = lt;
                _setDuration(ot, ot === _globalTimeline && ot._time > nt ? ot._time : nt, 1, 1), ot._dirty = 0
            }
            return ot._tDur
        }, _e.updateRoot = function(tt) {
            if (_globalTimeline._ts && (_lazySafeRender(_globalTimeline, _parentToChildTotalTime(tt, _globalTimeline)), _lastRenderedFrame = _ticker.frame), _ticker.frame >= _nextGCFrame) {
                _nextGCFrame += _config.autoSleep || 120;
                var nt = _globalTimeline._first;
                if ((!nt || !nt._ts) && _config.autoSleep && _ticker._listeners.length < 2) {
                    for (; nt && !nt._ts;) nt = nt._next;
                    nt || _ticker.sleep()
                }
            }
        }, _e
    }(Animation);
    _setDefaults(Timeline.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var _addComplexStringPropTween = function(_, _e, et, tt, nt, ot, at) {
            var st = new PropTween(this._pt, _, _e, 0, 1, _renderComplexString, null, nt),
                lt = 0,
                ut = 0,
                dt, ct, pt, ft, ht, mt, bt, gt;
            for (st.b = et, st.e = tt, et += "", tt += "", (bt = ~tt.indexOf("random(")) && (tt = _replaceRandom(tt)), ot && (gt = [et, tt], ot(gt, _, _e), et = gt[0], tt = gt[1]), ct = et.match(_complexStringNumExp) || []; dt = _complexStringNumExp.exec(tt);) ft = dt[0], ht = tt.substring(lt, dt.index), pt ? pt = (pt + 1) % 5 : ht.substr(-5) === "rgba(" && (pt = 1), ft !== ct[ut++] && (mt = parseFloat(ct[ut - 1]) || 0, st._pt = {
                _next: st._pt,
                p: ht || ut === 1 ? ht : ",",
                s: mt,
                c: ft.charAt(1) === "=" ? _parseRelative(mt, ft) - mt : parseFloat(ft) - mt,
                m: pt && pt < 4 ? Math.round : 0
            }, lt = _complexStringNumExp.lastIndex);
            return st.c = lt < tt.length ? tt.substring(lt, tt.length) : "", st.fp = at, (_relExp.test(tt) || bt) && (st.e = 0), this._pt = st, st
        },
        _addPropTween = function(_, _e, et, tt, nt, ot, at, st, lt, ut) {
            _isFunction(tt) && (tt = tt(nt || 0, _, ot));
            var dt = _[_e],
                ct = et !== "get" ? et : _isFunction(dt) ? lt ? _[_e.indexOf("set") || !_isFunction(_["get" + _e.substr(3)]) ? _e : "get" + _e.substr(3)](lt) : _[_e]() : dt,
                pt = _isFunction(dt) ? lt ? _setterFuncWithParam : _setterFunc : _setterPlain,
                ft;
            if (_isString(tt) && (~tt.indexOf("random(") && (tt = _replaceRandom(tt)), tt.charAt(1) === "=" && (ft = _parseRelative(ct, tt) + (getUnit(ct) || 0), (ft || ft === 0) && (tt = ft))), !ut || ct !== tt || _forceAllPropTweens) return !isNaN(ct * tt) && tt !== "" ? (ft = new PropTween(this._pt, _, _e, +ct || 0, tt - (ct || 0), typeof dt == "boolean" ? _renderBoolean : _renderPlain, 0, pt), lt && (ft.fp = lt), at && ft.modifier(at, this, _), this._pt = ft) : (!dt && !(_e in _) && _missingPlugin(_e, tt), _addComplexStringPropTween.call(this, _, _e, ct, tt, pt, st || _config.stringFilter, lt))
        },
        _processVars = function(_, _e, et, tt, nt) {
            if (_isFunction(_) && (_ = _parseFuncOrString(_, nt, _e, et, tt)), !_isObject(_) || _.style && _.nodeType || _isArray(_) || _isTypedArray(_)) return _isString(_) ? _parseFuncOrString(_, nt, _e, et, tt) : _;
            var ot = {},
                at;
            for (at in _) ot[at] = _parseFuncOrString(_[at], nt, _e, et, tt);
            return ot
        },
        _checkPlugin = function(_, _e, et, tt, nt, ot) {
            var at, st, lt, ut;
            if (_plugins[_] && (at = new _plugins[_]).init(nt, at.rawVars ? _e[_] : _processVars(_e[_], tt, nt, ot, et), et, tt, ot) !== !1 && (et._pt = st = new PropTween(et._pt, nt, _, 0, 1, at.render, at, 0, at.priority), et !== _quickTween))
                for (lt = et._ptLookup[et._targets.indexOf(nt)], ut = at._props.length; ut--;) lt[at._props[ut]] = st;
            return at
        },
        _overwritingTween, _forceAllPropTweens, _initTween = function _(_e, et, tt) {
            var nt = _e.vars,
                ot = nt.ease,
                at = nt.startAt,
                st = nt.immediateRender,
                lt = nt.lazy,
                ut = nt.onUpdate,
                dt = nt.runBackwards,
                ct = nt.yoyoEase,
                pt = nt.keyframes,
                ft = nt.autoRevert,
                ht = _e._dur,
                mt = _e._startAt,
                bt = _e._targets,
                gt = _e.parent,
                vt = gt && gt.data === "nested" ? gt.vars.targets : bt,
                xt = _e._overwrite === "auto" && !_suppressOverwrites,
                yt = _e.timeline,
                Et, wt, St, $t, Ct, Rt, Pt, Tt, It, Ot, Dt, jt, Ht;
            if (yt && (!pt || !ot) && (ot = "none"), _e._ease = _parseEase(ot, _defaults.ease), _e._yEase = ct ? _invertEase(_parseEase(ct === !0 ? ot : ct, _defaults.ease)) : 0, ct && _e._yoyo && !_e._repeat && (ct = _e._yEase, _e._yEase = _e._ease, _e._ease = ct), _e._from = !yt && !!nt.runBackwards, !yt || pt && !nt.stagger) {
                if (Tt = bt[0] ? _getCache(bt[0]).harness : 0, jt = Tt && nt[Tt.prop], Et = _copyExcluding(nt, _reservedProps), mt && (mt._zTime < 0 && mt.progress(1), et < 0 && dt && st && !ft ? mt.render(-1, !0) : mt.revert(dt && ht ? _revertConfigNoKill : _startAtRevertConfig), mt._lazy = 0), at) {
                    if (_removeFromParent(_e._startAt = Tween.set(bt, _setDefaults({
                            data: "isStart",
                            overwrite: !1,
                            parent: gt,
                            immediateRender: !0,
                            lazy: !mt && _isNotFalse(lt),
                            startAt: null,
                            delay: 0,
                            onUpdate: ut && function() {
                                return _callback(_e, "onUpdate")
                            },
                            stagger: 0
                        }, at))), _e._startAt._dp = 0, _e._startAt._sat = _e, et < 0 && (_reverting$1 || !st && !ft) && _e._startAt.revert(_revertConfigNoKill), st && ht && et <= 0 && tt <= 0) {
                        et && (_e._zTime = et);
                        return
                    }
                } else if (dt && ht && !mt) {
                    if (et && (st = !1), St = _setDefaults({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: st && !mt && _isNotFalse(lt),
                            immediateRender: st,
                            stagger: 0,
                            parent: gt
                        }, Et), jt && (St[Tt.prop] = jt), _removeFromParent(_e._startAt = Tween.set(bt, St)), _e._startAt._dp = 0, _e._startAt._sat = _e, et < 0 && (_reverting$1 ? _e._startAt.revert(_revertConfigNoKill) : _e._startAt.render(-1, !0)), _e._zTime = et, !st) _(_e._startAt, _tinyNum, _tinyNum);
                    else if (!et) return
                }
                for (_e._pt = _e._ptCache = 0, lt = ht && _isNotFalse(lt) || lt && !ht, wt = 0; wt < bt.length; wt++) {
                    if (Ct = bt[wt], Pt = Ct._gsap || _harness(bt)[wt]._gsap, _e._ptLookup[wt] = Ot = {}, _lazyLookup[Pt.id] && _lazyTweens.length && _lazyRender(), Dt = vt === bt ? wt : vt.indexOf(Ct), Tt && (It = new Tt).init(Ct, jt || Et, _e, Dt, vt) !== !1 && (_e._pt = $t = new PropTween(_e._pt, Ct, It.name, 0, 1, It.render, It, 0, It.priority), It._props.forEach(function(Mt) {
                            Ot[Mt] = $t
                        }), It.priority && (Rt = 1)), !Tt || jt)
                        for (St in Et) _plugins[St] && (It = _checkPlugin(St, Et, _e, Dt, Ct, vt)) ? It.priority && (Rt = 1) : Ot[St] = $t = _addPropTween.call(_e, Ct, St, "get", Et[St], Dt, vt, 0, nt.stringFilter);
                    _e._op && _e._op[wt] && _e.kill(Ct, _e._op[wt]), xt && _e._pt && (_overwritingTween = _e, _globalTimeline.killTweensOf(Ct, Ot, _e.globalTime(et)), Ht = !_e.parent, _overwritingTween = 0), _e._pt && lt && (_lazyLookup[Pt.id] = 1)
                }
                Rt && _sortPropTweensByPriority(_e), _e._onInit && _e._onInit(_e)
            }
            _e._onUpdate = ut, _e._initted = (!_e._op || _e._pt) && !Ht, pt && et <= 0 && yt.render(_bigNum$1, !0, !0)
        },
        _updatePropTweens = function(_, _e, et, tt, nt, ot, at, st) {
            var lt = (_._pt && _._ptCache || (_._ptCache = {}))[_e],
                ut, dt, ct, pt;
            if (!lt)
                for (lt = _._ptCache[_e] = [], ct = _._ptLookup, pt = _._targets.length; pt--;) {
                    if (ut = ct[pt][_e], ut && ut.d && ut.d._pt)
                        for (ut = ut.d._pt; ut && ut.p !== _e && ut.fp !== _e;) ut = ut._next;
                    if (!ut) return _forceAllPropTweens = 1, _.vars[_e] = "+=0", _initTween(_, at), _forceAllPropTweens = 0, st ? _warn(_e + " not eligible for reset") : 1;
                    lt.push(ut)
                }
            for (pt = lt.length; pt--;) dt = lt[pt], ut = dt._pt || dt, ut.s = (tt || tt === 0) && !nt ? tt : ut.s + (tt || 0) + ot * ut.c, ut.c = et - ut.s, dt.e && (dt.e = _round(et) + getUnit(dt.e)), dt.b && (dt.b = ut.s + getUnit(dt.b))
        },
        _addAliasesToVars = function(_, _e) {
            var et = _[0] ? _getCache(_[0]).harness : 0,
                tt = et && et.aliases,
                nt, ot, at, st;
            if (!tt) return _e;
            nt = _merge({}, _e);
            for (ot in tt)
                if (ot in nt)
                    for (st = tt[ot].split(","), at = st.length; at--;) nt[st[at]] = nt[ot];
            return nt
        },
        _parseKeyframe = function(_, _e, et, tt) {
            var nt = _e.ease || tt || "power1.inOut",
                ot, at;
            if (_isArray(_e)) at = et[_] || (et[_] = []), _e.forEach(function(st, lt) {
                return at.push({
                    t: lt / (_e.length - 1) * 100,
                    v: st,
                    e: nt
                })
            });
            else
                for (ot in _e) at = et[ot] || (et[ot] = []), ot === "ease" || at.push({
                    t: parseFloat(_),
                    v: _e[ot],
                    e: nt
                })
        },
        _parseFuncOrString = function(_, _e, et, tt, nt) {
            return _isFunction(_) ? _.call(_e, et, tt, nt) : _isString(_) && ~_.indexOf("random(") ? _replaceRandom(_) : _
        },
        _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        _staggerPropsToSkip = {};
    _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(_) {
        return _staggerPropsToSkip[_] = 1
    });
    var Tween = function(_) {
        _inheritsLoose(_e, _);

        function _e(tt, nt, ot, at) {
            var st;
            typeof nt == "number" && (ot.duration = nt, nt = ot, ot = null), st = _.call(this, at ? nt : _inheritDefaults(nt)) || this;
            var lt = st.vars,
                ut = lt.duration,
                dt = lt.delay,
                ct = lt.immediateRender,
                pt = lt.stagger,
                ft = lt.overwrite,
                ht = lt.keyframes,
                mt = lt.defaults,
                bt = lt.scrollTrigger,
                gt = lt.yoyoEase,
                vt = nt.parent || _globalTimeline,
                xt = (_isArray(tt) || _isTypedArray(tt) ? _isNumber(tt[0]) : "length" in nt) ? [tt] : toArray$2(tt),
                yt, Et, wt, St, $t, Ct, Rt, Pt;
            if (st._targets = xt.length ? _harness(xt) : _warn("GSAP target " + tt + " not found. https://gsap.com", !_config.nullTargetWarn) || [], st._ptLookup = [], st._overwrite = ft, ht || pt || _isFuncOrString(ut) || _isFuncOrString(dt)) {
                if (nt = st.vars, yt = st.timeline = new Timeline({
                        data: "nested",
                        defaults: mt || {},
                        targets: vt && vt.data === "nested" ? vt.vars.targets : xt
                    }), yt.kill(), yt.parent = yt._dp = _assertThisInitialized(st), yt._start = 0, pt || _isFuncOrString(ut) || _isFuncOrString(dt)) {
                    if (St = xt.length, Rt = pt && distribute(pt), _isObject(pt))
                        for ($t in pt) ~_staggerTweenProps.indexOf($t) && (Pt || (Pt = {}), Pt[$t] = pt[$t]);
                    for (Et = 0; Et < St; Et++) wt = _copyExcluding(nt, _staggerPropsToSkip), wt.stagger = 0, gt && (wt.yoyoEase = gt), Pt && _merge(wt, Pt), Ct = xt[Et], wt.duration = +_parseFuncOrString(ut, _assertThisInitialized(st), Et, Ct, xt), wt.delay = (+_parseFuncOrString(dt, _assertThisInitialized(st), Et, Ct, xt) || 0) - st._delay, !pt && St === 1 && wt.delay && (st._delay = dt = wt.delay, st._start += dt, wt.delay = 0), yt.to(Ct, wt, Rt ? Rt(Et, Ct, xt) : 0), yt._ease = _easeMap.none;
                    yt.duration() ? ut = dt = 0 : st.timeline = 0
                } else if (ht) {
                    _inheritDefaults(_setDefaults(yt.vars.defaults, {
                        ease: "none"
                    })), yt._ease = _parseEase(ht.ease || nt.ease || "none");
                    var Tt = 0,
                        It, Ot, Dt;
                    if (_isArray(ht)) ht.forEach(function(jt) {
                        return yt.to(xt, jt, ">")
                    }), yt.duration();
                    else {
                        wt = {};
                        for ($t in ht) $t === "ease" || $t === "easeEach" || _parseKeyframe($t, ht[$t], wt, ht.easeEach);
                        for ($t in wt)
                            for (It = wt[$t].sort(function(jt, Ht) {
                                    return jt.t - Ht.t
                                }), Tt = 0, Et = 0; Et < It.length; Et++) Ot = It[Et], Dt = {
                                ease: Ot.e,
                                duration: (Ot.t - (Et ? It[Et - 1].t : 0)) / 100 * ut
                            }, Dt[$t] = Ot.v, yt.to(xt, Dt, Tt), Tt += Dt.duration;
                        yt.duration() < ut && yt.to({}, {
                            duration: ut - yt.duration()
                        })
                    }
                }
                ut || st.duration(ut = yt.duration())
            } else st.timeline = 0;
            return ft === !0 && !_suppressOverwrites && (_overwritingTween = _assertThisInitialized(st), _globalTimeline.killTweensOf(xt), _overwritingTween = 0), _addToTimeline(vt, _assertThisInitialized(st), ot), nt.reversed && st.reverse(), nt.paused && st.paused(!0), (ct || !ut && !ht && st._start === _roundPrecise(vt._time) && _isNotFalse(ct) && _hasNoPausedAncestors(_assertThisInitialized(st)) && vt.data !== "nested") && (st._tTime = -_tinyNum, st.render(Math.max(0, -dt) || 0)), bt && _scrollTrigger(_assertThisInitialized(st), bt), st
        }
        var et = _e.prototype;
        return et.render = function(tt, nt, ot) {
            var at = this._time,
                st = this._tDur,
                lt = this._dur,
                ut = tt < 0,
                dt = tt > st - _tinyNum && !ut ? st : tt < _tinyNum ? 0 : tt,
                ct, pt, ft, ht, mt, bt, gt, vt, xt;
            if (!lt) _renderZeroDurationTween(this, tt, nt, ot);
            else if (dt !== this._tTime || !tt || ot || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== ut) {
                if (ct = dt, vt = this.timeline, this._repeat) {
                    if (ht = lt + this._rDelay, this._repeat < -1 && ut) return this.totalTime(ht * 100 + tt, nt, ot);
                    if (ct = _roundPrecise(dt % ht), dt === st ? (ft = this._repeat, ct = lt) : (ft = ~~(dt / ht), ft && ft === _roundPrecise(dt / ht) && (ct = lt, ft--), ct > lt && (ct = lt)), bt = this._yoyo && ft & 1, bt && (xt = this._yEase, ct = lt - ct), mt = _animationCycle(this._tTime, ht), ct === at && !ot && this._initted && ft === mt) return this._tTime = dt, this;
                    ft !== mt && (vt && this._yEase && _propagateYoyoEase(vt, bt), this.vars.repeatRefresh && !bt && !this._lock && this._time !== lt && this._initted && (this._lock = ot = 1, this.render(_roundPrecise(ht * ft), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                    if (_attemptInitTween(this, ut ? tt : ct, ot, nt, dt)) return this._tTime = 0, this;
                    if (at !== this._time && !(ot && this.vars.repeatRefresh && ft !== mt)) return this;
                    if (lt !== this._dur) return this.render(tt, nt, ot)
                }
                if (this._tTime = dt, this._time = ct, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = gt = (xt || this._ease)(ct / lt), this._from && (this.ratio = gt = 1 - gt), ct && !at && !nt && !ft && (_callback(this, "onStart"), this._tTime !== dt)) return this;
                for (pt = this._pt; pt;) pt.r(gt, pt.d), pt = pt._next;
                vt && vt.render(tt < 0 ? tt : !ct && bt ? -_tinyNum : vt._dur * vt._ease(ct / this._dur), nt, ot) || this._startAt && (this._zTime = tt), this._onUpdate && !nt && (ut && _rewindStartAt(this, tt, nt, ot), _callback(this, "onUpdate")), this._repeat && ft !== mt && this.vars.onRepeat && !nt && this.parent && _callback(this, "onRepeat"), (dt === this._tDur || !dt) && this._tTime === dt && (ut && !this._onUpdate && _rewindStartAt(this, tt, !0, !0), (tt || !lt) && (dt === this._tDur && this._ts > 0 || !dt && this._ts < 0) && _removeFromParent(this, 1), !nt && !(ut && !at) && (dt || at || bt) && (_callback(this, dt === st ? "onComplete" : "onReverseComplete", !0), this._prom && !(dt < st && this.timeScale() > 0) && this._prom()))
            }
            return this
        }, et.targets = function() {
            return this._targets
        }, et.invalidate = function(tt) {
            return (!tt || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(tt), _.prototype.invalidate.call(this, tt)
        }, et.resetTo = function(tt, nt, ot, at, st) {
            _tickerActive || _ticker.wake(), this._ts || this.play();
            var lt = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
                ut;
            return this._initted || _initTween(this, lt), ut = this._ease(lt / this._dur), _updatePropTweens(this, tt, nt, ot, at, ut, lt, st) ? this.resetTo(tt, nt, ot, at, 1) : (_alignPlayhead(this, 0), this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
        }, et.kill = function(tt, nt) {
            if (nt === void 0 && (nt = "all"), !tt && (!nt || nt === "all")) return this._lazy = this._pt = 0, this.parent ? _interrupt(this) : this;
            if (this.timeline) {
                var ot = this.timeline.totalDuration();
                return this.timeline.killTweensOf(tt, nt, _overwritingTween && _overwritingTween.vars.overwrite !== !0)._first || _interrupt(this), this.parent && ot !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / ot, 0, 1), this
            }
            var at = this._targets,
                st = tt ? toArray$2(tt) : at,
                lt = this._ptLookup,
                ut = this._pt,
                dt, ct, pt, ft, ht, mt, bt;
            if ((!nt || nt === "all") && _arraysMatch(at, st)) return nt === "all" && (this._pt = 0), _interrupt(this);
            for (dt = this._op = this._op || [], nt !== "all" && (_isString(nt) && (ht = {}, _forEachName(nt, function(gt) {
                    return ht[gt] = 1
                }), nt = ht), nt = _addAliasesToVars(at, nt)), bt = at.length; bt--;)
                if (~st.indexOf(at[bt])) {
                    ct = lt[bt], nt === "all" ? (dt[bt] = nt, ft = ct, pt = {}) : (pt = dt[bt] = dt[bt] || {}, ft = nt);
                    for (ht in ft) mt = ct && ct[ht], mt && ((!("kill" in mt.d) || mt.d.kill(ht) === !0) && _removeLinkedListItem(this, mt, "_pt"), delete ct[ht]), pt !== "all" && (pt[ht] = 1)
                }
            return this._initted && !this._pt && ut && _interrupt(this), this
        }, _e.to = function(tt, nt) {
            return new _e(tt, nt, arguments[2])
        }, _e.from = function(tt, nt) {
            return _createTweenType(1, arguments)
        }, _e.delayedCall = function(tt, nt, ot, at) {
            return new _e(nt, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: tt,
                onComplete: nt,
                onReverseComplete: nt,
                onCompleteParams: ot,
                onReverseCompleteParams: ot,
                callbackScope: at
            })
        }, _e.fromTo = function(tt, nt, ot) {
            return _createTweenType(2, arguments)
        }, _e.set = function(tt, nt) {
            return nt.duration = 0, nt.repeatDelay || (nt.repeat = 0), new _e(tt, nt)
        }, _e.killTweensOf = function(tt, nt, ot) {
            return _globalTimeline.killTweensOf(tt, nt, ot)
        }, _e
    }(Animation);
    _setDefaults(Tween.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), _forEachName("staggerTo,staggerFrom,staggerFromTo", function(_) {
        Tween[_] = function() {
            var _e = new Timeline,
                et = _slice.call(arguments, 0);
            return et.splice(_ === "staggerFromTo" ? 5 : 4, 0, 0), _e[_].apply(_e, et)
        }
    });
    var _setterPlain = function(_, _e, et) {
            return _[_e] = et
        },
        _setterFunc = function(_, _e, et) {
            return _[_e](et)
        },
        _setterFuncWithParam = function(_, _e, et, tt) {
            return _[_e](tt.fp, et)
        },
        _setterAttribute = function(_, _e, et) {
            return _.setAttribute(_e, et)
        },
        _getSetter = function(_, _e) {
            return _isFunction(_[_e]) ? _setterFunc : _isUndefined(_[_e]) && _.setAttribute ? _setterAttribute : _setterPlain
        },
        _renderPlain = function(_, _e) {
            return _e.set(_e.t, _e.p, Math.round((_e.s + _e.c * _) * 1e6) / 1e6, _e)
        },
        _renderBoolean = function(_, _e) {
            return _e.set(_e.t, _e.p, !!(_e.s + _e.c * _), _e)
        },
        _renderComplexString = function(_, _e) {
            var et = _e._pt,
                tt = "";
            if (!_ && _e.b) tt = _e.b;
            else if (_ === 1 && _e.e) tt = _e.e;
            else {
                for (; et;) tt = et.p + (et.m ? et.m(et.s + et.c * _) : Math.round((et.s + et.c * _) * 1e4) / 1e4) + tt, et = et._next;
                tt += _e.c
            }
            _e.set(_e.t, _e.p, tt, _e)
        },
        _renderPropTweens = function(_, _e) {
            for (var et = _e._pt; et;) et.r(_, et.d), et = et._next
        },
        _addPluginModifier = function(_, _e, et, tt) {
            for (var nt = this._pt, ot; nt;) ot = nt._next, nt.p === tt && nt.modifier(_, _e, et), nt = ot
        },
        _killPropTweensOf = function(_) {
            for (var _e = this._pt, et, tt; _e;) tt = _e._next, _e.p === _ && !_e.op || _e.op === _ ? _removeLinkedListItem(this, _e, "_pt") : _e.dep || (et = 1), _e = tt;
            return !et
        },
        _setterWithModifier = function(_, _e, et, tt) {
            tt.mSet(_, _e, tt.m.call(tt.tween, et, tt.mt), tt)
        },
        _sortPropTweensByPriority = function(_) {
            for (var _e = _._pt, et, tt, nt, ot; _e;) {
                for (et = _e._next, tt = nt; tt && tt.pr > _e.pr;) tt = tt._next;
                (_e._prev = tt ? tt._prev : ot) ? _e._prev._next = _e: nt = _e, (_e._next = tt) ? tt._prev = _e : ot = _e, _e = et
            }
            _._pt = nt
        },
        PropTween = function() {
            function _(et, tt, nt, ot, at, st, lt, ut, dt) {
                this.t = tt, this.s = ot, this.c = at, this.p = nt, this.r = st || _renderPlain, this.d = lt || this, this.set = ut || _setterPlain, this.pr = dt || 0, this._next = et, et && (et._prev = this)
            }
            var _e = _.prototype;
            return _e.modifier = function(et, tt, nt) {
                this.mSet = this.mSet || this.set, this.set = _setterWithModifier, this.m = et, this.mt = nt, this.tween = tt
            }, _
        }();
    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(_) {
        return _reservedProps[_] = 1
    }), _globals.TweenMax = _globals.TweenLite = Tween, _globals.TimelineLite = _globals.TimelineMax = Timeline, _globalTimeline = new Timeline({
        sortChildren: !1,
        defaults: _defaults,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), _config.stringFilter = _colorStringFilter;
    var _media = [],
        _listeners$1 = {},
        _emptyArray = [],
        _lastMediaTime = 0,
        _contextID = 0,
        _dispatch = function(_) {
            return (_listeners$1[_] || _emptyArray).map(function(_e) {
                return _e()
            })
        },
        _onMediaChange = function() {
            var _ = Date.now(),
                _e = [];
            _ - _lastMediaTime > 2 && (_dispatch("matchMediaInit"), _media.forEach(function(et) {
                var tt = et.queries,
                    nt = et.conditions,
                    ot, at, st, lt;
                for (at in tt) ot = _win$1.matchMedia(tt[at]).matches, ot && (st = 1), ot !== nt[at] && (nt[at] = ot, lt = 1);
                lt && (et.revert(), st && _e.push(et))
            }), _dispatch("matchMediaRevert"), _e.forEach(function(et) {
                return et.onMatch(et, function(tt) {
                    return et.add(null, tt)
                })
            }), _lastMediaTime = _, _dispatch("matchMedia"))
        },
        Context$1 = function() {
            function _(et, tt) {
                this.selector = tt && selector(tt), this.data = [], this._r = [], this.isReverted = !1, this.id = _contextID++, et && this.add(et)
            }
            var _e = _.prototype;
            return _e.add = function(et, tt, nt) {
                _isFunction(et) && (nt = tt, tt = et, et = _isFunction);
                var ot = this,
                    at = function() {
                        var st = _context,
                            lt = ot.selector,
                            ut;
                        return st && st !== ot && st.data.push(ot), nt && (ot.selector = selector(nt)), _context = ot, ut = tt.apply(ot, arguments), _isFunction(ut) && ot._r.push(ut), _context = st, ot.selector = lt, ot.isReverted = !1, ut
                    };
                return ot.last = at, et === _isFunction ? at(ot, function(st) {
                    return ot.add(null, st)
                }) : et ? ot[et] = at : at
            }, _e.ignore = function(et) {
                var tt = _context;
                _context = null, et(this), _context = tt
            }, _e.getTweens = function() {
                var et = [];
                return this.data.forEach(function(tt) {
                    return tt instanceof _ ? et.push.apply(et, tt.getTweens()) : tt instanceof Tween && !(tt.parent && tt.parent.data === "nested") && et.push(tt)
                }), et
            }, _e.clear = function() {
                this._r.length = this.data.length = 0
            }, _e.kill = function(et, tt) {
                var nt = this;
                if (et ? function() {
                        for (var at = nt.getTweens(), st = nt.data.length, lt; st--;) lt = nt.data[st], lt.data === "isFlip" && (lt.revert(), lt.getChildren(!0, !0, !1).forEach(function(ut) {
                            return at.splice(at.indexOf(ut), 1)
                        }));
                        for (at.map(function(ut) {
                                return {
                                    g: ut._dur || ut._delay || ut._sat && !ut._sat.vars.immediateRender ? ut.globalTime(0) : -1 / 0,
                                    t: ut
                                }
                            }).sort(function(ut, dt) {
                                return dt.g - ut.g || -1 / 0
                            }).forEach(function(ut) {
                                return ut.t.revert(et)
                            }), st = nt.data.length; st--;) lt = nt.data[st], lt instanceof Timeline ? lt.data !== "nested" && (lt.scrollTrigger && lt.scrollTrigger.revert(), lt.kill()) : !(lt instanceof Tween) && lt.revert && lt.revert(et);
                        nt._r.forEach(function(ut) {
                            return ut(et, nt)
                        }), nt.isReverted = !0
                    }() : this.data.forEach(function(at) {
                        return at.kill && at.kill()
                    }), this.clear(), tt)
                    for (var ot = _media.length; ot--;) _media[ot].id === this.id && _media.splice(ot, 1)
            }, _e.revert = function(et) {
                this.kill(et || {})
            }, _
        }(),
        MatchMedia = function() {
            function _(et) {
                this.contexts = [], this.scope = et
            }
            var _e = _.prototype;
            return _e.add = function(et, tt, nt) {
                _isObject(et) || (et = {
                    matches: et
                });
                var ot = new Context$1(0, nt || this.scope),
                    at = ot.conditions = {},
                    st, lt, ut;
                _context && !ot.selector && (ot.selector = _context.selector), this.contexts.push(ot), tt = ot.add("onMatch", tt), ot.queries = et;
                for (lt in et) lt === "all" ? ut = 1 : (st = _win$1.matchMedia(et[lt]), st && (_media.indexOf(ot) < 0 && _media.push(ot), (at[lt] = st.matches) && (ut = 1), st.addListener ? st.addListener(_onMediaChange) : st.addEventListener("change", _onMediaChange)));
                return ut && tt(ot, function(dt) {
                    return ot.add(null, dt)
                }), this
            }, _e.revert = function(et) {
                this.kill(et || {})
            }, _e.kill = function(et) {
                this.contexts.forEach(function(tt) {
                    return tt.kill(et, !0)
                })
            }, _
        }(),
        _gsap = {
            registerPlugin: function() {
                for (var _ = arguments.length, _e = new Array(_), et = 0; et < _; et++) _e[et] = arguments[et];
                _e.forEach(function(tt) {
                    return _createPlugin(tt)
                })
            },
            timeline: function(_) {
                return new Timeline(_)
            },
            getTweensOf: function(_, _e) {
                return _globalTimeline.getTweensOf(_, _e)
            },
            getProperty: function(_, _e, et, tt) {
                _isString(_) && (_ = toArray$2(_)[0]);
                var nt = _getCache(_ || {}).get,
                    ot = et ? _passThrough : _numericIfPossible;
                return et === "native" && (et = ""), _ && (_e ? ot((_plugins[_e] && _plugins[_e].get || nt)(_, _e, et, tt)) : function(at, st, lt) {
                    return ot((_plugins[at] && _plugins[at].get || nt)(_, at, st, lt))
                })
            },
            quickSetter: function(_, _e, et) {
                if (_ = toArray$2(_), _.length > 1) {
                    var tt = _.map(function(ut) {
                            return gsap$1.quickSetter(ut, _e, et)
                        }),
                        nt = tt.length;
                    return function(ut) {
                        for (var dt = nt; dt--;) tt[dt](ut)
                    }
                }
                _ = _[0] || {};
                var ot = _plugins[_e],
                    at = _getCache(_),
                    st = at.harness && (at.harness.aliases || {})[_e] || _e,
                    lt = ot ? function(ut) {
                        var dt = new ot;
                        _quickTween._pt = 0, dt.init(_, et ? ut + et : ut, _quickTween, 0, [_]), dt.render(1, dt), _quickTween._pt && _renderPropTweens(1, _quickTween)
                    } : at.set(_, st);
                return ot ? lt : function(ut) {
                    return lt(_, st, et ? ut + et : ut, at, 1)
                }
            },
            quickTo: function(_, _e, et) {
                var tt, nt = gsap$1.to(_, _merge((tt = {}, tt[_e] = "+=0.1", tt.paused = !0, tt), et || {})),
                    ot = function(at, st, lt) {
                        return nt.resetTo(_e, at, st, lt)
                    };
                return ot.tween = nt, ot
            },
            isTweening: function(_) {
                return _globalTimeline.getTweensOf(_, !0).length > 0
            },
            defaults: function(_) {
                return _ && _.ease && (_.ease = _parseEase(_.ease, _defaults.ease)), _mergeDeep(_defaults, _ || {})
            },
            config: function(_) {
                return _mergeDeep(_config, _ || {})
            },
            registerEffect: function(_) {
                var _e = _.name,
                    et = _.effect,
                    tt = _.plugins,
                    nt = _.defaults,
                    ot = _.extendTimeline;
                (tt || "").split(",").forEach(function(at) {
                    return at && !_plugins[at] && !_globals[at] && _warn(_e + " effect requires " + at + " plugin.")
                }), _effects[_e] = function(at, st, lt) {
                    return et(toArray$2(at), _setDefaults(st || {}, nt), lt)
                }, ot && (Timeline.prototype[_e] = function(at, st, lt) {
                    return this.add(_effects[_e](at, _isObject(st) ? st : (lt = st) && {}, this), lt)
                })
            },
            registerEase: function(_, _e) {
                _easeMap[_] = _parseEase(_e)
            },
            parseEase: function(_, _e) {
                return arguments.length ? _parseEase(_, _e) : _easeMap
            },
            getById: function(_) {
                return _globalTimeline.getById(_)
            },
            exportRoot: function(_, _e) {
                _ === void 0 && (_ = {});
                var et = new Timeline(_),
                    tt, nt;
                for (et.smoothChildTiming = _isNotFalse(_.smoothChildTiming), _globalTimeline.remove(et), et._dp = 0, et._time = et._tTime = _globalTimeline._time, tt = _globalTimeline._first; tt;) nt = tt._next, (_e || !(!tt._dur && tt instanceof Tween && tt.vars.onComplete === tt._targets[0])) && _addToTimeline(et, tt, tt._start - tt._delay), tt = nt;
                return _addToTimeline(_globalTimeline, et, 0), et
            },
            context: function(_, _e) {
                return _ ? new Context$1(_, _e) : _context
            },
            matchMedia: function(_) {
                return new MatchMedia(_)
            },
            matchMediaRefresh: function() {
                return _media.forEach(function(_) {
                    var _e = _.conditions,
                        et, tt;
                    for (tt in _e) _e[tt] && (_e[tt] = !1, et = 1);
                    et && _.revert()
                }) || _onMediaChange()
            },
            addEventListener: function(_, _e) {
                var et = _listeners$1[_] || (_listeners$1[_] = []);
                ~et.indexOf(_e) || et.push(_e)
            },
            removeEventListener: function(_, _e) {
                var et = _listeners$1[_],
                    tt = et && et.indexOf(_e);
                tt >= 0 && et.splice(tt, 1)
            },
            utils: {
                wrap,
                wrapYoyo,
                distribute,
                random: random$1,
                snap,
                normalize,
                getUnit,
                clamp: clamp$1,
                splitColor: splitColor$1,
                toArray: toArray$2,
                selector,
                mapRange,
                pipe: pipe$1,
                unitize,
                interpolate: interpolate$1,
                shuffle
            },
            install: _install,
            effects: _effects,
            ticker: _ticker,
            updateRoot: Timeline.updateRoot,
            plugins: _plugins,
            globalTimeline: _globalTimeline,
            core: {
                PropTween,
                globals: _addGlobal,
                Tween,
                Timeline,
                Animation,
                getCache: _getCache,
                _removeLinkedListItem,
                reverting: function() {
                    return _reverting$1
                },
                context: function(_) {
                    return _ && _context && (_context.data.push(_), _._ctx = _context), _context
                },
                suppressOverwrites: function(_) {
                    return _suppressOverwrites = _
                }
            }
        };
    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(_) {
        return _gsap[_] = Tween[_]
    }), _ticker.add(Timeline.updateRoot), _quickTween = _gsap.to({}, {
        duration: 0
    });
    var _getPluginPropTween = function(_, _e) {
            for (var et = _._pt; et && et.p !== _e && et.op !== _e && et.fp !== _e;) et = et._next;
            return et
        },
        _addModifiers = function(_, _e) {
            var et = _._targets,
                tt, nt, ot;
            for (tt in _e)
                for (nt = et.length; nt--;) ot = _._ptLookup[nt][tt], ot && (ot = ot.d) && (ot._pt && (ot = _getPluginPropTween(ot, tt)), ot && ot.modifier && ot.modifier(_e[tt], _, et[nt], tt))
        },
        _buildModifierPlugin = function(_, _e) {
            return {
                name: _,
                rawVars: 1,
                init: function(et, tt, nt) {
                    nt._onInit = function(ot) {
                        var at, st;
                        if (_isString(tt) && (at = {}, _forEachName(tt, function(lt) {
                                return at[lt] = 1
                            }), tt = at), _e) {
                            at = {};
                            for (st in tt) at[st] = _e(tt[st]);
                            tt = at
                        }
                        _addModifiers(ot, tt)
                    }
                }
            }
        },
        gsap$1 = _gsap.registerPlugin({
            name: "attr",
            init: function(_, _e, et, tt, nt) {
                var ot, at, st;
                this.tween = et;
                for (ot in _e) st = _.getAttribute(ot) || "", at = this.add(_, "setAttribute", (st || 0) + "", _e[ot], tt, nt, 0, 0, ot), at.op = ot, at.b = st, this._props.push(ot)
            },
            render: function(_, _e) {
                for (var et = _e._pt; et;) _reverting$1 ? et.set(et.t, et.p, et.b, et) : et.r(_, et.d), et = et._next
            }
        }, {
            name: "endArray",
            init: function(_, _e) {
                for (var et = _e.length; et--;) this.add(_, et, _[et] || 0, _e[et], 0, 0, 0, 0, 0, 1)
            }
        }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
    Tween.version = Timeline.version = gsap$1.version = "3.12.4", _coreReady = 1, _windowExists$1() && _wake();
    let Power0, Power1, Power2, Power3, Power4, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ;
    Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ;
    var _win, _doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _windowExists = function() {
            return typeof window < "u"
        },
        _transformProps = {},
        _RAD2DEG = 180 / Math.PI,
        _DEG2RAD = Math.PI / 180,
        _atan2 = Math.atan2,
        _bigNum = 1e8,
        _capsExp = /([A-Z])/g,
        _horizontalExp = /(left|right|width|margin|padding|x)/i,
        _complexExp = /[\s,\(]\S/,
        _propertyAliases = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        _renderCSSProp = function(_, _e) {
            return _e.set(_e.t, _e.p, Math.round((_e.s + _e.c * _) * 1e4) / 1e4 + _e.u, _e)
        },
        _renderPropWithEnd = function(_, _e) {
            return _e.set(_e.t, _e.p, _ === 1 ? _e.e : Math.round((_e.s + _e.c * _) * 1e4) / 1e4 + _e.u, _e)
        },
        _renderCSSPropWithBeginning = function(_, _e) {
            return _e.set(_e.t, _e.p, _ ? Math.round((_e.s + _e.c * _) * 1e4) / 1e4 + _e.u : _e.b, _e)
        },
        _renderRoundedCSSProp = function(_, _e) {
            var et = _e.s + _e.c * _;
            _e.set(_e.t, _e.p, ~~(et + (et < 0 ? -.5 : .5)) + _e.u, _e)
        },
        _renderNonTweeningValue = function(_, _e) {
            return _e.set(_e.t, _e.p, _ ? _e.e : _e.b, _e)
        },
        _renderNonTweeningValueOnlyAtEnd = function(_, _e) {
            return _e.set(_e.t, _e.p, _ !== 1 ? _e.b : _e.e, _e)
        },
        _setterCSSStyle = function(_, _e, et) {
            return _.style[_e] = et
        },
        _setterCSSProp = function(_, _e, et) {
            return _.style.setProperty(_e, et)
        },
        _setterTransform = function(_, _e, et) {
            return _._gsap[_e] = et
        },
        _setterScale = function(_, _e, et) {
            return _._gsap.scaleX = _._gsap.scaleY = et
        },
        _setterScaleWithRender = function(_, _e, et, tt, nt) {
            var ot = _._gsap;
            ot.scaleX = ot.scaleY = et, ot.renderTransform(nt, ot)
        },
        _setterTransformWithRender = function(_, _e, et, tt, nt) {
            var ot = _._gsap;
            ot[_e] = et, ot.renderTransform(nt, ot)
        },
        _transformProp = "transform",
        _transformOriginProp = _transformProp + "Origin",
        _saveStyle = function _(_e, et) {
            var tt = this,
                nt = this.target,
                ot = nt.style,
                at = nt._gsap;
            if (_e in _transformProps && ot) {
                if (this.tfm = this.tfm || {}, _e !== "transform") _e = _propertyAliases[_e] || _e, ~_e.indexOf(",") ? _e.split(",").forEach(function(st) {
                    return tt.tfm[st] = _get(nt, st)
                }) : this.tfm[_e] = at.x ? at[_e] : _get(nt, _e), _e === _transformOriginProp && (this.tfm.zOrigin = at.zOrigin);
                else return _propertyAliases.transform.split(",").forEach(function(st) {
                    return _.call(tt, st, et)
                });
                if (this.props.indexOf(_transformProp) >= 0) return;
                at.svg && (this.svgo = nt.getAttribute("data-svg-origin"), this.props.push(_transformOriginProp, et, "")), _e = _transformProp
            }(ot || et) && this.props.push(_e, et, ot[_e])
        },
        _removeIndependentTransforms = function(_) {
            _.translate && (_.removeProperty("translate"), _.removeProperty("scale"), _.removeProperty("rotate"))
        },
        _revertStyle = function() {
            var _ = this.props,
                _e = this.target,
                et = _e.style,
                tt = _e._gsap,
                nt, ot;
            for (nt = 0; nt < _.length; nt += 3) _[nt + 1] ? _e[_[nt]] = _[nt + 2] : _[nt + 2] ? et[_[nt]] = _[nt + 2] : et.removeProperty(_[nt].substr(0, 2) === "--" ? _[nt] : _[nt].replace(_capsExp, "-$1").toLowerCase());
            if (this.tfm) {
                for (ot in this.tfm) tt[ot] = this.tfm[ot];
                tt.svg && (tt.renderTransform(), _e.setAttribute("data-svg-origin", this.svgo || "")), nt = _reverting(), (!nt || !nt.isStart) && !et[_transformProp] && (_removeIndependentTransforms(et), tt.zOrigin && et[_transformOriginProp] && (et[_transformOriginProp] += " " + tt.zOrigin + "px", tt.zOrigin = 0, tt.renderTransform()), tt.uncache = 1)
            }
        },
        _getStyleSaver = function(_, _e) {
            var et = {
                target: _,
                props: [],
                revert: _revertStyle,
                save: _saveStyle
            };
            return _._gsap || gsap$1.core.getCache(_), _e && _e.split(",").forEach(function(tt) {
                return et.save(tt)
            }), et
        },
        _supports3D, _createElement = function(_, _e) {
            var et = _doc.createElementNS ? _doc.createElementNS((_e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), _) : _doc.createElement(_);
            return et && et.style ? et : _doc.createElement(_)
        },
        _getComputedProperty = function _(_e, et, tt) {
            var nt = getComputedStyle(_e);
            return nt[et] || nt.getPropertyValue(et.replace(_capsExp, "-$1").toLowerCase()) || nt.getPropertyValue(et) || !tt && _(_e, _checkPropPrefix(et) || et, 1) || ""
        },
        _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
        _checkPropPrefix = function(_, _e, et) {
            var tt = _e || _tempDiv,
                nt = tt.style,
                ot = 5;
            if (_ in nt && !et) return _;
            for (_ = _.charAt(0).toUpperCase() + _.substr(1); ot-- && !(_prefixes[ot] + _ in nt););
            return ot < 0 ? null : (ot === 3 ? "ms" : ot >= 0 ? _prefixes[ot] : "") + _
        },
        _initCore = function() {
            _windowExists() && window.document && (_win = window, _doc = _win.document, _docElement = _doc.documentElement, _tempDiv = _createElement("div") || {
                style: {}
            }, _createElement("div"), _transformProp = _checkPropPrefix(_transformProp), _transformOriginProp = _transformProp + "Origin", _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", _supports3D = !!_checkPropPrefix("perspective"), _reverting = gsap$1.core.reverting, _pluginInitted = 1)
        },
        _getBBoxHack = function _(_e) {
            var et = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                tt = this.parentNode,
                nt = this.nextSibling,
                ot = this.style.cssText,
                at;
            if (_docElement.appendChild(et), et.appendChild(this), this.style.display = "block", _e) try {
                at = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = _
            } catch (st) {} else this._gsapBBox && (at = this._gsapBBox());
            return tt && (nt ? tt.insertBefore(this, nt) : tt.appendChild(this)), _docElement.removeChild(et), this.style.cssText = ot, at
        },
        _getAttributeFallbacks = function(_, _e) {
            for (var et = _e.length; et--;)
                if (_.hasAttribute(_e[et])) return _.getAttribute(_e[et])
        },
        _getBBox = function(_) {
            var _e;
            try {
                _e = _.getBBox()
            } catch (et) {
                _e = _getBBoxHack.call(_, !0)
            }
            return _e && (_e.width || _e.height) || _.getBBox === _getBBoxHack || (_e = _getBBoxHack.call(_, !0)), _e && !_e.width && !_e.x && !_e.y ? {
                x: +_getAttributeFallbacks(_, ["x", "cx", "x1"]) || 0,
                y: +_getAttributeFallbacks(_, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            } : _e
        },
        _isSVG = function(_) {
            return !!(_.getCTM && (!_.parentNode || _.ownerSVGElement) && _getBBox(_))
        },
        _removeProperty = function(_, _e) {
            if (_e) {
                var et = _.style,
                    tt;
                _e in _transformProps && _e !== _transformOriginProp && (_e = _transformProp), et.removeProperty ? (tt = _e.substr(0, 2), (tt === "ms" || _e.substr(0, 6) === "webkit") && (_e = "-" + _e), et.removeProperty(tt === "--" ? _e : _e.replace(_capsExp, "-$1").toLowerCase())) : et.removeAttribute(_e)
            }
        },
        _addNonTweeningPT = function(_, _e, et, tt, nt, ot) {
            var at = new PropTween(_._pt, _e, et, 0, 1, ot ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
            return _._pt = at, at.b = tt, at.e = nt, _._props.push(et), at
        },
        _nonConvertibleUnits = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        _nonStandardLayouts = {
            grid: 1,
            flex: 1
        },
        _convertToUnit = function _(_e, et, tt, nt) {
            var ot = parseFloat(tt) || 0,
                at = (tt + "").trim().substr((ot + "").length) || "px",
                st = _tempDiv.style,
                lt = _horizontalExp.test(et),
                ut = _e.tagName.toLowerCase() === "svg",
                dt = (ut ? "client" : "offset") + (lt ? "Width" : "Height"),
                ct = 100,
                pt = nt === "px",
                ft = nt === "%",
                ht, mt, bt, gt;
            if (nt === at || !ot || _nonConvertibleUnits[nt] || _nonConvertibleUnits[at]) return ot;
            if (at !== "px" && !pt && (ot = _(_e, et, tt, "px")), gt = _e.getCTM && _isSVG(_e), (ft || at === "%") && (_transformProps[et] || ~et.indexOf("adius"))) return ht = gt ? _e.getBBox()[lt ? "width" : "height"] : _e[dt], _round(ft ? ot / ht * ct : ot / 100 * ht);
            if (st[lt ? "width" : "height"] = ct + (pt ? at : nt), mt = ~et.indexOf("adius") || nt === "em" && _e.appendChild && !ut ? _e : _e.parentNode, gt && (mt = (_e.ownerSVGElement || {}).parentNode), (!mt || mt === _doc || !mt.appendChild) && (mt = _doc.body), bt = mt._gsap, bt && ft && bt.width && lt && bt.time === _ticker.time && !bt.uncache) return _round(ot / bt.width * ct);
            if (ft && (et === "height" || et === "width")) {
                var vt = _e.style[et];
                _e.style[et] = ct + nt, ht = _e[dt], vt ? _e.style[et] = vt : _removeProperty(_e, et)
            } else(ft || at === "%") && !_nonStandardLayouts[_getComputedProperty(mt, "display")] && (st.position = _getComputedProperty(_e, "position")), mt === _e && (st.position = "static"), mt.appendChild(_tempDiv), ht = _tempDiv[dt], mt.removeChild(_tempDiv), st.position = "absolute";
            return lt && ft && (bt = _getCache(mt), bt.time = _ticker.time, bt.width = mt[dt]), _round(pt ? ht * ot / ct : ht && ot ? ct / ht * ot : 0)
        },
        _get = function(_, _e, et, tt) {
            var nt;
            return _pluginInitted || _initCore(), _e in _propertyAliases && _e !== "transform" && (_e = _propertyAliases[_e], ~_e.indexOf(",") && (_e = _e.split(",")[0])), _transformProps[_e] && _e !== "transform" ? (nt = _parseTransform(_, tt), nt = _e !== "transformOrigin" ? nt[_e] : nt.svg ? nt.origin : _firstTwoOnly(_getComputedProperty(_, _transformOriginProp)) + " " + nt.zOrigin + "px") : (nt = _.style[_e], (!nt || nt === "auto" || tt || ~(nt + "").indexOf("calc(")) && (nt = _specialProps[_e] && _specialProps[_e](_, _e, et) || _getComputedProperty(_, _e) || _getProperty(_, _e) || (_e === "opacity" ? 1 : 0))), et && !~(nt + "").trim().indexOf(" ") ? _convertToUnit(_, _e, nt, et) + et : nt
        },
        _tweenComplexCSSString = function(_, _e, et, tt) {
            if (!et || et === "none") {
                var nt = _checkPropPrefix(_e, _, 1),
                    ot = nt && _getComputedProperty(_, nt, 1);
                ot && ot !== et ? (_e = nt, et = ot) : _e === "borderColor" && (et = _getComputedProperty(_, "borderTopColor"))
            }
            var at = new PropTween(this._pt, _.style, _e, 0, 1, _renderComplexString),
                st = 0,
                lt = 0,
                ut, dt, ct, pt, ft, ht, mt, bt, gt, vt, xt, yt;
            if (at.b = et, at.e = tt, et += "", tt += "", tt === "auto" && (ht = _.style[_e], _.style[_e] = tt, tt = _getComputedProperty(_, _e) || tt, ht ? _.style[_e] = ht : _removeProperty(_, _e)), ut = [et, tt], _colorStringFilter(ut), et = ut[0], tt = ut[1], ct = et.match(_numWithUnitExp) || [], yt = tt.match(_numWithUnitExp) || [], yt.length) {
                for (; dt = _numWithUnitExp.exec(tt);) mt = dt[0], gt = tt.substring(st, dt.index), ft ? ft = (ft + 1) % 5 : (gt.substr(-5) === "rgba(" || gt.substr(-5) === "hsla(") && (ft = 1), mt !== (ht = ct[lt++] || "") && (pt = parseFloat(ht) || 0, xt = ht.substr((pt + "").length), mt.charAt(1) === "=" && (mt = _parseRelative(pt, mt) + xt), bt = parseFloat(mt), vt = mt.substr((bt + "").length), st = _numWithUnitExp.lastIndex - vt.length, vt || (vt = vt || _config.units[_e] || xt, st === tt.length && (tt += vt, at.e += vt)), xt !== vt && (pt = _convertToUnit(_, _e, ht, vt) || 0), at._pt = {
                    _next: at._pt,
                    p: gt || lt === 1 ? gt : ",",
                    s: pt,
                    c: bt - pt,
                    m: ft && ft < 4 || _e === "zIndex" ? Math.round : 0
                });
                at.c = st < tt.length ? tt.substring(st, tt.length) : ""
            } else at.r = _e === "display" && tt === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
            return _relExp.test(tt) && (at.e = 0), this._pt = at, at
        },
        _keywordToPercent = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        _convertKeywordsToPercentages = function(_) {
            var _e = _.split(" "),
                et = _e[0],
                tt = _e[1] || "50%";
            return (et === "top" || et === "bottom" || tt === "left" || tt === "right") && (_ = et, et = tt, tt = _), _e[0] = _keywordToPercent[et] || et, _e[1] = _keywordToPercent[tt] || tt, _e.join(" ")
        },
        _renderClearProps = function(_, _e) {
            if (_e.tween && _e.tween._time === _e.tween._dur) {
                var et = _e.t,
                    tt = et.style,
                    nt = _e.u,
                    ot = et._gsap,
                    at, st, lt;
                if (nt === "all" || nt === !0) tt.cssText = "", st = 1;
                else
                    for (nt = nt.split(","), lt = nt.length; --lt > -1;) at = nt[lt], _transformProps[at] && (st = 1, at = at === "transformOrigin" ? _transformOriginProp : _transformProp), _removeProperty(et, at);
                st && (_removeProperty(et, _transformProp), ot && (ot.svg && et.removeAttribute("transform"), _parseTransform(et, 1), ot.uncache = 1, _removeIndependentTransforms(tt)))
            }
        },
        _specialProps = {
            clearProps: function(_, _e, et, tt, nt) {
                if (nt.data !== "isFromStart") {
                    var ot = _._pt = new PropTween(_._pt, _e, et, 0, 0, _renderClearProps);
                    return ot.u = tt, ot.pr = -10, ot.tween = nt, _._props.push(et), 1
                }
            }
        },
        _identity2DMatrix = [1, 0, 0, 1, 0, 0],
        _rotationalProperties = {},
        _isNullTransform = function(_) {
            return _ === "matrix(1, 0, 0, 1, 0, 0)" || _ === "none" || !_
        },
        _getComputedTransformMatrixAsArray = function(_) {
            var _e = _getComputedProperty(_, _transformProp);
            return _isNullTransform(_e) ? _identity2DMatrix : _e.substr(7).match(_numExp).map(_round)
        },
        _getMatrix = function(_, _e) {
            var et = _._gsap || _getCache(_),
                tt = _.style,
                nt = _getComputedTransformMatrixAsArray(_),
                ot, at, st, lt;
            return et.svg && _.getAttribute("transform") ? (st = _.transform.baseVal.consolidate().matrix, nt = [st.a, st.b, st.c, st.d, st.e, st.f], nt.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : nt) : (nt === _identity2DMatrix && !_.offsetParent && _ !== _docElement && !et.svg && (st = tt.display, tt.display = "block", ot = _.parentNode, (!ot || !_.offsetParent) && (lt = 1, at = _.nextElementSibling, _docElement.appendChild(_)), nt = _getComputedTransformMatrixAsArray(_), st ? tt.display = st : _removeProperty(_, "display"), lt && (at ? ot.insertBefore(_, at) : ot ? ot.appendChild(_) : _docElement.removeChild(_))), _e && nt.length > 6 ? [nt[0], nt[1], nt[4], nt[5], nt[12], nt[13]] : nt)
        },
        _applySVGOrigin = function(_, _e, et, tt, nt, ot) {
            var at = _._gsap,
                st = nt || _getMatrix(_, !0),
                lt = at.xOrigin || 0,
                ut = at.yOrigin || 0,
                dt = at.xOffset || 0,
                ct = at.yOffset || 0,
                pt = st[0],
                ft = st[1],
                ht = st[2],
                mt = st[3],
                bt = st[4],
                gt = st[5],
                vt = _e.split(" "),
                xt = parseFloat(vt[0]) || 0,
                yt = parseFloat(vt[1]) || 0,
                Et, wt, St, $t;
            et ? st !== _identity2DMatrix && (wt = pt * mt - ft * ht) && (St = xt * (mt / wt) + yt * (-ht / wt) + (ht * gt - mt * bt) / wt, $t = xt * (-ft / wt) + yt * (pt / wt) - (pt * gt - ft * bt) / wt, xt = St, yt = $t) : (Et = _getBBox(_), xt = Et.x + (~vt[0].indexOf("%") ? xt / 100 * Et.width : xt), yt = Et.y + (~(vt[1] || vt[0]).indexOf("%") ? yt / 100 * Et.height : yt)), tt || tt !== !1 && at.smooth ? (bt = xt - lt, gt = yt - ut, at.xOffset = dt + (bt * pt + gt * ht) - bt, at.yOffset = ct + (bt * ft + gt * mt) - gt) : at.xOffset = at.yOffset = 0, at.xOrigin = xt, at.yOrigin = yt, at.smooth = !!tt, at.origin = _e, at.originIsAbsolute = !!et, _.style[_transformOriginProp] = "0px 0px", ot && (_addNonTweeningPT(ot, at, "xOrigin", lt, xt), _addNonTweeningPT(ot, at, "yOrigin", ut, yt), _addNonTweeningPT(ot, at, "xOffset", dt, at.xOffset), _addNonTweeningPT(ot, at, "yOffset", ct, at.yOffset)), _.setAttribute("data-svg-origin", xt + " " + yt)
        },
        _parseTransform = function(_, _e) {
            var et = _._gsap || new GSCache(_);
            if ("x" in et && !_e && !et.uncache) return et;
            var tt = _.style,
                nt = et.scaleX < 0,
                ot = "px",
                at = "deg",
                st = getComputedStyle(_),
                lt = _getComputedProperty(_, _transformOriginProp) || "0",
                ut, dt, ct, pt, ft, ht, mt, bt, gt, vt, xt, yt, Et, wt, St, $t, Ct, Rt, Pt, Tt, It, Ot, Dt, jt, Ht, Mt, Ft, Vt, Zt, Jt, qt, Kt;
            return ut = dt = ct = ht = mt = bt = gt = vt = xt = 0, pt = ft = 1, et.svg = !!(_.getCTM && _isSVG(_)), st.translate && ((st.translate !== "none" || st.scale !== "none" || st.rotate !== "none") && (tt[_transformProp] = (st.translate !== "none" ? "translate3d(" + (st.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (st.rotate !== "none" ? "rotate(" + st.rotate + ") " : "") + (st.scale !== "none" ? "scale(" + st.scale.split(" ").join(",") + ") " : "") + (st[_transformProp] !== "none" ? st[_transformProp] : "")), tt.scale = tt.rotate = tt.translate = "none"), wt = _getMatrix(_, et.svg), et.svg && (et.uncache ? (Ht = _.getBBox(), lt = et.xOrigin - Ht.x + "px " + (et.yOrigin - Ht.y) + "px", jt = "") : jt = !_e && _.getAttribute("data-svg-origin"), _applySVGOrigin(_, jt || lt, !!jt || et.originIsAbsolute, et.smooth !== !1, wt)), yt = et.xOrigin || 0, Et = et.yOrigin || 0, wt !== _identity2DMatrix && (Rt = wt[0], Pt = wt[1], Tt = wt[2], It = wt[3], ut = Ot = wt[4], dt = Dt = wt[5], wt.length === 6 ? (pt = Math.sqrt(Rt * Rt + Pt * Pt), ft = Math.sqrt(It * It + Tt * Tt), ht = Rt || Pt ? _atan2(Pt, Rt) * _RAD2DEG : 0, gt = Tt || It ? _atan2(Tt, It) * _RAD2DEG + ht : 0, gt && (ft *= Math.abs(Math.cos(gt * _DEG2RAD))), et.svg && (ut -= yt - (yt * Rt + Et * Tt), dt -= Et - (yt * Pt + Et * It))) : (Kt = wt[6], Jt = wt[7], Ft = wt[8], Vt = wt[9], Zt = wt[10], qt = wt[11], ut = wt[12], dt = wt[13], ct = wt[14], St = _atan2(Kt, Zt), mt = St * _RAD2DEG, St && ($t = Math.cos(-St), Ct = Math.sin(-St), jt = Ot * $t + Ft * Ct, Ht = Dt * $t + Vt * Ct, Mt = Kt * $t + Zt * Ct, Ft = Ot * -Ct + Ft * $t, Vt = Dt * -Ct + Vt * $t, Zt = Kt * -Ct + Zt * $t, qt = Jt * -Ct + qt * $t, Ot = jt, Dt = Ht, Kt = Mt), St = _atan2(-Tt, Zt), bt = St * _RAD2DEG, St && ($t = Math.cos(-St), Ct = Math.sin(-St), jt = Rt * $t - Ft * Ct, Ht = Pt * $t - Vt * Ct, Mt = Tt * $t - Zt * Ct, qt = It * Ct + qt * $t, Rt = jt, Pt = Ht, Tt = Mt), St = _atan2(Pt, Rt), ht = St * _RAD2DEG, St && ($t = Math.cos(St), Ct = Math.sin(St), jt = Rt * $t + Pt * Ct, Ht = Ot * $t + Dt * Ct, Pt = Pt * $t - Rt * Ct, Dt = Dt * $t - Ot * Ct, Rt = jt, Ot = Ht), mt && Math.abs(mt) + Math.abs(ht) > 359.9 && (mt = ht = 0, bt = 180 - bt), pt = _round(Math.sqrt(Rt * Rt + Pt * Pt + Tt * Tt)), ft = _round(Math.sqrt(Dt * Dt + Kt * Kt)), St = _atan2(Ot, Dt), gt = Math.abs(St) > 2e-4 ? St * _RAD2DEG : 0, xt = qt ? 1 / (qt < 0 ? -qt : qt) : 0), et.svg && (jt = _.getAttribute("transform"), et.forceCSS = _.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(_, _transformProp)), jt && _.setAttribute("transform", jt))), Math.abs(gt) > 90 && Math.abs(gt) < 270 && (nt ? (pt *= -1, gt += ht <= 0 ? 180 : -180, ht += ht <= 0 ? 180 : -180) : (ft *= -1, gt += gt <= 0 ? 180 : -180)), _e = _e || et.uncache, et.x = ut - ((et.xPercent = ut && (!_e && et.xPercent || (Math.round(_.offsetWidth / 2) === Math.round(-ut) ? -50 : 0))) ? _.offsetWidth * et.xPercent / 100 : 0) + ot, et.y = dt - ((et.yPercent = dt && (!_e && et.yPercent || (Math.round(_.offsetHeight / 2) === Math.round(-dt) ? -50 : 0))) ? _.offsetHeight * et.yPercent / 100 : 0) + ot, et.z = ct + ot, et.scaleX = _round(pt), et.scaleY = _round(ft), et.rotation = _round(ht) + at, et.rotationX = _round(mt) + at, et.rotationY = _round(bt) + at, et.skewX = gt + at, et.skewY = vt + at, et.transformPerspective = xt + ot, (et.zOrigin = parseFloat(lt.split(" ")[2]) || !_e && et.zOrigin || 0) && (tt[_transformOriginProp] = _firstTwoOnly(lt)), et.xOffset = et.yOffset = 0, et.force3D = _config.force3D, et.renderTransform = et.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms, et.uncache = 0, et
        },
        _firstTwoOnly = function(_) {
            return (_ = _.split(" "))[0] + " " + _[1]
        },
        _addPxTranslate = function(_, _e, et) {
            var tt = getUnit(_e);
            return _round(parseFloat(_e) + parseFloat(_convertToUnit(_, "x", et + "px", tt))) + tt
        },
        _renderNon3DTransforms = function(_, _e) {
            _e.z = "0px", _e.rotationY = _e.rotationX = "0deg", _e.force3D = 0, _renderCSSTransforms(_, _e)
        },
        _zeroDeg = "0deg",
        _zeroPx = "0px",
        _endParenthesis = ") ",
        _renderCSSTransforms = function(_, _e) {
            var et = _e || this,
                tt = et.xPercent,
                nt = et.yPercent,
                ot = et.x,
                at = et.y,
                st = et.z,
                lt = et.rotation,
                ut = et.rotationY,
                dt = et.rotationX,
                ct = et.skewX,
                pt = et.skewY,
                ft = et.scaleX,
                ht = et.scaleY,
                mt = et.transformPerspective,
                bt = et.force3D,
                gt = et.target,
                vt = et.zOrigin,
                xt = "",
                yt = bt === "auto" && _ && _ !== 1 || bt === !0;
            if (vt && (dt !== _zeroDeg || ut !== _zeroDeg)) {
                var Et = parseFloat(ut) * _DEG2RAD,
                    wt = Math.sin(Et),
                    St = Math.cos(Et),
                    $t;
                Et = parseFloat(dt) * _DEG2RAD, $t = Math.cos(Et), ot = _addPxTranslate(gt, ot, wt * $t * -vt), at = _addPxTranslate(gt, at, -Math.sin(Et) * -vt), st = _addPxTranslate(gt, st, St * $t * -vt + vt)
            }
            mt !== _zeroPx && (xt += "perspective(" + mt + _endParenthesis), (tt || nt) && (xt += "translate(" + tt + "%, " + nt + "%) "), (yt || ot !== _zeroPx || at !== _zeroPx || st !== _zeroPx) && (xt += st !== _zeroPx || yt ? "translate3d(" + ot + ", " + at + ", " + st + ") " : "translate(" + ot + ", " + at + _endParenthesis), lt !== _zeroDeg && (xt += "rotate(" + lt + _endParenthesis), ut !== _zeroDeg && (xt += "rotateY(" + ut + _endParenthesis), dt !== _zeroDeg && (xt += "rotateX(" + dt + _endParenthesis), (ct !== _zeroDeg || pt !== _zeroDeg) && (xt += "skew(" + ct + ", " + pt + _endParenthesis), (ft !== 1 || ht !== 1) && (xt += "scale(" + ft + ", " + ht + _endParenthesis), gt.style[_transformProp] = xt || "translate(0, 0)"
        },
        _renderSVGTransforms = function(_, _e) {
            var et = _e || this,
                tt = et.xPercent,
                nt = et.yPercent,
                ot = et.x,
                at = et.y,
                st = et.rotation,
                lt = et.skewX,
                ut = et.skewY,
                dt = et.scaleX,
                ct = et.scaleY,
                pt = et.target,
                ft = et.xOrigin,
                ht = et.yOrigin,
                mt = et.xOffset,
                bt = et.yOffset,
                gt = et.forceCSS,
                vt = parseFloat(ot),
                xt = parseFloat(at),
                yt, Et, wt, St, $t;
            st = parseFloat(st), lt = parseFloat(lt), ut = parseFloat(ut), ut && (ut = parseFloat(ut), lt += ut, st += ut), st || lt ? (st *= _DEG2RAD, lt *= _DEG2RAD, yt = Math.cos(st) * dt, Et = Math.sin(st) * dt, wt = Math.sin(st - lt) * -ct, St = Math.cos(st - lt) * ct, lt && (ut *= _DEG2RAD, $t = Math.tan(lt - ut), $t = Math.sqrt(1 + $t * $t), wt *= $t, St *= $t, ut && ($t = Math.tan(ut), $t = Math.sqrt(1 + $t * $t), yt *= $t, Et *= $t)), yt = _round(yt), Et = _round(Et), wt = _round(wt), St = _round(St)) : (yt = dt, St = ct, Et = wt = 0), (vt && !~(ot + "").indexOf("px") || xt && !~(at + "").indexOf("px")) && (vt = _convertToUnit(pt, "x", ot, "px"), xt = _convertToUnit(pt, "y", at, "px")), (ft || ht || mt || bt) && (vt = _round(vt + ft - (ft * yt + ht * wt) + mt), xt = _round(xt + ht - (ft * Et + ht * St) + bt)), (tt || nt) && ($t = pt.getBBox(), vt = _round(vt + tt / 100 * $t.width), xt = _round(xt + nt / 100 * $t.height)), $t = "matrix(" + yt + "," + Et + "," + wt + "," + St + "," + vt + "," + xt + ")", pt.setAttribute("transform", $t), gt && (pt.style[_transformProp] = $t)
        },
        _addRotationalPropTween = function(_, _e, et, tt, nt) {
            var ot = 360,
                at = _isString(nt),
                st = parseFloat(nt) * (at && ~nt.indexOf("rad") ? _RAD2DEG : 1),
                lt = st - tt,
                ut = tt + lt + "deg",
                dt, ct;
            return at && (dt = nt.split("_")[1], dt === "short" && (lt %= ot, lt !== lt % (ot / 2) && (lt += lt < 0 ? ot : -ot)), dt === "cw" && lt < 0 ? lt = (lt + ot * _bigNum) % ot - ~~(lt / ot) * ot : dt === "ccw" && lt > 0 && (lt = (lt - ot * _bigNum) % ot - ~~(lt / ot) * ot)), _._pt = ct = new PropTween(_._pt, _e, et, tt, lt, _renderPropWithEnd), ct.e = ut, ct.u = "deg", _._props.push(et), ct
        },
        _assign = function(_, _e) {
            for (var et in _e) _[et] = _e[et];
            return _
        },
        _addRawTransformPTs = function(_, _e, et) {
            var tt = _assign({}, et._gsap),
                nt = "perspective,force3D,transformOrigin,svgOrigin",
                ot = et.style,
                at, st, lt, ut, dt, ct, pt, ft;
            tt.svg ? (lt = et.getAttribute("transform"), et.setAttribute("transform", ""), ot[_transformProp] = _e, at = _parseTransform(et, 1), _removeProperty(et, _transformProp), et.setAttribute("transform", lt)) : (lt = getComputedStyle(et)[_transformProp], ot[_transformProp] = _e, at = _parseTransform(et, 1), ot[_transformProp] = lt);
            for (st in _transformProps) lt = tt[st], ut = at[st], lt !== ut && nt.indexOf(st) < 0 && (pt = getUnit(lt), ft = getUnit(ut), dt = pt !== ft ? _convertToUnit(et, st, lt, ft) : parseFloat(lt), ct = parseFloat(ut), _._pt = new PropTween(_._pt, at, st, dt, ct - dt, _renderCSSProp), _._pt.u = ft || 0, _._props.push(st));
            _assign(at, tt)
        };
    _forEachName("padding,margin,Width,Radius", function(_, _e) {
        var et = "Top",
            tt = "Right",
            nt = "Bottom",
            ot = "Left",
            at = (_e < 3 ? [et, tt, nt, ot] : [et + ot, et + tt, nt + tt, nt + ot]).map(function(st) {
                return _e < 2 ? _ + st : "border" + st + _
            });
        _specialProps[_e > 1 ? "border" + _ : _] = function(st, lt, ut, dt, ct) {
            var pt, ft;
            if (arguments.length < 4) return pt = at.map(function(ht) {
                return _get(st, ht, ut)
            }), ft = pt.join(" "), ft.split(pt[0]).length === 5 ? pt[0] : ft;
            pt = (dt + "").split(" "), ft = {}, at.forEach(function(ht, mt) {
                return ft[ht] = pt[mt] = pt[mt] || pt[(mt - 1) / 2 | 0]
            }), st.init(lt, ft, ct)
        }
    });
    var CSSPlugin = {
        name: "css",
        register: _initCore,
        targetTest: function(_) {
            return _.style && _.nodeType
        },
        init: function(_, _e, et, tt, nt) {
            var ot = this._props,
                at = _.style,
                st = et.vars.startAt,
                lt, ut, dt, ct, pt, ft, ht, mt, bt, gt, vt, xt, yt, Et, wt, St;
            _pluginInitted || _initCore(), this.styles = this.styles || _getStyleSaver(_), St = this.styles.props, this.tween = et;
            for (ht in _e)
                if (ht !== "autoRound" && (ut = _e[ht], !(_plugins[ht] && _checkPlugin(ht, _e, et, tt, _, nt)))) {
                    if (pt = typeof ut, ft = _specialProps[ht], pt === "function" && (ut = ut.call(et, tt, _, nt), pt = typeof ut), pt === "string" && ~ut.indexOf("random(") && (ut = _replaceRandom(ut)), ft) ft(this, _, ht, ut, et) && (wt = 1);
                    else if (ht.substr(0, 2) === "--") lt = (getComputedStyle(_).getPropertyValue(ht) + "").trim(), ut += "", _colorExp.lastIndex = 0, _colorExp.test(lt) || (mt = getUnit(lt), bt = getUnit(ut)), bt ? mt !== bt && (lt = _convertToUnit(_, ht, lt, bt) + bt) : mt && (ut += mt), this.add(at, "setProperty", lt, ut, tt, nt, 0, 0, ht), ot.push(ht), St.push(ht, 0, at[ht]);
                    else if (pt !== "undefined") {
                        if (st && ht in st ? (lt = typeof st[ht] == "function" ? st[ht].call(et, tt, _, nt) : st[ht], _isString(lt) && ~lt.indexOf("random(") && (lt = _replaceRandom(lt)), getUnit(lt + "") || lt === "auto" || (lt += _config.units[ht] || getUnit(_get(_, ht)) || ""), (lt + "").charAt(1) === "=" && (lt = _get(_, ht))) : lt = _get(_, ht), ct = parseFloat(lt), gt = pt === "string" && ut.charAt(1) === "=" && ut.substr(0, 2), gt && (ut = ut.substr(2)), dt = parseFloat(ut), ht in _propertyAliases && (ht === "autoAlpha" && (ct === 1 && _get(_, "visibility") === "hidden" && dt && (ct = 0), St.push("visibility", 0, at.visibility), _addNonTweeningPT(this, at, "visibility", ct ? "inherit" : "hidden", dt ? "inherit" : "hidden", !dt)), ht !== "scale" && ht !== "transform" && (ht = _propertyAliases[ht], ~ht.indexOf(",") && (ht = ht.split(",")[0]))), vt = ht in _transformProps, vt) {
                            if (this.styles.save(ht), xt || (yt = _._gsap, yt.renderTransform && !_e.parseTransform || _parseTransform(_, _e.parseTransform), Et = _e.smoothOrigin !== !1 && yt.smooth, xt = this._pt = new PropTween(this._pt, at, _transformProp, 0, 1, yt.renderTransform, yt, 0, -1), xt.dep = 1), ht === "scale") this._pt = new PropTween(this._pt, yt, "scaleY", yt.scaleY, (gt ? _parseRelative(yt.scaleY, gt + dt) : dt) - yt.scaleY || 0, _renderCSSProp), this._pt.u = 0, ot.push("scaleY", ht), ht += "X";
                            else if (ht === "transformOrigin") {
                                St.push(_transformOriginProp, 0, at[_transformOriginProp]), ut = _convertKeywordsToPercentages(ut), yt.svg ? _applySVGOrigin(_, ut, 0, Et, 0, this) : (bt = parseFloat(ut.split(" ")[2]) || 0, bt !== yt.zOrigin && _addNonTweeningPT(this, yt, "zOrigin", yt.zOrigin, bt), _addNonTweeningPT(this, at, ht, _firstTwoOnly(lt), _firstTwoOnly(ut)));
                                continue
                            } else if (ht === "svgOrigin") {
                                _applySVGOrigin(_, ut, 1, Et, 0, this);
                                continue
                            } else if (ht in _rotationalProperties) {
                                _addRotationalPropTween(this, yt, ht, ct, gt ? _parseRelative(ct, gt + ut) : ut);
                                continue
                            } else if (ht === "smoothOrigin") {
                                _addNonTweeningPT(this, yt, "smooth", yt.smooth, ut);
                                continue
                            } else if (ht === "force3D") {
                                yt[ht] = ut;
                                continue
                            } else if (ht === "transform") {
                                _addRawTransformPTs(this, ut, _);
                                continue
                            }
                        } else ht in at || (ht = _checkPropPrefix(ht) || ht);
                        if (vt || (dt || dt === 0) && (ct || ct === 0) && !_complexExp.test(ut) && ht in at) mt = (lt + "").substr((ct + "").length), dt || (dt = 0), bt = getUnit(ut) || (ht in _config.units ? _config.units[ht] : mt), mt !== bt && (ct = _convertToUnit(_, ht, lt, bt)), this._pt = new PropTween(this._pt, vt ? yt : at, ht, ct, (gt ? _parseRelative(ct, gt + dt) : dt) - ct, !vt && (bt === "px" || ht === "zIndex") && _e.autoRound !== !1 ? _renderRoundedCSSProp : _renderCSSProp), this._pt.u = bt || 0, mt !== bt && bt !== "%" && (this._pt.b = lt, this._pt.r = _renderCSSPropWithBeginning);
                        else if (ht in at) _tweenComplexCSSString.call(this, _, ht, lt, gt ? gt + ut : ut);
                        else if (ht in _) this.add(_, ht, lt || _[ht], gt ? gt + ut : ut, tt, nt);
                        else if (ht !== "parseTransform") {
                            _missingPlugin(ht, ut);
                            continue
                        }
                        vt || (ht in at ? St.push(ht, 0, at[ht]) : St.push(ht, 1, lt || _[ht])), ot.push(ht)
                    }
                }
            wt && _sortPropTweensByPriority(this)
        },
        render: function(_, _e) {
            if (_e.tween._time || !_reverting())
                for (var et = _e._pt; et;) et.r(_, et.d), et = et._next;
            else _e.styles.revert()
        },
        get: _get,
        aliases: _propertyAliases,
        getSetter: function(_, _e, et) {
            var tt = _propertyAliases[_e];
            return tt && tt.indexOf(",") < 0 && (_e = tt), _e in _transformProps && _e !== _transformOriginProp && (_._gsap.x || _get(_, "x")) ? et && _recentSetterPlugin === et ? _e === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = et || {}) && (_e === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : _.style && !_isUndefined(_.style[_e]) ? _setterCSSStyle : ~_e.indexOf("-") ? _setterCSSProp : _getSetter(_, _e)
        },
        core: {
            _removeProperty,
            _getMatrix
        }
    };
    gsap$1.utils.checkPrefix = _checkPropPrefix, gsap$1.core.getStyleSaver = _getStyleSaver,
        function(_, _e, et, tt) {
            var nt = _forEachName(_ + "," + _e + "," + et, function(ot) {
                _transformProps[ot] = 1
            });
            _forEachName(_e, function(ot) {
                _config.units[ot] = "deg", _rotationalProperties[ot] = 1
            }), _propertyAliases[nt[13]] = _ + "," + _e, _forEachName(tt, function(ot) {
                var at = ot.split(":");
                _propertyAliases[at[1]] = nt[at[0]]
            })
        }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(_) {
            _config.units[_] = "px"
        }), gsap$1.registerPlugin(CSSPlugin);
    let TweenMaxWithCSS;
    gsapWithCSS = gsap$1.registerPlugin(CSSPlugin) || gsap$1, TweenMaxWithCSS = gsapWithCSS.core.Tween, gsap = Object.freeze(Object.defineProperty({
        __proto__: null,
        Back,
        Bounce,
        CSSPlugin,
        Circ,
        Cubic,
        Elastic,
        Expo,
        Linear,
        Power0,
        Power1,
        Power2,
        Power3,
        Power4,
        Quad,
        Quart,
        Quint,
        Sine,
        SteppedEase,
        Strong,
        TimelineLite: Timeline,
        TimelineMax: Timeline,
        TweenLite: Tween,
        TweenMax: TweenMaxWithCSS,
        default: gsapWithCSS,
        gsap: gsapWithCSS
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self,
        root = freeGlobal$1 || freeSelf || Function("return this")();
    root$1 = root;
    var Symbol$1 = root$1.Symbol;
    Symbol$2 = Symbol$1;
    var objectProto$b = Object.prototype,
        hasOwnProperty$9 = objectProto$b.hasOwnProperty,
        nativeObjectToString$1 = objectProto$b.toString,
        symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;

    function getRawTag(_) {
        var _e = hasOwnProperty$9.call(_, symToStringTag$1),
            et = _[symToStringTag$1];
        try {
            _[symToStringTag$1] = void 0;
            var tt = !0
        } catch (ot) {}
        var nt = nativeObjectToString$1.call(_);
        return tt && (_e ? _[symToStringTag$1] = et : delete _[symToStringTag$1]), nt
    }
    var objectProto$a = Object.prototype,
        nativeObjectToString = objectProto$a.toString;

    function objectToString(_) {
        return nativeObjectToString.call(_)
    }
    var nullTag = "[object Null]",
        undefinedTag = "[object Undefined]",
        symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    baseGetTag = function(_) {
        return _ == null ? _ === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(_) ? getRawTag(_) : objectToString(_)
    }, isObjectLike = function(_) {
        return _ != null && typeof _ == "object"
    };
    var symbolTag$1 = "[object Symbol]";
    isSymbol = function(_) {
        return typeof _ == "symbol" || isObjectLike(_) && baseGetTag(_) == symbolTag$1
    }, arrayMap = function(_, _e) {
        for (var et = -1, tt = _ == null ? 0 : _.length, nt = Array(tt); ++et < tt;) nt[et] = _e(_[et], et, _);
        return nt
    };
    var isArray$3 = Array.isArray;
    n0 = isArray$3;
    var INFINITY$2 = 1 / 0,
        symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    baseToString = function(_) {
        if (typeof _ == "string") return _;
        if (n0(_)) return arrayMap(_, baseToString) + "";
        if (isSymbol(_)) return symbolToString ? symbolToString.call(_) : "";
        var _e = _ + "";
        return _e == "0" && 1 / _ == -INFINITY$2 ? "-0" : _e
    };
    var reWhitespace = /\s/;
    trimmedEndIndex = function(_) {
        for (var _e = _.length; _e-- && reWhitespace.test(_.charAt(_e)););
        return _e
    };
    var reTrimStart = /^\s+/;
    baseTrim = function(_) {
        return _ && _.slice(0, trimmedEndIndex(_) + 1).replace(reTrimStart, "")
    }, isObject$2 = function(_) {
        var _e = typeof _;
        return _ != null && (_e == "object" || _e == "function")
    };
    var NAN = 0 / 0,
        reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
        reIsBinary = /^0b[01]+$/i,
        reIsOctal = /^0o[0-7]+$/i,
        freeParseInt = parseInt;
    toNumber = function(_) {
        if (typeof _ == "number") return _;
        if (isSymbol(_)) return NAN;
        if (isObject$2(_)) {
            var _e = typeof _.valueOf == "function" ? _.valueOf() : _;
            _ = isObject$2(_e) ? _e + "" : _e
        }
        if (typeof _ != "string") return _ === 0 ? _ : +_;
        _ = baseTrim(_);
        var et = reIsBinary.test(_);
        return et || reIsOctal.test(_) ? freeParseInt(_.slice(2), et ? 2 : 8) : reIsBadHex.test(_) ? NAN : +_
    };
    var INFINITY$1 = 1 / 0,
        MAX_INTEGER = 17976931348623157e292;
    toFinite = function(_) {
        if (!_) return _ === 0 ? _ : 0;
        if (_ = toNumber(_), _ === INFINITY$1 || _ === -INFINITY$1) {
            var _e = _ < 0 ? -1 : 1;
            return _e * MAX_INTEGER
        }
        return _ === _ ? _ : 0
    }, toInteger = function(_) {
        var _e = toFinite(_),
            et = _e % 1;
        return _e === _e ? et ? _e - et : _e : 0
    }, identity = function(_) {
        return _
    };
    var asyncTag = "[object AsyncFunction]",
        funcTag$1 = "[object Function]",
        genTag = "[object GeneratorFunction]",
        proxyTag = "[object Proxy]";
    isFunction$1 = function(_) {
        if (!isObject$2(_)) return !1;
        var _e = baseGetTag(_);
        return _e == funcTag$1 || _e == genTag || _e == asyncTag || _e == proxyTag
    };
    var coreJsData = root$1["__core-js_shared__"];
    coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
        var _ = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return _ ? "Symbol(src)_1." + _ : ""
    }();

    function isMasked(_) {
        return !!maskSrcKey && maskSrcKey in _
    }
    var funcProto$1 = Function.prototype,
        funcToString$1 = funcProto$1.toString;

    function toSource(_) {
        if (_ != null) {
            try {
                return funcToString$1.call(_)
            } catch (_e) {}
            try {
                return _ + ""
            } catch (_e) {}
        }
        return ""
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reIsHostCtor = /^\[object .+?Constructor\]$/,
        funcProto = Function.prototype,
        objectProto$9 = Object.prototype,
        funcToString = funcProto.toString,
        hasOwnProperty$8 = objectProto$9.hasOwnProperty,
        reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    baseIsNative = function(_) {
        if (!isObject$2(_) || isMasked(_)) return !1;
        var _e = isFunction$1(_) ? reIsNative : reIsHostCtor;
        return _e.test(toSource(_))
    };

    function getValue(_, _e) {
        return _ == null ? void 0 : _[_e]
    }
    getNative = function(_, _e) {
        var et = getValue(_, _e);
        return baseIsNative(et) ? et : void 0
    };
    var WeakMap$1 = getNative(root$1, "WeakMap");
    WeakMap$2 = WeakMap$1;
    var MAX_SAFE_INTEGER$2 = 9007199254740991,
        reIsUint = /^(?:0|[1-9]\d*)$/;
    isIndex = function(_, _e) {
        var et = typeof _;
        return _e = _e != null ? _e : MAX_SAFE_INTEGER$2, !!_e && (et == "number" || et != "symbol" && reIsUint.test(_)) && _ > -1 && _ % 1 == 0 && _ < _e
    }, eq = function(_, _e) {
        return _ === _e || _ !== _ && _e !== _e
    };
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    isLength = function(_) {
        return typeof _ == "number" && _ > -1 && _ % 1 == 0 && _ <= MAX_SAFE_INTEGER$1
    }, isArrayLike = function(_) {
        return _ != null && isLength(_.length) && !isFunction$1(_)
    }, isIterateeCall = function(_, _e, et) {
        if (!isObject$2(et)) return !1;
        var tt = typeof _e;
        return (tt == "number" ? isArrayLike(et) && isIndex(_e, et.length) : tt == "string" && _e in et) ? eq(et[_e], _) : !1
    };
    var objectProto$8 = Object.prototype;
    isPrototype = function(_) {
        var _e = _ && _.constructor,
            et = typeof _e == "function" && _e.prototype || objectProto$8;
        return _ === et
    }, baseTimes = function(_, _e) {
        for (var et = -1, tt = Array(_); ++et < _;) tt[et] = _e(et);
        return tt
    };
    var argsTag$2 = "[object Arguments]";

    function baseIsArguments(_) {
        return isObjectLike(_) && baseGetTag(_) == argsTag$2
    }
    var objectProto$7 = Object.prototype,
        hasOwnProperty$7 = objectProto$7.hasOwnProperty,
        propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable,
        isArguments = baseIsArguments(function() {
            return arguments
        }()) ? baseIsArguments : function(_) {
            return isObjectLike(_) && hasOwnProperty$7.call(_, "callee") && !propertyIsEnumerable$1.call(_, "callee")
        };
    isArguments$1 = isArguments, stubFalse = function() {
        return !1
    };
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports,
        freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module,
        moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1,
        Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0,
        nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0,
        isBuffer$2 = nativeIsBuffer || stubFalse;
    isBuffer$3 = isBuffer$2;
    var argsTag$1 = "[object Arguments]",
        arrayTag$1 = "[object Array]",
        boolTag$1 = "[object Boolean]",
        dateTag$1 = "[object Date]",
        errorTag$1 = "[object Error]",
        funcTag = "[object Function]",
        mapTag$2 = "[object Map]",
        numberTag$1 = "[object Number]",
        objectTag$2 = "[object Object]",
        regexpTag$1 = "[object RegExp]",
        setTag$2 = "[object Set]",
        stringTag$1 = "[object String]",
        weakMapTag$1 = "[object WeakMap]",
        arrayBufferTag$1 = "[object ArrayBuffer]",
        dataViewTag$2 = "[object DataView]",
        float32Tag = "[object Float32Array]",
        float64Tag = "[object Float64Array]",
        int8Tag = "[object Int8Array]",
        int16Tag = "[object Int16Array]",
        int32Tag = "[object Int32Array]",
        uint8Tag = "[object Uint8Array]",
        uint8ClampedTag = "[object Uint8ClampedArray]",
        uint16Tag = "[object Uint16Array]",
        uint32Tag = "[object Uint32Array]",
        typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = !1;

    function baseIsTypedArray(_) {
        return isObjectLike(_) && isLength(_.length) && !!typedArrayTags[baseGetTag(_)]
    }
    baseUnary = function(_) {
        return function(_e) {
            return _(_e)
        }
    };
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports,
        freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports,
        freeProcess = moduleExports && freeGlobal$1.process,
        nodeUtil = function() {
            try {
                var _ = freeModule && freeModule.require && freeModule.require("util").types;
                return _ || freeProcess && freeProcess.binding && freeProcess.binding("util")
            } catch (_e) {}
        }();
    nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray,
        isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    isTypedArray$2 = isTypedArray$1;
    var objectProto$6 = Object.prototype,
        hasOwnProperty$6 = objectProto$6.hasOwnProperty;
    arrayLikeKeys = function(_, _e) {
        var et = n0(_),
            tt = !et && isArguments$1(_),
            nt = !et && !tt && isBuffer$3(_),
            ot = !et && !tt && !nt && isTypedArray$2(_),
            at = et || tt || nt || ot,
            st = at ? baseTimes(_.length, String) : [],
            lt = st.length;
        for (var ut in _)(_e || hasOwnProperty$6.call(_, ut)) && !(at && (ut == "length" || nt && (ut == "offset" || ut == "parent") || ot && (ut == "buffer" || ut == "byteLength" || ut == "byteOffset") || isIndex(ut, lt))) && st.push(ut);
        return st
    }, overArg = function(_, _e) {
        return function(et) {
            return _(_e(et))
        }
    };
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$5 = Object.prototype,
        hasOwnProperty$5 = objectProto$5.hasOwnProperty;
    baseKeys = function(_) {
        if (!isPrototype(_)) return nativeKeys$1(_);
        var _e = [];
        for (var et in Object(_)) hasOwnProperty$5.call(_, et) && et != "constructor" && _e.push(et);
        return _e
    }, keys$1 = function(_) {
        return isArrayLike(_) ? arrayLikeKeys(_) : baseKeys(_)
    };
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    function isKey(_, _e) {
        if (n0(_)) return !1;
        var et = typeof _;
        return et == "number" || et == "symbol" || et == "boolean" || _ == null || isSymbol(_) ? !0 : reIsPlainProp.test(_) || !reIsDeepProp.test(_) || _e != null && _ in Object(_e)
    }
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;

    function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}, this.size = 0
    }

    function hashDelete(_) {
        var _e = this.has(_) && delete this.__data__[_];
        return this.size -= _e ? 1 : 0, _e
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__",
        objectProto$4 = Object.prototype,
        hasOwnProperty$4 = objectProto$4.hasOwnProperty;

    function hashGet(_) {
        var _e = this.__data__;
        if (nativeCreate$1) {
            var et = _e[_];
            return et === HASH_UNDEFINED$2 ? void 0 : et
        }
        return hasOwnProperty$4.call(_e, _) ? _e[_] : void 0
    }
    var objectProto$3 = Object.prototype,
        hasOwnProperty$3 = objectProto$3.hasOwnProperty;

    function hashHas(_) {
        var _e = this.__data__;
        return nativeCreate$1 ? _e[_] !== void 0 : hasOwnProperty$3.call(_e, _)
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";

    function hashSet(_, _e) {
        var et = this.__data__;
        return this.size += this.has(_) ? 0 : 1, et[_] = nativeCreate$1 && _e === void 0 ? HASH_UNDEFINED$1 : _e, this
    }

    function Hash(_) {
        var _e = -1,
            et = _ == null ? 0 : _.length;
        for (this.clear(); ++_e < et;) {
            var tt = _[_e];
            this.set(tt[0], tt[1])
        }
    }
    Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;

    function listCacheClear() {
        this.__data__ = [], this.size = 0
    }

    function assocIndexOf(_, _e) {
        for (var et = _.length; et--;)
            if (eq(_[et][0], _e)) return et;
        return -1
    }
    var arrayProto = Array.prototype,
        splice = arrayProto.splice;

    function listCacheDelete(_) {
        var _e = this.__data__,
            et = assocIndexOf(_e, _);
        if (et < 0) return !1;
        var tt = _e.length - 1;
        return et == tt ? _e.pop() : splice.call(_e, et, 1), --this.size, !0
    }

    function listCacheGet(_) {
        var _e = this.__data__,
            et = assocIndexOf(_e, _);
        return et < 0 ? void 0 : _e[et][1]
    }

    function listCacheHas(_) {
        return assocIndexOf(this.__data__, _) > -1
    }

    function listCacheSet(_, _e) {
        var et = this.__data__,
            tt = assocIndexOf(et, _);
        return tt < 0 ? (++this.size, et.push([_, _e])) : et[tt][1] = _e, this
    }

    function ListCache(_) {
        var _e = -1,
            et = _ == null ? 0 : _.length;
        for (this.clear(); ++_e < et;) {
            var tt = _[_e];
            this.set(tt[0], tt[1])
        }
    }
    ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;

    function mapCacheClear() {
        this.size = 0, this.__data__ = {
            hash: new Hash,
            map: new(Map$2 || ListCache),
            string: new Hash
        }
    }

    function isKeyable(_) {
        var _e = typeof _;
        return _e == "string" || _e == "number" || _e == "symbol" || _e == "boolean" ? _ !== "__proto__" : _ === null
    }

    function getMapData(_, _e) {
        var et = _.__data__;
        return isKeyable(_e) ? et[typeof _e == "string" ? "string" : "hash"] : et.map
    }

    function mapCacheDelete(_) {
        var _e = getMapData(this, _).delete(_);
        return this.size -= _e ? 1 : 0, _e
    }

    function mapCacheGet(_) {
        return getMapData(this, _).get(_)
    }

    function mapCacheHas(_) {
        return getMapData(this, _).has(_)
    }

    function mapCacheSet(_, _e) {
        var et = getMapData(this, _),
            tt = et.size;
        return et.set(_, _e), this.size += et.size == tt ? 0 : 1, this
    }

    function MapCache(_) {
        var _e = -1,
            et = _ == null ? 0 : _.length;
        for (this.clear(); ++_e < et;) {
            var tt = _[_e];
            this.set(tt[0], tt[1])
        }
    }
    MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$4 = "Expected a function";
    memoize$1 = function(_, _e) {
        if (typeof _ != "function" || _e != null && typeof _e != "function") throw new TypeError(FUNC_ERROR_TEXT$4);
        var et = function() {
            var tt = arguments,
                nt = _e ? _e.apply(this, tt) : tt[0],
                ot = et.cache;
            if (ot.has(nt)) return ot.get(nt);
            var at = _.apply(this, tt);
            return et.cache = ot.set(nt, at) || ot, at
        };
        return et.cache = new(memoize$1.Cache || MapCache), et
    }, memoize$1.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;

    function memoizeCapped(_) {
        var _e = memoize$1(_, function(tt) {
                return et.size === MAX_MEMOIZE_SIZE && et.clear(), tt
            }),
            et = _e.cache;
        return _e
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        reEscapeChar = /\\(\\)?/g,
        stringToPath = memoizeCapped(function(_) {
            var _e = [];
            return _.charCodeAt(0) === 46 && _e.push(""), _.replace(rePropName, function(et, tt, nt, ot) {
                _e.push(nt ? ot.replace(reEscapeChar, "$1") : tt || et)
            }), _e
        });
    stringToPath$1 = stringToPath, toString$5 = function(_) {
        return _ == null ? "" : baseToString(_)
    }, castPath = function(_, _e) {
        return n0(_) ? _ : isKey(_, _e) ? [_] : stringToPath$1(toString$5(_))
    };
    var INFINITY = 1 / 0;
    toKey = function(_) {
        if (typeof _ == "string" || isSymbol(_)) return _;
        var _e = _ + "";
        return _e == "0" && 1 / _ == -INFINITY ? "-0" : _e
    }, baseGet = function(_, _e) {
        _e = castPath(_e, _);
        for (var et = 0, tt = _e.length; _ != null && et < tt;) _ = _[toKey(_e[et++])];
        return et && et == tt ? _ : void 0
    }, get$1 = function(_, _e, et) {
        var tt = _ == null ? void 0 : baseGet(_, _e);
        return tt === void 0 ? et : tt
    }, arrayPush = function(_, _e) {
        for (var et = -1, tt = _e.length, nt = _.length; ++et < tt;) _[nt + et] = _e[et];
        return _
    };
    var FUNC_ERROR_TEXT$3 = "Expected a function";
    before = function(_, _e) {
        var et;
        if (typeof _e != "function") throw new TypeError(FUNC_ERROR_TEXT$3);
        return _ = toInteger(_),
            function() {
                return --_ > 0 && (et = _e.apply(this, arguments)), _ <= 1 && (_e = void 0), et
            }
    }, baseSlice = function(_, _e, et) {
        var tt = -1,
            nt = _.length;
        _e < 0 && (_e = -_e > nt ? 0 : nt + _e), et = et > nt ? nt : et, et < 0 && (et += nt), nt = _e > et ? 0 : et - _e >>> 0, _e >>>= 0;
        for (var ot = Array(nt); ++tt < nt;) ot[tt] = _[tt + _e];
        return ot
    }, basePropertyOf = function(_) {
        return function(_e) {
            return _ == null ? void 0 : _[_e]
        }
    };
    var nativeCeil = Math.ceil,
        nativeMax$1 = Math.max;
    chunk = function(_, _e, et) {
        (et ? isIterateeCall(_, _e, et) : _e === void 0) ? _e = 1: _e = nativeMax$1(toInteger(_e), 0);
        var tt = _ == null ? 0 : _.length;
        if (!tt || _e < 1) return [];
        for (var nt = 0, ot = 0, at = Array(nativeCeil(tt / _e)); nt < tt;) at[ot++] = baseSlice(_, nt, nt += _e);
        return at
    };

    function stackClear() {
        this.__data__ = new ListCache, this.size = 0
    }

    function stackDelete(_) {
        var _e = this.__data__,
            et = _e.delete(_);
        return this.size = _e.size, et
    }

    function stackGet(_) {
        return this.__data__.get(_)
    }

    function stackHas(_) {
        return this.__data__.has(_)
    }
    var LARGE_ARRAY_SIZE = 200;

    function stackSet(_, _e) {
        var et = this.__data__;
        if (et instanceof ListCache) {
            var tt = et.__data__;
            if (!Map$2 || tt.length < LARGE_ARRAY_SIZE - 1) return tt.push([_, _e]), this.size = ++et.size, this;
            et = this.__data__ = new MapCache(tt)
        }
        return et.set(_, _e), this.size = et.size, this
    }
    Stack = function(_) {
        var _e = this.__data__ = new ListCache(_);
        this.size = _e.size
    }, Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet, arrayFilter = function(_, _e) {
        for (var et = -1, tt = _ == null ? 0 : _.length, nt = 0, ot = []; ++et < tt;) {
            var at = _[et];
            _e(at, et, _) && (ot[nt++] = at)
        }
        return ot
    }, stubArray = function() {
        return []
    };
    var objectProto$2 = Object.prototype,
        propertyIsEnumerable = objectProto$2.propertyIsEnumerable,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        getSymbols = nativeGetSymbols ? function(_) {
            return _ == null ? [] : (_ = Object(_), arrayFilter(nativeGetSymbols(_), function(_e) {
                return propertyIsEnumerable.call(_, _e)
            }))
        } : stubArray;
    getSymbols$1 = getSymbols, baseGetAllKeys = function(_, _e, et) {
        var tt = _e(_);
        return n0(_) ? tt : arrayPush(tt, et(_))
    }, getAllKeys = function(_) {
        return baseGetAllKeys(_, keys$1, getSymbols$1)
    };
    var DataView$1 = getNative(root$1, "DataView");
    const DataView$2 = DataView$1;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    Set$2 = Set$1;
    var mapTag$1 = "[object Map]",
        objectTag$1 = "[object Object]",
        promiseTag = "[object Promise]",
        setTag$1 = "[object Set]",
        weakMapTag = "[object WeakMap]",
        dataViewTag$1 = "[object DataView]",
        dataViewCtorString = toSource(DataView$2),
        mapCtorString = toSource(Map$2),
        promiseCtorString = toSource(Promise$2),
        setCtorString = toSource(Set$2),
        weakMapCtorString = toSource(WeakMap$2),
        getTag = baseGetTag;
    (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2) != weakMapTag) && (getTag = function(_) {
        var _e = baseGetTag(_),
            et = _e == objectTag$1 ? _.constructor : void 0,
            tt = et ? toSource(et) : "";
        if (tt) switch (tt) {
            case dataViewCtorString:
                return dataViewTag$1;
            case mapCtorString:
                return mapTag$1;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag$1;
            case weakMapCtorString:
                return weakMapTag
        }
        return _e
    }), getTag$1 = getTag;
    var Uint8Array$1 = root$1.Uint8Array;
    Uint8Array$2 = Uint8Array$1;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";

    function setCacheAdd(_) {
        return this.__data__.set(_, HASH_UNDEFINED), this
    }

    function setCacheHas(_) {
        return this.__data__.has(_)
    }
    SetCache = function(_) {
        var _e = -1,
            et = _ == null ? 0 : _.length;
        for (this.__data__ = new MapCache; ++_e < et;) this.add(_[_e])
    }, SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, arraySome = function(_, _e) {
        for (var et = -1, tt = _ == null ? 0 : _.length; ++et < tt;)
            if (_e(_[et], et, _)) return !0;
        return !1
    }, cacheHas = function(_, _e) {
        return _.has(_e)
    };
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    function equalArrays(_, _e, et, tt, nt, ot) {
        var at = et & COMPARE_PARTIAL_FLAG$5,
            st = _.length,
            lt = _e.length;
        if (st != lt && !(at && lt > st)) return !1;
        var ut = ot.get(_),
            dt = ot.get(_e);
        if (ut && dt) return ut == _e && dt == _;
        var ct = -1,
            pt = !0,
            ft = et & COMPARE_UNORDERED_FLAG$3 ? new SetCache : void 0;
        for (ot.set(_, _e), ot.set(_e, _); ++ct < st;) {
            var ht = _[ct],
                mt = _e[ct];
            if (tt) var bt = at ? tt(mt, ht, ct, _e, _, ot) : tt(ht, mt, ct, _, _e, ot);
            if (bt !== void 0) {
                if (bt) continue;
                pt = !1;
                break
            }
            if (ft) {
                if (!arraySome(_e, function(gt, vt) {
                        if (!cacheHas(ft, vt) && (ht === gt || nt(ht, gt, et, tt, ot))) return ft.push(vt)
                    })) {
                    pt = !1;
                    break
                }
            } else if (!(ht === mt || nt(ht, mt, et, tt, ot))) {
                pt = !1;
                break
            }
        }
        return ot.delete(_), ot.delete(_e), pt
    }
    mapToArray = function(_) {
        var _e = -1,
            et = Array(_.size);
        return _.forEach(function(tt, nt) {
            et[++_e] = [nt, tt]
        }), et
    }, setToArray = function(_) {
        var _e = -1,
            et = Array(_.size);
        return _.forEach(function(tt) {
            et[++_e] = tt
        }), et
    };
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2,
        boolTag = "[object Boolean]",
        dateTag = "[object Date]",
        errorTag = "[object Error]",
        mapTag = "[object Map]",
        numberTag = "[object Number]",
        regexpTag = "[object RegExp]",
        setTag = "[object Set]",
        stringTag = "[object String]",
        symbolTag = "[object Symbol]",
        arrayBufferTag = "[object ArrayBuffer]",
        dataViewTag = "[object DataView]",
        symbolProto = Symbol$2 ? Symbol$2.prototype : void 0,
        symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;

    function equalByTag(_, _e, et, tt, nt, ot, at) {
        switch (et) {
            case dataViewTag:
                if (_.byteLength != _e.byteLength || _.byteOffset != _e.byteOffset) return !1;
                _ = _.buffer, _e = _e.buffer;
            case arrayBufferTag:
                return !(_.byteLength != _e.byteLength || !ot(new Uint8Array$2(_), new Uint8Array$2(_e)));
            case boolTag:
            case dateTag:
            case numberTag:
                return eq(+_, +_e);
            case errorTag:
                return _.name == _e.name && _.message == _e.message;
            case regexpTag:
            case stringTag:
                return _ == _e + "";
            case mapTag:
                var st = mapToArray;
            case setTag:
                var lt = tt & COMPARE_PARTIAL_FLAG$4;
                if (st || (st = setToArray), _.size != _e.size && !lt) return !1;
                var ut = at.get(_);
                if (ut) return ut == _e;
                tt |= COMPARE_UNORDERED_FLAG$2, at.set(_, _e);
                var dt = equalArrays(st(_), st(_e), tt, nt, ot, at);
                return at.delete(_), dt;
            case symbolTag:
                if (symbolValueOf) return symbolValueOf.call(_) == symbolValueOf.call(_e)
        }
        return !1
    }
    var COMPARE_PARTIAL_FLAG$3 = 1,
        objectProto$1 = Object.prototype,
        hasOwnProperty$2 = objectProto$1.hasOwnProperty;

    function equalObjects(_, _e, et, tt, nt, ot) {
        var at = et & COMPARE_PARTIAL_FLAG$3,
            st = getAllKeys(_),
            lt = st.length,
            ut = getAllKeys(_e),
            dt = ut.length;
        if (lt != dt && !at) return !1;
        for (var ct = lt; ct--;) {
            var pt = st[ct];
            if (!(at ? pt in _e : hasOwnProperty$2.call(_e, pt))) return !1
        }
        var ft = ot.get(_),
            ht = ot.get(_e);
        if (ft && ht) return ft == _e && ht == _;
        var mt = !0;
        ot.set(_, _e), ot.set(_e, _);
        for (var bt = at; ++ct < lt;) {
            pt = st[ct];
            var gt = _[pt],
                vt = _e[pt];
            if (tt) var xt = at ? tt(vt, gt, pt, _e, _, ot) : tt(gt, vt, pt, _, _e, ot);
            if (!(xt === void 0 ? gt === vt || nt(gt, vt, et, tt, ot) : xt)) {
                mt = !1;
                break
            }
            bt || (bt = pt == "constructor")
        }
        if (mt && !bt) {
            var yt = _.constructor,
                Et = _e.constructor;
            yt != Et && "constructor" in _ && "constructor" in _e && !(typeof yt == "function" && yt instanceof yt && typeof Et == "function" && Et instanceof Et) && (mt = !1)
        }
        return ot.delete(_), ot.delete(_e), mt
    }
    var COMPARE_PARTIAL_FLAG$2 = 1,
        argsTag = "[object Arguments]",
        arrayTag = "[object Array]",
        objectTag = "[object Object]",
        objectProto = Object.prototype,
        hasOwnProperty$1 = objectProto.hasOwnProperty;

    function baseIsEqualDeep(_, _e, et, tt, nt, ot) {
        var at = n0(_),
            st = n0(_e),
            lt = at ? arrayTag : getTag$1(_),
            ut = st ? arrayTag : getTag$1(_e);
        lt = lt == argsTag ? objectTag : lt, ut = ut == argsTag ? objectTag : ut;
        var dt = lt == objectTag,
            ct = ut == objectTag,
            pt = lt == ut;
        if (pt && isBuffer$3(_)) {
            if (!isBuffer$3(_e)) return !1;
            at = !0, dt = !1
        }
        if (pt && !dt) return ot || (ot = new Stack), at || isTypedArray$2(_) ? equalArrays(_, _e, et, tt, nt, ot) : equalByTag(_, _e, lt, et, tt, nt, ot);
        if (!(et & COMPARE_PARTIAL_FLAG$2)) {
            var ft = dt && hasOwnProperty$1.call(_, "__wrapped__"),
                ht = ct && hasOwnProperty$1.call(_e, "__wrapped__");
            if (ft || ht) {
                var mt = ft ? _.value() : _,
                    bt = ht ? _e.value() : _e;
                return ot || (ot = new Stack), nt(mt, bt, et, tt, ot)
            }
        }
        return pt ? (ot || (ot = new Stack), equalObjects(_, _e, et, tt, nt, ot)) : !1
    }
    baseIsEqual = function(_, _e, et, tt, nt) {
        return _ === _e ? !0 : _ == null || _e == null || !isObjectLike(_) && !isObjectLike(_e) ? _ !== _ && _e !== _e : baseIsEqualDeep(_, _e, et, tt, baseIsEqual, nt)
    };
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;
    baseIsMatch = function(_, _e, et, tt) {
        var nt = et.length,
            ot = nt,
            at = !tt;
        if (_ == null) return !ot;
        for (_ = Object(_); nt--;) {
            var st = et[nt];
            if (at && st[2] ? st[1] !== _[st[0]] : !(st[0] in _)) return !1
        }
        for (; ++nt < ot;) {
            st = et[nt];
            var lt = st[0],
                ut = _[lt],
                dt = st[1];
            if (at && st[2]) {
                if (ut === void 0 && !(lt in _)) return !1
            } else {
                var ct = new Stack;
                if (tt) var pt = tt(ut, dt, lt, _, _e, ct);
                if (!(pt === void 0 ? baseIsEqual(dt, ut, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, tt, ct) : pt)) return !1
            }
        }
        return !0
    };

    function isStrictComparable(_) {
        return _ === _ && !isObject$2(_)
    }
    getMatchData = function(_) {
        for (var _e = keys$1(_), et = _e.length; et--;) {
            var tt = _e[et],
                nt = _[tt];
            _e[et] = [tt, nt, isStrictComparable(nt)]
        }
        return _e
    };

    function matchesStrictComparable(_, _e) {
        return function(et) {
            return et == null ? !1 : et[_] === _e && (_e !== void 0 || _ in Object(et))
        }
    }
    baseMatches = function(_) {
        var _e = getMatchData(_);
        return _e.length == 1 && _e[0][2] ? matchesStrictComparable(_e[0][0], _e[0][1]) : function(et) {
            return et === _ || baseIsMatch(et, _, _e)
        }
    };

    function baseHasIn(_, _e) {
        return _ != null && _e in Object(_)
    }
    hasPath = function(_, _e, et) {
        _e = castPath(_e, _);
        for (var tt = -1, nt = _e.length, ot = !1; ++tt < nt;) {
            var at = toKey(_e[tt]);
            if (!(ot = _ != null && et(_, at))) break;
            _ = _[at]
        }
        return ot || ++tt != nt ? ot : (nt = _ == null ? 0 : _.length, !!nt && isLength(nt) && isIndex(at, nt) && (n0(_) || isArguments$1(_)))
    }, hasIn = function(_, _e) {
        return _ != null && hasPath(_, _e, baseHasIn)
    };
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
    baseMatchesProperty = function(_, _e) {
        return isKey(_) && isStrictComparable(_e) ? matchesStrictComparable(toKey(_), _e) : function(et) {
            var tt = get$1(et, _);
            return tt === void 0 && tt === _e ? hasIn(et, _) : baseIsEqual(_e, tt, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
        }
    }, baseProperty = function(_) {
        return function(_e) {
            return _e == null ? void 0 : _e[_]
        }
    };

    function basePropertyDeep(_) {
        return function(_e) {
            return baseGet(_e, _)
        }
    }
    property = function(_) {
        return isKey(_) ? baseProperty(toKey(_)) : basePropertyDeep(_)
    }, baseIteratee = function(_) {
        return typeof _ == "function" ? _ : _ == null ? identity : typeof _ == "object" ? n0(_) ? baseMatchesProperty(_[0], _[1]) : baseMatches(_) : property(_)
    };
    var now = function() {
        return root$1.Date.now()
    };
    now$1 = now;
    var FUNC_ERROR_TEXT$2 = "Expected a function",
        nativeMax = Math.max,
        nativeMin$1 = Math.min;
    debounce = function(_, _e, et) {
        var tt, nt, ot, at, st, lt, ut = 0,
            dt = !1,
            ct = !1,
            pt = !0;
        if (typeof _ != "function") throw new TypeError(FUNC_ERROR_TEXT$2);
        _e = toNumber(_e) || 0, isObject$2(et) && (dt = !!et.leading, ct = "maxWait" in et, ot = ct ? nativeMax(toNumber(et.maxWait) || 0, _e) : ot, pt = "trailing" in et ? !!et.trailing : pt);

        function ft(wt) {
            var St = tt,
                $t = nt;
            return tt = nt = void 0, ut = wt, at = _.apply($t, St), at
        }

        function ht(wt) {
            return ut = wt, st = setTimeout(gt, _e), dt ? ft(wt) : at
        }

        function mt(wt) {
            var St = wt - lt,
                $t = wt - ut,
                Ct = _e - St;
            return ct ? nativeMin$1(Ct, ot - $t) : Ct
        }

        function bt(wt) {
            var St = wt - lt,
                $t = wt - ut;
            return lt === void 0 || St >= _e || St < 0 || ct && $t >= ot
        }

        function gt() {
            var wt = now$1();
            if (bt(wt)) return vt(wt);
            st = setTimeout(gt, mt(wt))
        }

        function vt(wt) {
            return st = void 0, pt && tt ? ft(wt) : (tt = nt = void 0, at)
        }

        function xt() {
            st !== void 0 && clearTimeout(st), ut = 0, tt = lt = nt = st = void 0
        }

        function yt() {
            return st === void 0 ? at : vt(now$1())
        }

        function Et() {
            var wt = now$1(),
                St = bt(wt);
            if (tt = arguments, nt = this, lt = wt, St) {
                if (st === void 0) return ht(lt);
                if (ct) return clearTimeout(st), st = setTimeout(gt, _e), ft(lt)
            }
            return st === void 0 && (st = setTimeout(gt, _e)), at
        }
        return Et.cancel = xt, Et.flush = yt, Et
    }, once$1 = function(_) {
        return before(2, _)
    };
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        nativeFloor = Math.floor,
        nativeMin = Math.min;
    baseSortedIndexBy = function(_, _e, et, tt) {
        var nt = 0,
            ot = _ == null ? 0 : _.length;
        if (ot === 0) return 0;
        _e = et(_e);
        for (var at = _e !== _e, st = _e === null, lt = isSymbol(_e), ut = _e === void 0; nt < ot;) {
            var dt = nativeFloor((nt + ot) / 2),
                ct = et(_[dt]),
                pt = ct !== void 0,
                ft = ct === null,
                ht = ct === ct,
                mt = isSymbol(ct);
            if (at) var bt = tt || ht;
            else ut ? bt = ht && (tt || pt) : st ? bt = ht && pt && (tt || !ft) : lt ? bt = ht && pt && !ft && (tt || !mt) : ft || mt ? bt = !1 : bt = tt ? ct <= _e : ct < _e;
            bt ? nt = dt + 1 : ot = dt
        }
        return nativeMin(ot, MAX_ARRAY_INDEX)
    }, sortedIndexBy = function(_, _e, et) {
        return baseSortedIndexBy(_, _e, baseIteratee(et))
    };
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    throttle = function(_, _e, et) {
        var tt = !0,
            nt = !0;
        if (typeof _ != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
        return isObject$2(et) && (tt = "leading" in et ? !!et.leading : tt, nt = "trailing" in et ? !!et.trailing : nt), debounce(_, _e, {
            leading: tt,
            maxWait: _e,
            trailing: nt
        })
    };
    var htmlUnescapes = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        },
        unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    const unescapeHtmlChar$1 = unescapeHtmlChar;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source);
    unescape$2 = function(_) {
            return _ = toString$5(_), _ && reHasEscapedHtml.test(_) ? _.replace(reEscapedHtml, unescapeHtmlChar$1) : _
        }, howler = {},
        function(_) {
            (function() {
                var _e = function() {
                    this.init()
                };
                _e.prototype = {
                    init: function() {
                        var ct = this || et;
                        return ct._counter = 1e3, ct._html5AudioPool = [], ct.html5PoolSize = 10, ct._codecs = {}, ct._howls = [], ct._muted = !1, ct._volume = 1, ct._canPlayEvent = "canplaythrough", ct._navigator = typeof window < "u" && window.navigator ? window.navigator : null, ct.masterGain = null, ct.noAudio = !1, ct.usingWebAudio = !0, ct.autoSuspend = !0, ct.ctx = null, ct.autoUnlock = !0, ct._setup(), ct
                    },
                    volume: function(ct) {
                        var pt = this || et;
                        if (ct = parseFloat(ct), pt.ctx || dt(), typeof ct < "u" && ct >= 0 && ct <= 1) {
                            if (pt._volume = ct, pt._muted) return pt;
                            pt.usingWebAudio && pt.masterGain.gain.setValueAtTime(ct, et.ctx.currentTime);
                            for (var ft = 0; ft < pt._howls.length; ft++)
                                if (!pt._howls[ft]._webAudio)
                                    for (var ht = pt._howls[ft]._getSoundIds(), mt = 0; mt < ht.length; mt++) {
                                        var bt = pt._howls[ft]._soundById(ht[mt]);
                                        bt && bt._node && (bt._node.volume = bt._volume * ct)
                                    }
                            return pt
                        }
                        return pt._volume
                    },
                    mute: function(ct) {
                        var pt = this || et;
                        pt.ctx || dt(), pt._muted = ct, pt.usingWebAudio && pt.masterGain.gain.setValueAtTime(ct ? 0 : pt._volume, et.ctx.currentTime);
                        for (var ft = 0; ft < pt._howls.length; ft++)
                            if (!pt._howls[ft]._webAudio)
                                for (var ht = pt._howls[ft]._getSoundIds(), mt = 0; mt < ht.length; mt++) {
                                    var bt = pt._howls[ft]._soundById(ht[mt]);
                                    bt && bt._node && (bt._node.muted = ct ? !0 : bt._muted)
                                }
                        return pt
                    },
                    stop: function() {
                        for (var ct = this || et, pt = 0; pt < ct._howls.length; pt++) ct._howls[pt].stop();
                        return ct
                    },
                    unload: function() {
                        for (var ct = this || et, pt = ct._howls.length - 1; pt >= 0; pt--) ct._howls[pt].unload();
                        return ct.usingWebAudio && ct.ctx && typeof ct.ctx.close < "u" && (ct.ctx.close(), ct.ctx = null, dt()), ct
                    },
                    codecs: function(ct) {
                        return (this || et)._codecs[ct.replace(/^x-/, "")]
                    },
                    _setup: function() {
                        var ct = this || et;
                        if (ct.state = ct.ctx && ct.ctx.state || "suspended", ct._autoSuspend(), !ct.usingWebAudio)
                            if (typeof Audio < "u") try {
                                var pt = new Audio;
                                typeof pt.oncanplaythrough > "u" && (ct._canPlayEvent = "canplay")
                            } catch (ft) {
                                ct.noAudio = !0
                            } else ct.noAudio = !0;
                        try {
                            var pt = new Audio;
                            pt.muted && (ct.noAudio = !0)
                        } catch (ft) {}
                        return ct.noAudio || ct._setupCodecs(), ct
                    },
                    _setupCodecs: function() {
                        var ct = this || et,
                            pt = null;
                        try {
                            pt = typeof Audio < "u" ? new Audio : null
                        } catch (yt) {
                            return ct
                        }
                        if (!pt || typeof pt.canPlayType != "function") return ct;
                        var ft = pt.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                            ht = ct._navigator ? ct._navigator.userAgent : "",
                            mt = ht.match(/OPR\/(\d+)/g),
                            bt = mt && parseInt(mt[0].split("/")[1], 10) < 33,
                            gt = ht.indexOf("Safari") !== -1 && ht.indexOf("Chrome") === -1,
                            vt = ht.match(/Version\/(.*?) /),
                            xt = gt && vt && parseInt(vt[1], 10) < 15;
                        return ct._codecs = {
                            mp3: !!(!bt && (ft || pt.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                            mpeg: !!ft,
                            opus: !!pt.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                            ogg: !!pt.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            oga: !!pt.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            wav: !!(pt.canPlayType('audio/wav; codecs="1"') || pt.canPlayType("audio/wav")).replace(/^no$/, ""),
                            aac: !!pt.canPlayType("audio/aac;").replace(/^no$/, ""),
                            caf: !!pt.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                            m4a: !!(pt.canPlayType("audio/x-m4a;") || pt.canPlayType("audio/m4a;") || pt.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            m4b: !!(pt.canPlayType("audio/x-m4b;") || pt.canPlayType("audio/m4b;") || pt.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            mp4: !!(pt.canPlayType("audio/x-mp4;") || pt.canPlayType("audio/mp4;") || pt.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            weba: !!(!xt && pt.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                            webm: !!(!xt && pt.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                            dolby: !!pt.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                            flac: !!(pt.canPlayType("audio/x-flac;") || pt.canPlayType("audio/flac;")).replace(/^no$/, "")
                        }, ct
                    },
                    _unlockAudio: function() {
                        var ct = this || et;
                        if (!(ct._audioUnlocked || !ct.ctx)) {
                            ct._audioUnlocked = !1, ct.autoUnlock = !1, !ct._mobileUnloaded && ct.ctx.sampleRate !== 44100 && (ct._mobileUnloaded = !0, ct.unload()), ct._scratchBuffer = ct.ctx.createBuffer(1, 1, 22050);
                            var pt = function(ft) {
                                for (; ct._html5AudioPool.length < ct.html5PoolSize;) try {
                                    var ht = new Audio;
                                    ht._unlocked = !0, ct._releaseHtml5Audio(ht)
                                } catch (yt) {
                                    ct.noAudio = !0;
                                    break
                                }
                                for (var mt = 0; mt < ct._howls.length; mt++)
                                    if (!ct._howls[mt]._webAudio)
                                        for (var bt = ct._howls[mt]._getSoundIds(), gt = 0; gt < bt.length; gt++) {
                                            var vt = ct._howls[mt]._soundById(bt[gt]);
                                            vt && vt._node && !vt._node._unlocked && (vt._node._unlocked = !0, vt._node.load())
                                        }
                                ct._autoResume();
                                var xt = ct.ctx.createBufferSource();
                                xt.buffer = ct._scratchBuffer, xt.connect(ct.ctx.destination), typeof xt.start > "u" ? xt.noteOn(0) : xt.start(0), typeof ct.ctx.resume == "function" && ct.ctx.resume(), xt.onended = function() {
                                    xt.disconnect(0), ct._audioUnlocked = !0, document.removeEventListener("touchstart", pt, !0), document.removeEventListener("touchend", pt, !0), document.removeEventListener("click", pt, !0), document.removeEventListener("keydown", pt, !0);
                                    for (var yt = 0; yt < ct._howls.length; yt++) ct._howls[yt]._emit("unlock")
                                }
                            };
                            return document.addEventListener("touchstart", pt, !0), document.addEventListener("touchend", pt, !0), document.addEventListener("click", pt, !0), document.addEventListener("keydown", pt, !0), ct
                        }
                    },
                    _obtainHtml5Audio: function() {
                        var ct = this || et;
                        if (ct._html5AudioPool.length) return ct._html5AudioPool.pop();
                        var pt = new Audio().play();
                        return pt && typeof Promise < "u" && (pt instanceof Promise || typeof pt.then == "function") && pt.catch(function() {
                            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                        }), new Audio
                    },
                    _releaseHtml5Audio: function(ct) {
                        var pt = this || et;
                        return ct._unlocked && pt._html5AudioPool.push(ct), pt
                    },
                    _autoSuspend: function() {
                        var ct = this;
                        if (!(!ct.autoSuspend || !ct.ctx || typeof ct.ctx.suspend > "u" || !et.usingWebAudio)) {
                            for (var pt = 0; pt < ct._howls.length; pt++)
                                if (ct._howls[pt]._webAudio) {
                                    for (var ft = 0; ft < ct._howls[pt]._sounds.length; ft++)
                                        if (!ct._howls[pt]._sounds[ft]._paused) return ct
                                }
                            return ct._suspendTimer && clearTimeout(ct._suspendTimer), ct._suspendTimer = setTimeout(function() {
                                if (ct.autoSuspend) {
                                    ct._suspendTimer = null, ct.state = "suspending";
                                    var ht = function() {
                                        ct.state = "suspended", ct._resumeAfterSuspend && (delete ct._resumeAfterSuspend, ct._autoResume())
                                    };
                                    ct.ctx.suspend().then(ht, ht)
                                }
                            }, 3e4), ct
                        }
                    },
                    _autoResume: function() {
                        var ct = this;
                        if (!(!ct.ctx || typeof ct.ctx.resume > "u" || !et.usingWebAudio)) return ct.state === "running" && ct.ctx.state !== "interrupted" && ct._suspendTimer ? (clearTimeout(ct._suspendTimer), ct._suspendTimer = null) : ct.state === "suspended" || ct.state === "running" && ct.ctx.state === "interrupted" ? (ct.ctx.resume().then(function() {
                            ct.state = "running";
                            for (var pt = 0; pt < ct._howls.length; pt++) ct._howls[pt]._emit("resume")
                        }), ct._suspendTimer && (clearTimeout(ct._suspendTimer), ct._suspendTimer = null)) : ct.state === "suspending" && (ct._resumeAfterSuspend = !0), ct
                    }
                };
                var et = new _e,
                    tt = function(ct) {
                        var pt = this;
                        if (!ct.src || ct.src.length === 0) {
                            console.error("An array of source files must be passed with any new Howl.");
                            return
                        }
                        pt.init(ct)
                    };
                tt.prototype = {
                    init: function(ct) {
                        var pt = this;
                        return et.ctx || dt(), pt._autoplay = ct.autoplay || !1, pt._format = typeof ct.format != "string" ? ct.format : [ct.format], pt._html5 = ct.html5 || !1, pt._muted = ct.mute || !1, pt._loop = ct.loop || !1, pt._pool = ct.pool || 5, pt._preload = typeof ct.preload == "boolean" || ct.preload === "metadata" ? ct.preload : !0, pt._rate = ct.rate || 1, pt._sprite = ct.sprite || {}, pt._src = typeof ct.src != "string" ? ct.src : [ct.src], pt._volume = ct.volume !== void 0 ? ct.volume : 1, pt._xhr = {
                            method: ct.xhr && ct.xhr.method ? ct.xhr.method : "GET",
                            headers: ct.xhr && ct.xhr.headers ? ct.xhr.headers : null,
                            withCredentials: ct.xhr && ct.xhr.withCredentials ? ct.xhr.withCredentials : !1
                        }, pt._duration = 0, pt._state = "unloaded", pt._sounds = [], pt._endTimers = {}, pt._queue = [], pt._playLock = !1, pt._onend = ct.onend ? [{
                            fn: ct.onend
                        }] : [], pt._onfade = ct.onfade ? [{
                            fn: ct.onfade
                        }] : [], pt._onload = ct.onload ? [{
                            fn: ct.onload
                        }] : [], pt._onloaderror = ct.onloaderror ? [{
                            fn: ct.onloaderror
                        }] : [], pt._onplayerror = ct.onplayerror ? [{
                            fn: ct.onplayerror
                        }] : [], pt._onpause = ct.onpause ? [{
                            fn: ct.onpause
                        }] : [], pt._onplay = ct.onplay ? [{
                            fn: ct.onplay
                        }] : [], pt._onstop = ct.onstop ? [{
                            fn: ct.onstop
                        }] : [], pt._onmute = ct.onmute ? [{
                            fn: ct.onmute
                        }] : [], pt._onvolume = ct.onvolume ? [{
                            fn: ct.onvolume
                        }] : [], pt._onrate = ct.onrate ? [{
                            fn: ct.onrate
                        }] : [], pt._onseek = ct.onseek ? [{
                            fn: ct.onseek
                        }] : [], pt._onunlock = ct.onunlock ? [{
                            fn: ct.onunlock
                        }] : [], pt._onresume = [], pt._webAudio = et.usingWebAudio && !pt._html5, typeof et.ctx < "u" && et.ctx && et.autoUnlock && et._unlockAudio(), et._howls.push(pt), pt._autoplay && pt._queue.push({
                            event: "play",
                            action: function() {
                                pt.play()
                            }
                        }), pt._preload && pt._preload !== "none" && pt.load(), pt
                    },
                    load: function() {
                        var ct = this,
                            pt = null;
                        if (et.noAudio) {
                            ct._emit("loaderror", null, "No audio support.");
                            return
                        }
                        typeof ct._src == "string" && (ct._src = [ct._src]);
                        for (var ft = 0; ft < ct._src.length; ft++) {
                            var ht, mt;
                            if (ct._format && ct._format[ft]) ht = ct._format[ft];
                            else {
                                if (mt = ct._src[ft], typeof mt != "string") {
                                    ct._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                    continue
                                }
                                ht = /^data:audio\/([^;,]+);/i.exec(mt), ht || (ht = /\.([^.]+)$/.exec(mt.split("?", 1)[0])), ht && (ht = ht[1].toLowerCase())
                            }
                            if (ht || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), ht && et.codecs(ht)) {
                                pt = ct._src[ft];
                                break
                            }
                        }
                        if (!pt) {
                            ct._emit("loaderror", null, "No codec support for selected audio sources.");
                            return
                        }
                        return ct._src = pt, ct._state = "loading", window.location.protocol === "https:" && pt.slice(0, 5) === "http:" && (ct._html5 = !0, ct._webAudio = !1), new nt(ct), ct._webAudio && at(ct), ct
                    },
                    play: function(ct, pt) {
                        var ft = this,
                            ht = null;
                        if (typeof ct == "number") ht = ct, ct = null;
                        else {
                            if (typeof ct == "string" && ft._state === "loaded" && !ft._sprite[ct]) return null;
                            if (typeof ct > "u" && (ct = "__default", !ft._playLock)) {
                                for (var mt = 0, bt = 0; bt < ft._sounds.length; bt++) ft._sounds[bt]._paused && !ft._sounds[bt]._ended && (mt++, ht = ft._sounds[bt]._id);
                                mt === 1 ? ct = null : ht = null
                            }
                        }
                        var gt = ht ? ft._soundById(ht) : ft._inactiveSound();
                        if (!gt) return null;
                        if (ht && !ct && (ct = gt._sprite || "__default"), ft._state !== "loaded") {
                            gt._sprite = ct, gt._ended = !1;
                            var vt = gt._id;
                            return ft._queue.push({
                                event: "play",
                                action: function() {
                                    ft.play(vt)
                                }
                            }), vt
                        }
                        if (ht && !gt._paused) return pt || ft._loadQueue("play"), gt._id;
                        ft._webAudio && et._autoResume();
                        var xt = Math.max(0, gt._seek > 0 ? gt._seek : ft._sprite[ct][0] / 1e3),
                            yt = Math.max(0, (ft._sprite[ct][0] + ft._sprite[ct][1]) / 1e3 - xt),
                            Et = yt * 1e3 / Math.abs(gt._rate),
                            wt = ft._sprite[ct][0] / 1e3,
                            St = (ft._sprite[ct][0] + ft._sprite[ct][1]) / 1e3;
                        gt._sprite = ct, gt._ended = !1;
                        var $t = function() {
                            gt._paused = !1, gt._seek = xt, gt._start = wt, gt._stop = St, gt._loop = !!(gt._loop || ft._sprite[ct][2])
                        };
                        if (xt >= St) {
                            ft._ended(gt);
                            return
                        }
                        var Ct = gt._node;
                        if (ft._webAudio) {
                            var Rt = function() {
                                ft._playLock = !1, $t(), ft._refreshBuffer(gt);
                                var Ot = gt._muted || ft._muted ? 0 : gt._volume;
                                Ct.gain.setValueAtTime(Ot, et.ctx.currentTime), gt._playStart = et.ctx.currentTime, typeof Ct.bufferSource.start > "u" ? gt._loop ? Ct.bufferSource.noteGrainOn(0, xt, 86400) : Ct.bufferSource.noteGrainOn(0, xt, yt) : gt._loop ? Ct.bufferSource.start(0, xt, 86400) : Ct.bufferSource.start(0, xt, yt), Et !== 1 / 0 && (ft._endTimers[gt._id] = setTimeout(ft._ended.bind(ft, gt), Et)), pt || setTimeout(function() {
                                    ft._emit("play", gt._id), ft._loadQueue()
                                }, 0)
                            };
                            et.state === "running" && et.ctx.state !== "interrupted" ? Rt() : (ft._playLock = !0, ft.once("resume", Rt), ft._clearTimer(gt._id))
                        } else {
                            var Pt = function() {
                                Ct.currentTime = xt, Ct.muted = gt._muted || ft._muted || et._muted || Ct.muted, Ct.volume = gt._volume * et.volume(), Ct.playbackRate = gt._rate;
                                try {
                                    var Ot = Ct.play();
                                    if (Ot && typeof Promise < "u" && (Ot instanceof Promise || typeof Ot.then == "function") ? (ft._playLock = !0, $t(), Ot.then(function() {
                                            ft._playLock = !1, Ct._unlocked = !0, pt ? ft._loadQueue() : ft._emit("play", gt._id)
                                        }).catch(function() {
                                            ft._playLock = !1, ft._emit("playerror", gt._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), gt._ended = !0, gt._paused = !0
                                        })) : pt || (ft._playLock = !1, $t(), ft._emit("play", gt._id)), Ct.playbackRate = gt._rate, Ct.paused) {
                                        ft._emit("playerror", gt._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                        return
                                    }
                                    ct !== "__default" || gt._loop ? ft._endTimers[gt._id] = setTimeout(ft._ended.bind(ft, gt), Et) : (ft._endTimers[gt._id] = function() {
                                        ft._ended(gt), Ct.removeEventListener("ended", ft._endTimers[gt._id], !1)
                                    }, Ct.addEventListener("ended", ft._endTimers[gt._id], !1))
                                } catch (Dt) {
                                    ft._emit("playerror", gt._id, Dt)
                                }
                            };
                            Ct.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (Ct.src = ft._src, Ct.load());
                            var Tt = window && window.ejecta || !Ct.readyState && et._navigator.isCocoonJS;
                            if (Ct.readyState >= 3 || Tt) Pt();
                            else {
                                ft._playLock = !0, ft._state = "loading";
                                var It = function() {
                                    ft._state = "loaded", Pt(), Ct.removeEventListener(et._canPlayEvent, It, !1)
                                };
                                Ct.addEventListener(et._canPlayEvent, It, !1), ft._clearTimer(gt._id)
                            }
                        }
                        return gt._id
                    },
                    pause: function(ct) {
                        var pt = this;
                        if (pt._state !== "loaded" || pt._playLock) return pt._queue.push({
                            event: "pause",
                            action: function() {
                                pt.pause(ct)
                            }
                        }), pt;
                        for (var ft = pt._getSoundIds(ct), ht = 0; ht < ft.length; ht++) {
                            pt._clearTimer(ft[ht]);
                            var mt = pt._soundById(ft[ht]);
                            if (mt && !mt._paused && (mt._seek = pt.seek(ft[ht]), mt._rateSeek = 0, mt._paused = !0, pt._stopFade(ft[ht]), mt._node))
                                if (pt._webAudio) {
                                    if (!mt._node.bufferSource) continue;
                                    typeof mt._node.bufferSource.stop > "u" ? mt._node.bufferSource.noteOff(0) : mt._node.bufferSource.stop(0), pt._cleanBuffer(mt._node)
                                } else(!isNaN(mt._node.duration) || mt._node.duration === 1 / 0) && mt._node.pause();
                            arguments[1] || pt._emit("pause", mt ? mt._id : null)
                        }
                        return pt
                    },
                    stop: function(ct, pt) {
                        var ft = this;
                        if (ft._state !== "loaded" || ft._playLock) return ft._queue.push({
                            event: "stop",
                            action: function() {
                                ft.stop(ct)
                            }
                        }), ft;
                        for (var ht = ft._getSoundIds(ct), mt = 0; mt < ht.length; mt++) {
                            ft._clearTimer(ht[mt]);
                            var bt = ft._soundById(ht[mt]);
                            bt && (bt._seek = bt._start || 0, bt._rateSeek = 0, bt._paused = !0, bt._ended = !0, ft._stopFade(ht[mt]), bt._node && (ft._webAudio ? bt._node.bufferSource && (typeof bt._node.bufferSource.stop > "u" ? bt._node.bufferSource.noteOff(0) : bt._node.bufferSource.stop(0), ft._cleanBuffer(bt._node)) : (!isNaN(bt._node.duration) || bt._node.duration === 1 / 0) && (bt._node.currentTime = bt._start || 0, bt._node.pause(), bt._node.duration === 1 / 0 && ft._clearSound(bt._node))), pt || ft._emit("stop", bt._id))
                        }
                        return ft
                    },
                    mute: function(ct, pt) {
                        var ft = this;
                        if (ft._state !== "loaded" || ft._playLock) return ft._queue.push({
                            event: "mute",
                            action: function() {
                                ft.mute(ct, pt)
                            }
                        }), ft;
                        if (typeof pt > "u")
                            if (typeof ct == "boolean") ft._muted = ct;
                            else return ft._muted;
                        for (var ht = ft._getSoundIds(pt), mt = 0; mt < ht.length; mt++) {
                            var bt = ft._soundById(ht[mt]);
                            bt && (bt._muted = ct, bt._interval && ft._stopFade(bt._id), ft._webAudio && bt._node ? bt._node.gain.setValueAtTime(ct ? 0 : bt._volume, et.ctx.currentTime) : bt._node && (bt._node.muted = et._muted ? !0 : ct), ft._emit("mute", bt._id))
                        }
                        return ft
                    },
                    volume: function() {
                        var ct = this,
                            pt = arguments,
                            ft, ht;
                        if (pt.length === 0) return ct._volume;
                        if (pt.length === 1 || pt.length === 2 && typeof pt[1] > "u") {
                            var mt = ct._getSoundIds(),
                                bt = mt.indexOf(pt[0]);
                            bt >= 0 ? ht = parseInt(pt[0], 10) : ft = parseFloat(pt[0])
                        } else pt.length >= 2 && (ft = parseFloat(pt[0]), ht = parseInt(pt[1], 10));
                        var gt;
                        if (typeof ft < "u" && ft >= 0 && ft <= 1) {
                            if (ct._state !== "loaded" || ct._playLock) return ct._queue.push({
                                event: "volume",
                                action: function() {
                                    ct.volume.apply(ct, pt)
                                }
                            }), ct;
                            typeof ht > "u" && (ct._volume = ft), ht = ct._getSoundIds(ht);
                            for (var vt = 0; vt < ht.length; vt++) gt = ct._soundById(ht[vt]), gt && (gt._volume = ft, pt[2] || ct._stopFade(ht[vt]), ct._webAudio && gt._node && !gt._muted ? gt._node.gain.setValueAtTime(ft, et.ctx.currentTime) : gt._node && !gt._muted && (gt._node.volume = ft * et.volume()), ct._emit("volume", gt._id))
                        } else return gt = ht ? ct._soundById(ht) : ct._sounds[0], gt ? gt._volume : 0;
                        return ct
                    },
                    fade: function(ct, pt, ft, ht) {
                        var mt = this;
                        if (mt._state !== "loaded" || mt._playLock) return mt._queue.push({
                            event: "fade",
                            action: function() {
                                mt.fade(ct, pt, ft, ht)
                            }
                        }), mt;
                        ct = Math.min(Math.max(0, parseFloat(ct)), 1), pt = Math.min(Math.max(0, parseFloat(pt)), 1), ft = parseFloat(ft), mt.volume(ct, ht);
                        for (var bt = mt._getSoundIds(ht), gt = 0; gt < bt.length; gt++) {
                            var vt = mt._soundById(bt[gt]);
                            if (vt) {
                                if (ht || mt._stopFade(bt[gt]), mt._webAudio && !vt._muted) {
                                    var xt = et.ctx.currentTime,
                                        yt = xt + ft / 1e3;
                                    vt._volume = ct, vt._node.gain.setValueAtTime(ct, xt), vt._node.gain.linearRampToValueAtTime(pt, yt)
                                }
                                mt._startFadeInterval(vt, ct, pt, ft, bt[gt], typeof ht > "u")
                            }
                        }
                        return mt
                    },
                    _startFadeInterval: function(ct, pt, ft, ht, mt, bt) {
                        var gt = this,
                            vt = pt,
                            xt = ft - pt,
                            yt = Math.abs(xt / .01),
                            Et = Math.max(4, yt > 0 ? ht / yt : ht),
                            wt = Date.now();
                        ct._fadeTo = ft, ct._interval = setInterval(function() {
                            var St = (Date.now() - wt) / ht;
                            wt = Date.now(), vt += xt * St, vt = Math.round(vt * 100) / 100, xt < 0 ? vt = Math.max(ft, vt) : vt = Math.min(ft, vt), gt._webAudio ? ct._volume = vt : gt.volume(vt, ct._id, !0), bt && (gt._volume = vt), (ft < pt && vt <= ft || ft > pt && vt >= ft) && (clearInterval(ct._interval), ct._interval = null, ct._fadeTo = null, gt.volume(ft, ct._id), gt._emit("fade", ct._id))
                        }, Et)
                    },
                    _stopFade: function(ct) {
                        var pt = this,
                            ft = pt._soundById(ct);
                        return ft && ft._interval && (pt._webAudio && ft._node.gain.cancelScheduledValues(et.ctx.currentTime), clearInterval(ft._interval), ft._interval = null, pt.volume(ft._fadeTo, ct), ft._fadeTo = null, pt._emit("fade", ct)), pt
                    },
                    loop: function() {
                        var ct = this,
                            pt = arguments,
                            ft, ht, mt;
                        if (pt.length === 0) return ct._loop;
                        if (pt.length === 1)
                            if (typeof pt[0] == "boolean") ft = pt[0], ct._loop = ft;
                            else return mt = ct._soundById(parseInt(pt[0], 10)), mt ? mt._loop : !1;
                        else pt.length === 2 && (ft = pt[0], ht = parseInt(pt[1], 10));
                        for (var bt = ct._getSoundIds(ht), gt = 0; gt < bt.length; gt++) mt = ct._soundById(bt[gt]), mt && (mt._loop = ft, ct._webAudio && mt._node && mt._node.bufferSource && (mt._node.bufferSource.loop = ft, ft && (mt._node.bufferSource.loopStart = mt._start || 0, mt._node.bufferSource.loopEnd = mt._stop, ct.playing(bt[gt]) && (ct.pause(bt[gt], !0), ct.play(bt[gt], !0)))));
                        return ct
                    },
                    rate: function() {
                        var ct = this,
                            pt = arguments,
                            ft, ht;
                        if (pt.length === 0) ht = ct._sounds[0]._id;
                        else if (pt.length === 1) {
                            var mt = ct._getSoundIds(),
                                bt = mt.indexOf(pt[0]);
                            bt >= 0 ? ht = parseInt(pt[0], 10) : ft = parseFloat(pt[0])
                        } else pt.length === 2 && (ft = parseFloat(pt[0]), ht = parseInt(pt[1], 10));
                        var gt;
                        if (typeof ft == "number") {
                            if (ct._state !== "loaded" || ct._playLock) return ct._queue.push({
                                event: "rate",
                                action: function() {
                                    ct.rate.apply(ct, pt)
                                }
                            }), ct;
                            typeof ht > "u" && (ct._rate = ft), ht = ct._getSoundIds(ht);
                            for (var vt = 0; vt < ht.length; vt++)
                                if (gt = ct._soundById(ht[vt]), gt) {
                                    ct.playing(ht[vt]) && (gt._rateSeek = ct.seek(ht[vt]), gt._playStart = ct._webAudio ? et.ctx.currentTime : gt._playStart), gt._rate = ft, ct._webAudio && gt._node && gt._node.bufferSource ? gt._node.bufferSource.playbackRate.setValueAtTime(ft, et.ctx.currentTime) : gt._node && (gt._node.playbackRate = ft);
                                    var xt = ct.seek(ht[vt]),
                                        yt = (ct._sprite[gt._sprite][0] + ct._sprite[gt._sprite][1]) / 1e3 - xt,
                                        Et = yt * 1e3 / Math.abs(gt._rate);
                                    (ct._endTimers[ht[vt]] || !gt._paused) && (ct._clearTimer(ht[vt]), ct._endTimers[ht[vt]] = setTimeout(ct._ended.bind(ct, gt), Et)), ct._emit("rate", gt._id)
                                }
                        } else return gt = ct._soundById(ht), gt ? gt._rate : ct._rate;
                        return ct
                    },
                    seek: function() {
                        var ct = this,
                            pt = arguments,
                            ft, ht;
                        if (pt.length === 0) ct._sounds.length && (ht = ct._sounds[0]._id);
                        else if (pt.length === 1) {
                            var mt = ct._getSoundIds(),
                                bt = mt.indexOf(pt[0]);
                            bt >= 0 ? ht = parseInt(pt[0], 10) : ct._sounds.length && (ht = ct._sounds[0]._id, ft = parseFloat(pt[0]))
                        } else pt.length === 2 && (ft = parseFloat(pt[0]), ht = parseInt(pt[1], 10));
                        if (typeof ht > "u") return 0;
                        if (typeof ft == "number" && (ct._state !== "loaded" || ct._playLock)) return ct._queue.push({
                            event: "seek",
                            action: function() {
                                ct.seek.apply(ct, pt)
                            }
                        }), ct;
                        var gt = ct._soundById(ht);
                        if (gt)
                            if (typeof ft == "number" && ft >= 0) {
                                var vt = ct.playing(ht);
                                vt && ct.pause(ht, !0), gt._seek = ft, gt._ended = !1, ct._clearTimer(ht), !ct._webAudio && gt._node && !isNaN(gt._node.duration) && (gt._node.currentTime = ft);
                                var xt = function() {
                                    vt && ct.play(ht, !0), ct._emit("seek", ht)
                                };
                                if (vt && !ct._webAudio) {
                                    var yt = function() {
                                        ct._playLock ? setTimeout(yt, 0) : xt()
                                    };
                                    setTimeout(yt, 0)
                                } else xt()
                            } else if (ct._webAudio) {
                            var Et = ct.playing(ht) ? et.ctx.currentTime - gt._playStart : 0,
                                wt = gt._rateSeek ? gt._rateSeek - gt._seek : 0;
                            return gt._seek + (wt + Et * Math.abs(gt._rate))
                        } else return gt._node.currentTime;
                        return ct
                    },
                    playing: function(ct) {
                        var pt = this;
                        if (typeof ct == "number") {
                            var ft = pt._soundById(ct);
                            return ft ? !ft._paused : !1
                        }
                        for (var ht = 0; ht < pt._sounds.length; ht++)
                            if (!pt._sounds[ht]._paused) return !0;
                        return !1
                    },
                    duration: function(ct) {
                        var pt = this,
                            ft = pt._duration,
                            ht = pt._soundById(ct);
                        return ht && (ft = pt._sprite[ht._sprite][1] / 1e3), ft
                    },
                    state: function() {
                        return this._state
                    },
                    unload: function() {
                        for (var ct = this, pt = ct._sounds, ft = 0; ft < pt.length; ft++) pt[ft]._paused || ct.stop(pt[ft]._id), ct._webAudio || (ct._clearSound(pt[ft]._node), pt[ft]._node.removeEventListener("error", pt[ft]._errorFn, !1), pt[ft]._node.removeEventListener(et._canPlayEvent, pt[ft]._loadFn, !1), pt[ft]._node.removeEventListener("ended", pt[ft]._endFn, !1), et._releaseHtml5Audio(pt[ft]._node)), delete pt[ft]._node, ct._clearTimer(pt[ft]._id);
                        var ht = et._howls.indexOf(ct);
                        ht >= 0 && et._howls.splice(ht, 1);
                        var mt = !0;
                        for (ft = 0; ft < et._howls.length; ft++)
                            if (et._howls[ft]._src === ct._src || ct._src.indexOf(et._howls[ft]._src) >= 0) {
                                mt = !1;
                                break
                            }
                        return ot && mt && delete ot[ct._src], et.noAudio = !1, ct._state = "unloaded", ct._sounds = [], ct = null, null
                    },
                    on: function(ct, pt, ft, ht) {
                        var mt = this,
                            bt = mt["_on" + ct];
                        return typeof pt == "function" && bt.push(ht ? {
                            id: ft,
                            fn: pt,
                            once: ht
                        } : {
                            id: ft,
                            fn: pt
                        }), mt
                    },
                    off: function(ct, pt, ft) {
                        var ht = this,
                            mt = ht["_on" + ct],
                            bt = 0;
                        if (typeof pt == "number" && (ft = pt, pt = null), pt || ft)
                            for (bt = 0; bt < mt.length; bt++) {
                                var gt = ft === mt[bt].id;
                                if (pt === mt[bt].fn && gt || !pt && gt) {
                                    mt.splice(bt, 1);
                                    break
                                }
                            } else if (ct) ht["_on" + ct] = [];
                            else {
                                var vt = Object.keys(ht);
                                for (bt = 0; bt < vt.length; bt++) vt[bt].indexOf("_on") === 0 && Array.isArray(ht[vt[bt]]) && (ht[vt[bt]] = [])
                            }
                        return ht
                    },
                    once: function(ct, pt, ft) {
                        var ht = this;
                        return ht.on(ct, pt, ft, 1), ht
                    },
                    _emit: function(ct, pt, ft) {
                        for (var ht = this, mt = ht["_on" + ct], bt = mt.length - 1; bt >= 0; bt--)(!mt[bt].id || mt[bt].id === pt || ct === "load") && (setTimeout(function(gt) {
                            gt.call(this, pt, ft)
                        }.bind(ht, mt[bt].fn), 0), mt[bt].once && ht.off(ct, mt[bt].fn, mt[bt].id));
                        return ht._loadQueue(ct), ht
                    },
                    _loadQueue: function(ct) {
                        var pt = this;
                        if (pt._queue.length > 0) {
                            var ft = pt._queue[0];
                            ft.event === ct && (pt._queue.shift(), pt._loadQueue()), ct || ft.action()
                        }
                        return pt
                    },
                    _ended: function(ct) {
                        var pt = this,
                            ft = ct._sprite;
                        if (!pt._webAudio && ct._node && !ct._node.paused && !ct._node.ended && ct._node.currentTime < ct._stop) return setTimeout(pt._ended.bind(pt, ct), 100), pt;
                        var ht = !!(ct._loop || pt._sprite[ft][2]);
                        if (pt._emit("end", ct._id), !pt._webAudio && ht && pt.stop(ct._id, !0).play(ct._id), pt._webAudio && ht) {
                            pt._emit("play", ct._id), ct._seek = ct._start || 0, ct._rateSeek = 0, ct._playStart = et.ctx.currentTime;
                            var mt = (ct._stop - ct._start) * 1e3 / Math.abs(ct._rate);
                            pt._endTimers[ct._id] = setTimeout(pt._ended.bind(pt, ct), mt)
                        }
                        return pt._webAudio && !ht && (ct._paused = !0, ct._ended = !0, ct._seek = ct._start || 0, ct._rateSeek = 0, pt._clearTimer(ct._id), pt._cleanBuffer(ct._node), et._autoSuspend()), !pt._webAudio && !ht && pt.stop(ct._id, !0), pt
                    },
                    _clearTimer: function(ct) {
                        var pt = this;
                        if (pt._endTimers[ct]) {
                            if (typeof pt._endTimers[ct] != "function") clearTimeout(pt._endTimers[ct]);
                            else {
                                var ft = pt._soundById(ct);
                                ft && ft._node && ft._node.removeEventListener("ended", pt._endTimers[ct], !1)
                            }
                            delete pt._endTimers[ct]
                        }
                        return pt
                    },
                    _soundById: function(ct) {
                        for (var pt = this, ft = 0; ft < pt._sounds.length; ft++)
                            if (ct === pt._sounds[ft]._id) return pt._sounds[ft];
                        return null
                    },
                    _inactiveSound: function() {
                        var ct = this;
                        ct._drain();
                        for (var pt = 0; pt < ct._sounds.length; pt++)
                            if (ct._sounds[pt]._ended) return ct._sounds[pt].reset();
                        return new nt(ct)
                    },
                    _drain: function() {
                        var ct = this,
                            pt = ct._pool,
                            ft = 0,
                            ht = 0;
                        if (!(ct._sounds.length < pt)) {
                            for (ht = 0; ht < ct._sounds.length; ht++) ct._sounds[ht]._ended && ft++;
                            for (ht = ct._sounds.length - 1; ht >= 0; ht--) {
                                if (ft <= pt) return;
                                ct._sounds[ht]._ended && (ct._webAudio && ct._sounds[ht]._node && ct._sounds[ht]._node.disconnect(0), ct._sounds.splice(ht, 1), ft--)
                            }
                        }
                    },
                    _getSoundIds: function(ct) {
                        var pt = this;
                        if (typeof ct > "u") {
                            for (var ft = [], ht = 0; ht < pt._sounds.length; ht++) ft.push(pt._sounds[ht]._id);
                            return ft
                        } else return [ct]
                    },
                    _refreshBuffer: function(ct) {
                        var pt = this;
                        return ct._node.bufferSource = et.ctx.createBufferSource(), ct._node.bufferSource.buffer = ot[pt._src], ct._panner ? ct._node.bufferSource.connect(ct._panner) : ct._node.bufferSource.connect(ct._node), ct._node.bufferSource.loop = ct._loop, ct._loop && (ct._node.bufferSource.loopStart = ct._start || 0, ct._node.bufferSource.loopEnd = ct._stop || 0), ct._node.bufferSource.playbackRate.setValueAtTime(ct._rate, et.ctx.currentTime), pt
                    },
                    _cleanBuffer: function(ct) {
                        var pt = this,
                            ft = et._navigator && et._navigator.vendor.indexOf("Apple") >= 0;
                        if (!ct.bufferSource) return pt;
                        if (et._scratchBuffer && ct.bufferSource && (ct.bufferSource.onended = null, ct.bufferSource.disconnect(0), ft)) try {
                            ct.bufferSource.buffer = et._scratchBuffer
                        } catch (ht) {}
                        return ct.bufferSource = null, pt
                    },
                    _clearSound: function(ct) {
                        var pt = /MSIE |Trident\//.test(et._navigator && et._navigator.userAgent);
                        pt || (ct.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                    }
                };
                var nt = function(ct) {
                    this._parent = ct, this.init()
                };
                nt.prototype = {
                    init: function() {
                        var ct = this,
                            pt = ct._parent;
                        return ct._muted = pt._muted, ct._loop = pt._loop, ct._volume = pt._volume, ct._rate = pt._rate, ct._seek = 0, ct._paused = !0, ct._ended = !0, ct._sprite = "__default", ct._id = ++et._counter, pt._sounds.push(ct), ct.create(), ct
                    },
                    create: function() {
                        var ct = this,
                            pt = ct._parent,
                            ft = et._muted || ct._muted || ct._parent._muted ? 0 : ct._volume;
                        return pt._webAudio ? (ct._node = typeof et.ctx.createGain > "u" ? et.ctx.createGainNode() : et.ctx.createGain(), ct._node.gain.setValueAtTime(ft, et.ctx.currentTime), ct._node.paused = !0, ct._node.connect(et.masterGain)) : et.noAudio || (ct._node = et._obtainHtml5Audio(), ct._errorFn = ct._errorListener.bind(ct), ct._node.addEventListener("error", ct._errorFn, !1), ct._loadFn = ct._loadListener.bind(ct), ct._node.addEventListener(et._canPlayEvent, ct._loadFn, !1), ct._endFn = ct._endListener.bind(ct), ct._node.addEventListener("ended", ct._endFn, !1), ct._node.src = pt._src, ct._node.preload = pt._preload === !0 ? "auto" : pt._preload, ct._node.volume = ft * et.volume(), ct._node.load()), ct
                    },
                    reset: function() {
                        var ct = this,
                            pt = ct._parent;
                        return ct._muted = pt._muted, ct._loop = pt._loop, ct._volume = pt._volume, ct._rate = pt._rate, ct._seek = 0, ct._rateSeek = 0, ct._paused = !0, ct._ended = !0, ct._sprite = "__default", ct._id = ++et._counter, ct
                    },
                    _errorListener: function() {
                        var ct = this;
                        ct._parent._emit("loaderror", ct._id, ct._node.error ? ct._node.error.code : 0), ct._node.removeEventListener("error", ct._errorFn, !1)
                    },
                    _loadListener: function() {
                        var ct = this,
                            pt = ct._parent;
                        pt._duration = Math.ceil(ct._node.duration * 10) / 10, Object.keys(pt._sprite).length === 0 && (pt._sprite = {
                            __default: [0, pt._duration * 1e3]
                        }), pt._state !== "loaded" && (pt._state = "loaded", pt._emit("load"), pt._loadQueue()), ct._node.removeEventListener(et._canPlayEvent, ct._loadFn, !1)
                    },
                    _endListener: function() {
                        var ct = this,
                            pt = ct._parent;
                        pt._duration === 1 / 0 && (pt._duration = Math.ceil(ct._node.duration * 10) / 10, pt._sprite.__default[1] === 1 / 0 && (pt._sprite.__default[1] = pt._duration * 1e3), pt._ended(ct)), ct._node.removeEventListener("ended", ct._endFn, !1)
                    }
                };
                var ot = {},
                    at = function(ct) {
                        var pt = ct._src;
                        if (ot[pt]) {
                            ct._duration = ot[pt].duration, ut(ct);
                            return
                        }
                        if (/^data:[^;]+;base64,/.test(pt)) {
                            for (var ft = atob(pt.split(",")[1]), ht = new Uint8Array(ft.length), mt = 0; mt < ft.length; ++mt) ht[mt] = ft.charCodeAt(mt);
                            lt(ht.buffer, ct)
                        } else {
                            var bt = new XMLHttpRequest;
                            bt.open(ct._xhr.method, pt, !0), bt.withCredentials = ct._xhr.withCredentials, bt.responseType = "arraybuffer", ct._xhr.headers && Object.keys(ct._xhr.headers).forEach(function(gt) {
                                bt.setRequestHeader(gt, ct._xhr.headers[gt])
                            }), bt.onload = function() {
                                var gt = (bt.status + "")[0];
                                if (gt !== "0" && gt !== "2" && gt !== "3") {
                                    ct._emit("loaderror", null, "Failed loading audio file with status: " + bt.status + ".");
                                    return
                                }
                                lt(bt.response, ct)
                            }, bt.onerror = function() {
                                ct._webAudio && (ct._html5 = !0, ct._webAudio = !1, ct._sounds = [], delete ot[pt], ct.load())
                            }, st(bt)
                        }
                    },
                    st = function(ct) {
                        try {
                            ct.send()
                        } catch (pt) {
                            ct.onerror()
                        }
                    },
                    lt = function(ct, pt) {
                        var ft = function() {
                                pt._emit("loaderror", null, "Decoding audio data failed.")
                            },
                            ht = function(mt) {
                                mt && pt._sounds.length > 0 ? (ot[pt._src] = mt, ut(pt, mt)) : ft()
                            };
                        typeof Promise < "u" && et.ctx.decodeAudioData.length === 1 ? et.ctx.decodeAudioData(ct).then(ht).catch(ft) : et.ctx.decodeAudioData(ct, ht, ft)
                    },
                    ut = function(ct, pt) {
                        pt && !ct._duration && (ct._duration = pt.duration), Object.keys(ct._sprite).length === 0 && (ct._sprite = {
                            __default: [0, ct._duration * 1e3]
                        }), ct._state !== "loaded" && (ct._state = "loaded", ct._emit("load"), ct._loadQueue())
                    },
                    dt = function() {
                        if (et.usingWebAudio) {
                            try {
                                typeof AudioContext < "u" ? et.ctx = new AudioContext : typeof webkitAudioContext < "u" ? et.ctx = new webkitAudioContext : et.usingWebAudio = !1
                            } catch (mt) {
                                et.usingWebAudio = !1
                            }
                            et.ctx || (et.usingWebAudio = !1);
                            var ct = /iP(hone|od|ad)/.test(et._navigator && et._navigator.platform),
                                pt = et._navigator && et._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                ft = pt ? parseInt(pt[1], 10) : null;
                            if (ct && ft && ft < 9) {
                                var ht = /safari/.test(et._navigator && et._navigator.userAgent.toLowerCase());
                                et._navigator && !ht && (et.usingWebAudio = !1)
                            }
                            et.usingWebAudio && (et.masterGain = typeof et.ctx.createGain > "u" ? et.ctx.createGainNode() : et.ctx.createGain(), et.masterGain.gain.setValueAtTime(et._muted ? 0 : et._volume, et.ctx.currentTime), et.masterGain.connect(et.ctx.destination)), et._setup()
                        }
                    };
                _.Howler = et, _.Howl = tt, typeof commonjsGlobal$1 < "u" ? (commonjsGlobal$1.HowlerGlobal = _e, commonjsGlobal$1.Howler = et, commonjsGlobal$1.Howl = tt, commonjsGlobal$1.Sound = nt) : typeof window < "u" && (window.HowlerGlobal = _e, window.Howler = et, window.Howl = tt, window.Sound = nt)
            })(),
            function() {
                HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(et) {
                    var tt = this;
                    if (!tt.ctx || !tt.ctx.listener) return tt;
                    for (var nt = tt._howls.length - 1; nt >= 0; nt--) tt._howls[nt].stereo(et);
                    return tt
                }, HowlerGlobal.prototype.pos = function(et, tt, nt) {
                    var ot = this;
                    if (!ot.ctx || !ot.ctx.listener) return ot;
                    if (tt = typeof tt != "number" ? ot._pos[1] : tt, nt = typeof nt != "number" ? ot._pos[2] : nt, typeof et == "number") ot._pos = [et, tt, nt], typeof ot.ctx.listener.positionX < "u" ? (ot.ctx.listener.positionX.setTargetAtTime(ot._pos[0], Howler.ctx.currentTime, .1), ot.ctx.listener.positionY.setTargetAtTime(ot._pos[1], Howler.ctx.currentTime, .1), ot.ctx.listener.positionZ.setTargetAtTime(ot._pos[2], Howler.ctx.currentTime, .1)) : ot.ctx.listener.setPosition(ot._pos[0], ot._pos[1], ot._pos[2]);
                    else return ot._pos;
                    return ot
                }, HowlerGlobal.prototype.orientation = function(et, tt, nt, ot, at, st) {
                    var lt = this;
                    if (!lt.ctx || !lt.ctx.listener) return lt;
                    var ut = lt._orientation;
                    if (tt = typeof tt != "number" ? ut[1] : tt, nt = typeof nt != "number" ? ut[2] : nt, ot = typeof ot != "number" ? ut[3] : ot, at = typeof at != "number" ? ut[4] : at, st = typeof st != "number" ? ut[5] : st, typeof et == "number") lt._orientation = [et, tt, nt, ot, at, st], typeof lt.ctx.listener.forwardX < "u" ? (lt.ctx.listener.forwardX.setTargetAtTime(et, Howler.ctx.currentTime, .1), lt.ctx.listener.forwardY.setTargetAtTime(tt, Howler.ctx.currentTime, .1), lt.ctx.listener.forwardZ.setTargetAtTime(nt, Howler.ctx.currentTime, .1), lt.ctx.listener.upX.setTargetAtTime(ot, Howler.ctx.currentTime, .1), lt.ctx.listener.upY.setTargetAtTime(at, Howler.ctx.currentTime, .1), lt.ctx.listener.upZ.setTargetAtTime(st, Howler.ctx.currentTime, .1)) : lt.ctx.listener.setOrientation(et, tt, nt, ot, at, st);
                    else return ut;
                    return lt
                }, Howl.prototype.init = function(et) {
                    return function(tt) {
                        var nt = this;
                        return nt._orientation = tt.orientation || [1, 0, 0], nt._stereo = tt.stereo || null, nt._pos = tt.pos || null, nt._pannerAttr = {
                            coneInnerAngle: typeof tt.coneInnerAngle < "u" ? tt.coneInnerAngle : 360,
                            coneOuterAngle: typeof tt.coneOuterAngle < "u" ? tt.coneOuterAngle : 360,
                            coneOuterGain: typeof tt.coneOuterGain < "u" ? tt.coneOuterGain : 0,
                            distanceModel: typeof tt.distanceModel < "u" ? tt.distanceModel : "inverse",
                            maxDistance: typeof tt.maxDistance < "u" ? tt.maxDistance : 1e4,
                            panningModel: typeof tt.panningModel < "u" ? tt.panningModel : "HRTF",
                            refDistance: typeof tt.refDistance < "u" ? tt.refDistance : 1,
                            rolloffFactor: typeof tt.rolloffFactor < "u" ? tt.rolloffFactor : 1
                        }, nt._onstereo = tt.onstereo ? [{
                            fn: tt.onstereo
                        }] : [], nt._onpos = tt.onpos ? [{
                            fn: tt.onpos
                        }] : [], nt._onorientation = tt.onorientation ? [{
                            fn: tt.onorientation
                        }] : [], et.call(this, tt)
                    }
                }(Howl.prototype.init), Howl.prototype.stereo = function(et, tt) {
                    var nt = this;
                    if (!nt._webAudio) return nt;
                    if (nt._state !== "loaded") return nt._queue.push({
                        event: "stereo",
                        action: function() {
                            nt.stereo(et, tt)
                        }
                    }), nt;
                    var ot = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
                    if (typeof tt > "u")
                        if (typeof et == "number") nt._stereo = et, nt._pos = [et, 0, 0];
                        else return nt._stereo;
                    for (var at = nt._getSoundIds(tt), st = 0; st < at.length; st++) {
                        var lt = nt._soundById(at[st]);
                        if (lt)
                            if (typeof et == "number") lt._stereo = et, lt._pos = [et, 0, 0], lt._node && (lt._pannerAttr.panningModel = "equalpower", (!lt._panner || !lt._panner.pan) && _e(lt, ot), ot === "spatial" ? typeof lt._panner.positionX < "u" ? (lt._panner.positionX.setValueAtTime(et, Howler.ctx.currentTime), lt._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), lt._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : lt._panner.setPosition(et, 0, 0) : lt._panner.pan.setValueAtTime(et, Howler.ctx.currentTime)), nt._emit("stereo", lt._id);
                            else return lt._stereo
                    }
                    return nt
                }, Howl.prototype.pos = function(et, tt, nt, ot) {
                    var at = this;
                    if (!at._webAudio) return at;
                    if (at._state !== "loaded") return at._queue.push({
                        event: "pos",
                        action: function() {
                            at.pos(et, tt, nt, ot)
                        }
                    }), at;
                    if (tt = typeof tt != "number" ? 0 : tt, nt = typeof nt != "number" ? -.5 : nt, typeof ot > "u")
                        if (typeof et == "number") at._pos = [et, tt, nt];
                        else return at._pos;
                    for (var st = at._getSoundIds(ot), lt = 0; lt < st.length; lt++) {
                        var ut = at._soundById(st[lt]);
                        if (ut)
                            if (typeof et == "number") ut._pos = [et, tt, nt], ut._node && ((!ut._panner || ut._panner.pan) && _e(ut, "spatial"), typeof ut._panner.positionX < "u" ? (ut._panner.positionX.setValueAtTime(et, Howler.ctx.currentTime), ut._panner.positionY.setValueAtTime(tt, Howler.ctx.currentTime), ut._panner.positionZ.setValueAtTime(nt, Howler.ctx.currentTime)) : ut._panner.setPosition(et, tt, nt)), at._emit("pos", ut._id);
                            else return ut._pos
                    }
                    return at
                }, Howl.prototype.orientation = function(et, tt, nt, ot) {
                    var at = this;
                    if (!at._webAudio) return at;
                    if (at._state !== "loaded") return at._queue.push({
                        event: "orientation",
                        action: function() {
                            at.orientation(et, tt, nt, ot)
                        }
                    }), at;
                    if (tt = typeof tt != "number" ? at._orientation[1] : tt, nt = typeof nt != "number" ? at._orientation[2] : nt, typeof ot > "u")
                        if (typeof et == "number") at._orientation = [et, tt, nt];
                        else return at._orientation;
                    for (var st = at._getSoundIds(ot), lt = 0; lt < st.length; lt++) {
                        var ut = at._soundById(st[lt]);
                        if (ut)
                            if (typeof et == "number") ut._orientation = [et, tt, nt], ut._node && (ut._panner || (ut._pos || (ut._pos = at._pos || [0, 0, -.5]), _e(ut, "spatial")), typeof ut._panner.orientationX < "u" ? (ut._panner.orientationX.setValueAtTime(et, Howler.ctx.currentTime), ut._panner.orientationY.setValueAtTime(tt, Howler.ctx.currentTime), ut._panner.orientationZ.setValueAtTime(nt, Howler.ctx.currentTime)) : ut._panner.setOrientation(et, tt, nt)), at._emit("orientation", ut._id);
                            else return ut._orientation
                    }
                    return at
                }, Howl.prototype.pannerAttr = function() {
                    var et = this,
                        tt = arguments,
                        nt, ot, at;
                    if (!et._webAudio) return et;
                    if (tt.length === 0) return et._pannerAttr;
                    if (tt.length === 1)
                        if (typeof tt[0] == "object") nt = tt[0], typeof ot > "u" && (nt.pannerAttr || (nt.pannerAttr = {
                            coneInnerAngle: nt.coneInnerAngle,
                            coneOuterAngle: nt.coneOuterAngle,
                            coneOuterGain: nt.coneOuterGain,
                            distanceModel: nt.distanceModel,
                            maxDistance: nt.maxDistance,
                            refDistance: nt.refDistance,
                            rolloffFactor: nt.rolloffFactor,
                            panningModel: nt.panningModel
                        }), et._pannerAttr = {
                            coneInnerAngle: typeof nt.pannerAttr.coneInnerAngle < "u" ? nt.pannerAttr.coneInnerAngle : et._coneInnerAngle,
                            coneOuterAngle: typeof nt.pannerAttr.coneOuterAngle < "u" ? nt.pannerAttr.coneOuterAngle : et._coneOuterAngle,
                            coneOuterGain: typeof nt.pannerAttr.coneOuterGain < "u" ? nt.pannerAttr.coneOuterGain : et._coneOuterGain,
                            distanceModel: typeof nt.pannerAttr.distanceModel < "u" ? nt.pannerAttr.distanceModel : et._distanceModel,
                            maxDistance: typeof nt.pannerAttr.maxDistance < "u" ? nt.pannerAttr.maxDistance : et._maxDistance,
                            refDistance: typeof nt.pannerAttr.refDistance < "u" ? nt.pannerAttr.refDistance : et._refDistance,
                            rolloffFactor: typeof nt.pannerAttr.rolloffFactor < "u" ? nt.pannerAttr.rolloffFactor : et._rolloffFactor,
                            panningModel: typeof nt.pannerAttr.panningModel < "u" ? nt.pannerAttr.panningModel : et._panningModel
                        });
                        else return at = et._soundById(parseInt(tt[0], 10)), at ? at._pannerAttr : et._pannerAttr;
                    else tt.length === 2 && (nt = tt[0], ot = parseInt(tt[1], 10));
                    for (var st = et._getSoundIds(ot), lt = 0; lt < st.length; lt++)
                        if (at = et._soundById(st[lt]), at) {
                            var ut = at._pannerAttr;
                            ut = {
                                coneInnerAngle: typeof nt.coneInnerAngle < "u" ? nt.coneInnerAngle : ut.coneInnerAngle,
                                coneOuterAngle: typeof nt.coneOuterAngle < "u" ? nt.coneOuterAngle : ut.coneOuterAngle,
                                coneOuterGain: typeof nt.coneOuterGain < "u" ? nt.coneOuterGain : ut.coneOuterGain,
                                distanceModel: typeof nt.distanceModel < "u" ? nt.distanceModel : ut.distanceModel,
                                maxDistance: typeof nt.maxDistance < "u" ? nt.maxDistance : ut.maxDistance,
                                refDistance: typeof nt.refDistance < "u" ? nt.refDistance : ut.refDistance,
                                rolloffFactor: typeof nt.rolloffFactor < "u" ? nt.rolloffFactor : ut.rolloffFactor,
                                panningModel: typeof nt.panningModel < "u" ? nt.panningModel : ut.panningModel
                            };
                            var dt = at._panner;
                            dt || (at._pos || (at._pos = et._pos || [0, 0, -.5]), _e(at, "spatial"), dt = at._panner), dt.coneInnerAngle = ut.coneInnerAngle, dt.coneOuterAngle = ut.coneOuterAngle, dt.coneOuterGain = ut.coneOuterGain, dt.distanceModel = ut.distanceModel, dt.maxDistance = ut.maxDistance, dt.refDistance = ut.refDistance, dt.rolloffFactor = ut.rolloffFactor, dt.panningModel = ut.panningModel
                        }
                    return et
                }, Sound.prototype.init = function(et) {
                    return function() {
                        var tt = this,
                            nt = tt._parent;
                        tt._orientation = nt._orientation, tt._stereo = nt._stereo, tt._pos = nt._pos, tt._pannerAttr = nt._pannerAttr, et.call(this), tt._stereo ? nt.stereo(tt._stereo) : tt._pos && nt.pos(tt._pos[0], tt._pos[1], tt._pos[2], tt._id)
                    }
                }(Sound.prototype.init), Sound.prototype.reset = function(et) {
                    return function() {
                        var tt = this,
                            nt = tt._parent;
                        return tt._orientation = nt._orientation, tt._stereo = nt._stereo, tt._pos = nt._pos, tt._pannerAttr = nt._pannerAttr, tt._stereo ? nt.stereo(tt._stereo) : tt._pos ? nt.pos(tt._pos[0], tt._pos[1], tt._pos[2], tt._id) : tt._panner && (tt._panner.disconnect(0), tt._panner = void 0, nt._refreshBuffer(tt)), et.call(this)
                    }
                }(Sound.prototype.reset);
                var _e = function(et, tt) {
                    tt = tt || "spatial", tt === "spatial" ? (et._panner = Howler.ctx.createPanner(), et._panner.coneInnerAngle = et._pannerAttr.coneInnerAngle, et._panner.coneOuterAngle = et._pannerAttr.coneOuterAngle, et._panner.coneOuterGain = et._pannerAttr.coneOuterGain, et._panner.distanceModel = et._pannerAttr.distanceModel, et._panner.maxDistance = et._pannerAttr.maxDistance, et._panner.refDistance = et._pannerAttr.refDistance, et._panner.rolloffFactor = et._pannerAttr.rolloffFactor, et._panner.panningModel = et._pannerAttr.panningModel, typeof et._panner.positionX < "u" ? (et._panner.positionX.setValueAtTime(et._pos[0], Howler.ctx.currentTime), et._panner.positionY.setValueAtTime(et._pos[1], Howler.ctx.currentTime), et._panner.positionZ.setValueAtTime(et._pos[2], Howler.ctx.currentTime)) : et._panner.setPosition(et._pos[0], et._pos[1], et._pos[2]), typeof et._panner.orientationX < "u" ? (et._panner.orientationX.setValueAtTime(et._orientation[0], Howler.ctx.currentTime), et._panner.orientationY.setValueAtTime(et._orientation[1], Howler.ctx.currentTime), et._panner.orientationZ.setValueAtTime(et._orientation[2], Howler.ctx.currentTime)) : et._panner.setOrientation(et._orientation[0], et._orientation[1], et._orientation[2])) : (et._panner = Howler.ctx.createStereoPanner(), et._panner.pan.setValueAtTime(et._stereo, Howler.ctx.currentTime)), et._panner.connect(et._node), et._paused || et._parent.pause(et._id, !0).play(et._id, !0)
                }
            }()
        }(howler);
    var eventemitter3$1 = {
        exports: {}
    };
    (function(_) {
        var _e = Object.prototype.hasOwnProperty,
            et = "~";

        function tt() {}
        Object.create && (tt.prototype = Object.create(null), new tt().__proto__ || (et = !1));

        function nt(lt, ut, dt) {
            this.fn = lt, this.context = ut, this.once = dt || !1
        }

        function ot(lt, ut, dt, ct, pt) {
            if (typeof dt != "function") throw new TypeError("The listener must be a function");
            var ft = new nt(dt, ct || lt, pt),
                ht = et ? et + ut : ut;
            return lt._events[ht] ? lt._events[ht].fn ? lt._events[ht] = [lt._events[ht], ft] : lt._events[ht].push(ft) : (lt._events[ht] = ft, lt._eventsCount++), lt
        }

        function at(lt, ut) {
            --lt._eventsCount === 0 ? lt._events = new tt : delete lt._events[ut]
        }

        function st() {
            this._events = new tt, this._eventsCount = 0
        }
        st.prototype.eventNames = function() {
            var lt = [],
                ut, dt;
            if (this._eventsCount === 0) return lt;
            for (dt in ut = this._events) _e.call(ut, dt) && lt.push(et ? dt.slice(1) : dt);
            return Object.getOwnPropertySymbols ? lt.concat(Object.getOwnPropertySymbols(ut)) : lt
        }, st.prototype.listeners = function(lt) {
            var ut = et ? et + lt : lt,
                dt = this._events[ut];
            if (!dt) return [];
            if (dt.fn) return [dt.fn];
            for (var ct = 0, pt = dt.length, ft = new Array(pt); ct < pt; ct++) ft[ct] = dt[ct].fn;
            return ft
        }, st.prototype.listenerCount = function(lt) {
            var ut = et ? et + lt : lt,
                dt = this._events[ut];
            return dt ? dt.fn ? 1 : dt.length : 0
        }, st.prototype.emit = function(lt, ut, dt, ct, pt, ft) {
            var ht = et ? et + lt : lt;
            if (!this._events[ht]) return !1;
            var mt = this._events[ht],
                bt = arguments.length,
                gt, vt;
            if (mt.fn) {
                switch (mt.once && this.removeListener(lt, mt.fn, void 0, !0), bt) {
                    case 1:
                        return mt.fn.call(mt.context), !0;
                    case 2:
                        return mt.fn.call(mt.context, ut), !0;
                    case 3:
                        return mt.fn.call(mt.context, ut, dt), !0;
                    case 4:
                        return mt.fn.call(mt.context, ut, dt, ct), !0;
                    case 5:
                        return mt.fn.call(mt.context, ut, dt, ct, pt), !0;
                    case 6:
                        return mt.fn.call(mt.context, ut, dt, ct, pt, ft), !0
                }
                for (vt = 1, gt = new Array(bt - 1); vt < bt; vt++) gt[vt - 1] = arguments[vt];
                mt.fn.apply(mt.context, gt)
            } else {
                var xt = mt.length,
                    yt;
                for (vt = 0; vt < xt; vt++) switch (mt[vt].once && this.removeListener(lt, mt[vt].fn, void 0, !0), bt) {
                    case 1:
                        mt[vt].fn.call(mt[vt].context);
                        break;
                    case 2:
                        mt[vt].fn.call(mt[vt].context, ut);
                        break;
                    case 3:
                        mt[vt].fn.call(mt[vt].context, ut, dt);
                        break;
                    case 4:
                        mt[vt].fn.call(mt[vt].context, ut, dt, ct);
                        break;
                    default:
                        if (!gt)
                            for (yt = 1, gt = new Array(bt - 1); yt < bt; yt++) gt[yt - 1] = arguments[yt];
                        mt[vt].fn.apply(mt[vt].context, gt)
                }
            }
            return !0
        }, st.prototype.on = function(lt, ut, dt) {
            return ot(this, lt, ut, dt, !1)
        }, st.prototype.once = function(lt, ut, dt) {
            return ot(this, lt, ut, dt, !0)
        }, st.prototype.removeListener = function(lt, ut, dt, ct) {
            var pt = et ? et + lt : lt;
            if (!this._events[pt]) return this;
            if (!ut) return at(this, pt), this;
            var ft = this._events[pt];
            if (ft.fn) ft.fn === ut && (!ct || ft.once) && (!dt || ft.context === dt) && at(this, pt);
            else {
                for (var ht = 0, mt = [], bt = ft.length; ht < bt; ht++)(ft[ht].fn !== ut || ct && !ft[ht].once || dt && ft[ht].context !== dt) && mt.push(ft[ht]);
                mt.length ? this._events[pt] = mt.length === 1 ? mt[0] : mt : at(this, pt)
            }
            return this
        }, st.prototype.removeAllListeners = function(lt) {
            var ut;
            return lt ? (ut = et ? et + lt : lt, this._events[ut] && at(this, ut)) : (this._events = new tt, this._eventsCount = 0), this
        }, st.prototype.off = st.prototype.removeListener, st.prototype.addListener = st.prototype.on, st.prefixed = et, st.EventEmitter = st, _.exports = st
    })(eventemitter3$1);
    var eventemitter3Exports$1 = eventemitter3$1.exports;
    const EventEmitter$4 = getDefaultExportFromCjs$1(eventemitter3Exports$1);
    class TimeoutError extends Error {
        constructor(_e) {
            super(_e), this.name = "TimeoutError"
        }
    }
    class AbortError extends Error {
        constructor(_e) {
            super(), this.name = "AbortError", this.message = _e
        }
    }
    const getDOMException = _ => globalThis.DOMException === void 0 ? new AbortError(_) : new DOMException(_),
        getAbortedReason = _ => {
            const _e = _.reason === void 0 ? getDOMException("This operation was aborted.") : _.reason;
            return _e instanceof Error ? _e : getDOMException(_e)
        };

    function pTimeout(_, _e, et, tt) {
        let nt;
        const ot = new Promise((at, st) => {
            if (typeof _e != "number" || Math.sign(_e) !== 1) throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${_e}\``);
            if (_e === Number.POSITIVE_INFINITY) {
                at(_);
                return
            }
            if (tt = kt({
                    customTimers: {
                        setTimeout,
                        clearTimeout
                    }
                }, tt), tt.signal) {
                const {
                    signal: lt
                } = tt;
                lt.aborted && st(getAbortedReason(lt)), lt.addEventListener("abort", () => {
                    st(getAbortedReason(lt))
                })
            }
            nt = tt.customTimers.setTimeout.call(void 0, () => {
                if (typeof et == "function") {
                    try {
                        at(et())
                    } catch (dt) {
                        st(dt)
                    }
                    return
                }
                const lt = typeof et == "string" ? et : `Promise timed out after ${_e} milliseconds`,
                    ut = et instanceof Error ? et : new TimeoutError(lt);
                typeof _.cancel == "function" && _.cancel(), st(ut)
            }, _e), (async () => {
                try {
                    at(await _)
                } catch (lt) {
                    st(lt)
                } finally {
                    tt.customTimers.clearTimeout.call(void 0, nt)
                }
            })()
        });
        return ot.clear = () => {
            clearTimeout(nt), nt = void 0
        }, ot
    }

    function lowerBound(_, _e, et) {
        let tt = 0,
            nt = _.length;
        for (; nt > 0;) {
            const ot = Math.trunc(nt / 2);
            let at = tt + ot;
            et(_[at], _e) <= 0 ? (tt = ++at, nt -= ot + 1) : nt = ot
        }
        return tt
    }
    class PriorityQueue {
        constructor() {
            Object.defineProperty(this, "_queue", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            })
        }
        enqueue(_e, et) {
            var tt;
            et = kt({
                priority: 0
            }, et);
            const nt = {
                priority: et.priority,
                run: _e
            };
            if (this.size && ((tt = this._queue[this.size - 1]) === null || tt === void 0 ? void 0 : tt.priority) >= et.priority) {
                this._queue.push(nt);
                return
            }
            const ot = lowerBound(this._queue, nt, (at, st) => st.priority - at.priority);
            this._queue.splice(ot, 0, nt)
        }
        dequeue() {
            const _e = this._queue.shift();
            return _e == null ? void 0 : _e.run
        }
        filter(_e) {
            return this._queue.filter(et => et.priority === _e.priority).map(et => et.run)
        }
        get size() {
            return this._queue.length
        }
    }
    const empty$2 = () => {},
        timeoutError = new TimeoutError;
    PQueue = class extends EventEmitter$4 {
        constructor(_) {
            var _e, et, tt, nt;
            if (super(), Object.defineProperty(this, "_carryoverConcurrencyCount", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_isIntervalIgnored", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_intervalCount", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "_intervalCap", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_interval", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_intervalEnd", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "_intervalId", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_timeoutId", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_queue", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_queueClass", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_pendingCount", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "_concurrency", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_isPaused", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_resolveEmpty", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: empty$2
                }), Object.defineProperty(this, "_resolveIdle", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: empty$2
                }), Object.defineProperty(this, "_timeout", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "_throwOnTimeout", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), _ = kt({
                    carryoverConcurrencyCount: !1,
                    intervalCap: Number.POSITIVE_INFINITY,
                    interval: 0,
                    concurrency: Number.POSITIVE_INFINITY,
                    autoStart: !0,
                    queueClass: PriorityQueue
                }, _), !(typeof _.intervalCap == "number" && _.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(et=(_e=_.intervalCap)===null||_e===void 0?void 0:_e.toString())!==null&&et!==void 0?et:""}\` (${typeof _.intervalCap})`);
            if (_.interval === void 0 || !(Number.isFinite(_.interval) && _.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(nt=(tt=_.interval)===null||tt===void 0?void 0:tt.toString())!==null&&nt!==void 0?nt:""}\` (${typeof _.interval})`);
            this._carryoverConcurrencyCount = _.carryoverConcurrencyCount, this._isIntervalIgnored = _.intervalCap === Number.POSITIVE_INFINITY || _.interval === 0, this._intervalCap = _.intervalCap, this._interval = _.interval, this._queue = new _.queueClass, this._queueClass = _.queueClass, this.concurrency = _.concurrency, this._timeout = _.timeout, this._throwOnTimeout = _.throwOnTimeout === !0, this._isPaused = _.autoStart === !1
        }
        get _doesIntervalAllowAnother() {
            return this._isIntervalIgnored || this._intervalCount < this._intervalCap
        }
        get _doesConcurrentAllowAnother() {
            return this._pendingCount < this._concurrency
        }
        _next() {
            this._pendingCount--, this._tryToStartAnother(), this.emit("next")
        }
        _resolvePromises() {
            this._resolveEmpty(), this._resolveEmpty = empty$2, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = empty$2, this.emit("idle"))
        }
        _onResumeInterval() {
            this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0
        }
        _isIntervalPaused() {
            const _ = Date.now();
            if (this._intervalId === void 0) {
                const _e = this._intervalEnd - _;
                if (_e < 0) this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
                else return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
                    this._onResumeInterval()
                }, _e)), !0
            }
            return !1
        }
        _tryToStartAnother() {
            if (this._queue.size === 0) return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1;
            if (!this._isPaused) {
                const _ = !this._isIntervalPaused();
                if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                    const _e = this._queue.dequeue();
                    return _e ? (this.emit("active"), _e(), _ && this._initializeIntervalIfNeeded(), !0) : !1
                }
            }
            return !1
        }
        _initializeIntervalIfNeeded() {
            this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
                this._onInterval()
            }, this._interval), this._intervalEnd = Date.now() + this._interval)
        }
        _onInterval() {
            this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue()
        }
        _processQueue() {
            for (; this._tryToStartAnother(););
        }
        get concurrency() {
            return this._concurrency
        }
        set concurrency(_) {
            if (!(typeof _ == "number" && _ >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${_}\` (${typeof _})`);
            this._concurrency = _, this._processQueue()
        }
        async add(_, _e = {}) {
            return new Promise((et, tt) => {
                const nt = async () => {
                    this._pendingCount++, this._intervalCount++;
                    try {
                        const ot = await (this._timeout === void 0 && _e.timeout === void 0 ? _() : pTimeout(Promise.resolve(_()), _e.timeout === void 0 ? this._timeout : _e.timeout, () => {
                            (_e.throwOnTimeout === void 0 ? this._throwOnTimeout : _e.throwOnTimeout) && tt(timeoutError)
                        }));
                        et(ot), this.emit("completed", ot)
                    } catch (ot) {
                        tt(ot), this.emit("error", ot)
                    }
                    this._next()
                };
                this._queue.enqueue(nt, _e), this._tryToStartAnother(), this.emit("add")
            })
        }
        async addAll(_, _e) {
            return Promise.all(_.map(async et => this.add(et, _e)))
        }
        start() {
            return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this
        }
        pause() {
            this._isPaused = !0
        }
        clear() {
            this._queue = new this._queueClass
        }
        async onEmpty() {
            if (this._queue.size !== 0) return new Promise(_ => {
                const _e = this._resolveEmpty;
                this._resolveEmpty = () => {
                    _e(), _()
                }
            })
        }
        async onSizeLessThan(_) {
            if (!(this._queue.size < _)) return new Promise(_e => {
                const et = () => {
                    this._queue.size < _ && (this.removeListener("next", et), _e())
                };
                this.on("next", et)
            })
        }
        async onIdle() {
            if (!(this._pendingCount === 0 && this._queue.size === 0)) return new Promise(_ => {
                const _e = this._resolveIdle;
                this._resolveIdle = () => {
                    _e(), _()
                }
            })
        }
        get size() {
            return this._queue.size
        }
        sizeBy(_) {
            return this._queue.filter(_).length
        }
        get pending() {
            return this._pendingCount
        }
        get isPaused() {
            return this._isPaused
        }
        get timeout() {
            return this._timeout
        }
        set timeout(_) {
            this._timeout = _
        }
    };

    function bind$1(_, _e) {
        return function() {
            return _.apply(_e, arguments)
        }
    }
    const {
        toString: toString$4
    } = Object.prototype, {
        getPrototypeOf
    } = Object, kindOf = (_ => _e => {
        const et = toString$4.call(_e);
        return _[et] || (_[et] = et.slice(8, -1).toLowerCase())
    })(Object.create(null)), kindOfTest = _ => (_ = _.toLowerCase(), _e => kindOf(_e) === _), typeOfTest = _ => _e => typeof _e === _, {
        isArray: isArray$2
    } = Array, isUndefined = typeOfTest("undefined");

    function isBuffer$1(_) {
        return _ !== null && !isUndefined(_) && _.constructor !== null && !isUndefined(_.constructor) && isFunction(_.constructor.isBuffer) && _.constructor.isBuffer(_)
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");

    function isArrayBufferView(_) {
        let _e;
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? _e = ArrayBuffer.isView(_) : _e = _ && _.buffer && isArrayBuffer(_.buffer), _e
    }
    const isString$1 = typeOfTest("string"),
        isFunction = typeOfTest("function"),
        isNumber = typeOfTest("number"),
        isObject$1 = _ => _ !== null && typeof _ == "object",
        isBoolean = _ => _ === !0 || _ === !1,
        isPlainObject = _ => {
            if (kindOf(_) !== "object") return !1;
            const _e = getPrototypeOf(_);
            return (_e === null || _e === Object.prototype || Object.getPrototypeOf(_e) === null) && !(Symbol.toStringTag in _) && !(Symbol.iterator in _)
        },
        isDate = kindOfTest("Date"),
        isFile = kindOfTest("File"),
        isBlob = kindOfTest("Blob"),
        isFileList = kindOfTest("FileList"),
        isStream = _ => isObject$1(_) && isFunction(_.pipe),
        isFormData = _ => {
            let _e;
            return _ && (typeof FormData == "function" && _ instanceof FormData || isFunction(_.append) && ((_e = kindOf(_)) === "formdata" || _e === "object" && isFunction(_.toString) && _.toString() === "[object FormData]"))
        },
        isURLSearchParams = kindOfTest("URLSearchParams"),
        trim = _ => _.trim ? _.trim() : _.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

    function forEach(_, _e, {
        allOwnKeys: et = !1
    } = {}) {
        if (_ === null || typeof _ > "u") return;
        let tt, nt;
        if (typeof _ != "object" && (_ = [_]), isArray$2(_))
            for (tt = 0, nt = _.length; tt < nt; tt++) _e.call(null, _[tt], tt, _);
        else {
            const ot = et ? Object.getOwnPropertyNames(_) : Object.keys(_),
                at = ot.length;
            let st;
            for (tt = 0; tt < at; tt++) st = ot[tt], _e.call(null, _[st], st, _)
        }
    }

    function findKey(_, _e) {
        _e = _e.toLowerCase();
        const et = Object.keys(_);
        let tt = et.length,
            nt;
        for (; tt-- > 0;)
            if (nt = et[tt], _e === nt.toLowerCase()) return nt;
        return null
    }
    const _global = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(),
        isContextDefined = _ => !isUndefined(_) && _ !== _global;

    function merge() {
        const {
            caseless: _
        } = isContextDefined(this) && this || {}, _e = {}, et = (tt, nt) => {
            const ot = _ && findKey(_e, nt) || nt;
            isPlainObject(_e[ot]) && isPlainObject(tt) ? _e[ot] = merge(_e[ot], tt) : isPlainObject(tt) ? _e[ot] = merge({}, tt) : isArray$2(tt) ? _e[ot] = tt.slice() : _e[ot] = tt
        };
        for (let tt = 0, nt = arguments.length; tt < nt; tt++) arguments[tt] && forEach(arguments[tt], et);
        return _e
    }
    const extend = (_, _e, et, {
            allOwnKeys: tt
        } = {}) => (forEach(_e, (nt, ot) => {
            et && isFunction(nt) ? _[ot] = bind$1(nt, et) : _[ot] = nt
        }, {
            allOwnKeys: tt
        }), _),
        stripBOM = _ => (_.charCodeAt(0) === 65279 && (_ = _.slice(1)), _),
        inherits = (_, _e, et, tt) => {
            _.prototype = Object.create(_e.prototype, tt), _.prototype.constructor = _, Object.defineProperty(_, "super", {
                value: _e.prototype
            }), et && Object.assign(_.prototype, et)
        },
        toFlatObject = (_, _e, et, tt) => {
            let nt, ot, at;
            const st = {};
            if (_e = _e || {}, _ == null) return _e;
            do {
                for (nt = Object.getOwnPropertyNames(_), ot = nt.length; ot-- > 0;) at = nt[ot], (!tt || tt(at, _, _e)) && !st[at] && (_e[at] = _[at], st[at] = !0);
                _ = et !== !1 && getPrototypeOf(_)
            } while (_ && (!et || et(_, _e)) && _ !== Object.prototype);
            return _e
        },
        endsWith = (_, _e, et) => {
            _ = String(_), (et === void 0 || et > _.length) && (et = _.length), et -= _e.length;
            const tt = _.indexOf(_e, et);
            return tt !== -1 && tt === et
        },
        toArray$1 = _ => {
            if (!_) return null;
            if (isArray$2(_)) return _;
            let _e = _.length;
            if (!isNumber(_e)) return null;
            const et = new Array(_e);
            for (; _e-- > 0;) et[_e] = _[_e];
            return et
        },
        isTypedArray = (_ => _e => _ && _e instanceof _)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)),
        forEachEntry = (_, _e) => {
            const et = (_ && _[Symbol.iterator]).call(_);
            let tt;
            for (;
                (tt = et.next()) && !tt.done;) {
                const nt = tt.value;
                _e.call(_, nt[0], nt[1])
            }
        },
        matchAll = (_, _e) => {
            let et;
            const tt = [];
            for (;
                (et = _.exec(_e)) !== null;) tt.push(et);
            return tt
        },
        isHTMLForm = kindOfTest("HTMLFormElement"),
        toCamelCase = _ => _.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(_e, et, tt) {
            return et.toUpperCase() + tt
        }),
        hasOwnProperty = (({
            hasOwnProperty: _
        }) => (_e, et) => _.call(_e, et))(Object.prototype),
        isRegExp = kindOfTest("RegExp"),
        reduceDescriptors = (_, _e) => {
            const et = Object.getOwnPropertyDescriptors(_),
                tt = {};
            forEach(et, (nt, ot) => {
                let at;
                (at = _e(nt, ot, _)) !== !1 && (tt[ot] = at || nt)
            }), Object.defineProperties(_, tt)
        },
        freezeMethods = _ => {
            reduceDescriptors(_, (_e, et) => {
                if (isFunction(_) && ["arguments", "caller", "callee"].indexOf(et) !== -1) return !1;
                const tt = _[et];
                if (isFunction(tt)) {
                    if (_e.enumerable = !1, "writable" in _e) {
                        _e.writable = !1;
                        return
                    }
                    _e.set || (_e.set = () => {
                        throw Error("Can not rewrite read-only method '" + et + "'")
                    })
                }
            })
        },
        toObjectSet = (_, _e) => {
            const et = {},
                tt = nt => {
                    nt.forEach(ot => {
                        et[ot] = !0
                    })
                };
            return isArray$2(_) ? tt(_) : tt(String(_).split(_e)), et
        },
        noop$5 = () => {},
        toFiniteNumber = (_, _e) => (_ = +_, Number.isFinite(_) ? _ : _e),
        ALPHA = "abcdefghijklmnopqrstuvwxyz",
        DIGIT = "0123456789",
        ALPHABET = {
            DIGIT,
            ALPHA,
            ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
        },
        generateString = (_ = 16, _e = ALPHABET.ALPHA_DIGIT) => {
            let et = "";
            const {
                length: tt
            } = _e;
            for (; _--;) et += _e[Math.random() * tt | 0];
            return et
        };

    function isSpecCompliantForm(_) {
        return !!(_ && isFunction(_.append) && _[Symbol.toStringTag] === "FormData" && _[Symbol.iterator])
    }
    const toJSONObject = _ => {
            const _e = new Array(10),
                et = (tt, nt) => {
                    if (isObject$1(tt)) {
                        if (_e.indexOf(tt) >= 0) return;
                        if (!("toJSON" in tt)) {
                            _e[nt] = tt;
                            const ot = isArray$2(tt) ? [] : {};
                            return forEach(tt, (at, st) => {
                                const lt = et(at, nt + 1);
                                !isUndefined(lt) && (ot[st] = lt)
                            }), _e[nt] = void 0, ot
                        }
                    }
                    return tt
                };
            return et(_, 0)
        },
        isAsyncFn = kindOfTest("AsyncFunction"),
        isThenable = _ => _ && (isObject$1(_) || isFunction(_)) && isFunction(_.then) && isFunction(_.catch),
        utils$1 = {
            isArray: isArray$2,
            isArrayBuffer,
            isBuffer: isBuffer$1,
            isFormData,
            isArrayBufferView,
            isString: isString$1,
            isNumber,
            isBoolean,
            isObject: isObject$1,
            isPlainObject,
            isUndefined,
            isDate,
            isFile,
            isBlob,
            isRegExp,
            isFunction,
            isStream,
            isURLSearchParams,
            isTypedArray,
            isFileList,
            forEach,
            merge,
            extend,
            trim,
            stripBOM,
            inherits,
            toFlatObject,
            kindOf,
            kindOfTest,
            endsWith,
            toArray: toArray$1,
            forEachEntry,
            matchAll,
            isHTMLForm,
            hasOwnProperty,
            hasOwnProp: hasOwnProperty,
            reduceDescriptors,
            freezeMethods,
            toObjectSet,
            toCamelCase,
            noop: noop$5,
            toFiniteNumber,
            findKey,
            global: _global,
            isContextDefined,
            ALPHABET,
            generateString,
            isSpecCompliantForm,
            toJSONObject,
            isAsyncFn,
            isThenable
        };

    function AxiosError(_, _e, et, tt, nt) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = _, this.name = "AxiosError", _e && (this.code = _e), et && (this.config = et), tt && (this.request = tt), nt && (this.response = nt)
    }
    utils$1.inherits(AxiosError, Error, {
        toJSON: function() {
            return {
                message: this.message,
                name: this.name,
                description: this.description,
                number: this.number,
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                config: utils$1.toJSONObject(this.config),
                code: this.code,
                status: this.response && this.response.status ? this.response.status : null
            }
        }
    });
    const prototype$1 = AxiosError.prototype,
        descriptors = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(_ => {
        descriptors[_] = {
            value: _
        }
    }), Object.defineProperties(AxiosError, descriptors), Object.defineProperty(prototype$1, "isAxiosError", {
        value: !0
    }), AxiosError.from = (_, _e, et, tt, nt, ot) => {
        const at = Object.create(prototype$1);
        return utils$1.toFlatObject(_, at, function(st) {
            return st !== Error.prototype
        }, st => st !== "isAxiosError"), AxiosError.call(at, _.message, _e, et, tt, nt), at.cause = _, at.name = _.name, ot && Object.assign(at, ot), at
    };
    const httpAdapter = null;

    function isVisitable(_) {
        return utils$1.isPlainObject(_) || utils$1.isArray(_)
    }

    function removeBrackets(_) {
        return utils$1.endsWith(_, "[]") ? _.slice(0, -2) : _
    }

    function renderKey(_, _e, et) {
        return _ ? _.concat(_e).map(function(tt, nt) {
            return tt = removeBrackets(tt), !et && nt ? "[" + tt + "]" : tt
        }).join(et ? "." : "") : _e
    }

    function isFlatArray(_) {
        return utils$1.isArray(_) && !_.some(isVisitable)
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function(_) {
        return /^is[A-Z]/.test(_)
    });

    function toFormData(_, _e, et) {
        if (!utils$1.isObject(_)) throw new TypeError("target must be an object");
        _e = _e || new FormData, et = utils$1.toFlatObject(et, {
            metaTokens: !0,
            dots: !1,
            indexes: !1
        }, !1, function(ft, ht) {
            return !utils$1.isUndefined(ht[ft])
        });
        const tt = et.metaTokens,
            nt = et.visitor || ut,
            ot = et.dots,
            at = et.indexes,
            st = (et.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(_e);
        if (!utils$1.isFunction(nt)) throw new TypeError("visitor must be a function");

        function lt(ft) {
            if (ft === null) return "";
            if (utils$1.isDate(ft)) return ft.toISOString();
            if (!st && utils$1.isBlob(ft)) throw new AxiosError("Blob is not supported. Use a Buffer instead.");
            return utils$1.isArrayBuffer(ft) || utils$1.isTypedArray(ft) ? st && typeof Blob == "function" ? new Blob([ft]) : Buffer.from(ft) : ft
        }

        function ut(ft, ht, mt) {
            let bt = ft;
            if (ft && !mt && typeof ft == "object") {
                if (utils$1.endsWith(ht, "{}")) ht = tt ? ht : ht.slice(0, -2), ft = JSON.stringify(ft);
                else if (utils$1.isArray(ft) && isFlatArray(ft) || (utils$1.isFileList(ft) || utils$1.endsWith(ht, "[]")) && (bt = utils$1.toArray(ft))) return ht = removeBrackets(ht), bt.forEach(function(gt, vt) {
                    !(utils$1.isUndefined(gt) || gt === null) && _e.append(at === !0 ? renderKey([ht], vt, ot) : at === null ? ht : ht + "[]", lt(gt))
                }), !1
            }
            return isVisitable(ft) ? !0 : (_e.append(renderKey(mt, ht, ot), lt(ft)), !1)
        }
        const dt = [],
            ct = Object.assign(predicates, {
                defaultVisitor: ut,
                convertValue: lt,
                isVisitable
            });

        function pt(ft, ht) {
            if (!utils$1.isUndefined(ft)) {
                if (dt.indexOf(ft) !== -1) throw Error("Circular reference detected in " + ht.join("."));
                dt.push(ft), utils$1.forEach(ft, function(mt, bt) {
                    (!(utils$1.isUndefined(mt) || mt === null) && nt.call(_e, mt, utils$1.isString(bt) ? bt.trim() : bt, ht, ct)) === !0 && pt(mt, ht ? ht.concat(bt) : [bt])
                }), dt.pop()
            }
        }
        if (!utils$1.isObject(_)) throw new TypeError("data must be an object");
        return pt(_), _e
    }

    function encode$2(_) {
        const _e = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0"
        };
        return encodeURIComponent(_).replace(/[!'()~]|%20|%00/g, function(et) {
            return _e[et]
        })
    }

    function AxiosURLSearchParams(_, _e) {
        this._pairs = [], _ && toFormData(_, this, _e)
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function(_, _e) {
        this._pairs.push([_, _e])
    }, prototype.toString = function(_) {
        const _e = _ ? function(et) {
            return _.call(this, et, encode$2)
        } : encode$2;
        return this._pairs.map(function(et) {
            return _e(et[0]) + "=" + _e(et[1])
        }, "").join("&")
    };

    function encode$1(_) {
        return encodeURIComponent(_).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }

    function buildURL(_, _e, et) {
        if (!_e) return _;
        const tt = et && et.encode || encode$1,
            nt = et && et.serialize;
        let ot;
        if (nt ? ot = nt(_e, et) : ot = utils$1.isURLSearchParams(_e) ? _e.toString() : new AxiosURLSearchParams(_e, et).toString(tt), ot) {
            const at = _.indexOf("#");
            at !== -1 && (_ = _.slice(0, at)), _ += (_.indexOf("?") === -1 ? "?" : "&") + ot
        }
        return _
    }
    class InterceptorManager {
        constructor() {
            this.handlers = []
        }
        use(_e, et, tt) {
            return this.handlers.push({
                fulfilled: _e,
                rejected: et,
                synchronous: tt ? tt.synchronous : !1,
                runWhen: tt ? tt.runWhen : null
            }), this.handlers.length - 1
        }
        eject(_e) {
            this.handlers[_e] && (this.handlers[_e] = null)
        }
        clear() {
            this.handlers && (this.handlers = [])
        }
        forEach(_e) {
            utils$1.forEach(this.handlers, function(et) {
                et !== null && _e(et)
            })
        }
    }
    const InterceptorManager$1 = InterceptorManager,
        transitionalDefaults = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        },
        URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams,
        FormData$1 = typeof FormData < "u" ? FormData : null,
        Blob$1 = typeof Blob < "u" ? Blob : null,
        platform$1 = {
            isBrowser: !0,
            classes: {
                URLSearchParams: URLSearchParams$1,
                FormData: FormData$1,
                Blob: Blob$1
            },
            protocols: ["http", "https", "file", "blob", "url", "data"]
        },
        hasBrowserEnv = typeof window < "u" && typeof document < "u",
        hasStandardBrowserEnv = (_ => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(_) < 0)(typeof navigator < "u" && navigator.product),
        hasStandardBrowserWebWorkerEnv = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(),
        utils = Object.freeze(Object.defineProperty({
            __proto__: null,
            hasBrowserEnv,
            hasStandardBrowserEnv,
            hasStandardBrowserWebWorkerEnv
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        platform = kt(kt({}, utils), platform$1);

    function toURLEncodedForm(_, _e) {
        return toFormData(_, new platform.classes.URLSearchParams, Object.assign({
            visitor: function(et, tt, nt, ot) {
                return platform.isNode && utils$1.isBuffer(et) ? (this.append(tt, et.toString("base64")), !1) : ot.defaultVisitor.apply(this, arguments)
            }
        }, _e))
    }

    function parsePropPath(_) {
        return utils$1.matchAll(/\w+|\[(\w*)]/g, _).map(_e => _e[0] === "[]" ? "" : _e[1] || _e[0])
    }

    function arrayToObject(_) {
        const _e = {},
            et = Object.keys(_);
        let tt;
        const nt = et.length;
        let ot;
        for (tt = 0; tt < nt; tt++) ot = et[tt], _e[ot] = _[ot];
        return _e
    }

    function formDataToJSON(_) {
        function _e(et, tt, nt, ot) {
            let at = et[ot++];
            const st = Number.isFinite(+at),
                lt = ot >= et.length;
            return at = !at && utils$1.isArray(nt) ? nt.length : at, lt ? (utils$1.hasOwnProp(nt, at) ? nt[at] = [nt[at], tt] : nt[at] = tt, !st) : ((!nt[at] || !utils$1.isObject(nt[at])) && (nt[at] = []), _e(et, tt, nt[at], ot) && utils$1.isArray(nt[at]) && (nt[at] = arrayToObject(nt[at])), !st)
        }
        if (utils$1.isFormData(_) && utils$1.isFunction(_.entries)) {
            const et = {};
            return utils$1.forEachEntry(_, (tt, nt) => {
                _e(parsePropPath(tt), nt, et, 0)
            }), et
        }
        return null
    }

    function stringifySafely(_, _e, et) {
        if (utils$1.isString(_)) try {
            return (_e || JSON.parse)(_), utils$1.trim(_)
        } catch (tt) {
            if (tt.name !== "SyntaxError") throw tt
        }
        return (et || JSON.stringify)(_)
    }
    const defaults$1 = {
        transitional: transitionalDefaults,
        adapter: ["xhr", "http"],
        transformRequest: [function(_, _e) {
            const et = _e.getContentType() || "",
                tt = et.indexOf("application/json") > -1,
                nt = utils$1.isObject(_);
            if (nt && utils$1.isHTMLForm(_) && (_ = new FormData(_)), utils$1.isFormData(_)) return tt && tt ? JSON.stringify(formDataToJSON(_)) : _;
            if (utils$1.isArrayBuffer(_) || utils$1.isBuffer(_) || utils$1.isStream(_) || utils$1.isFile(_) || utils$1.isBlob(_)) return _;
            if (utils$1.isArrayBufferView(_)) return _.buffer;
            if (utils$1.isURLSearchParams(_)) return _e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), _.toString();
            let ot;
            if (nt) {
                if (et.indexOf("application/x-www-form-urlencoded") > -1) return toURLEncodedForm(_, this.formSerializer).toString();
                if ((ot = utils$1.isFileList(_)) || et.indexOf("multipart/form-data") > -1) {
                    const at = this.env && this.env.FormData;
                    return toFormData(ot ? {
                        "files[]": _
                    } : _, at && new at, this.formSerializer)
                }
            }
            return nt || tt ? (_e.setContentType("application/json", !1), stringifySafely(_)) : _
        }],
        transformResponse: [function(_) {
            const _e = this.transitional || defaults$1.transitional,
                et = _e && _e.forcedJSONParsing,
                tt = this.responseType === "json";
            if (_ && utils$1.isString(_) && (et && !this.responseType || tt)) {
                const nt = !(_e && _e.silentJSONParsing) && tt;
                try {
                    return JSON.parse(_)
                } catch (ot) {
                    if (nt) throw ot.name === "SyntaxError" ? AxiosError.from(ot, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : ot
                }
            }
            return _
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
            FormData: platform.classes.FormData,
            Blob: platform.classes.Blob
        },
        validateStatus: function(_) {
            return _ >= 200 && _ < 300
        },
        headers: {
            common: {
                Accept: "application/json, text/plain, */*",
                "Content-Type": void 0
            }
        }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], _ => {
        defaults$1.headers[_] = {}
    });
    const defaults$2 = defaults$1,
        ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
        parseHeaders = _ => {
            const _e = {};
            let et, tt, nt;
            return _ && _.split(`
`).forEach(function(ot) {
                nt = ot.indexOf(":"), et = ot.substring(0, nt).trim().toLowerCase(), tt = ot.substring(nt + 1).trim(), !(!et || _e[et] && ignoreDuplicateOf[et]) && (et === "set-cookie" ? _e[et] ? _e[et].push(tt) : _e[et] = [tt] : _e[et] = _e[et] ? _e[et] + ", " + tt : tt)
            }), _e
        },
        $internals = Symbol("internals");

    function normalizeHeader(_) {
        return _ && String(_).trim().toLowerCase()
    }

    function normalizeValue(_) {
        return _ === !1 || _ == null ? _ : utils$1.isArray(_) ? _.map(normalizeValue) : String(_)
    }

    function parseTokens(_) {
        const _e = Object.create(null),
            et = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let tt;
        for (; tt = et.exec(_);) _e[tt[1]] = tt[2];
        return _e
    }
    const isValidHeaderName = _ => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(_.trim());

    function matchHeaderValue(_, _e, et, tt, nt) {
        if (utils$1.isFunction(tt)) return tt.call(this, _e, et);
        if (nt && (_e = et), !!utils$1.isString(_e)) {
            if (utils$1.isString(tt)) return _e.indexOf(tt) !== -1;
            if (utils$1.isRegExp(tt)) return tt.test(_e)
        }
    }

    function formatHeader(_) {
        return _.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (_e, et, tt) => et.toUpperCase() + tt)
    }

    function buildAccessors(_, _e) {
        const et = utils$1.toCamelCase(" " + _e);
        ["get", "set", "has"].forEach(tt => {
            Object.defineProperty(_, tt + et, {
                value: function(nt, ot, at) {
                    return this[tt].call(this, _e, nt, ot, at)
                },
                configurable: !0
            })
        })
    }
    class AxiosHeaders {
        constructor(_e) {
            _e && this.set(_e)
        }
        set(_e, et, tt) {
            const nt = this;

            function ot(st, lt, ut) {
                const dt = normalizeHeader(lt);
                if (!dt) throw new Error("header name must be a non-empty string");
                const ct = utils$1.findKey(nt, dt);
                (!ct || nt[ct] === void 0 || ut === !0 || ut === void 0 && nt[ct] !== !1) && (nt[ct || lt] = normalizeValue(st))
            }
            const at = (st, lt) => utils$1.forEach(st, (ut, dt) => ot(ut, dt, lt));
            return utils$1.isPlainObject(_e) || _e instanceof this.constructor ? at(_e, et) : utils$1.isString(_e) && (_e = _e.trim()) && !isValidHeaderName(_e) ? at(parseHeaders(_e), et) : _e != null && ot(et, _e, tt), this
        }
        get(_e, et) {
            if (_e = normalizeHeader(_e), _e) {
                const tt = utils$1.findKey(this, _e);
                if (tt) {
                    const nt = this[tt];
                    if (!et) return nt;
                    if (et === !0) return parseTokens(nt);
                    if (utils$1.isFunction(et)) return et.call(this, nt, tt);
                    if (utils$1.isRegExp(et)) return et.exec(nt);
                    throw new TypeError("parser must be boolean|regexp|function")
                }
            }
        }
        has(_e, et) {
            if (_e = normalizeHeader(_e), _e) {
                const tt = utils$1.findKey(this, _e);
                return !!(tt && this[tt] !== void 0 && (!et || matchHeaderValue(this, this[tt], tt, et)))
            }
            return !1
        }
        delete(_e, et) {
            const tt = this;
            let nt = !1;

            function ot(at) {
                if (at = normalizeHeader(at), at) {
                    const st = utils$1.findKey(tt, at);
                    st && (!et || matchHeaderValue(tt, tt[st], st, et)) && (delete tt[st], nt = !0)
                }
            }
            return utils$1.isArray(_e) ? _e.forEach(ot) : ot(_e), nt
        }
        clear(_e) {
            const et = Object.keys(this);
            let tt = et.length,
                nt = !1;
            for (; tt--;) {
                const ot = et[tt];
                (!_e || matchHeaderValue(this, this[ot], ot, _e, !0)) && (delete this[ot], nt = !0)
            }
            return nt
        }
        normalize(_e) {
            const et = this,
                tt = {};
            return utils$1.forEach(this, (nt, ot) => {
                const at = utils$1.findKey(tt, ot);
                if (at) {
                    et[at] = normalizeValue(nt), delete et[ot];
                    return
                }
                const st = _e ? formatHeader(ot) : String(ot).trim();
                st !== ot && delete et[ot], et[st] = normalizeValue(nt), tt[st] = !0
            }), this
        }
        concat(..._e) {
            return this.constructor.concat(this, ..._e)
        }
        toJSON(_e) {
            const et = Object.create(null);
            return utils$1.forEach(this, (tt, nt) => {
                tt != null && tt !== !1 && (et[nt] = _e && utils$1.isArray(tt) ? tt.join(", ") : tt)
            }), et
        }[Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]()
        }
        toString() {
            return Object.entries(this.toJSON()).map(([_e, et]) => _e + ": " + et).join(`
`)
        }
        get[Symbol.toStringTag]() {
            return "AxiosHeaders"
        }
        static from(_e) {
            return _e instanceof this ? _e : new this(_e)
        }
        static concat(_e, ...et) {
            const tt = new this(_e);
            return et.forEach(nt => tt.set(nt)), tt
        }
        static accessor(_e) {
            const et = (this[$internals] = this[$internals] = {
                    accessors: {}
                }).accessors,
                tt = this.prototype;

            function nt(ot) {
                const at = normalizeHeader(ot);
                et[at] || (buildAccessors(tt, ot), et[at] = !0)
            }
            return utils$1.isArray(_e) ? _e.forEach(nt) : nt(_e), this
        }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), utils$1.reduceDescriptors(AxiosHeaders.prototype, ({
        value: _
    }, _e) => {
        let et = _e[0].toUpperCase() + _e.slice(1);
        return {
            get: () => _,
            set(tt) {
                this[et] = tt
            }
        }
    }), utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;

    function transformData(_, _e) {
        const et = this || defaults$2,
            tt = _e || et,
            nt = AxiosHeaders$1.from(tt.headers);
        let ot = tt.data;
        return utils$1.forEach(_, function(at) {
            ot = at.call(et, ot, nt.normalize(), _e ? _e.status : void 0)
        }), nt.normalize(), ot
    }

    function isCancel(_) {
        return !!(_ && _.__CANCEL__)
    }

    function CanceledError(_, _e, et) {
        AxiosError.call(this, _ != null ? _ : "canceled", AxiosError.ERR_CANCELED, _e, et), this.name = "CanceledError"
    }
    utils$1.inherits(CanceledError, AxiosError, {
        __CANCEL__: !0
    });

    function settle(_, _e, et) {
        const tt = et.config.validateStatus;
        !et.status || !tt || tt(et.status) ? _(et) : _e(new AxiosError("Request failed with status code " + et.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(et.status / 100) - 4], et.config, et.request, et))
    }
    const cookies = platform.hasStandardBrowserEnv ? {
        write(_, _e, et, tt, nt, ot) {
            const at = [_ + "=" + encodeURIComponent(_e)];
            utils$1.isNumber(et) && at.push("expires=" + new Date(et).toGMTString()), utils$1.isString(tt) && at.push("path=" + tt), utils$1.isString(nt) && at.push("domain=" + nt), ot === !0 && at.push("secure"), document.cookie = at.join("; ")
        },
        read(_) {
            const _e = document.cookie.match(new RegExp("(^|;\\s*)(" + _ + ")=([^;]*)"));
            return _e ? decodeURIComponent(_e[3]) : null
        },
        remove(_) {
            this.write(_, "", Date.now() - 864e5)
        }
    } : {
        write() {},
        read() {
            return null
        },
        remove() {}
    };

    function isAbsoluteURL(_) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(_)
    }

    function combineURLs(_, _e) {
        return _e ? _.replace(/\/+$/, "") + "/" + _e.replace(/^\/+/, "") : _
    }

    function buildFullPath(_, _e) {
        return _ && !isAbsoluteURL(_e) ? combineURLs(_, _e) : _e
    }
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? function() {
        const _ = /(msie|trident)/i.test(navigator.userAgent),
            _e = document.createElement("a");
        let et;

        function tt(nt) {
            let ot = nt;
            return _ && (_e.setAttribute("href", ot), ot = _e.href), _e.setAttribute("href", ot), {
                href: _e.href,
                protocol: _e.protocol ? _e.protocol.replace(/:$/, "") : "",
                host: _e.host,
                search: _e.search ? _e.search.replace(/^\?/, "") : "",
                hash: _e.hash ? _e.hash.replace(/^#/, "") : "",
                hostname: _e.hostname,
                port: _e.port,
                pathname: _e.pathname.charAt(0) === "/" ? _e.pathname : "/" + _e.pathname
            }
        }
        return et = tt(window.location.href),
            function(nt) {
                const ot = utils$1.isString(nt) ? tt(nt) : nt;
                return ot.protocol === et.protocol && ot.host === et.host
            }
    }() : function() {
        return function() {
            return !0
        }
    }();

    function parseProtocol(_) {
        const _e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(_);
        return _e && _e[1] || ""
    }

    function speedometer(_, _e) {
        _ = _ || 10;
        const et = new Array(_),
            tt = new Array(_);
        let nt = 0,
            ot = 0,
            at;
        return _e = _e !== void 0 ? _e : 1e3,
            function(st) {
                const lt = Date.now(),
                    ut = tt[ot];
                at || (at = lt), et[nt] = st, tt[nt] = lt;
                let dt = ot,
                    ct = 0;
                for (; dt !== nt;) ct += et[dt++], dt = dt % _;
                if (nt = (nt + 1) % _, nt === ot && (ot = (ot + 1) % _), lt - at < _e) return;
                const pt = ut && lt - ut;
                return pt ? Math.round(ct * 1e3 / pt) : void 0
            }
    }

    function progressEventReducer(_, _e) {
        let et = 0;
        const tt = speedometer(50, 250);
        return nt => {
            const ot = nt.loaded,
                at = nt.lengthComputable ? nt.total : void 0,
                st = ot - et,
                lt = tt(st),
                ut = ot <= at;
            et = ot;
            const dt = {
                loaded: ot,
                total: at,
                progress: at ? ot / at : void 0,
                bytes: st,
                rate: lt || void 0,
                estimated: lt && at && ut ? (at - ot) / lt : void 0,
                event: nt
            };
            dt[_e ? "download" : "upload"] = !0, _(dt)
        }
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest < "u",
        xhrAdapter = isXHRAdapterSupported && function(_) {
            return new Promise(function(_e, et) {
                let tt = _.data;
                const nt = AxiosHeaders$1.from(_.headers).normalize();
                let {
                    responseType: ot,
                    withXSRFToken: at
                } = _, st;

                function lt() {
                    _.cancelToken && _.cancelToken.unsubscribe(st), _.signal && _.signal.removeEventListener("abort", st)
                }
                let ut;
                if (utils$1.isFormData(tt)) {
                    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) nt.setContentType(!1);
                    else if ((ut = nt.getContentType()) !== !1) {
                        const [ht, ...mt] = ut ? ut.split(";").map(bt => bt.trim()).filter(Boolean) : [];
                        nt.setContentType([ht || "multipart/form-data", ...mt].join("; "))
                    }
                }
                let dt = new XMLHttpRequest;
                if (_.auth) {
                    const ht = _.auth.username || "",
                        mt = _.auth.password ? unescape(encodeURIComponent(_.auth.password)) : "";
                    nt.set("Authorization", "Basic " + btoa(ht + ":" + mt))
                }
                const ct = buildFullPath(_.baseURL, _.url);
                dt.open(_.method.toUpperCase(), buildURL(ct, _.params, _.paramsSerializer), !0), dt.timeout = _.timeout;

                function pt() {
                    if (!dt) return;
                    const ht = AxiosHeaders$1.from("getAllResponseHeaders" in dt && dt.getAllResponseHeaders()),
                        mt = {
                            data: !ot || ot === "text" || ot === "json" ? dt.responseText : dt.response,
                            status: dt.status,
                            statusText: dt.statusText,
                            headers: ht,
                            config: _,
                            request: dt
                        };
                    settle(function(bt) {
                        _e(bt), lt()
                    }, function(bt) {
                        et(bt), lt()
                    }, mt), dt = null
                }
                if ("onloadend" in dt ? dt.onloadend = pt : dt.onreadystatechange = function() {
                        !dt || dt.readyState !== 4 || dt.status === 0 && !(dt.responseURL && dt.responseURL.indexOf("file:") === 0) || setTimeout(pt)
                    }, dt.onabort = function() {
                        dt && (et(new AxiosError("Request aborted", AxiosError.ECONNABORTED, _, dt)), dt = null)
                    }, dt.onerror = function() {
                        et(new AxiosError("Network Error", AxiosError.ERR_NETWORK, _, dt)), dt = null
                    }, dt.ontimeout = function() {
                        let ht = _.timeout ? "timeout of " + _.timeout + "ms exceeded" : "timeout exceeded";
                        const mt = _.transitional || transitionalDefaults;
                        _.timeoutErrorMessage && (ht = _.timeoutErrorMessage), et(new AxiosError(ht, mt.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, _, dt)), dt = null
                    }, platform.hasStandardBrowserEnv && (at && utils$1.isFunction(at) && (at = at(_)), at || at !== !1 && isURLSameOrigin(ct))) {
                    const ht = _.xsrfHeaderName && _.xsrfCookieName && cookies.read(_.xsrfCookieName);
                    ht && nt.set(_.xsrfHeaderName, ht)
                }
                tt === void 0 && nt.setContentType(null), "setRequestHeader" in dt && utils$1.forEach(nt.toJSON(), function(ht, mt) {
                    dt.setRequestHeader(mt, ht)
                }), utils$1.isUndefined(_.withCredentials) || (dt.withCredentials = !!_.withCredentials), ot && ot !== "json" && (dt.responseType = _.responseType), typeof _.onDownloadProgress == "function" && dt.addEventListener("progress", progressEventReducer(_.onDownloadProgress, !0)), typeof _.onUploadProgress == "function" && dt.upload && dt.upload.addEventListener("progress", progressEventReducer(_.onUploadProgress)), (_.cancelToken || _.signal) && (st = ht => {
                    dt && (et(!ht || ht.type ? new CanceledError(null, _, dt) : ht), dt.abort(), dt = null)
                }, _.cancelToken && _.cancelToken.subscribe(st), _.signal && (_.signal.aborted ? st() : _.signal.addEventListener("abort", st)));
                const ft = parseProtocol(ct);
                if (ft && platform.protocols.indexOf(ft) === -1) {
                    et(new AxiosError("Unsupported protocol " + ft + ":", AxiosError.ERR_BAD_REQUEST, _));
                    return
                }
                dt.send(tt || null)
            })
        },
        knownAdapters = {
            http: httpAdapter,
            xhr: xhrAdapter
        };
    utils$1.forEach(knownAdapters, (_, _e) => {
        if (_) {
            try {
                Object.defineProperty(_, "name", {
                    value: _e
                })
            } catch (et) {}
            Object.defineProperty(_, "adapterName", {
                value: _e
            })
        }
    });
    const renderReason = _ => `- ${_}`,
        isResolvedHandle = _ => utils$1.isFunction(_) || _ === null || _ === !1,
        adapters = {
            getAdapter: _ => {
                _ = utils$1.isArray(_) ? _ : [_];
                const {
                    length: _e
                } = _;
                let et, tt;
                const nt = {};
                for (let ot = 0; ot < _e; ot++) {
                    et = _[ot];
                    let at;
                    if (tt = et, !isResolvedHandle(et) && (tt = knownAdapters[(at = String(et)).toLowerCase()], tt === void 0)) throw new AxiosError(`Unknown adapter '${at}'`);
                    if (tt) break;
                    nt[at || "#" + ot] = tt
                }
                if (!tt) {
                    const ot = Object.entries(nt).map(([st, lt]) => `adapter ${st} ` + (lt === !1 ? "is not supported by the environment" : "is not available in the build"));
                    let at = _e ? ot.length > 1 ? `since :
` + ot.map(renderReason).join(`
`) : " " + renderReason(ot[0]) : "as no adapter specified";
                    throw new AxiosError("There is no suitable adapter to dispatch the request " + at, "ERR_NOT_SUPPORT")
                }
                return tt
            },
            adapters: knownAdapters
        };

    function throwIfCancellationRequested(_) {
        if (_.cancelToken && _.cancelToken.throwIfRequested(), _.signal && _.signal.aborted) throw new CanceledError(null, _)
    }

    function dispatchRequest(_) {
        return throwIfCancellationRequested(_), _.headers = AxiosHeaders$1.from(_.headers), _.data = transformData.call(_, _.transformRequest), ["post", "put", "patch"].indexOf(_.method) !== -1 && _.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(_.adapter || defaults$2.adapter)(_).then(function(_e) {
            return throwIfCancellationRequested(_), _e.data = transformData.call(_, _.transformResponse, _e), _e.headers = AxiosHeaders$1.from(_e.headers), _e
        }, function(_e) {
            return isCancel(_e) || (throwIfCancellationRequested(_), _e && _e.response && (_e.response.data = transformData.call(_, _.transformResponse, _e.response), _e.response.headers = AxiosHeaders$1.from(_e.response.headers))), Promise.reject(_e)
        })
    }
    const headersToObject = _ => _ instanceof AxiosHeaders$1 ? _.toJSON() : _;

    function mergeConfig(_, _e) {
        _e = _e || {};
        const et = {};

        function tt(ut, dt, ct) {
            return utils$1.isPlainObject(ut) && utils$1.isPlainObject(dt) ? utils$1.merge.call({
                caseless: ct
            }, ut, dt) : utils$1.isPlainObject(dt) ? utils$1.merge({}, dt) : utils$1.isArray(dt) ? dt.slice() : dt
        }

        function nt(ut, dt, ct) {
            if (utils$1.isUndefined(dt)) {
                if (!utils$1.isUndefined(ut)) return tt(void 0, ut, ct)
            } else return tt(ut, dt, ct)
        }

        function ot(ut, dt) {
            if (!utils$1.isUndefined(dt)) return tt(void 0, dt)
        }

        function at(ut, dt) {
            if (utils$1.isUndefined(dt)) {
                if (!utils$1.isUndefined(ut)) return tt(void 0, ut)
            } else return tt(void 0, dt)
        }

        function st(ut, dt, ct) {
            if (ct in _e) return tt(ut, dt);
            if (ct in _) return tt(void 0, ut)
        }
        const lt = {
            url: ot,
            method: ot,
            data: ot,
            baseURL: at,
            transformRequest: at,
            transformResponse: at,
            paramsSerializer: at,
            timeout: at,
            timeoutMessage: at,
            withCredentials: at,
            withXSRFToken: at,
            adapter: at,
            responseType: at,
            xsrfCookieName: at,
            xsrfHeaderName: at,
            onUploadProgress: at,
            onDownloadProgress: at,
            decompress: at,
            maxContentLength: at,
            maxBodyLength: at,
            beforeRedirect: at,
            transport: at,
            httpAgent: at,
            httpsAgent: at,
            cancelToken: at,
            socketPath: at,
            responseEncoding: at,
            validateStatus: st,
            headers: (ut, dt) => nt(headersToObject(ut), headersToObject(dt), !0)
        };
        return utils$1.forEach(Object.keys(Object.assign({}, _, _e)), function(ut) {
            const dt = lt[ut] || nt,
                ct = dt(_[ut], _e[ut], ut);
            utils$1.isUndefined(ct) && dt !== st || (et[ut] = ct)
        }), et
    }
    const VERSION = "1.6.2",
        validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((_, _e) => {
        validators$1[_] = function(et) {
            return typeof et === _ || "a" + (_e < 1 ? "n " : " ") + _
        }
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function(_, _e, et) {
        function tt(nt, ot) {
            return "[Axios v" + VERSION + "] Transitional option '" + nt + "'" + ot + (et ? ". " + et : "")
        }
        return (nt, ot, at) => {
            if (_ === !1) throw new AxiosError(tt(ot, " has been removed" + (_e ? " in " + _e : "")), AxiosError.ERR_DEPRECATED);
            return _e && !deprecatedWarnings[ot] && (deprecatedWarnings[ot] = !0, console.warn(tt(ot, " has been deprecated since v" + _e + " and will be removed in the near future"))), _ ? _(nt, ot, at) : !0
        }
    };

    function assertOptions(_, _e, et) {
        if (typeof _ != "object") throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
        const tt = Object.keys(_);
        let nt = tt.length;
        for (; nt-- > 0;) {
            const ot = tt[nt],
                at = _e[ot];
            if (at) {
                const st = _[ot],
                    lt = st === void 0 || at(st, ot, _);
                if (lt !== !0) throw new AxiosError("option " + ot + " must be " + lt, AxiosError.ERR_BAD_OPTION_VALUE);
                continue
            }
            if (et !== !0) throw new AxiosError("Unknown option " + ot, AxiosError.ERR_BAD_OPTION)
        }
    }
    const validator = {
            assertOptions,
            validators: validators$1
        },
        validators = validator.validators;
    class Axios {
        constructor(_e) {
            this.defaults = _e, this.interceptors = {
                request: new InterceptorManager$1,
                response: new InterceptorManager$1
            }
        }
        request(_e, et) {
            typeof _e == "string" ? (et = et || {}, et.url = _e) : et = _e || {}, et = mergeConfig(this.defaults, et);
            const {
                transitional: tt,
                paramsSerializer: nt,
                headers: ot
            } = et;
            tt !== void 0 && validator.assertOptions(tt, {
                silentJSONParsing: validators.transitional(validators.boolean),
                forcedJSONParsing: validators.transitional(validators.boolean),
                clarifyTimeoutError: validators.transitional(validators.boolean)
            }, !1), nt != null && (utils$1.isFunction(nt) ? et.paramsSerializer = {
                serialize: nt
            } : validator.assertOptions(nt, {
                encode: validators.function,
                serialize: validators.function
            }, !0)), et.method = (et.method || this.defaults.method || "get").toLowerCase();
            let at = ot && utils$1.merge(ot.common, ot[et.method]);
            ot && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], ht => {
                delete ot[ht]
            }), et.headers = AxiosHeaders$1.concat(at, ot);
            const st = [];
            let lt = !0;
            this.interceptors.request.forEach(function(ht) {
                typeof ht.runWhen == "function" && ht.runWhen(et) === !1 || (lt = lt && ht.synchronous, st.unshift(ht.fulfilled, ht.rejected))
            });
            const ut = [];
            this.interceptors.response.forEach(function(ht) {
                ut.push(ht.fulfilled, ht.rejected)
            });
            let dt, ct = 0,
                pt;
            if (!lt) {
                const ht = [dispatchRequest.bind(this), void 0];
                for (ht.unshift.apply(ht, st), ht.push.apply(ht, ut), pt = ht.length, dt = Promise.resolve(et); ct < pt;) dt = dt.then(ht[ct++], ht[ct++]);
                return dt
            }
            pt = st.length;
            let ft = et;
            for (ct = 0; ct < pt;) {
                const ht = st[ct++],
                    mt = st[ct++];
                try {
                    ft = ht(ft)
                } catch (bt) {
                    mt.call(this, bt);
                    break
                }
            }
            try {
                dt = dispatchRequest.call(this, ft)
            } catch (ht) {
                return Promise.reject(ht)
            }
            for (ct = 0, pt = ut.length; ct < pt;) dt = dt.then(ut[ct++], ut[ct++]);
            return dt
        }
        getUri(_e) {
            _e = mergeConfig(this.defaults, _e);
            const et = buildFullPath(_e.baseURL, _e.url);
            return buildURL(et, _e.params, _e.paramsSerializer)
        }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function(_) {
        Axios.prototype[_] = function(_e, et) {
            return this.request(mergeConfig(et || {}, {
                method: _,
                url: _e,
                data: (et || {}).data
            }))
        }
    }), utils$1.forEach(["post", "put", "patch"], function(_) {
        function _e(et) {
            return function(tt, nt, ot) {
                return this.request(mergeConfig(ot || {}, {
                    method: _,
                    headers: et ? {
                        "Content-Type": "multipart/form-data"
                    } : {},
                    url: tt,
                    data: nt
                }))
            }
        }
        Axios.prototype[_] = _e(), Axios.prototype[_ + "Form"] = _e(!0)
    });
    const Axios$1 = Axios;
    class CancelToken {
        constructor(_e) {
            if (typeof _e != "function") throw new TypeError("executor must be a function.");
            let et;
            this.promise = new Promise(function(nt) {
                et = nt
            });
            const tt = this;
            this.promise.then(nt => {
                if (!tt._listeners) return;
                let ot = tt._listeners.length;
                for (; ot-- > 0;) tt._listeners[ot](nt);
                tt._listeners = null
            }), this.promise.then = nt => {
                let ot;
                const at = new Promise(st => {
                    tt.subscribe(st), ot = st
                }).then(nt);
                return at.cancel = function() {
                    tt.unsubscribe(ot)
                }, at
            }, _e(function(nt, ot, at) {
                tt.reason || (tt.reason = new CanceledError(nt, ot, at), et(tt.reason))
            })
        }
        throwIfRequested() {
            if (this.reason) throw this.reason
        }
        subscribe(_e) {
            if (this.reason) {
                _e(this.reason);
                return
            }
            this._listeners ? this._listeners.push(_e) : this._listeners = [_e]
        }
        unsubscribe(_e) {
            if (!this._listeners) return;
            const et = this._listeners.indexOf(_e);
            et !== -1 && this._listeners.splice(et, 1)
        }
        static source() {
            let _e;
            return {
                token: new CancelToken(function(et) {
                    _e = et
                }),
                cancel: _e
            }
        }
    }
    const CancelToken$1 = CancelToken;

    function spread(_) {
        return function(_e) {
            return _.apply(null, _e)
        }
    }

    function isAxiosError(_) {
        return utils$1.isObject(_) && _.isAxiosError === !0
    }
    const HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([_, _e]) => {
        HttpStatusCode[_e] = _
    });
    const HttpStatusCode$1 = HttpStatusCode;

    function createInstance(_) {
        const _e = new Axios$1(_),
            et = bind$1(Axios$1.prototype.request, _e);
        return utils$1.extend(et, Axios$1.prototype, _e, {
            allOwnKeys: !0
        }), utils$1.extend(et, _e, null, {
            allOwnKeys: !0
        }), et.create = function(tt) {
            return createInstance(mergeConfig(_, tt))
        }, et
    }
    const axios = createInstance(defaults$2);
    axios.Axios = Axios$1, axios.CanceledError = CanceledError, axios.CancelToken = CancelToken$1, axios.isCancel = isCancel, axios.VERSION = VERSION, axios.toFormData = toFormData, axios.AxiosError = AxiosError, axios.Cancel = axios.CanceledError, axios.all = function(_) {
        return Promise.all(_)
    }, axios.spread = spread, axios.isAxiosError = isAxiosError, axios.mergeConfig = mergeConfig, axios.AxiosHeaders = AxiosHeaders$1, axios.formToJSON = _ => formDataToJSON(utils$1.isHTMLForm(_) ? new FormData(_) : _), axios.getAdapter = adapters.getAdapter, axios.HttpStatusCode = HttpStatusCode$1, axios.default = axios;
    const axios$1 = axios;
    var eventemitter3 = {
        exports: {}
    };
    (function(_) {
        var _e = Object.prototype.hasOwnProperty,
            et = "~";

        function tt() {}
        Object.create && (tt.prototype = Object.create(null), new tt().__proto__ || (et = !1));

        function nt(lt, ut, dt) {
            this.fn = lt, this.context = ut, this.once = dt || !1
        }

        function ot(lt, ut, dt, ct, pt) {
            if (typeof dt != "function") throw new TypeError("The listener must be a function");
            var ft = new nt(dt, ct || lt, pt),
                ht = et ? et + ut : ut;
            return lt._events[ht] ? lt._events[ht].fn ? lt._events[ht] = [lt._events[ht], ft] : lt._events[ht].push(ft) : (lt._events[ht] = ft, lt._eventsCount++), lt
        }

        function at(lt, ut) {
            --lt._eventsCount === 0 ? lt._events = new tt : delete lt._events[ut]
        }

        function st() {
            this._events = new tt, this._eventsCount = 0
        }
        st.prototype.eventNames = function() {
            var lt = [],
                ut, dt;
            if (this._eventsCount === 0) return lt;
            for (dt in ut = this._events) _e.call(ut, dt) && lt.push(et ? dt.slice(1) : dt);
            return Object.getOwnPropertySymbols ? lt.concat(Object.getOwnPropertySymbols(ut)) : lt
        }, st.prototype.listeners = function(lt) {
            var ut = et ? et + lt : lt,
                dt = this._events[ut];
            if (!dt) return [];
            if (dt.fn) return [dt.fn];
            for (var ct = 0, pt = dt.length, ft = new Array(pt); ct < pt; ct++) ft[ct] = dt[ct].fn;
            return ft
        }, st.prototype.listenerCount = function(lt) {
            var ut = et ? et + lt : lt,
                dt = this._events[ut];
            return dt ? dt.fn ? 1 : dt.length : 0
        }, st.prototype.emit = function(lt, ut, dt, ct, pt, ft) {
            var ht = et ? et + lt : lt;
            if (!this._events[ht]) return !1;
            var mt = this._events[ht],
                bt = arguments.length,
                gt, vt;
            if (mt.fn) {
                switch (mt.once && this.removeListener(lt, mt.fn, void 0, !0), bt) {
                    case 1:
                        return mt.fn.call(mt.context), !0;
                    case 2:
                        return mt.fn.call(mt.context, ut), !0;
                    case 3:
                        return mt.fn.call(mt.context, ut, dt), !0;
                    case 4:
                        return mt.fn.call(mt.context, ut, dt, ct), !0;
                    case 5:
                        return mt.fn.call(mt.context, ut, dt, ct, pt), !0;
                    case 6:
                        return mt.fn.call(mt.context, ut, dt, ct, pt, ft), !0
                }
                for (vt = 1, gt = new Array(bt - 1); vt < bt; vt++) gt[vt - 1] = arguments[vt];
                mt.fn.apply(mt.context, gt)
            } else {
                var xt = mt.length,
                    yt;
                for (vt = 0; vt < xt; vt++) switch (mt[vt].once && this.removeListener(lt, mt[vt].fn, void 0, !0), bt) {
                    case 1:
                        mt[vt].fn.call(mt[vt].context);
                        break;
                    case 2:
                        mt[vt].fn.call(mt[vt].context, ut);
                        break;
                    case 3:
                        mt[vt].fn.call(mt[vt].context, ut, dt);
                        break;
                    case 4:
                        mt[vt].fn.call(mt[vt].context, ut, dt, ct);
                        break;
                    default:
                        if (!gt)
                            for (yt = 1, gt = new Array(bt - 1); yt < bt; yt++) gt[yt - 1] = arguments[yt];
                        mt[vt].fn.apply(mt[vt].context, gt)
                }
            }
            return !0
        }, st.prototype.on = function(lt, ut, dt) {
            return ot(this, lt, ut, dt, !1)
        }, st.prototype.once = function(lt, ut, dt) {
            return ot(this, lt, ut, dt, !0)
        }, st.prototype.removeListener = function(lt, ut, dt, ct) {
            var pt = et ? et + lt : lt;
            if (!this._events[pt]) return this;
            if (!ut) return at(this, pt), this;
            var ft = this._events[pt];
            if (ft.fn) ft.fn === ut && (!ct || ft.once) && (!dt || ft.context === dt) && at(this, pt);
            else {
                for (var ht = 0, mt = [], bt = ft.length; ht < bt; ht++)(ft[ht].fn !== ut || ct && !ft[ht].once || dt && ft[ht].context !== dt) && mt.push(ft[ht]);
                mt.length ? this._events[pt] = mt.length === 1 ? mt[0] : mt : at(this, pt)
            }
            return this
        }, st.prototype.removeAllListeners = function(lt) {
            var ut;
            return lt ? (ut = et ? et + lt : lt, this._events[ut] && at(this, ut)) : (this._events = new tt, this._eventsCount = 0), this
        }, st.prototype.off = st.prototype.removeListener, st.prototype.addListener = st.prototype.on, st.prefixed = et, st.EventEmitter = st, _.exports = st
    })(eventemitter3);
    var eventemitter3Exports = eventemitter3.exports;
    EventEmitter$3 = getDefaultExportFromCjs$1(eventemitter3Exports), MotionConfigContext = reactExports.createContext({
        transformPagePoint: _ => _,
        isStatic: !1,
        reducedMotion: "never"
    }), MotionContext = reactExports.createContext({}), PresenceContext = reactExports.createContext(null), isBrowser$1 = typeof document < "u", useIsomorphicLayoutEffect$2 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect, LazyContext = reactExports.createContext({
        strict: !1
    });

    function useVisualElement(_, _e, et, tt) {
        const {
            visualElement: nt
        } = reactExports.useContext(MotionContext), ot = reactExports.useContext(LazyContext), at = reactExports.useContext(PresenceContext), st = reactExports.useContext(MotionConfigContext).reducedMotion, lt = reactExports.useRef();
        tt = tt || ot.renderer, !lt.current && tt && (lt.current = tt(_, {
            visualState: _e,
            parent: nt,
            props: et,
            presenceContext: at,
            blockInitialAnimation: at ? at.initial === !1 : !1,
            reducedMotionConfig: st
        }));
        const ut = lt.current;
        reactExports.useInsertionEffect(() => {
            ut && ut.update(et, at)
        });
        const dt = reactExports.useRef(!!window.HandoffAppearAnimations);
        return useIsomorphicLayoutEffect$2(() => {
            ut && (ut.render(), dt.current && ut.animationState && ut.animationState.animateChanges())
        }), reactExports.useEffect(() => {
            ut && (ut.updateFeatures(), !dt.current && ut.animationState && ut.animationState.animateChanges(), window.HandoffAppearAnimations = void 0, dt.current = !1)
        }), ut
    }

    function isRefObject(_) {
        return typeof _ == "object" && Object.prototype.hasOwnProperty.call(_, "current")
    }

    function useMotionRef(_, _e, et) {
        return reactExports.useCallback(tt => {
            tt && _.mount && _.mount(tt), _e && (tt ? _e.mount(tt) : _e.unmount()), et && (typeof et == "function" ? et(tt) : isRefObject(et) && (et.current = tt))
        }, [_e])
    }

    function isVariantLabel(_) {
        return typeof _ == "string" || Array.isArray(_)
    }

    function isAnimationControls(_) {
        return typeof _ == "object" && typeof _.start == "function"
    }
    const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
        variantProps = ["initial", ...variantPriorityOrder];

    function isControllingVariants(_) {
        return isAnimationControls(_.animate) || variantProps.some(_e => isVariantLabel(_[_e]))
    }

    function isVariantNode(_) {
        return !!(isControllingVariants(_) || _.variants)
    }

    function getCurrentTreeVariants(_, _e) {
        if (isControllingVariants(_)) {
            const {
                initial: et,
                animate: tt
            } = _;
            return {
                initial: et === !1 || isVariantLabel(et) ? et : void 0,
                animate: isVariantLabel(tt) ? tt : void 0
            }
        }
        return _.inherit !== !1 ? _e : {}
    }

    function useCreateMotionContext(_) {
        const {
            initial: _e,
            animate: et
        } = getCurrentTreeVariants(_, reactExports.useContext(MotionContext));
        return reactExports.useMemo(() => ({
            initial: _e,
            animate: et
        }), [variantLabelsAsDependency(_e), variantLabelsAsDependency(et)])
    }

    function variantLabelsAsDependency(_) {
        return Array.isArray(_) ? _.join(" ") : _
    }
    const featureProps = {
            animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
            exit: ["exit"],
            drag: ["drag", "dragControls"],
            focus: ["whileFocus"],
            hover: ["whileHover", "onHoverStart", "onHoverEnd"],
            tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
            pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
            inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
            layout: ["layout", "layoutId"]
        },
        featureDefinitions = {};
    for (const _ in featureProps) featureDefinitions[_] = {
        isEnabled: _e => featureProps[_].some(et => !!_e[et])
    };
    loadFeatures = function(_) {
        for (const _e in _) featureDefinitions[_e] = kt(kt({}, featureDefinitions[_e]), _[_e])
    }, LayoutGroupContext = reactExports.createContext({}), SwitchLayoutGroupContext = reactExports.createContext({}), motionComponentSymbol = Symbol.for("motionComponentSymbol"), createMotionComponent = function({
        preloadedFeatures: _,
        createVisualElement: _e,
        useRender: et,
        useVisualState: tt,
        Component: nt
    }) {
        _ && loadFeatures(_);

        function ot(st, lt) {
            let ut;
            const dt = Bt(kt(kt({}, reactExports.useContext(MotionConfigContext)), st), {
                    layoutId: useLayoutId(st)
                }),
                {
                    isStatic: ct
                } = dt,
                pt = useCreateMotionContext(st),
                ft = tt(st, ct);
            if (!ct && isBrowser$1) {
                pt.visualElement = useVisualElement(nt, ft, dt, _e);
                const ht = reactExports.useContext(SwitchLayoutGroupContext),
                    mt = reactExports.useContext(LazyContext).strict;
                pt.visualElement && (ut = pt.visualElement.loadFeatures(dt, mt, _, ht))
            }
            return reactExports.createElement(MotionContext.Provider, {
                value: pt
            }, ut && pt.visualElement ? reactExports.createElement(ut, kt({
                visualElement: pt.visualElement
            }, dt)) : null, et(nt, st, useMotionRef(ft, pt.visualElement, lt), ft, ct, pt.visualElement))
        }
        const at = reactExports.forwardRef(ot);
        return at[motionComponentSymbol] = nt, at
    };

    function useLayoutId({
        layoutId: _
    }) {
        const _e = reactExports.useContext(LayoutGroupContext).id;
        return _e && _ !== void 0 ? _e + "-" + _ : _
    }
    createMotionProxy = function(_) {
        function _e(tt, nt = {}) {
            return createMotionComponent(_(tt, nt))
        }
        if (typeof Proxy > "u") return _e;
        const et = new Map;
        return new Proxy(_e, {
            get: (tt, nt) => (et.has(nt) || et.set(nt, _e(nt)), et.get(nt))
        })
    };
    const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

    function isSVGComponent(_) {
        return typeof _ != "string" || _.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(_) > -1 || /[A-Z]/.test(_))
    }
    const scaleCorrectors = {};
    addScaleCorrector = function(_) {
        Object.assign(scaleCorrectors, _)
    };
    let transformPropOrder;
    transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], transformProps = new Set(transformPropOrder);

    function isForcedMotionValue(_, {
        layout: _e,
        layoutId: et
    }) {
        return transformProps.has(_) || _.startsWith("origin") || (_e || et !== void 0) && (!!scaleCorrectors[_] || _ === "opacity")
    }
    let translateAlias, numTransforms;
    isMotionValue = _ => !!(_ && _.getVelocity), translateAlias = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    }, numTransforms = transformPropOrder.length, buildTransform = function(_, {
        enableHardwareAcceleration: _e = !0,
        allowTransformNone: et = !0
    }, tt, nt) {
        let ot = "";
        for (let at = 0; at < numTransforms; at++) {
            const st = transformPropOrder[at];
            if (_[st] !== void 0) {
                const lt = translateAlias[st] || st;
                ot += `${lt}(${_[st]}) `
            }
        }
        return _e && !_.z && (ot += "translateZ(0)"), ot = ot.trim(), nt ? ot = nt(_, tt ? "" : ot) : et && tt && (ot = "none"), ot
    };
    let checkStringStartsWith, isCSSVariableToken, cssVariableRegex, getValueAsType, number, alpha, scale, sanitize, floatRegex, colorRegex, singleColorRegex;
    checkStringStartsWith = _ => _e => typeof _e == "string" && _e.startsWith(_), isCSSVariableName = checkStringStartsWith("--"), isCSSVariableToken = checkStringStartsWith("var(--"), cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, getValueAsType = (_, _e) => _e && typeof _ == "number" ? _e.transform(_) : _, clamp = (_, _e, et) => Math.min(Math.max(et, _), _e), number = {
        test: _ => typeof _ == "number",
        parse: parseFloat,
        transform: _ => _
    }, alpha = Bt(kt({}, number), {
        transform: _ => clamp(0, 1, _)
    }), scale = Bt(kt({}, number), {
        default: 1
    }), sanitize = _ => Math.round(_ * 1e5) / 1e5, floatRegex = /(-)?([\d]*\.?[\d])+/g, colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;

    function isString(_) {
        return typeof _ == "string"
    }
    let createUnitType, degrees, percent, vh$1, vw, progressPercentage, int, numberValueTypes;
    createUnitType = _ => ({
        test: _e => isString(_e) && _e.endsWith(_) && _e.split(" ").length === 1,
        parse: parseFloat,
        transform: _e => `${_e}${_}`
    }), degrees = createUnitType("deg"), percent = createUnitType("%"), px = createUnitType("px"), vh$1 = createUnitType("vh"), vw = createUnitType("vw"), progressPercentage = Bt(kt({}, percent), {
        parse: _ => percent.parse(_) / 100,
        transform: _ => percent.transform(_ * 100)
    }), int = Bt(kt({}, number), {
        transform: Math.round
    }), numberValueTypes = {
        borderWidth: px,
        borderTopWidth: px,
        borderRightWidth: px,
        borderBottomWidth: px,
        borderLeftWidth: px,
        borderRadius: px,
        radius: px,
        borderTopLeftRadius: px,
        borderTopRightRadius: px,
        borderBottomRightRadius: px,
        borderBottomLeftRadius: px,
        width: px,
        maxWidth: px,
        height: px,
        maxHeight: px,
        size: px,
        top: px,
        right: px,
        bottom: px,
        left: px,
        padding: px,
        paddingTop: px,
        paddingRight: px,
        paddingBottom: px,
        paddingLeft: px,
        margin: px,
        marginTop: px,
        marginRight: px,
        marginBottom: px,
        marginLeft: px,
        rotate: degrees,
        rotateX: degrees,
        rotateY: degrees,
        rotateZ: degrees,
        scale,
        scaleX: scale,
        scaleY: scale,
        scaleZ: scale,
        skew: degrees,
        skewX: degrees,
        skewY: degrees,
        distance: px,
        translateX: px,
        translateY: px,
        translateZ: px,
        x: px,
        y: px,
        z: px,
        perspective: px,
        transformPerspective: px,
        opacity: alpha,
        originX: progressPercentage,
        originY: progressPercentage,
        originZ: px,
        zIndex: int,
        fillOpacity: alpha,
        strokeOpacity: alpha,
        numOctaves: int
    };

    function buildHTMLStyles(_, _e, et, tt) {
        const {
            style: nt,
            vars: ot,
            transform: at,
            transformOrigin: st
        } = _;
        let lt = !1,
            ut = !1,
            dt = !0;
        for (const ct in _e) {
            const pt = _e[ct];
            if (isCSSVariableName(ct)) {
                ot[ct] = pt;
                continue
            }
            const ft = numberValueTypes[ct],
                ht = getValueAsType(pt, ft);
            if (transformProps.has(ct)) {
                if (lt = !0, at[ct] = ht, !dt) continue;
                pt !== (ft.default || 0) && (dt = !1)
            } else ct.startsWith("origin") ? (ut = !0, st[ct] = ht) : nt[ct] = ht
        }
        if (_e.transform || (lt || tt ? nt.transform = buildTransform(_.transform, et, dt, tt) : nt.transform && (nt.transform = "none")), ut) {
            const {
                originX: ct = "50%",
                originY: pt = "50%",
                originZ: ft = 0
            } = st;
            nt.transformOrigin = `${ct} ${pt} ${ft}`
        }
    }
    const createHtmlRenderState = () => ({
        style: {},
        transform: {},
        transformOrigin: {},
        vars: {}
    });

    function copyRawValuesOnly(_, _e, et) {
        for (const tt in _e) !isMotionValue(_e[tt]) && !isForcedMotionValue(tt, et) && (_[tt] = _e[tt])
    }

    function useInitialMotionValues({
        transformTemplate: _
    }, _e, et) {
        return reactExports.useMemo(() => {
            const tt = createHtmlRenderState();
            return buildHTMLStyles(tt, _e, {
                enableHardwareAcceleration: !et
            }, _), Object.assign({}, tt.vars, tt.style)
        }, [_e])
    }

    function useStyle(_, _e, et) {
        const tt = _.style || {},
            nt = {};
        return copyRawValuesOnly(nt, tt, _), Object.assign(nt, useInitialMotionValues(_, _e, et)), _.transformValues ? _.transformValues(nt) : nt
    }

    function useHTMLProps(_, _e, et) {
        const tt = {},
            nt = useStyle(_, _e, et);
        return _.drag && _.dragListener !== !1 && (tt.draggable = !1, nt.userSelect = nt.WebkitUserSelect = nt.WebkitTouchCallout = "none", nt.touchAction = _.drag === !0 ? "none" : `pan-${_.drag==="x"?"y":"x"}`), _.tabIndex === void 0 && (_.onTap || _.onTapStart || _.whileTap) && (tt.tabIndex = 0), tt.style = nt, tt
    }
    const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);
    isValidMotionProp = function(_) {
        return _.startsWith("while") || _.startsWith("drag") && _ !== "draggable" || _.startsWith("layout") || _.startsWith("onTap") || _.startsWith("onPan") || validMotionProps.has(_)
    };
    let shouldForward = _ => !isValidMotionProp(_);
    loadExternalIsValidProp = function(_) {
        _ && (shouldForward = _e => _e.startsWith("on") ? !isValidMotionProp(_e) : _(_e))
    };
    try {
        loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
    } catch (_) {}
    filterProps = function(_, _e, et) {
        const tt = {};
        for (const nt in _) nt === "values" && typeof _.values == "object" || (shouldForward(nt) || et === !0 && isValidMotionProp(nt) || !_e && !isValidMotionProp(nt) || _.draggable && nt.startsWith("onDrag")) && (tt[nt] = _[nt]);
        return tt
    };

    function calcOrigin$1(_, _e, et) {
        return typeof _ == "string" ? _ : px.transform(_e + et * _)
    }

    function calcSVGTransformOrigin(_, _e, et) {
        const tt = calcOrigin$1(_e, _.x, _.width),
            nt = calcOrigin$1(et, _.y, _.height);
        return `${tt} ${nt}`
    }
    const dashKeys = {
            offset: "stroke-dashoffset",
            array: "stroke-dasharray"
        },
        camelKeys = {
            offset: "strokeDashoffset",
            array: "strokeDasharray"
        };

    function buildSVGPath(_, _e, et = 1, tt = 0, nt = !0) {
        _.pathLength = 1;
        const ot = nt ? dashKeys : camelKeys;
        _[ot.offset] = px.transform(-tt);
        const at = px.transform(_e),
            st = px.transform(et);
        _[ot.array] = `${at} ${st}`
    }

    function buildSVGAttrs(_, ft, dt, ct, pt) {
        var ht = ft,
            {
                attrX: _e,
                attrY: et,
                attrScale: tt,
                originX: nt,
                originY: ot,
                pathLength: at,
                pathSpacing: st = 1,
                pathOffset: lt = 0
            } = ht,
            ut = Wt(ht, ["attrX", "attrY", "attrScale", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
        if (buildHTMLStyles(_, ut, dt, pt), ct) {
            _.style.viewBox && (_.attrs.viewBox = _.style.viewBox);
            return
        }
        _.attrs = _.style, _.style = {};
        const {
            attrs: mt,
            style: bt,
            dimensions: gt
        } = _;
        mt.transform && (gt && (bt.transform = mt.transform), delete mt.transform), gt && (nt !== void 0 || ot !== void 0 || bt.transform) && (bt.transformOrigin = calcSVGTransformOrigin(gt, nt !== void 0 ? nt : .5, ot !== void 0 ? ot : .5)), _e !== void 0 && (mt.x = _e), et !== void 0 && (mt.y = et), tt !== void 0 && (mt.scale = tt), at !== void 0 && buildSVGPath(mt, at, st, lt, !1)
    }
    const createSvgRenderState = () => Bt(kt({}, createHtmlRenderState()), {
            attrs: {}
        }),
        isSVGTag = _ => typeof _ == "string" && _.toLowerCase() === "svg";

    function useSVGProps(_, _e, et, tt) {
        const nt = reactExports.useMemo(() => {
            const ot = createSvgRenderState();
            return buildSVGAttrs(ot, _e, {
                enableHardwareAcceleration: !1
            }, isSVGTag(tt), _.transformTemplate), Bt(kt({}, ot.attrs), {
                style: kt({}, ot.style)
            })
        }, [_e]);
        if (_.style) {
            const ot = {};
            copyRawValuesOnly(ot, _.style, _), nt.style = kt(kt({}, ot), nt.style)
        }
        return nt
    }

    function createUseRender(_ = !1) {
        return (_e, et, tt, {
            latestValues: nt
        }, ot) => {
            const at = (isSVGComponent(_e) ? useSVGProps : useHTMLProps)(et, nt, ot, _e),
                st = Bt(kt(kt({}, filterProps(et, typeof _e == "string", _)), at), {
                    ref: tt
                }),
                {
                    children: lt
                } = et,
                ut = reactExports.useMemo(() => isMotionValue(lt) ? lt.get() : lt, [lt]);
            return reactExports.createElement(_e, Bt(kt({}, st), {
                children: ut
            }))
        }
    }
    camelToDash = _ => _.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

    function renderHTML(_, {
        style: _e,
        vars: et
    }, tt, nt) {
        Object.assign(_.style, _e, nt && nt.getProjectionStyles(tt));
        for (const ot in et) _.style.setProperty(ot, et[ot])
    }
    const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

    function renderSVG(_, _e, et, tt) {
        renderHTML(_, _e, void 0, tt);
        for (const nt in _e.attrs) _.setAttribute(camelCaseAttributes.has(nt) ? nt : camelToDash(nt), _e.attrs[nt])
    }

    function scrapeMotionValuesFromProps$1(_, _e) {
        const {
            style: et
        } = _, tt = {};
        for (const nt in et)(isMotionValue(et[nt]) || _e.style && isMotionValue(_e.style[nt]) || isForcedMotionValue(nt, _)) && (tt[nt] = et[nt]);
        return tt
    }

    function scrapeMotionValuesFromProps(_, _e) {
        const et = scrapeMotionValuesFromProps$1(_, _e);
        for (const tt in _)
            if (isMotionValue(_[tt]) || isMotionValue(_e[tt])) {
                const nt = transformPropOrder.indexOf(tt) !== -1 ? "attr" + tt.charAt(0).toUpperCase() + tt.substring(1) : tt;
                et[nt] = _[tt]
            }
        return et
    }

    function resolveVariantFromProps(_, _e, et, tt = {}, nt = {}) {
        return typeof _e == "function" && (_e = _e(et !== void 0 ? et : _.custom, tt, nt)), typeof _e == "string" && (_e = _.variants && _.variants[_e]), typeof _e == "function" && (_e = _e(et !== void 0 ? et : _.custom, tt, nt)), _e
    }
    useConstant = function(_) {
        const _e = reactExports.useRef(null);
        return _e.current === null && (_e.current = _()), _e.current
    };
    const isKeyframesTarget = _ => Array.isArray(_),
        isCustomValue = _ => !!(_ && typeof _ == "object" && _.mix && _.toValue),
        resolveFinalValueInKeyframes = _ => isKeyframesTarget(_) ? _[_.length - 1] || 0 : _;
    resolveMotionValue = function(_) {
        const _e = isMotionValue(_) ? _.get() : _;
        return isCustomValue(_e) ? _e.toValue() : _e
    };

    function makeState({
        scrapeMotionValuesFromProps: _,
        createRenderState: _e,
        onMount: et
    }, tt, nt, ot) {
        const at = {
            latestValues: makeLatestValues(tt, nt, ot, _),
            renderState: _e()
        };
        return et && (at.mount = st => et(tt, st, at)), at
    }
    makeUseVisualState = _ => (_e, et) => {
        const tt = reactExports.useContext(MotionContext),
            nt = reactExports.useContext(PresenceContext),
            ot = () => makeState(_, _e, tt, nt);
        return et ? ot() : useConstant(ot)
    };

    function makeLatestValues(_, _e, et, tt) {
        const nt = {},
            ot = tt(_, {});
        for (const pt in ot) nt[pt] = resolveMotionValue(ot[pt]);
        let {
            initial: at,
            animate: st
        } = _;
        const lt = isControllingVariants(_),
            ut = isVariantNode(_);
        _e && ut && !lt && _.inherit !== !1 && (at === void 0 && (at = _e.initial), st === void 0 && (st = _e.animate));
        let dt = et ? et.initial === !1 : !1;
        dt = dt || at === !1;
        const ct = dt ? st : at;
        return ct && typeof ct != "boolean" && !isAnimationControls(ct) && (Array.isArray(ct) ? ct : [ct]).forEach(pt => {
            const ft = resolveVariantFromProps(_, pt);
            if (!ft) return;
            const gt = ft,
                {
                    transitionEnd: ht,
                    transition: mt
                } = gt,
                bt = Wt(gt, ["transitionEnd", "transition"]);
            for (const vt in bt) {
                let xt = bt[vt];
                if (Array.isArray(xt)) {
                    const yt = dt ? xt.length - 1 : 0;
                    xt = xt[yt]
                }
                xt !== null && (nt[vt] = xt)
            }
            for (const vt in ht) nt[vt] = ht[vt]
        }), nt
    }
    noop$4 = _ => _;

    function createRenderStep(_) {
        let _e = [],
            et = [],
            tt = 0,
            nt = !1,
            ot = !1;
        const at = new WeakSet,
            st = {
                schedule: (lt, ut = !1, dt = !1) => {
                    const ct = dt && nt,
                        pt = ct ? _e : et;
                    return ut && at.add(lt), pt.indexOf(lt) === -1 && (pt.push(lt), ct && nt && (tt = _e.length)), lt
                },
                cancel: lt => {
                    const ut = et.indexOf(lt);
                    ut !== -1 && et.splice(ut, 1), at.delete(lt)
                },
                process: lt => {
                    if (nt) {
                        ot = !0;
                        return
                    }
                    if (nt = !0, [_e, et] = [et, _e], et.length = 0, tt = _e.length, tt)
                        for (let ut = 0; ut < tt; ut++) {
                            const dt = _e[ut];
                            dt(lt), at.has(dt) && (st.schedule(dt), _())
                        }
                    nt = !1, ot && (ot = !1, st.process(lt))
                }
            };
        return st
    }
    let maxElapsed;
    stepsOrder = ["prepare", "read", "update", "preRender", "render", "postRender"], maxElapsed = 40;

    function createRenderBatcher(_, _e) {
        let et = !1,
            tt = !0;
        const nt = {
                delta: 0,
                timestamp: 0,
                isProcessing: !1
            },
            ot = stepsOrder.reduce((ut, dt) => (ut[dt] = createRenderStep(() => et = !0), ut), {}),
            at = ut => ot[ut].process(nt),
            st = () => {
                const ut = performance.now();
                et = !1, nt.delta = tt ? 1e3 / 60 : Math.max(Math.min(ut - nt.timestamp, maxElapsed), 1), nt.timestamp = ut, nt.isProcessing = !0, stepsOrder.forEach(at), nt.isProcessing = !1, et && _e && (tt = !1, _(st))
            },
            lt = () => {
                et = !0, tt = !0, nt.isProcessing || _(st)
            };
        return {
            schedule: stepsOrder.reduce((ut, dt) => {
                const ct = ot[dt];
                return ut[dt] = (pt, ft = !1, ht = !1) => (et || lt(), ct.schedule(pt, ft, ht)), ut
            }, {}),
            cancel: ut => stepsOrder.forEach(dt => ot[dt].cancel(ut)),
            state: nt,
            steps: ot
        }
    }
    let svgMotionConfig, htmlMotionConfig;
    ({
        schedule: frame,
        cancel: cancelFrame,
        state: frameData,
        steps
    } = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$4, !0)), svgMotionConfig = {
        useVisualState: makeUseVisualState({
            scrapeMotionValuesFromProps,
            createRenderState: createSvgRenderState,
            onMount: (_, _e, {
                renderState: et,
                latestValues: tt
            }) => {
                frame.read(() => {
                    try {
                        et.dimensions = typeof _e.getBBox == "function" ? _e.getBBox() : _e.getBoundingClientRect()
                    } catch (nt) {
                        et.dimensions = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    }
                }), frame.render(() => {
                    buildSVGAttrs(et, tt, {
                        enableHardwareAcceleration: !1
                    }, isSVGTag(_e.tagName), _.transformTemplate), renderSVG(_e, et)
                })
            }
        })
    }, htmlMotionConfig = {
        useVisualState: makeUseVisualState({
            scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
            createRenderState: createHtmlRenderState
        })
    }, createDomMotionConfig = function(_, {
        forwardMotionProps: _e = !1
    }, et, tt) {
        return Bt(kt({}, isSVGComponent(_) ? svgMotionConfig : htmlMotionConfig), {
            preloadedFeatures: et,
            useRender: createUseRender(_e),
            createVisualElement: tt,
            Component: _
        })
    }, addDomEvent = function(_, _e, et, tt = {
        passive: !0
    }) {
        return _.addEventListener(_e, et, tt), () => _.removeEventListener(_e, et)
    };
    const isPrimaryPointer = _ => _.pointerType === "mouse" ? typeof _.button != "number" || _.button <= 0 : _.isPrimary !== !1;

    function extractEventInfo(_, _e = "page") {
        return {
            point: {
                x: _[_e + "X"],
                y: _[_e + "Y"]
            }
        }
    }
    addPointerInfo = _ => _e => isPrimaryPointer(_e) && _(_e, extractEventInfo(_e)), addPointerEvent = function(_, _e, et, tt) {
        return addDomEvent(_, _e, addPointerInfo(et), tt)
    };
    let combineFunctions;
    combineFunctions = (_, _e) => et => _e(_(et)), pipe = (..._) => _.reduce(combineFunctions);

    function createLock(_) {
        let _e = null;
        return () => {
            const et = () => {
                _e = null
            };
            return _e === null ? (_e = _, et) : !1
        }
    }
    const globalHorizontalLock = createLock("dragHorizontal"),
        globalVerticalLock = createLock("dragVertical");

    function getGlobalLock(_) {
        let _e = !1;
        if (_ === "y") _e = globalVerticalLock();
        else if (_ === "x") _e = globalHorizontalLock();
        else {
            const et = globalHorizontalLock(),
                tt = globalVerticalLock();
            et && tt ? _e = () => {
                et(), tt()
            } : (et && et(), tt && tt())
        }
        return _e
    }
    isDragActive = function() {
        const _ = getGlobalLock(!0);
        return _ ? (_(), !1) : !0
    };
    class Feature {
        constructor(_e) {
            this.isMounted = !1, this.node = _e
        }
        update() {}
    }

    function addHoverEvent(_, _e) {
        const et = "pointer" + (_e ? "enter" : "leave"),
            tt = "onHover" + (_e ? "Start" : "End"),
            nt = (ot, at) => {
                if (ot.type === "touch" || isDragActive()) return;
                const st = _.getProps();
                _.animationState && st.whileHover && _.animationState.setActive("whileHover", _e), st[tt] && frame.update(() => st[tt](ot, at))
            };
        return addPointerEvent(_.current, et, nt, {
            passive: !_.getProps()[tt]
        })
    }
    class HoverGesture extends Feature {
        mount() {
            this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
        }
        unmount() {}
    }
    class FocusGesture extends Feature {
        constructor() {
            super(...arguments), this.isActive = !1
        }
        onFocus() {
            let _e = !1;
            try {
                _e = this.node.current.matches(":focus-visible")
            } catch (et) {
                _e = !0
            }!_e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
        }
        onBlur() {
            !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
        }
        mount() {
            this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()))
        }
        unmount() {}
    }
    const isNodeOrChild = (_, _e) => _e ? _ === _e ? !0 : isNodeOrChild(_, _e.parentElement) : !1;

    function fireSyntheticPointerEvent(_, _e) {
        if (!_e) return;
        const et = new PointerEvent("pointer" + _);
        _e(et, extractEventInfo(et))
    }
    class PressGesture extends Feature {
        constructor() {
            super(...arguments), this.removeStartListeners = noop$4, this.removeEndListeners = noop$4, this.removeAccessibleListeners = noop$4, this.startPointerPress = (_e, et) => {
                if (this.removeEndListeners(), this.isPressing) return;
                const tt = this.node.getProps(),
                    nt = addPointerEvent(window, "pointerup", (at, st) => {
                        if (!this.checkPressEnd()) return;
                        const {
                            onTap: lt,
                            onTapCancel: ut
                        } = this.node.getProps();
                        frame.update(() => {
                            isNodeOrChild(this.node.current, at.target) ? lt && lt(at, st) : ut && ut(at, st)
                        })
                    }, {
                        passive: !(tt.onTap || tt.onPointerUp)
                    }),
                    ot = addPointerEvent(window, "pointercancel", (at, st) => this.cancelPress(at, st), {
                        passive: !(tt.onTapCancel || tt.onPointerCancel)
                    });
                this.removeEndListeners = pipe(nt, ot), this.startPress(_e, et)
            }, this.startAccessiblePress = () => {
                const _e = ot => {
                        if (ot.key !== "Enter" || this.isPressing) return;
                        const at = st => {
                            st.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (lt, ut) => {
                                const {
                                    onTap: dt
                                } = this.node.getProps();
                                dt && frame.update(() => dt(lt, ut))
                            })
                        };
                        this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", at), fireSyntheticPointerEvent("down", (st, lt) => {
                            this.startPress(st, lt)
                        })
                    },
                    et = addDomEvent(this.node.current, "keydown", _e),
                    tt = () => {
                        this.isPressing && fireSyntheticPointerEvent("cancel", (ot, at) => this.cancelPress(ot, at))
                    },
                    nt = addDomEvent(this.node.current, "blur", tt);
                this.removeAccessibleListeners = pipe(et, nt)
            }
        }
        startPress(_e, et) {
            this.isPressing = !0;
            const {
                onTapStart: tt,
                whileTap: nt
            } = this.node.getProps();
            nt && this.node.animationState && this.node.animationState.setActive("whileTap", !0), tt && frame.update(() => tt(_e, et))
        }
        checkPressEnd() {
            return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive()
        }
        cancelPress(_e, et) {
            if (!this.checkPressEnd()) return;
            const {
                onTapCancel: tt
            } = this.node.getProps();
            tt && frame.update(() => tt(_e, et))
        }
        mount() {
            const _e = this.node.getProps(),
                et = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, {
                    passive: !(_e.onTapStart || _e.onPointerStart)
                }),
                tt = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
            this.removeStartListeners = pipe(et, tt)
        }
        unmount() {
            this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
        }
    }
    const observerCallbacks = new WeakMap,
        observers = new WeakMap,
        fireObserverCallback = _ => {
            const _e = observerCallbacks.get(_.target);
            _e && _e(_)
        },
        fireAllObserverCallbacks = _ => {
            _.forEach(fireObserverCallback)
        };

    function initIntersectionObserver(et) {
        var tt = et,
            {
                root: _
            } = tt,
            _e = Wt(tt, ["root"]);
        const nt = _ || document;
        observers.has(nt) || observers.set(nt, {});
        const ot = observers.get(nt),
            at = JSON.stringify(_e);
        return ot[at] || (ot[at] = new IntersectionObserver(fireAllObserverCallbacks, kt({
            root: _
        }, _e))), ot[at]
    }

    function observeIntersection(_, _e, et) {
        const tt = initIntersectionObserver(_e);
        return observerCallbacks.set(_, et), tt.observe(_), () => {
            observerCallbacks.delete(_), tt.unobserve(_)
        }
    }
    const thresholdNames = {
        some: 0,
        all: 1
    };
    class InViewFeature extends Feature {
        constructor() {
            super(...arguments), this.hasEnteredView = !1, this.isInView = !1
        }
        startObserver() {
            this.unmount();
            const {
                viewport: _e = {}
            } = this.node.getProps(), {
                root: et,
                margin: tt,
                amount: nt = "some",
                once: ot
            } = _e, at = {
                root: et ? et.current : void 0,
                rootMargin: tt,
                threshold: typeof nt == "number" ? nt : thresholdNames[nt]
            }, st = lt => {
                const {
                    isIntersecting: ut
                } = lt;
                if (this.isInView === ut || (this.isInView = ut, ot && !ut && this.hasEnteredView)) return;
                ut && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", ut);
                const {
                    onViewportEnter: dt,
                    onViewportLeave: ct
                } = this.node.getProps(), pt = ut ? dt : ct;
                pt && pt(lt)
            };
            return observeIntersection(this.node.current, at, st)
        }
        mount() {
            this.startObserver()
        }
        update() {
            if (typeof IntersectionObserver > "u") return;
            const {
                props: _e,
                prevProps: et
            } = this.node;
            ["amount", "margin", "root"].some(hasViewportOptionChanged(_e, et)) && this.startObserver()
        }
        unmount() {}
    }

    function hasViewportOptionChanged({
        viewport: _ = {}
    }, {
        viewport: _e = {}
    } = {}) {
        return et => _[et] !== _e[et]
    }
    gestureAnimations = {
        inView: {
            Feature: InViewFeature
        },
        tap: {
            Feature: PressGesture
        },
        focus: {
            Feature: FocusGesture
        },
        hover: {
            Feature: HoverGesture
        }
    };

    function shallowCompare(_, _e) {
        if (!Array.isArray(_e)) return !1;
        const et = _e.length;
        if (et !== _.length) return !1;
        for (let tt = 0; tt < et; tt++)
            if (_e[tt] !== _[tt]) return !1;
        return !0
    }

    function getCurrent(_) {
        const _e = {};
        return _.values.forEach((et, tt) => _e[tt] = et.get()), _e
    }

    function getVelocity$1(_) {
        const _e = {};
        return _.values.forEach((et, tt) => _e[tt] = et.getVelocity()), _e
    }

    function resolveVariant(_, _e, et) {
        const tt = _.getProps();
        return resolveVariantFromProps(tt, _e, et !== void 0 ? et : tt.custom, getCurrent(_), getVelocity$1(_))
    }
    optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId), warning$1 = noop$4, invariant$1 = noop$4;
    let isBezierDefinition;
    secondsToMilliseconds = _ => _ * 1e3, millisecondsToSeconds = _ => _ / 1e3, instantAnimationState = {
        current: !1
    }, isBezierDefinition = _ => Array.isArray(_) && typeof _[0] == "number";

    function isWaapiSupportedEasing(_) {
        return !!(!_ || typeof _ == "string" && supportedWaapiEasing[_] || isBezierDefinition(_) || Array.isArray(_) && _.every(isWaapiSupportedEasing))
    }
    const cubicBezierAsString = ([_, _e, et, tt]) => `cubic-bezier(${_}, ${_e}, ${et}, ${tt})`,
        supportedWaapiEasing = {
            linear: "linear",
            ease: "ease",
            easeIn: "ease-in",
            easeOut: "ease-out",
            easeInOut: "ease-in-out",
            circIn: cubicBezierAsString([0, .65, .55, 1]),
            circOut: cubicBezierAsString([.55, 0, 1, .45]),
            backIn: cubicBezierAsString([.31, .01, .66, -.59]),
            backOut: cubicBezierAsString([.33, 1.53, .69, .99])
        };

    function mapEasingToNativeEasing(_) {
        if (_) return isBezierDefinition(_) ? cubicBezierAsString(_) : Array.isArray(_) ? _.map(mapEasingToNativeEasing) : supportedWaapiEasing[_]
    }
    animateStyle = function(_, _e, et, {
        delay: tt = 0,
        duration: nt,
        repeat: ot = 0,
        repeatType: at = "loop",
        ease: st,
        times: lt
    } = {}) {
        const ut = {
            [_e]: et
        };
        lt && (ut.offset = lt);
        const dt = mapEasingToNativeEasing(st);
        return Array.isArray(dt) && (ut.easing = dt), _.animate(ut, {
            delay: tt,
            duration: nt,
            easing: Array.isArray(dt) ? "linear" : dt,
            fill: "both",
            iterations: ot + 1,
            direction: at === "reverse" ? "alternate" : "normal"
        })
    };

    function getFinalKeyframe(_, {
        repeat: _e,
        repeatType: et = "loop"
    }) {
        const tt = _e && et !== "loop" && _e % 2 === 1 ? 0 : _.length - 1;
        return _[tt]
    }
    const calcBezier = (_, _e, et) => (((1 - 3 * et + 3 * _e) * _ + (3 * et - 6 * _e)) * _ + 3 * _e) * _,
        subdivisionPrecision = 1e-7,
        subdivisionMaxIterations = 12;

    function binarySubdivide(_, _e, et, tt, nt) {
        let ot, at, st = 0;
        do at = _e + (et - _e) / 2, ot = calcBezier(at, tt, nt) - _, ot > 0 ? et = at : _e = at; while (Math.abs(ot) > subdivisionPrecision && ++st < subdivisionMaxIterations);
        return at
    }
    cubicBezier = function(_, _e, et, tt) {
        if (_ === _e && et === tt) return noop$4;
        const nt = ot => binarySubdivide(ot, 0, 1, _, et);
        return ot => ot === 0 || ot === 1 ? ot : calcBezier(nt(ot), _e, tt)
    };
    let easingLookup, isColorString, splitColor, clampRgbUnit, rgbUnit, rgba;
    easeIn = cubicBezier(.42, 0, 1, 1), easeOut = cubicBezier(0, 0, .58, 1), easeInOut = cubicBezier(.42, 0, .58, 1), isEasingArray = _ => Array.isArray(_) && typeof _[0] != "number", mirrorEasing = _ => _e => _e <= .5 ? _(2 * _e) / 2 : (2 - _(2 * (1 - _e))) / 2, reverseEasing = _ => _e => 1 - _(1 - _e), circIn = _ => 1 - Math.sin(Math.acos(_)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circOut), backOut = cubicBezier(.33, 1.53, .69, .99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn), anticipate = _ => (_ *= 2) < 1 ? .5 * backIn(_) : .5 * (2 - Math.pow(2, -10 * (_ - 1))), easingLookup = {
        linear: noop$4,
        easeIn,
        easeInOut,
        easeOut,
        circIn,
        circInOut,
        circOut,
        backIn,
        backInOut,
        backOut,
        anticipate
    }, easingDefinitionToFunction = _ => {
        if (Array.isArray(_)) {
            invariant$1(_.length === 4);
            const [_e, et, tt, nt] = _;
            return cubicBezier(_e, et, tt, nt)
        } else if (typeof _ == "string") return easingLookup[_];
        return _
    }, isColorString = (_, _e) => et => !!(isString(et) && singleColorRegex.test(et) && et.startsWith(_) || _e && Object.prototype.hasOwnProperty.call(et, _e)), splitColor = (_, _e, et) => tt => {
        if (!isString(tt)) return tt;
        const [nt, ot, at, st] = tt.match(floatRegex);
        return {
            [_]: parseFloat(nt),
            [_e]: parseFloat(ot),
            [et]: parseFloat(at),
            alpha: st !== void 0 ? parseFloat(st) : 1
        }
    }, clampRgbUnit = _ => clamp(0, 255, _), rgbUnit = Bt(kt({}, number), {
        transform: _ => Math.round(clampRgbUnit(_))
    }), rgba = {
        test: isColorString("rgb", "red"),
        parse: splitColor("red", "green", "blue"),
        transform: ({
            red: _,
            green: _e,
            blue: et,
            alpha: tt = 1
        }) => "rgba(" + rgbUnit.transform(_) + ", " + rgbUnit.transform(_e) + ", " + rgbUnit.transform(et) + ", " + sanitize(alpha.transform(tt)) + ")"
    };

    function parseHex(_) {
        let _e = "",
            et = "",
            tt = "",
            nt = "";
        return _.length > 5 ? (_e = _.substring(1, 3), et = _.substring(3, 5), tt = _.substring(5, 7), nt = _.substring(7, 9)) : (_e = _.substring(1, 2), et = _.substring(2, 3), tt = _.substring(3, 4), nt = _.substring(4, 5), _e += _e, et += et, tt += tt, nt += nt), {
            red: parseInt(_e, 16),
            green: parseInt(et, 16),
            blue: parseInt(tt, 16),
            alpha: nt ? parseInt(nt, 16) / 255 : 1
        }
    }
    let hex, hsla;
    hex = {
        test: isColorString("#"),
        parse: parseHex,
        transform: rgba.transform
    }, hsla = {
        test: isColorString("hsl", "hue"),
        parse: splitColor("hue", "saturation", "lightness"),
        transform: ({
            hue: _,
            saturation: _e,
            lightness: et,
            alpha: tt = 1
        }) => "hsla(" + Math.round(_) + ", " + percent.transform(sanitize(_e)) + ", " + percent.transform(sanitize(et)) + ", " + sanitize(alpha.transform(tt)) + ")"
    }, color = {
        test: _ => rgba.test(_) || hex.test(_) || hsla.test(_),
        parse: _ => rgba.test(_) ? rgba.parse(_) : hsla.test(_) ? hsla.parse(_) : hex.parse(_),
        transform: _ => isString(_) ? _ : _.hasOwnProperty("red") ? rgba.transform(_) : hsla.transform(_)
    }, mix = (_, _e, et) => -et * _ + et * _e + _;

    function hueToRgb(_, _e, et) {
        return et < 0 && (et += 1), et > 1 && (et -= 1), et < 1 / 6 ? _ + (_e - _) * 6 * et : et < 1 / 2 ? _e : et < 2 / 3 ? _ + (_e - _) * (2 / 3 - et) * 6 : _
    }

    function hslaToRgba({
        hue: _,
        saturation: _e,
        lightness: et,
        alpha: tt
    }) {
        _ /= 360, _e /= 100, et /= 100;
        let nt = 0,
            ot = 0,
            at = 0;
        if (!_e) nt = ot = at = et;
        else {
            const st = et < .5 ? et * (1 + _e) : et + _e - et * _e,
                lt = 2 * et - st;
            nt = hueToRgb(lt, st, _ + 1 / 3), ot = hueToRgb(lt, st, _), at = hueToRgb(lt, st, _ - 1 / 3)
        }
        return {
            red: Math.round(nt * 255),
            green: Math.round(ot * 255),
            blue: Math.round(at * 255),
            alpha: tt
        }
    }
    const mixLinearColor = (_, _e, et) => {
            const tt = _ * _;
            return Math.sqrt(Math.max(0, et * (_e * _e - tt) + tt))
        },
        colorTypes = [hex, rgba, hsla],
        getColorType = _ => colorTypes.find(_e => _e.test(_));

    function asRGBA(_) {
        const _e = getColorType(_);
        let et = _e.parse(_);
        return _e === hsla && (et = hslaToRgba(et)), et
    }
    const mixColor = (_, _e) => {
        const et = asRGBA(_),
            tt = asRGBA(_e),
            nt = kt({}, et);
        return ot => (nt.red = mixLinearColor(et.red, tt.red, ot), nt.green = mixLinearColor(et.green, tt.green, ot), nt.blue = mixLinearColor(et.blue, tt.blue, ot), nt.alpha = mix(et.alpha, tt.alpha, ot), rgba.transform(nt))
    };

    function test(_) {
        var _e, et;
        return isNaN(_) && isString(_) && (((_e = _.match(floatRegex)) === null || _e === void 0 ? void 0 : _e.length) || 0) + (((et = _.match(colorRegex)) === null || et === void 0 ? void 0 : et.length) || 0) > 0
    }
    const cssVarTokeniser = {
            regex: cssVariableRegex,
            countKey: "Vars",
            token: "${v}",
            parse: noop$4
        },
        colorTokeniser = {
            regex: colorRegex,
            countKey: "Colors",
            token: "${c}",
            parse: color.parse
        },
        numberTokeniser = {
            regex: floatRegex,
            countKey: "Numbers",
            token: "${n}",
            parse: number.parse
        };

    function tokenise(_, {
        regex: _e,
        countKey: et,
        token: tt,
        parse: nt
    }) {
        const ot = _.tokenised.match(_e);
        ot && (_["num" + et] = ot.length, _.tokenised = _.tokenised.replace(_e, tt), _.values.push(...ot.map(nt)))
    }

    function analyseComplexValue(_) {
        const _e = _.toString(),
            et = {
                value: _e,
                tokenised: _e,
                values: [],
                numVars: 0,
                numColors: 0,
                numNumbers: 0
            };
        return et.value.includes("var(--") && tokenise(et, cssVarTokeniser), tokenise(et, colorTokeniser), tokenise(et, numberTokeniser), et
    }

    function parseComplexValue(_) {
        return analyseComplexValue(_).values
    }

    function createTransformer(_) {
        const {
            values: _e,
            numColors: et,
            numVars: tt,
            tokenised: nt
        } = analyseComplexValue(_), ot = _e.length;
        return at => {
            let st = nt;
            for (let lt = 0; lt < ot; lt++) lt < tt ? st = st.replace(cssVarTokeniser.token, at[lt]) : lt < tt + et ? st = st.replace(colorTokeniser.token, color.transform(at[lt])) : st = st.replace(numberTokeniser.token, sanitize(at[lt]));
            return st
        }
    }
    const convertNumbersToZero = _ => typeof _ == "number" ? 0 : _;

    function getAnimatableNone$1(_) {
        const _e = parseComplexValue(_);
        return createTransformer(_)(_e.map(convertNumbersToZero))
    }
    let mixImmediate;
    complex = {
        test,
        parse: parseComplexValue,
        createTransformer,
        getAnimatableNone: getAnimatableNone$1
    }, mixImmediate = (_, _e) => et => `${et>0?_e:_}`;

    function getMixer(_, _e) {
        return typeof _ == "number" ? et => mix(_, _e, et) : color.test(_) ? mixColor(_, _e) : _.startsWith("var(") ? mixImmediate(_, _e) : mixComplex(_, _e)
    }
    let mixArray, mixObject, mixComplex, mixNumber;
    mixArray = (_, _e) => {
        const et = [..._],
            tt = et.length,
            nt = _.map((ot, at) => getMixer(ot, _e[at]));
        return ot => {
            for (let at = 0; at < tt; at++) et[at] = nt[at](ot);
            return et
        }
    }, mixObject = (_, _e) => {
        const et = kt(kt({}, _), _e),
            tt = {};
        for (const nt in et) _[nt] !== void 0 && _e[nt] !== void 0 && (tt[nt] = getMixer(_[nt], _e[nt]));
        return nt => {
            for (const ot in tt) et[ot] = tt[ot](nt);
            return et
        }
    }, mixComplex = (_, _e) => {
        const et = complex.createTransformer(_e),
            tt = analyseComplexValue(_),
            nt = analyseComplexValue(_e);
        return tt.numVars === nt.numVars && tt.numColors === nt.numColors && tt.numNumbers >= nt.numNumbers ? pipe(mixArray(tt.values, nt.values), et) : mixImmediate(_, _e)
    }, progress = (_, _e, et) => {
        const tt = _e - _;
        return tt === 0 ? 1 : (et - _) / tt
    }, mixNumber = (_, _e) => et => mix(_, _e, et);

    function detectMixerFactory(_) {
        return typeof _ == "number" ? mixNumber : typeof _ == "string" ? color.test(_) ? mixColor : mixComplex : Array.isArray(_) ? mixArray : typeof _ == "object" ? mixObject : mixNumber
    }

    function createMixers(_, _e, et) {
        const tt = [],
            nt = et || detectMixerFactory(_[0]),
            ot = _.length - 1;
        for (let at = 0; at < ot; at++) {
            let st = nt(_[at], _[at + 1]);
            if (_e) {
                const lt = Array.isArray(_e) ? _e[at] || noop$4 : _e;
                st = pipe(lt, st)
            }
            tt.push(st)
        }
        return tt
    }
    interpolate = function(_, _e, {
        clamp: et = !0,
        ease: tt,
        mixer: nt
    } = {}) {
        const ot = _.length;
        if (invariant$1(ot === _e.length), ot === 1) return () => _e[0];
        _[0] > _[ot - 1] && (_ = [..._].reverse(), _e = [..._e].reverse());
        const at = createMixers(_e, tt, nt),
            st = at.length,
            lt = ut => {
                let dt = 0;
                if (st > 1)
                    for (; dt < _.length - 2 && !(ut < _[dt + 1]); dt++);
                const ct = progress(_[dt], _[dt + 1], ut);
                return at[dt](ct)
            };
        return et ? ut => lt(clamp(_[0], _[ot - 1], ut)) : lt
    }, fillOffset = function(_, _e) {
        const et = _[_.length - 1];
        for (let tt = 1; tt <= _e; tt++) {
            const nt = progress(0, _e, tt);
            _.push(mix(et, 1, nt))
        }
    }, defaultOffset = function(_) {
        const _e = [0];
        return fillOffset(_e, _.length - 1), _e
    };

    function convertOffsetToTimes(_, _e) {
        return _.map(et => et * _e)
    }

    function defaultEasing(_, _e) {
        return _.map(() => _e || easeInOut).splice(0, _.length - 1)
    }

    function keyframes({
        duration: _ = 300,
        keyframes: _e,
        times: et,
        ease: tt = "easeInOut"
    }) {
        const nt = isEasingArray(tt) ? tt.map(easingDefinitionToFunction) : easingDefinitionToFunction(tt),
            ot = {
                done: !1,
                value: _e[0]
            },
            at = convertOffsetToTimes(et && et.length === _e.length ? et : defaultOffset(_e), _),
            st = interpolate(at, _e, {
                ease: Array.isArray(nt) ? nt : defaultEasing(_e, nt)
            });
        return {
            calculatedDuration: _,
            next: lt => (ot.value = st(lt), ot.done = lt >= _, ot)
        }
    }
    velocityPerSecond = function(_, _e) {
        return _e ? _ * (1e3 / _e) : 0
    };
    const velocitySampleDuration = 5;

    function calcGeneratorVelocity(_, _e, et) {
        const tt = Math.max(_e - velocitySampleDuration, 0);
        return velocityPerSecond(et - _(tt), _e - tt)
    }
    const safeMin = .001,
        minDuration = .01,
        maxDuration$1 = 10,
        minDamping = .05,
        maxDamping = 1;

    function findSpring({
        duration: _ = 800,
        bounce: _e = .25,
        velocity: et = 0,
        mass: tt = 1
    }) {
        let nt, ot;
        warning$1(_ <= secondsToMilliseconds(maxDuration$1));
        let at = 1 - _e;
        at = clamp(minDamping, maxDamping, at), _ = clamp(minDuration, maxDuration$1, millisecondsToSeconds(_)), at < 1 ? (nt = ut => {
            const dt = ut * at,
                ct = dt * _,
                pt = dt - et,
                ft = calcAngularFreq(ut, at),
                ht = Math.exp(-ct);
            return safeMin - pt / ft * ht
        }, ot = ut => {
            const dt = ut * at * _,
                ct = dt * et + et,
                pt = Math.pow(at, 2) * Math.pow(ut, 2) * _,
                ft = Math.exp(-dt),
                ht = calcAngularFreq(Math.pow(ut, 2), at);
            return (-nt(ut) + safeMin > 0 ? -1 : 1) * ((ct - pt) * ft) / ht
        }) : (nt = ut => {
            const dt = Math.exp(-ut * _),
                ct = (ut - et) * _ + 1;
            return -safeMin + dt * ct
        }, ot = ut => {
            const dt = Math.exp(-ut * _),
                ct = (et - ut) * (_ * _);
            return dt * ct
        });
        const st = 5 / _,
            lt = approximateRoot(nt, ot, st);
        if (_ = secondsToMilliseconds(_), isNaN(lt)) return {
            stiffness: 100,
            damping: 10,
            duration: _
        }; {
            const ut = Math.pow(lt, 2) * tt;
            return {
                stiffness: ut,
                damping: at * 2 * Math.sqrt(tt * ut),
                duration: _
            }
        }
    }
    const rootIterations = 12;

    function approximateRoot(_, _e, et) {
        let tt = et;
        for (let nt = 1; nt < rootIterations; nt++) tt = tt - _(tt) / _e(tt);
        return tt
    }

    function calcAngularFreq(_, _e) {
        return _ * Math.sqrt(1 - _e * _e)
    }
    const durationKeys = ["duration", "bounce"],
        physicsKeys = ["stiffness", "damping", "mass"];

    function isSpringType(_, _e) {
        return _e.some(et => _[et] !== void 0)
    }

    function getSpringOptions(_) {
        let _e = kt({
            velocity: 0,
            stiffness: 100,
            damping: 10,
            mass: 1,
            isResolvedFromDuration: !1
        }, _);
        if (!isSpringType(_, physicsKeys) && isSpringType(_, durationKeys)) {
            const et = findSpring(_);
            _e = Bt(kt(kt({}, _e), et), {
                velocity: 0,
                mass: 1
            }), _e.isResolvedFromDuration = !0
        }
        return _e
    }
    spring = function(nt) {
        var ot = nt,
            {
                keyframes: _,
                restDelta: _e,
                restSpeed: et
            } = ot,
            tt = Wt(ot, ["keyframes", "restDelta", "restSpeed"]);
        const at = _[0],
            st = _[_.length - 1],
            lt = {
                done: !1,
                value: at
            },
            {
                stiffness: ut,
                damping: dt,
                mass: ct,
                velocity: pt,
                duration: ft,
                isResolvedFromDuration: ht
            } = getSpringOptions(tt),
            mt = pt ? -millisecondsToSeconds(pt) : 0,
            bt = dt / (2 * Math.sqrt(ut * ct)),
            gt = st - at,
            vt = millisecondsToSeconds(Math.sqrt(ut / ct)),
            xt = Math.abs(gt) < 5;
        et || (et = xt ? .01 : 2), _e || (_e = xt ? .005 : .5);
        let yt;
        if (bt < 1) {
            const Et = calcAngularFreq(vt, bt);
            yt = wt => {
                const St = Math.exp(-bt * vt * wt);
                return st - St * ((mt + bt * vt * gt) / Et * Math.sin(Et * wt) + gt * Math.cos(Et * wt))
            }
        } else if (bt === 1) yt = Et => st - Math.exp(-vt * Et) * (gt + (mt + vt * gt) * Et);
        else {
            const Et = vt * Math.sqrt(bt * bt - 1);
            yt = wt => {
                const St = Math.exp(-bt * vt * wt),
                    $t = Math.min(Et * wt, 300);
                return st - St * ((mt + bt * vt * gt) * Math.sinh($t) + Et * gt * Math.cosh($t)) / Et
            }
        }
        return {
            calculatedDuration: ht && ft || null,
            next: Et => {
                const wt = yt(Et);
                if (ht) lt.done = Et >= ft;
                else {
                    let St = mt;
                    Et !== 0 && (bt < 1 ? St = calcGeneratorVelocity(yt, Et, wt) : St = 0);
                    const $t = Math.abs(St) <= et,
                        Ct = Math.abs(st - wt) <= _e;
                    lt.done = $t && Ct
                }
                return lt.value = lt.done ? st : wt, lt
            }
        }
    };

    function inertia({
        keyframes: _,
        velocity: _e = 0,
        power: et = .8,
        timeConstant: tt = 325,
        bounceDamping: nt = 10,
        bounceStiffness: ot = 500,
        modifyTarget: at,
        min: st,
        max: lt,
        restDelta: ut = .5,
        restSpeed: dt
    }) {
        const ct = _[0],
            pt = {
                done: !1,
                value: ct
            },
            ft = $t => st !== void 0 && $t < st || lt !== void 0 && $t > lt,
            ht = $t => st === void 0 ? lt : lt === void 0 || Math.abs(st - $t) < Math.abs(lt - $t) ? st : lt;
        let mt = et * _e;
        const bt = ct + mt,
            gt = at === void 0 ? bt : at(bt);
        gt !== bt && (mt = gt - ct);
        const vt = $t => -mt * Math.exp(-$t / tt),
            xt = $t => gt + vt($t),
            yt = $t => {
                const Ct = vt($t),
                    Rt = xt($t);
                pt.done = Math.abs(Ct) <= ut, pt.value = pt.done ? gt : Rt
            };
        let Et, wt;
        const St = $t => {
            ft(pt.value) && (Et = $t, wt = spring({
                keyframes: [pt.value, ht(pt.value)],
                velocity: calcGeneratorVelocity(xt, $t, pt.value),
                damping: nt,
                stiffness: ot,
                restDelta: ut,
                restSpeed: dt
            }))
        };
        return St(0), {
            calculatedDuration: null,
            next: $t => {
                let Ct = !1;
                return !wt && Et === void 0 && (Ct = !0, yt($t), St($t)), Et !== void 0 && $t > Et ? wt.next($t - Et) : (!Ct && yt($t), pt)
            }
        }
    }
    let frameloopDriver;
    frameloopDriver = _ => {
        const _e = ({
            timestamp: et
        }) => _(et);
        return {
            start: () => frame.update(_e, !0),
            stop: () => cancelFrame(_e),
            now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
        }
    }, maxGeneratorDuration = 2e4, calcGeneratorDuration = function(_) {
        let _e = 0;
        const et = 50;
        let tt = _.next(_e);
        for (; !tt.done && _e < maxGeneratorDuration;) _e += et, tt = _.next(_e);
        return _e >= maxGeneratorDuration ? 1 / 0 : _e
    };
    const types = {
        decay: inertia,
        inertia,
        tween: keyframes,
        keyframes,
        spring
    };
    animateValue = function(ft) {
        var ht = ft,
            {
                autoplay: _ = !0,
                delay: _e = 0,
                driver: et = frameloopDriver,
                keyframes: tt,
                type: nt = "keyframes",
                repeat: ot = 0,
                repeatDelay: at = 0,
                repeatType: st = "loop",
                onPlay: lt,
                onStop: ut,
                onComplete: dt,
                onUpdate: ct
            } = ht,
            pt = Wt(ht, ["autoplay", "delay", "driver", "keyframes", "type", "repeat", "repeatDelay", "repeatType", "onPlay", "onStop", "onComplete", "onUpdate"]);
        let mt = 1,
            bt = !1,
            gt, vt;
        const xt = () => {
            vt = new Promise(qt => {
                gt = qt
            })
        };
        xt();
        let yt;
        const Et = types[nt] || keyframes;
        let wt;
        Et !== keyframes && typeof tt[0] != "number" && (wt = interpolate([0, 100], tt, {
            clamp: !1
        }), tt = [0, 100]);
        const St = Et(Bt(kt({}, pt), {
            keyframes: tt
        }));
        let $t;
        st === "mirror" && ($t = Et(Bt(kt({}, pt), {
            keyframes: [...tt].reverse(),
            velocity: -(pt.velocity || 0)
        })));
        let Ct = "idle",
            Rt = null,
            Pt = null,
            Tt = null;
        St.calculatedDuration === null && ot && (St.calculatedDuration = calcGeneratorDuration(St));
        const {
            calculatedDuration: It
        } = St;
        let Ot = 1 / 0,
            Dt = 1 / 0;
        It !== null && (Ot = It + at, Dt = Ot * (ot + 1) - at);
        let jt = 0;
        const Ht = qt => {
                if (Pt === null) return;
                mt > 0 && (Pt = Math.min(Pt, qt)), mt < 0 && (Pt = Math.min(qt - Dt / mt, Pt)), Rt !== null ? jt = Rt : jt = Math.round(qt - Pt) * mt;
                const Kt = jt - _e * (mt >= 0 ? 1 : -1),
                    mr = mt >= 0 ? Kt < 0 : Kt > Dt;
                jt = Math.max(Kt, 0), Ct === "finished" && Rt === null && (jt = Dt);
                let pr = jt,
                    xr = St;
                if (ot) {
                    const Sr = jt / Ot;
                    let lr = Math.floor(Sr),
                        ur = Sr % 1;
                    !ur && Sr >= 1 && (ur = 1), ur === 1 && lr--, lr = Math.min(lr, ot + 1);
                    const Rr = !!(lr % 2);
                    Rr && (st === "reverse" ? (ur = 1 - ur, at && (ur -= at / Ot)) : st === "mirror" && (xr = $t));
                    let nr = clamp(0, 1, ur);
                    jt > Dt && (nr = st === "reverse" && Rr ? 1 : 0), pr = nr * Ot
                }
                const er = mr ? {
                    done: !1,
                    value: tt[0]
                } : xr.next(pr);
                wt && (er.value = wt(er.value));
                let {
                    done: wr
                } = er;
                !mr && It !== null && (wr = mt >= 0 ? jt >= Dt : jt <= 0);
                const kr = Rt === null && (Ct === "finished" || Ct === "running" && wr);
                return ct && ct(er.value), kr && Vt(), er
            },
            Mt = () => {
                yt && yt.stop(), yt = void 0
            },
            Ft = () => {
                Ct = "idle", Mt(), gt(), xt(), Pt = Tt = null
            },
            Vt = () => {
                Ct = "finished", dt && dt(), Mt(), gt()
            },
            Zt = () => {
                if (bt) return;
                yt || (yt = et(Ht));
                const qt = yt.now();
                lt && lt(), Rt !== null ? Pt = qt - Rt : (!Pt || Ct === "finished") && (Pt = qt), Ct === "finished" && xt(), Tt = Pt, Rt = null, Ct = "running", yt.start()
            };
        _ && Zt();
        const Jt = {
            then(qt, Kt) {
                return vt.then(qt, Kt)
            },
            get time() {
                return millisecondsToSeconds(jt)
            },
            set time(qt) {
                qt = secondsToMilliseconds(qt), jt = qt, Rt !== null || !yt || mt === 0 ? Rt = qt : Pt = yt.now() - qt / mt
            },
            get duration() {
                const qt = St.calculatedDuration === null ? calcGeneratorDuration(St) : St.calculatedDuration;
                return millisecondsToSeconds(qt)
            },
            get speed() {
                return mt
            },
            set speed(qt) {
                qt === mt || !yt || (mt = qt, Jt.time = millisecondsToSeconds(jt))
            },
            get state() {
                return Ct
            },
            play: Zt,
            pause: () => {
                Ct = "paused", Rt = jt
            },
            stop: () => {
                bt = !0, Ct !== "idle" && (Ct = "idle", ut && ut(), Ft())
            },
            cancel: () => {
                Tt !== null && Ht(Tt), Ft()
            },
            complete: () => {
                Ct = "finished"
            },
            sample: qt => (Pt = 0, Ht(qt))
        };
        return Jt
    }, memo = function(_) {
        let _e;
        return () => (_e === void 0 && (_e = _()), _e)
    };
    const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
        acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]),
        sampleDelta = 10,
        maxDuration = 2e4,
        requiresPregeneratedKeyframes = (_, _e) => _e.type === "spring" || _ === "backgroundColor" || !isWaapiSupportedEasing(_e.ease);

    function createAcceleratedAnimation(_, _e, ot) {
        var at = ot,
            {
                onUpdate: et,
                onComplete: tt
            } = at,
            nt = Wt(at, ["onUpdate", "onComplete"]);
        if (!(supportsWaapi() && acceleratedValues.has(_e) && !nt.repeatDelay && nt.repeatType !== "mirror" && nt.damping !== 0 && nt.type !== "inertia")) return !1;
        let st = !1,
            lt, ut;
        const dt = () => {
            ut = new Promise(vt => {
                lt = vt
            })
        };
        dt();
        let {
            keyframes: ct,
            duration: pt = 300,
            ease: ft,
            times: ht
        } = nt;
        if (requiresPregeneratedKeyframes(_e, nt)) {
            const vt = animateValue(Bt(kt({}, nt), {
                repeat: 0,
                delay: 0
            }));
            let xt = {
                done: !1,
                value: ct[0]
            };
            const yt = [];
            let Et = 0;
            for (; !xt.done && Et < maxDuration;) xt = vt.sample(Et), yt.push(xt.value), Et += sampleDelta;
            ht = void 0, ct = yt, pt = Et - sampleDelta, ft = "linear"
        }
        const mt = animateStyle(_.owner.current, _e, ct, Bt(kt({}, nt), {
                duration: pt,
                ease: ft,
                times: ht
            })),
            bt = () => mt.cancel(),
            gt = () => {
                frame.update(bt), lt(), dt()
            };
        return mt.onfinish = () => {
            _.set(getFinalKeyframe(ct, nt)), tt && tt(), gt()
        }, {
            then(vt, xt) {
                return ut.then(vt, xt)
            },
            attachTimeline(vt) {
                return mt.timeline = vt, mt.onfinish = null, noop$4
            },
            get time() {
                return millisecondsToSeconds(mt.currentTime || 0)
            },
            set time(vt) {
                mt.currentTime = secondsToMilliseconds(vt)
            },
            get speed() {
                return mt.playbackRate
            },
            set speed(vt) {
                mt.playbackRate = vt
            },
            get duration() {
                return millisecondsToSeconds(pt)
            },
            play: () => {
                st || (mt.play(), cancelFrame(bt))
            },
            pause: () => mt.pause(),
            stop: () => {
                if (st = !0, mt.playState === "idle") return;
                const {
                    currentTime: vt
                } = mt;
                if (vt) {
                    const xt = animateValue(Bt(kt({}, nt), {
                        autoplay: !1
                    }));
                    _.setWithVelocity(xt.sample(vt - sampleDelta).value, xt.sample(vt).value, sampleDelta)
                }
                gt()
            },
            complete: () => mt.finish(),
            cancel: gt
        }
    }

    function createInstantAnimation({
        keyframes: _,
        delay: _e,
        onUpdate: et,
        onComplete: tt
    }) {
        const nt = () => (et && et(_[_.length - 1]), tt && tt(), {
            time: 0,
            speed: 1,
            duration: 0,
            play: noop$4,
            pause: noop$4,
            stop: noop$4,
            then: ot => (ot(), Promise.resolve()),
            cancel: noop$4,
            complete: noop$4
        });
        return _e ? animateValue({
            keyframes: [0, 1],
            duration: 0,
            delay: _e,
            onComplete: nt
        }) : nt()
    }
    const underDampedSpring = {
            type: "spring",
            stiffness: 500,
            damping: 25,
            restSpeed: 10
        },
        criticallyDampedSpring = _ => ({
            type: "spring",
            stiffness: 550,
            damping: _ === 0 ? 2 * Math.sqrt(550) : 30,
            restSpeed: 10
        }),
        keyframesTransition = {
            type: "keyframes",
            duration: .8
        },
        ease = {
            type: "keyframes",
            ease: [.25, .1, .35, 1],
            duration: .3
        },
        getDefaultTransition = (_, {
            keyframes: _e
        }) => _e.length > 2 ? keyframesTransition : transformProps.has(_) ? _.startsWith("scale") ? criticallyDampedSpring(_e[1]) : underDampedSpring : ease,
        isAnimatable = (_, _e) => _ === "zIndex" ? !1 : !!(typeof _e == "number" || Array.isArray(_e) || typeof _e == "string" && (complex.test(_e) || _e === "0") && !_e.startsWith("url(")),
        maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);

    function applyDefaultFilter(_) {
        const [_e, et] = _.slice(0, -1).split("(");
        if (_e === "drop-shadow") return _;
        const [tt] = et.match(floatRegex) || [];
        if (!tt) return _;
        const nt = et.replace(tt, "");
        let ot = maxDefaults.has(_e) ? 1 : 0;
        return tt !== et && (ot *= 100), _e + "(" + ot + nt + ")"
    }
    const functionRegex = /([a-z-]*)\(.*?\)/g,
        filter = Bt(kt({}, complex), {
            getAnimatableNone: _ => {
                const _e = _.match(functionRegex);
                return _e ? _e.map(applyDefaultFilter).join(" ") : _
            }
        }),
        defaultValueTypes = Bt(kt({}, numberValueTypes), {
            color,
            backgroundColor: color,
            outlineColor: color,
            fill: color,
            stroke: color,
            borderColor: color,
            borderTopColor: color,
            borderRightColor: color,
            borderBottomColor: color,
            borderLeftColor: color,
            filter,
            WebkitFilter: filter
        }),
        getDefaultValueType = _ => defaultValueTypes[_];

    function getAnimatableNone(_, _e) {
        let et = getDefaultValueType(_);
        return et !== filter && (et = complex), et.getAnimatableNone ? et.getAnimatableNone(_e) : void 0
    }
    const isZeroValueString = _ => /^0[^.\s]+$/.test(_);

    function isNone(_) {
        if (typeof _ == "number") return _ === 0;
        if (_ !== null) return _ === "none" || _ === "0" || isZeroValueString(_)
    }

    function getKeyframes(_, _e, et, tt) {
        const nt = isAnimatable(_e, et);
        let ot;
        Array.isArray(et) ? ot = [...et] : ot = [null, et];
        const at = tt.from !== void 0 ? tt.from : _.get();
        let st;
        const lt = [];
        for (let ut = 0; ut < ot.length; ut++) ot[ut] === null && (ot[ut] = ut === 0 ? at : ot[ut - 1]), isNone(ot[ut]) && lt.push(ut), typeof ot[ut] == "string" && ot[ut] !== "none" && ot[ut] !== "0" && (st = ot[ut]);
        if (nt && lt.length && st)
            for (let ut = 0; ut < lt.length; ut++) {
                const dt = lt[ut];
                ot[dt] = getAnimatableNone(_e, st)
            }
        return ot
    }

    function isTransitionDefined(ct) {
        var pt = ct,
            {
                when: _,
                delay: _e,
                delayChildren: et,
                staggerChildren: tt,
                staggerDirection: nt,
                repeat: ot,
                repeatType: at,
                repeatDelay: st,
                from: lt,
                elapsed: ut
            } = pt,
            dt = Wt(pt, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from", "elapsed"]);
        return !!Object.keys(dt).length
    }

    function getValueTransition(_, _e) {
        return _[_e] || _.default || _
    }
    const animateMotionValue = (_, _e, et, tt = {}) => nt => {
        const ot = getValueTransition(tt, _) || {},
            at = ot.delay || tt.delay || 0;
        let {
            elapsed: st = 0
        } = tt;
        st = st - secondsToMilliseconds(at);
        const lt = getKeyframes(_e, _, et, ot),
            ut = lt[0],
            dt = lt[lt.length - 1],
            ct = isAnimatable(_, ut),
            pt = isAnimatable(_, dt);
        let ft = Bt(kt({
            keyframes: lt,
            velocity: _e.getVelocity(),
            ease: "easeOut"
        }, ot), {
            delay: -st,
            onUpdate: ht => {
                _e.set(ht), ot.onUpdate && ot.onUpdate(ht)
            },
            onComplete: () => {
                nt(), ot.onComplete && ot.onComplete()
            }
        });
        if (isTransitionDefined(ot) || (ft = kt(kt({}, ft), getDefaultTransition(_, ft))), ft.duration && (ft.duration = secondsToMilliseconds(ft.duration)), ft.repeatDelay && (ft.repeatDelay = secondsToMilliseconds(ft.repeatDelay)), !ct || !pt || instantAnimationState.current || ot.type === !1) return createInstantAnimation(instantAnimationState.current ? Bt(kt({}, ft), {
            delay: 0
        }) : ft);
        if (_e.owner && _e.owner.current instanceof HTMLElement && !_e.owner.getProps().onUpdate) {
            const ht = createAcceleratedAnimation(_e, _, ft);
            if (ht) return ht
        }
        return animateValue(ft)
    };

    function isWillChangeMotionValue(_) {
        return !!(isMotionValue(_) && _.add)
    }
    const isNumericalString = _ => /^\-?\d*\.?\d+$/.test(_);
    addUniqueItem = function(_, _e) {
        _.indexOf(_e) === -1 && _.push(_e)
    }, removeItem = function(_, _e) {
        const et = _.indexOf(_e);
        et > -1 && _.splice(et, 1)
    }, moveItem = function([..._], _e, et) {
        const tt = _e < 0 ? _.length + _e : _e;
        if (tt >= 0 && tt < _.length) {
            const nt = et < 0 ? _.length + et : et,
                [ot] = _.splice(_e, 1);
            _.splice(nt, 0, ot)
        }
        return _
    };
    class SubscriptionManager {
        constructor() {
            this.subscriptions = []
        }
        add(_e) {
            return addUniqueItem(this.subscriptions, _e), () => removeItem(this.subscriptions, _e)
        }
        notify(_e, et, tt) {
            const nt = this.subscriptions.length;
            if (nt)
                if (nt === 1) this.subscriptions[0](_e, et, tt);
                else
                    for (let ot = 0; ot < nt; ot++) {
                        const at = this.subscriptions[ot];
                        at && at(_e, et, tt)
                    }
        }
        getSize() {
            return this.subscriptions.length
        }
        clear() {
            this.subscriptions.length = 0
        }
    }
    let isFloat;
    isFloat = _ => !isNaN(parseFloat(_)), collectMotionValues = {
        current: void 0
    }, MotionValue = class {
        constructor(_, _e = {}) {
            this.version = "10.16.1", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (et, tt = !0) => {
                this.prev = this.current, this.current = et;
                const {
                    delta: nt,
                    timestamp: ot
                } = frameData;
                this.lastUpdated !== ot && (this.timeDelta = nt, this.lastUpdated = ot, frame.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), tt && this.events.renderRequest && this.events.renderRequest.notify(this.current)
            }, this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck), this.velocityCheck = ({
                timestamp: et
            }) => {
                et !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
            }, this.hasAnimated = !1, this.prev = this.current = _, this.canTrackVelocity = isFloat(this.current), this.owner = _e.owner
        }
        onChange(_) {
            return this.on("change", _)
        }
        on(_, _e) {
            this.events[_] || (this.events[_] = new SubscriptionManager);
            const et = this.events[_].add(_e);
            return _ === "change" ? () => {
                et(), frame.read(() => {
                    this.events.change.getSize() || this.stop()
                })
            } : et
        }
        clearListeners() {
            for (const _ in this.events) this.events[_].clear()
        }
        attach(_, _e) {
            this.passiveEffect = _, this.stopPassiveEffect = _e
        }
        set(_, _e = !0) {
            !_e || !this.passiveEffect ? this.updateAndNotify(_, _e) : this.passiveEffect(_, this.updateAndNotify)
        }
        setWithVelocity(_, _e, et) {
            this.set(_e), this.prev = _, this.timeDelta = et
        }
        jump(_) {
            this.updateAndNotify(_), this.prev = _, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
        }
        get() {
            return collectMotionValues.current && collectMotionValues.current.push(this), this.current
        }
        getPrevious() {
            return this.prev
        }
        getVelocity() {
            return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
        }
        start(_) {
            return this.stop(), new Promise(_e => {
                this.hasAnimated = !0, this.animation = _(_e), this.events.animationStart && this.events.animationStart.notify()
            }).then(() => {
                this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
            })
        }
        stop() {
            this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
        }
        isAnimating() {
            return !!this.animation
        }
        clearAnimation() {
            delete this.animation
        }
        destroy() {
            this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
        }
    }, motionValue = function(_, _e) {
        return new MotionValue(_, _e)
    };
    const testValueType = _ => _e => _e.test(_),
        auto = {
            test: _ => _ === "auto",
            parse: _ => _
        },
        dimensionValueTypes = [number, px, percent, degrees, vw, vh$1, auto],
        findDimensionValueType = _ => dimensionValueTypes.find(testValueType(_)),
        valueTypes = [...dimensionValueTypes, color, complex],
        findValueType = _ => valueTypes.find(testValueType(_));

    function setMotionValue(_, _e, et) {
        _.hasValue(_e) ? _.getValue(_e).set(et) : _.addValue(_e, motionValue(et))
    }

    function setTarget(_, _e) {
        const et = resolveVariant(_, _e);
        let at = et ? _.makeTargetAnimatable(et, !1) : {},
            {
                transitionEnd: tt = {},
                transition: nt = {}
            } = at,
            ot = Wt(at, ["transitionEnd", "transition"]);
        ot = kt(kt({}, ot), tt);
        for (const st in ot) {
            const lt = resolveFinalValueInKeyframes(ot[st]);
            setMotionValue(_, st, lt)
        }
    }

    function setVariants(_, _e) {
        [..._e].reverse().forEach(et => {
            const tt = _.getVariant(et);
            tt && setTarget(_, tt), _.variantChildren && _.variantChildren.forEach(nt => {
                setVariants(nt, _e)
            })
        })
    }

    function setValues(_, _e) {
        if (Array.isArray(_e)) return setVariants(_, _e);
        if (typeof _e == "string") return setVariants(_, [_e]);
        setTarget(_, _e)
    }
    checkTargetForNewValues = function(_, _e, et) {
        var tt, nt;
        const ot = Object.keys(_e).filter(st => !_.hasValue(st)),
            at = ot.length;
        if (at)
            for (let st = 0; st < at; st++) {
                const lt = ot[st],
                    ut = _e[lt];
                let dt = null;
                Array.isArray(ut) && (dt = ut[0]), dt === null && (dt = (nt = (tt = et[lt]) !== null && tt !== void 0 ? tt : _.readValue(lt)) !== null && nt !== void 0 ? nt : _e[lt]), dt != null && (typeof dt == "string" && (isNumericalString(dt) || isZeroValueString(dt)) ? dt = parseFloat(dt) : !findValueType(dt) && complex.test(ut) && (dt = getAnimatableNone(lt, ut)), _.addValue(lt, motionValue(dt, {
                    owner: _
                })), et[lt] === void 0 && (et[lt] = dt), dt !== null && _.setBaseTarget(lt, dt))
            }
    };

    function getOriginFromTransition(_, _e) {
        return _e ? (_e[_] || _e.default || _e).from : void 0
    }
    getOrigin = function(_, _e, et) {
        const tt = {};
        for (const nt in _) {
            const ot = getOriginFromTransition(nt, _e);
            if (ot !== void 0) tt[nt] = ot;
            else {
                const at = et.getValue(nt);
                at && (tt[nt] = at.get())
            }
        }
        return tt
    };

    function shouldBlockAnimation({
        protectedKeys: _,
        needsAnimating: _e
    }, et) {
        const tt = _.hasOwnProperty(et) && _e[et] !== !0;
        return _e[et] = !1, tt
    }
    animateTarget = function(_, _e, {
        delay: et = 0,
        transitionOverride: tt,
        type: nt
    } = {}) {
        let ct = _.makeTargetAnimatable(_e),
            {
                transition: ot = _.getDefaultTransition(),
                transitionEnd: at
            } = ct,
            st = Wt(ct, ["transition", "transitionEnd"]);
        const lt = _.getValue("willChange");
        tt && (ot = tt);
        const ut = [],
            dt = nt && _.animationState && _.animationState.getState()[nt];
        for (const pt in st) {
            const ft = _.getValue(pt),
                ht = st[pt];
            if (!ft || ht === void 0 || dt && shouldBlockAnimation(dt, pt)) continue;
            const mt = kt({
                delay: et,
                elapsed: 0
            }, ot);
            if (window.HandoffAppearAnimations && !ft.hasAnimated) {
                const gt = _.getProps()[optimizedAppearDataAttribute];
                gt && (mt.elapsed = window.HandoffAppearAnimations(gt, pt, ft, frame))
            }
            ft.start(animateMotionValue(pt, ft, ht, _.shouldReduceMotion && transformProps.has(pt) ? {
                type: !1
            } : mt));
            const bt = ft.animation;
            isWillChangeMotionValue(lt) && (lt.add(pt), bt.then(() => lt.remove(pt))), ut.push(bt)
        }
        return at && Promise.all(ut).then(() => {
            at && setTarget(_, at)
        }), ut
    };

    function animateVariant(_, _e, et = {}) {
        const tt = resolveVariant(_, _e, et.custom);
        let {
            transition: nt = _.getDefaultTransition() || {}
        } = tt || {};
        et.transitionOverride && (nt = et.transitionOverride);
        const ot = tt ? () => Promise.all(animateTarget(_, tt, et)) : () => Promise.resolve(),
            at = _.variantChildren && _.variantChildren.size ? (lt = 0) => {
                const {
                    delayChildren: ut = 0,
                    staggerChildren: dt,
                    staggerDirection: ct
                } = nt;
                return animateChildren(_, _e, ut + lt, dt, ct, et)
            } : () => Promise.resolve(),
            {
                when: st
            } = nt;
        if (st) {
            const [lt, ut] = st === "beforeChildren" ? [ot, at] : [at, ot];
            return lt().then(() => ut())
        } else return Promise.all([ot(), at(et.delay)])
    }

    function animateChildren(_, _e, et = 0, tt = 0, nt = 1, ot) {
        const at = [],
            st = (_.variantChildren.size - 1) * tt,
            lt = nt === 1 ? (ut = 0) => ut * tt : (ut = 0) => st - ut * tt;
        return Array.from(_.variantChildren).sort(sortByTreeOrder).forEach((ut, dt) => {
            ut.notify("AnimationStart", _e), at.push(animateVariant(ut, _e, Bt(kt({}, ot), {
                delay: et + lt(dt)
            })).then(() => ut.notify("AnimationComplete", _e)))
        }), Promise.all(at)
    }

    function sortByTreeOrder(_, _e) {
        return _.sortNodePosition(_e)
    }
    animateVisualElement = function(_, _e, et = {}) {
        _.notify("AnimationStart", _e);
        let tt;
        if (Array.isArray(_e)) {
            const nt = _e.map(ot => animateVariant(_, ot, et));
            tt = Promise.all(nt)
        } else if (typeof _e == "string") tt = animateVariant(_, _e, et);
        else {
            const nt = typeof _e == "function" ? resolveVariant(_, _e, et.custom) : _e;
            tt = Promise.all(animateTarget(_, nt, et))
        }
        return tt.then(() => _.notify("AnimationComplete", _e))
    };
    const reversePriorityOrder = [...variantPriorityOrder].reverse(),
        numAnimationTypes = variantPriorityOrder.length;

    function animateList(_) {
        return _e => Promise.all(_e.map(({
            animation: et,
            options: tt
        }) => animateVisualElement(_, et, tt)))
    }

    function createAnimationState(_) {
        let _e = animateList(_);
        const et = createState();
        let tt = !0;
        const nt = (lt, ut) => {
            const dt = resolveVariant(_, ut);
            if (dt) {
                const ct = dt,
                    {
                        transition: pt,
                        transitionEnd: ft
                    } = ct,
                    ht = Wt(ct, ["transition", "transitionEnd"]);
                lt = kt(kt(kt({}, lt), ht), ft)
            }
            return lt
        };

        function ot(lt) {
            _e = lt(_)
        }

        function at(lt, ut) {
            const dt = _.getProps(),
                ct = _.getVariantContext(!0) || {},
                pt = [],
                ft = new Set;
            let ht = {},
                mt = 1 / 0;
            for (let gt = 0; gt < numAnimationTypes; gt++) {
                const vt = reversePriorityOrder[gt],
                    xt = et[vt],
                    yt = dt[vt] !== void 0 ? dt[vt] : ct[vt],
                    Et = isVariantLabel(yt),
                    wt = vt === ut ? xt.isActive : null;
                wt === !1 && (mt = gt);
                let St = yt === ct[vt] && yt !== dt[vt] && Et;
                if (St && tt && _.manuallyAnimateOnMount && (St = !1), xt.protectedKeys = kt({}, ht), !xt.isActive && wt === null || !yt && !xt.prevProp || isAnimationControls(yt) || typeof yt == "boolean") continue;
                const $t = checkVariantsDidChange(xt.prevProp, yt);
                let Ct = $t || vt === ut && xt.isActive && !St && Et || gt > mt && Et;
                const Rt = Array.isArray(yt) ? yt : [yt];
                let Pt = Rt.reduce(nt, {});
                wt === !1 && (Pt = {});
                const {
                    prevResolvedValues: Tt = {}
                } = xt, It = kt(kt({}, Tt), Pt), Ot = Dt => {
                    Ct = !0, ft.delete(Dt), xt.needsAnimating[Dt] = !0
                };
                for (const Dt in It) {
                    const jt = Pt[Dt],
                        Ht = Tt[Dt];
                    ht.hasOwnProperty(Dt) || (jt !== Ht ? isKeyframesTarget(jt) && isKeyframesTarget(Ht) ? !shallowCompare(jt, Ht) || $t ? Ot(Dt) : xt.protectedKeys[Dt] = !0 : jt !== void 0 ? Ot(Dt) : ft.add(Dt) : jt !== void 0 && ft.has(Dt) ? Ot(Dt) : xt.protectedKeys[Dt] = !0)
                }
                xt.prevProp = yt, xt.prevResolvedValues = Pt, xt.isActive && (ht = kt(kt({}, ht), Pt)), tt && _.blockInitialAnimation && (Ct = !1), Ct && !St && pt.push(...Rt.map(Dt => ({
                    animation: Dt,
                    options: kt({
                        type: vt
                    }, lt)
                })))
            }
            if (ft.size) {
                const gt = {};
                ft.forEach(vt => {
                    const xt = _.getBaseTarget(vt);
                    xt !== void 0 && (gt[vt] = xt)
                }), pt.push({
                    animation: gt
                })
            }
            let bt = !!pt.length;
            return tt && dt.initial === !1 && !_.manuallyAnimateOnMount && (bt = !1), tt = !1, bt ? _e(pt) : Promise.resolve()
        }

        function st(lt, ut, dt) {
            var ct;
            if (et[lt].isActive === ut) return Promise.resolve();
            (ct = _.variantChildren) === null || ct === void 0 || ct.forEach(ft => {
                var ht;
                return (ht = ft.animationState) === null || ht === void 0 ? void 0 : ht.setActive(lt, ut)
            }), et[lt].isActive = ut;
            const pt = at(dt, lt);
            for (const ft in et) et[ft].protectedKeys = {};
            return pt
        }
        return {
            animateChanges: at,
            setActive: st,
            setAnimateFunction: ot,
            getState: () => et
        }
    }

    function checkVariantsDidChange(_, _e) {
        return typeof _e == "string" ? _e !== _ : Array.isArray(_e) ? !shallowCompare(_e, _) : !1
    }

    function createTypeState(_ = !1) {
        return {
            isActive: _,
            protectedKeys: {},
            needsAnimating: {},
            prevResolvedValues: {}
        }
    }

    function createState() {
        return {
            animate: createTypeState(!0),
            whileInView: createTypeState(),
            whileHover: createTypeState(),
            whileTap: createTypeState(),
            whileDrag: createTypeState(),
            whileFocus: createTypeState(),
            exit: createTypeState()
        }
    }
    class AnimationFeature extends Feature {
        constructor(_e) {
            super(_e), _e.animationState || (_e.animationState = createAnimationState(_e))
        }
        updateAnimationControlsSubscription() {
            const {
                animate: _e
            } = this.node.getProps();
            this.unmount(), isAnimationControls(_e) && (this.unmount = _e.subscribe(this.node))
        }
        mount() {
            this.updateAnimationControlsSubscription()
        }
        update() {
            const {
                animate: _e
            } = this.node.getProps(), {
                animate: et
            } = this.node.prevProps || {};
            _e !== et && this.updateAnimationControlsSubscription()
        }
        unmount() {}
    }
    let id$2 = 0;
    class ExitAnimationFeature extends Feature {
        constructor() {
            super(...arguments), this.id = id$2++
        }
        update() {
            if (!this.node.presenceContext) return;
            const {
                isPresent: _e,
                onExitComplete: et,
                custom: tt
            } = this.node.presenceContext, {
                isPresent: nt
            } = this.node.prevPresenceContext || {};
            if (!this.node.animationState || _e === nt) return;
            const ot = this.node.animationState.setActive("exit", !_e, {
                custom: tt != null ? tt : this.node.getProps().custom
            });
            et && !_e && ot.then(() => et(this.id))
        }
        mount() {
            const {
                register: _e
            } = this.node.presenceContext || {};
            _e && (this.unmount = _e(this.id))
        }
        unmount() {}
    }
    animations = {
        animation: {
            Feature: AnimationFeature
        },
        exit: {
            Feature: ExitAnimationFeature
        }
    }, distance = (_, _e) => Math.abs(_ - _e), distance2D = function(_, _e) {
        const et = distance(_.x, _e.x),
            tt = distance(_.y, _e.y);
        return Math.sqrt(et ** 2 + tt ** 2)
    };
    class PanSession {
        constructor(_e, et, {
            transformPagePoint: tt
        } = {}) {
            if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
                    if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                    const ut = getPanInfo(this.lastMoveEventInfo, this.history),
                        dt = this.startEvent !== null,
                        ct = distance2D(ut.offset, {
                            x: 0,
                            y: 0
                        }) >= 3;
                    if (!dt && !ct) return;
                    const {
                        point: pt
                    } = ut, {
                        timestamp: ft
                    } = frameData;
                    this.history.push(Bt(kt({}, pt), {
                        timestamp: ft
                    }));
                    const {
                        onStart: ht,
                        onMove: mt
                    } = this.handlers;
                    dt || (ht && ht(this.lastMoveEvent, ut), this.startEvent = this.lastMoveEvent), mt && mt(this.lastMoveEvent, ut)
                }, this.handlePointerMove = (ut, dt) => {
                    this.lastMoveEvent = ut, this.lastMoveEventInfo = transformPoint(dt, this.transformPagePoint), frame.update(this.updatePoint, !0)
                }, this.handlePointerUp = (ut, dt) => {
                    if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                    const {
                        onEnd: ct,
                        onSessionEnd: pt
                    } = this.handlers, ft = getPanInfo(ut.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(dt, this.transformPagePoint), this.history);
                    this.startEvent && ct && ct(ut, ft), pt && pt(ut, ft)
                }, !isPrimaryPointer(_e)) return;
            this.handlers = et, this.transformPagePoint = tt;
            const nt = extractEventInfo(_e),
                ot = transformPoint(nt, this.transformPagePoint),
                {
                    point: at
                } = ot,
                {
                    timestamp: st
                } = frameData;
            this.history = [Bt(kt({}, at), {
                timestamp: st
            })];
            const {
                onSessionStart: lt
            } = et;
            lt && lt(_e, getPanInfo(ot, this.history)), this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp))
        }
        updateHandlers(_e) {
            this.handlers = _e
        }
        end() {
            this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint)
        }
    }

    function transformPoint(_, _e) {
        return _e ? {
            point: _e(_.point)
        } : _
    }

    function subtractPoint(_, _e) {
        return {
            x: _.x - _e.x,
            y: _.y - _e.y
        }
    }

    function getPanInfo({
        point: _
    }, _e) {
        return {
            point: _,
            delta: subtractPoint(_, lastDevicePoint(_e)),
            offset: subtractPoint(_, startDevicePoint(_e)),
            velocity: getVelocity(_e, .1)
        }
    }

    function startDevicePoint(_) {
        return _[0]
    }

    function lastDevicePoint(_) {
        return _[_.length - 1]
    }

    function getVelocity(_, _e) {
        if (_.length < 2) return {
            x: 0,
            y: 0
        };
        let et = _.length - 1,
            tt = null;
        const nt = lastDevicePoint(_);
        for (; et >= 0 && (tt = _[et], !(nt.timestamp - tt.timestamp > secondsToMilliseconds(_e)));) et--;
        if (!tt) return {
            x: 0,
            y: 0
        };
        const ot = millisecondsToSeconds(nt.timestamp - tt.timestamp);
        if (ot === 0) return {
            x: 0,
            y: 0
        };
        const at = {
            x: (nt.x - tt.x) / ot,
            y: (nt.y - tt.y) / ot
        };
        return at.x === 1 / 0 && (at.x = 0), at.y === 1 / 0 && (at.y = 0), at
    }
    calcLength = function(_) {
        return _.max - _.min
    };

    function isNear(_, _e = 0, et = .01) {
        return Math.abs(_ - _e) <= et
    }

    function calcAxisDelta(_, _e, et, tt = .5) {
        _.origin = tt, _.originPoint = mix(_e.min, _e.max, _.origin), _.scale = calcLength(et) / calcLength(_e), (isNear(_.scale, 1, 1e-4) || isNaN(_.scale)) && (_.scale = 1), _.translate = mix(et.min, et.max, _.origin) - _.originPoint, (isNear(_.translate) || isNaN(_.translate)) && (_.translate = 0)
    }

    function calcBoxDelta(_, _e, et, tt) {
        calcAxisDelta(_.x, _e.x, et.x, tt ? tt.originX : void 0), calcAxisDelta(_.y, _e.y, et.y, tt ? tt.originY : void 0)
    }

    function calcRelativeAxis(_, _e, et) {
        _.min = et.min + _e.min, _.max = _.min + calcLength(_e)
    }

    function calcRelativeBox(_, _e, et) {
        calcRelativeAxis(_.x, _e.x, et.x), calcRelativeAxis(_.y, _e.y, et.y)
    }

    function calcRelativeAxisPosition(_, _e, et) {
        _.min = _e.min - et.min, _.max = _.min + calcLength(_e)
    }

    function calcRelativePosition(_, _e, et) {
        calcRelativeAxisPosition(_.x, _e.x, et.x), calcRelativeAxisPosition(_.y, _e.y, et.y)
    }

    function applyConstraints(_, {
        min: _e,
        max: et
    }, tt) {
        return _e !== void 0 && _ < _e ? _ = tt ? mix(_e, _, tt.min) : Math.max(_, _e) : et !== void 0 && _ > et && (_ = tt ? mix(et, _, tt.max) : Math.min(_, et)), _
    }

    function calcRelativeAxisConstraints(_, _e, et) {
        return {
            min: _e !== void 0 ? _.min + _e : void 0,
            max: et !== void 0 ? _.max + et - (_.max - _.min) : void 0
        }
    }

    function calcRelativeConstraints(_, {
        top: _e,
        left: et,
        bottom: tt,
        right: nt
    }) {
        return {
            x: calcRelativeAxisConstraints(_.x, et, nt),
            y: calcRelativeAxisConstraints(_.y, _e, tt)
        }
    }

    function calcViewportAxisConstraints(_, _e) {
        let et = _e.min - _.min,
            tt = _e.max - _.max;
        return _e.max - _e.min < _.max - _.min && ([et, tt] = [tt, et]), {
            min: et,
            max: tt
        }
    }

    function calcViewportConstraints(_, _e) {
        return {
            x: calcViewportAxisConstraints(_.x, _e.x),
            y: calcViewportAxisConstraints(_.y, _e.y)
        }
    }

    function calcOrigin(_, _e) {
        let et = .5;
        const tt = calcLength(_),
            nt = calcLength(_e);
        return nt > tt ? et = progress(_e.min, _e.max - tt, _.min) : tt > nt && (et = progress(_.min, _.max - nt, _e.min)), clamp(0, 1, et)
    }

    function rebaseAxisConstraints(_, _e) {
        const et = {};
        return _e.min !== void 0 && (et.min = _e.min - _.min), _e.max !== void 0 && (et.max = _e.max - _.min), et
    }
    const defaultElastic = .35;

    function resolveDragElastic(_ = defaultElastic) {
        return _ === !1 ? _ = 0 : _ === !0 && (_ = defaultElastic), {
            x: resolveAxisElastic(_, "left", "right"),
            y: resolveAxisElastic(_, "top", "bottom")
        }
    }

    function resolveAxisElastic(_, _e, et) {
        return {
            min: resolvePointElastic(_, _e),
            max: resolvePointElastic(_, et)
        }
    }

    function resolvePointElastic(_, _e) {
        return typeof _ == "number" ? _ : _[_e] || 0
    }
    let createAxisDelta, createDelta, createAxis;
    createAxisDelta = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }), createDelta = () => ({
        x: createAxisDelta(),
        y: createAxisDelta()
    }), createAxis = () => ({
        min: 0,
        max: 0
    }), createBox = () => ({
        x: createAxis(),
        y: createAxis()
    });

    function eachAxis(_) {
        return [_("x"), _("y")]
    }

    function convertBoundingBoxToBox({
        top: _,
        left: _e,
        right: et,
        bottom: tt
    }) {
        return {
            x: {
                min: _e,
                max: et
            },
            y: {
                min: _,
                max: tt
            }
        }
    }

    function convertBoxToBoundingBox({
        x: _,
        y: _e
    }) {
        return {
            top: _e.min,
            right: _.max,
            bottom: _e.max,
            left: _.min
        }
    }

    function transformBoxPoints(_, _e) {
        if (!_e) return _;
        const et = _e({
                x: _.left,
                y: _.top
            }),
            tt = _e({
                x: _.right,
                y: _.bottom
            });
        return {
            top: et.y,
            left: et.x,
            bottom: tt.y,
            right: tt.x
        }
    }

    function isIdentityScale(_) {
        return _ === void 0 || _ === 1
    }

    function hasScale({
        scale: _,
        scaleX: _e,
        scaleY: et
    }) {
        return !isIdentityScale(_) || !isIdentityScale(_e) || !isIdentityScale(et)
    }

    function hasTransform(_) {
        return hasScale(_) || has2DTranslate(_) || _.z || _.rotate || _.rotateX || _.rotateY
    }

    function has2DTranslate(_) {
        return is2DTranslate(_.x) || is2DTranslate(_.y)
    }

    function is2DTranslate(_) {
        return _ && _ !== "0%"
    }

    function scalePoint(_, _e, et) {
        const tt = _ - et,
            nt = _e * tt;
        return et + nt
    }

    function applyPointDelta(_, _e, et, tt, nt) {
        return nt !== void 0 && (_ = scalePoint(_, nt, tt)), scalePoint(_, et, tt) + _e
    }

    function applyAxisDelta(_, _e = 0, et = 1, tt, nt) {
        _.min = applyPointDelta(_.min, _e, et, tt, nt), _.max = applyPointDelta(_.max, _e, et, tt, nt)
    }

    function applyBoxDelta(_, {
        x: _e,
        y: et
    }) {
        applyAxisDelta(_.x, _e.translate, _e.scale, _e.originPoint), applyAxisDelta(_.y, et.translate, et.scale, et.originPoint)
    }

    function applyTreeDeltas(_, _e, et, tt = !1) {
        const nt = et.length;
        if (!nt) return;
        _e.x = _e.y = 1;
        let ot, at;
        for (let st = 0; st < nt; st++) {
            ot = et[st], at = ot.projectionDelta;
            const lt = ot.instance;
            lt && lt.style && lt.style.display === "contents" || (tt && ot.options.layoutScroll && ot.scroll && ot !== ot.root && transformBox(_, {
                x: -ot.scroll.offset.x,
                y: -ot.scroll.offset.y
            }), at && (_e.x *= at.x.scale, _e.y *= at.y.scale, applyBoxDelta(_, at)), tt && hasTransform(ot.latestValues) && transformBox(_, ot.latestValues))
        }
        _e.x = snapToDefault(_e.x), _e.y = snapToDefault(_e.y)
    }

    function snapToDefault(_) {
        return Number.isInteger(_) || _ > 1.0000000000001 || _ < .999999999999 ? _ : 1
    }

    function translateAxis(_, _e) {
        _.min = _.min + _e, _.max = _.max + _e
    }

    function transformAxis(_, _e, [et, tt, nt]) {
        const ot = _e[nt] !== void 0 ? _e[nt] : .5,
            at = mix(_.min, _.max, ot);
        applyAxisDelta(_, _e[et], _e[tt], at, _e.scale)
    }
    const xKeys$1 = ["x", "scaleX", "originX"],
        yKeys$1 = ["y", "scaleY", "originY"];

    function transformBox(_, _e) {
        transformAxis(_.x, _e, xKeys$1), transformAxis(_.y, _e, yKeys$1)
    }

    function measureViewportBox(_, _e) {
        return convertBoundingBoxToBox(transformBoxPoints(_.getBoundingClientRect(), _e))
    }

    function measurePageBox(_, _e, et) {
        const tt = measureViewportBox(_, et),
            {
                scroll: nt
            } = _e;
        return nt && (translateAxis(tt.x, nt.offset.x), translateAxis(tt.y, nt.offset.y)), tt
    }
    const elementDragControls = new WeakMap;
    class VisualElementDragControls {
        constructor(_e) {
            this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
                x: 0,
                y: 0
            }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = _e
        }
        start(_e, {
            snapToCursor: et = !1
        } = {}) {
            const {
                presenceContext: tt
            } = this.visualElement;
            if (tt && tt.isPresent === !1) return;
            const nt = lt => {
                    this.stopAnimation(), et && this.snapToCursor(extractEventInfo(lt, "page").point)
                },
                ot = (lt, ut) => {
                    const {
                        drag: dt,
                        dragPropagation: ct,
                        onDragStart: pt
                    } = this.getProps();
                    if (dt && !ct && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(dt), !this.openGlobalLock)) return;
                    this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis(ht => {
                        let mt = this.getAxisMotionValue(ht).get() || 0;
                        if (percent.test(mt)) {
                            const {
                                projection: bt
                            } = this.visualElement;
                            if (bt && bt.layout) {
                                const gt = bt.layout.layoutBox[ht];
                                gt && (mt = calcLength(gt) * (parseFloat(mt) / 100))
                            }
                        }
                        this.originPoint[ht] = mt
                    }), pt && frame.update(() => pt(lt, ut), !1, !0);
                    const {
                        animationState: ft
                    } = this.visualElement;
                    ft && ft.setActive("whileDrag", !0)
                },
                at = (lt, ut) => {
                    const {
                        dragPropagation: dt,
                        dragDirectionLock: ct,
                        onDirectionLock: pt,
                        onDrag: ft
                    } = this.getProps();
                    if (!dt && !this.openGlobalLock) return;
                    const {
                        offset: ht
                    } = ut;
                    if (ct && this.currentDirection === null) {
                        this.currentDirection = getCurrentDirection(ht), this.currentDirection !== null && pt && pt(this.currentDirection);
                        return
                    }
                    this.updateAxis("x", ut.point, ht), this.updateAxis("y", ut.point, ht), this.visualElement.render(), ft && ft(lt, ut)
                },
                st = (lt, ut) => this.stop(lt, ut);
            this.panSession = new PanSession(_e, {
                onSessionStart: nt,
                onStart: ot,
                onMove: at,
                onSessionEnd: st
            }, {
                transformPagePoint: this.visualElement.getTransformPagePoint()
            })
        }
        stop(_e, et) {
            const tt = this.isDragging;
            if (this.cancel(), !tt) return;
            const {
                velocity: nt
            } = et;
            this.startAnimation(nt);
            const {
                onDragEnd: ot
            } = this.getProps();
            ot && frame.update(() => ot(_e, et))
        }
        cancel() {
            this.isDragging = !1;
            const {
                projection: _e,
                animationState: et
            } = this.visualElement;
            _e && (_e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
            const {
                dragPropagation: tt
            } = this.getProps();
            !tt && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), et && et.setActive("whileDrag", !1)
        }
        updateAxis(_e, et, tt) {
            const {
                drag: nt
            } = this.getProps();
            if (!tt || !shouldDrag(_e, nt, this.currentDirection)) return;
            const ot = this.getAxisMotionValue(_e);
            let at = this.originPoint[_e] + tt[_e];
            this.constraints && this.constraints[_e] && (at = applyConstraints(at, this.constraints[_e], this.elastic[_e])), ot.set(at)
        }
        resolveConstraints() {
            const {
                dragConstraints: _e,
                dragElastic: et
            } = this.getProps(), {
                layout: tt
            } = this.visualElement.projection || {}, nt = this.constraints;
            _e && isRefObject(_e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : _e && tt ? this.constraints = calcRelativeConstraints(tt.layoutBox, _e) : this.constraints = !1, this.elastic = resolveDragElastic(et), nt !== this.constraints && tt && this.constraints && !this.hasMutatedConstraints && eachAxis(ot => {
                this.getAxisMotionValue(ot) && (this.constraints[ot] = rebaseAxisConstraints(tt.layoutBox[ot], this.constraints[ot]))
            })
        }
        resolveRefConstraints() {
            const {
                dragConstraints: _e,
                onMeasureDragConstraints: et
            } = this.getProps();
            if (!_e || !isRefObject(_e)) return !1;
            const tt = _e.current,
                {
                    projection: nt
                } = this.visualElement;
            if (!nt || !nt.layout) return !1;
            const ot = measurePageBox(tt, nt.root, this.visualElement.getTransformPagePoint());
            let at = calcViewportConstraints(nt.layout.layoutBox, ot);
            if (et) {
                const st = et(convertBoxToBoundingBox(at));
                this.hasMutatedConstraints = !!st, st && (at = convertBoundingBoxToBox(st))
            }
            return at
        }
        startAnimation(_e) {
            const {
                drag: et,
                dragMomentum: tt,
                dragElastic: nt,
                dragTransition: ot,
                dragSnapToOrigin: at,
                onDragTransitionEnd: st
            } = this.getProps(), lt = this.constraints || {}, ut = eachAxis(dt => {
                if (!shouldDrag(dt, et, this.currentDirection)) return;
                let ct = lt && lt[dt] || {};
                at && (ct = {
                    min: 0,
                    max: 0
                });
                const pt = nt ? 200 : 1e6,
                    ft = nt ? 40 : 1e7,
                    ht = kt(kt({
                        type: "inertia",
                        velocity: tt ? _e[dt] : 0,
                        bounceStiffness: pt,
                        bounceDamping: ft,
                        timeConstant: 750,
                        restDelta: 1,
                        restSpeed: 10
                    }, ot), ct);
                return this.startAxisValueAnimation(dt, ht)
            });
            return Promise.all(ut).then(st)
        }
        startAxisValueAnimation(_e, et) {
            const tt = this.getAxisMotionValue(_e);
            return tt.start(animateMotionValue(_e, tt, 0, et))
        }
        stopAnimation() {
            eachAxis(_e => this.getAxisMotionValue(_e).stop())
        }
        getAxisMotionValue(_e) {
            const et = "_drag" + _e.toUpperCase(),
                tt = this.visualElement.getProps();
            return tt[et] || this.visualElement.getValue(_e, (tt.initial ? tt.initial[_e] : void 0) || 0)
        }
        snapToCursor(_e) {
            eachAxis(et => {
                const {
                    drag: tt
                } = this.getProps();
                if (!shouldDrag(et, tt, this.currentDirection)) return;
                const {
                    projection: nt
                } = this.visualElement, ot = this.getAxisMotionValue(et);
                if (nt && nt.layout) {
                    const {
                        min: at,
                        max: st
                    } = nt.layout.layoutBox[et];
                    ot.set(_e[et] - mix(at, st, .5))
                }
            })
        }
        scalePositionWithinConstraints() {
            if (!this.visualElement.current) return;
            const {
                drag: _e,
                dragConstraints: et
            } = this.getProps(), {
                projection: tt
            } = this.visualElement;
            if (!isRefObject(et) || !tt || !this.constraints) return;
            this.stopAnimation();
            const nt = {
                x: 0,
                y: 0
            };
            eachAxis(at => {
                const st = this.getAxisMotionValue(at);
                if (st) {
                    const lt = st.get();
                    nt[at] = calcOrigin({
                        min: lt,
                        max: lt
                    }, this.constraints[at])
                }
            });
            const {
                transformTemplate: ot
            } = this.visualElement.getProps();
            this.visualElement.current.style.transform = ot ? ot({}, "") : "none", tt.root && tt.root.updateScroll(), tt.updateLayout(), this.resolveConstraints(), eachAxis(at => {
                if (!shouldDrag(at, _e, null)) return;
                const st = this.getAxisMotionValue(at),
                    {
                        min: lt,
                        max: ut
                    } = this.constraints[at];
                st.set(mix(lt, ut, nt[at]))
            })
        }
        addListeners() {
            if (!this.visualElement.current) return;
            elementDragControls.set(this.visualElement, this);
            const _e = this.visualElement.current,
                et = addPointerEvent(_e, "pointerdown", lt => {
                    const {
                        drag: ut,
                        dragListener: dt = !0
                    } = this.getProps();
                    ut && dt && this.start(lt)
                }),
                tt = () => {
                    const {
                        dragConstraints: lt
                    } = this.getProps();
                    isRefObject(lt) && (this.constraints = this.resolveRefConstraints())
                },
                {
                    projection: nt
                } = this.visualElement,
                ot = nt.addEventListener("measure", tt);
            nt && !nt.layout && (nt.root && nt.root.updateScroll(), nt.updateLayout()), tt();
            const at = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()),
                st = nt.addEventListener("didUpdate", ({
                    delta: lt,
                    hasLayoutChanged: ut
                }) => {
                    this.isDragging && ut && (eachAxis(dt => {
                        const ct = this.getAxisMotionValue(dt);
                        ct && (this.originPoint[dt] += lt[dt].translate, ct.set(ct.get() + lt[dt].translate))
                    }), this.visualElement.render())
                });
            return () => {
                at(), et(), ot(), st && st()
            }
        }
        getProps() {
            const _e = this.visualElement.getProps(),
                {
                    drag: et = !1,
                    dragDirectionLock: tt = !1,
                    dragPropagation: nt = !1,
                    dragConstraints: ot = !1,
                    dragElastic: at = defaultElastic,
                    dragMomentum: st = !0
                } = _e;
            return Bt(kt({}, _e), {
                drag: et,
                dragDirectionLock: tt,
                dragPropagation: nt,
                dragConstraints: ot,
                dragElastic: at,
                dragMomentum: st
            })
        }
    }

    function shouldDrag(_, _e, et) {
        return (_e === !0 || _e === _) && (et === null || et === _)
    }

    function getCurrentDirection(_, _e = 10) {
        let et = null;
        return Math.abs(_.y) > _e ? et = "y" : Math.abs(_.x) > _e && (et = "x"), et
    }
    class DragGesture extends Feature {
        constructor(_e) {
            super(_e), this.removeGroupControls = noop$4, this.removeListeners = noop$4, this.controls = new VisualElementDragControls(_e)
        }
        mount() {
            const {
                dragControls: _e
            } = this.node.getProps();
            _e && (this.removeGroupControls = _e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$4
        }
        unmount() {
            this.removeGroupControls(), this.removeListeners()
        }
    }
    const asyncHandler = _ => (_e, et) => {
        _ && frame.update(() => _(_e, et))
    };
    class PanGesture extends Feature {
        constructor() {
            super(...arguments), this.removePointerDownListener = noop$4
        }
        onPointerDown(_e) {
            this.session = new PanSession(_e, this.createPanHandlers(), {
                transformPagePoint: this.node.getTransformPagePoint()
            })
        }
        createPanHandlers() {
            const {
                onPanSessionStart: _e,
                onPanStart: et,
                onPan: tt,
                onPanEnd: nt
            } = this.node.getProps();
            return {
                onSessionStart: asyncHandler(_e),
                onStart: asyncHandler(et),
                onMove: tt,
                onEnd: (ot, at) => {
                    delete this.session, nt && frame.update(() => nt(ot, at))
                }
            }
        }
        mount() {
            this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", _e => this.onPointerDown(_e))
        }
        update() {
            this.session && this.session.updateHandlers(this.createPanHandlers())
        }
        unmount() {
            this.removePointerDownListener(), this.session && this.session.end()
        }
    }
    usePresence = function() {
        const _ = reactExports.useContext(PresenceContext);
        if (_ === null) return [!0, null];
        const {
            isPresent: _e,
            onExitComplete: et,
            register: tt
        } = _, nt = reactExports.useId();
        return reactExports.useEffect(() => tt(nt), []), !_e && et ? [!1, () => et && et(nt)] : [!0]
    }, useIsPresent = function() {
        return isPresent(reactExports.useContext(PresenceContext))
    };

    function isPresent(_) {
        return _ === null ? !0 : _.isPresent
    }
    const globalProjectionState = {
        hasAnimatedSinceResize: !0,
        hasEverUpdated: !1
    };

    function pixelsToPercent(_, _e) {
        return _e.max === _e.min ? 0 : _ / (_e.max - _e.min) * 100
    }
    const correctBorderRadius = {
            correct: (_, _e) => {
                if (!_e.target) return _;
                if (typeof _ == "string")
                    if (px.test(_)) _ = parseFloat(_);
                    else return _;
                const et = pixelsToPercent(_, _e.target.x),
                    tt = pixelsToPercent(_, _e.target.y);
                return `${et}% ${tt}%`
            }
        },
        correctBoxShadow = {
            correct: (_, {
                treeScale: _e,
                projectionDelta: et
            }) => {
                const tt = _,
                    nt = complex.parse(_);
                if (nt.length > 5) return tt;
                const ot = complex.createTransformer(_),
                    at = typeof nt[0] != "number" ? 1 : 0,
                    st = et.x.scale * _e.x,
                    lt = et.y.scale * _e.y;
                nt[0 + at] /= st, nt[1 + at] /= lt;
                const ut = mix(st, lt, .5);
                return typeof nt[2 + at] == "number" && (nt[2 + at] /= ut), typeof nt[3 + at] == "number" && (nt[3 + at] /= ut), ot(nt)
            }
        };
    class MeasureLayoutWithContext extends React.Component {
        componentDidMount() {
            const {
                visualElement: _e,
                layoutGroup: et,
                switchLayoutGroup: tt,
                layoutId: nt
            } = this.props, {
                projection: ot
            } = _e;
            addScaleCorrector(defaultScaleCorrectors), ot && (et.group && et.group.add(ot), tt && tt.register && nt && tt.register(ot), ot.root.didUpdate(), ot.addEventListener("animationComplete", () => {
                this.safeToRemove()
            }), ot.setOptions(Bt(kt({}, ot.options), {
                onExitComplete: () => this.safeToRemove()
            }))), globalProjectionState.hasEverUpdated = !0
        }
        getSnapshotBeforeUpdate(_e) {
            const {
                layoutDependency: et,
                visualElement: tt,
                drag: nt,
                isPresent: ot
            } = this.props, at = tt.projection;
            return at && (at.isPresent = ot, nt || _e.layoutDependency !== et || et === void 0 ? at.willUpdate() : this.safeToRemove(), _e.isPresent !== ot && (ot ? at.promote() : at.relegate() || frame.postRender(() => {
                const st = at.getStack();
                (!st || !st.members.length) && this.safeToRemove()
            }))), null
        }
        componentDidUpdate() {
            const {
                projection: _e
            } = this.props.visualElement;
            _e && (_e.root.didUpdate(), queueMicrotask(() => {
                !_e.currentAnimation && _e.isLead() && this.safeToRemove()
            }))
        }
        componentWillUnmount() {
            const {
                visualElement: _e,
                layoutGroup: et,
                switchLayoutGroup: tt
            } = this.props, {
                projection: nt
            } = _e;
            nt && (nt.scheduleCheckAfterUnmount(), et && et.group && et.group.remove(nt), tt && tt.deregister && tt.deregister(nt))
        }
        safeToRemove() {
            const {
                safeToRemove: _e
            } = this.props;
            _e && _e()
        }
        render() {
            return null
        }
    }

    function MeasureLayout(_) {
        const [_e, et] = usePresence(), tt = reactExports.useContext(LayoutGroupContext);
        return React.createElement(MeasureLayoutWithContext, Bt(kt({}, _), {
            layoutGroup: tt,
            switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
            isPresent: _e,
            safeToRemove: et
        }))
    }
    const defaultScaleCorrectors = {
            borderRadius: Bt(kt({}, correctBorderRadius), {
                applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
            }),
            borderTopLeftRadius: correctBorderRadius,
            borderTopRightRadius: correctBorderRadius,
            borderBottomLeftRadius: correctBorderRadius,
            borderBottomRightRadius: correctBorderRadius,
            boxShadow: correctBoxShadow
        },
        borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
        numBorders = borders.length,
        asNumber = _ => typeof _ == "string" ? parseFloat(_) : _,
        isPx = _ => typeof _ == "number" || px.test(_);

    function mixValues(_, _e, et, tt, nt, ot) {
        nt ? (_.opacity = mix(0, et.opacity !== void 0 ? et.opacity : 1, easeCrossfadeIn(tt)), _.opacityExit = mix(_e.opacity !== void 0 ? _e.opacity : 1, 0, easeCrossfadeOut(tt))) : ot && (_.opacity = mix(_e.opacity !== void 0 ? _e.opacity : 1, et.opacity !== void 0 ? et.opacity : 1, tt));
        for (let at = 0; at < numBorders; at++) {
            const st = `border${borders[at]}Radius`;
            let lt = getRadius(_e, st),
                ut = getRadius(et, st);
            lt === void 0 && ut === void 0 || (lt || (lt = 0), ut || (ut = 0), lt === 0 || ut === 0 || isPx(lt) === isPx(ut) ? (_[st] = Math.max(mix(asNumber(lt), asNumber(ut), tt), 0), (percent.test(ut) || percent.test(lt)) && (_[st] += "%")) : _[st] = ut)
        }(_e.rotate || et.rotate) && (_.rotate = mix(_e.rotate || 0, et.rotate || 0, tt))
    }

    function getRadius(_, _e) {
        return _[_e] !== void 0 ? _[_e] : _.borderRadius
    }
    const easeCrossfadeIn = compress(0, .5, circOut),
        easeCrossfadeOut = compress(.5, .95, noop$4);

    function compress(_, _e, et) {
        return tt => tt < _ ? 0 : tt > _e ? 1 : et(progress(_, _e, tt))
    }

    function copyAxisInto(_, _e) {
        _.min = _e.min, _.max = _e.max
    }

    function copyBoxInto(_, _e) {
        copyAxisInto(_.x, _e.x), copyAxisInto(_.y, _e.y)
    }

    function removePointDelta(_, _e, et, tt, nt) {
        return _ -= _e, _ = scalePoint(_, 1 / et, tt), nt !== void 0 && (_ = scalePoint(_, 1 / nt, tt)), _
    }

    function removeAxisDelta(_, _e = 0, et = 1, tt = .5, nt, ot = _, at = _) {
        if (percent.test(_e) && (_e = parseFloat(_e), _e = mix(at.min, at.max, _e / 100) - at.min), typeof _e != "number") return;
        let st = mix(ot.min, ot.max, tt);
        _ === ot && (st -= _e), _.min = removePointDelta(_.min, _e, et, st, nt), _.max = removePointDelta(_.max, _e, et, st, nt)
    }

    function removeAxisTransforms(_, _e, [et, tt, nt], ot, at) {
        removeAxisDelta(_, _e[et], _e[tt], _e[nt], _e.scale, ot, at)
    }
    const xKeys = ["x", "scaleX", "originX"],
        yKeys = ["y", "scaleY", "originY"];

    function removeBoxTransforms(_, _e, et, tt) {
        removeAxisTransforms(_.x, _e, xKeys, et ? et.x : void 0, tt ? tt.x : void 0), removeAxisTransforms(_.y, _e, yKeys, et ? et.y : void 0, tt ? tt.y : void 0)
    }

    function isAxisDeltaZero(_) {
        return _.translate === 0 && _.scale === 1
    }

    function isDeltaZero(_) {
        return isAxisDeltaZero(_.x) && isAxisDeltaZero(_.y)
    }

    function boxEquals(_, _e) {
        return _.x.min === _e.x.min && _.x.max === _e.x.max && _.y.min === _e.y.min && _.y.max === _e.y.max
    }

    function boxEqualsRounded(_, _e) {
        return Math.round(_.x.min) === Math.round(_e.x.min) && Math.round(_.x.max) === Math.round(_e.x.max) && Math.round(_.y.min) === Math.round(_e.y.min) && Math.round(_.y.max) === Math.round(_e.y.max)
    }

    function aspectRatio(_) {
        return calcLength(_.x) / calcLength(_.y)
    }
    class NodeStack {
        constructor() {
            this.members = []
        }
        add(_e) {
            addUniqueItem(this.members, _e), _e.scheduleRender()
        }
        remove(_e) {
            if (removeItem(this.members, _e), _e === this.prevLead && (this.prevLead = void 0), _e === this.lead) {
                const et = this.members[this.members.length - 1];
                et && this.promote(et)
            }
        }
        relegate(_e) {
            const et = this.members.findIndex(nt => _e === nt);
            if (et === 0) return !1;
            let tt;
            for (let nt = et; nt >= 0; nt--) {
                const ot = this.members[nt];
                if (ot.isPresent !== !1) {
                    tt = ot;
                    break
                }
            }
            return tt ? (this.promote(tt), !0) : !1
        }
        promote(_e, et) {
            const tt = this.lead;
            if (_e !== tt && (this.prevLead = tt, this.lead = _e, _e.show(), tt)) {
                tt.instance && tt.scheduleRender(), _e.scheduleRender(), _e.resumeFrom = tt, et && (_e.resumeFrom.preserveOpacity = !0), tt.snapshot && (_e.snapshot = tt.snapshot, _e.snapshot.latestValues = tt.animationValues || tt.latestValues), _e.root && _e.root.isUpdating && (_e.isLayoutDirty = !0);
                const {
                    crossfade: nt
                } = _e.options;
                nt === !1 && tt.hide()
            }
        }
        exitAnimationComplete() {
            this.members.forEach(_e => {
                const {
                    options: et,
                    resumingFrom: tt
                } = _e;
                et.onExitComplete && et.onExitComplete(), tt && tt.options.onExitComplete && tt.options.onExitComplete()
            })
        }
        scheduleRender() {
            this.members.forEach(_e => {
                _e.instance && _e.scheduleRender(!1)
            })
        }
        removeLeadSnapshot() {
            this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
        }
    }

    function buildProjectionTransform(_, _e, et) {
        let tt = "";
        const nt = _.x.translate / _e.x,
            ot = _.y.translate / _e.y;
        if ((nt || ot) && (tt = `translate3d(${nt}px, ${ot}px, 0) `), (_e.x !== 1 || _e.y !== 1) && (tt += `scale(${1/_e.x}, ${1/_e.y}) `), et) {
            const {
                rotate: lt,
                rotateX: ut,
                rotateY: dt
            } = et;
            lt && (tt += `rotate(${lt}deg) `), ut && (tt += `rotateX(${ut}deg) `), dt && (tt += `rotateY(${dt}deg) `)
        }
        const at = _.x.scale * _e.x,
            st = _.y.scale * _e.y;
        return (at !== 1 || st !== 1) && (tt += `scale(${at}, ${st})`), tt || "none"
    }
    const compareByDepth = (_, _e) => _.depth - _e.depth;
    FlatTree = class {
        constructor() {
            this.children = [], this.isDirty = !1
        }
        add(_) {
            addUniqueItem(this.children, _), this.isDirty = !0
        }
        remove(_) {
            removeItem(this.children, _), this.isDirty = !0
        }
        forEach(_) {
            this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(_)
        }
    }, delay$1 = function(_, _e) {
        const et = performance.now(),
            tt = ({
                timestamp: nt
            }) => {
                const ot = nt - et;
                ot >= _e && (cancelFrame(tt), _(ot - _e))
            };
        return frame.read(tt, !0), () => cancelFrame(tt)
    };

    function record(_) {
        window.MotionDebug && window.MotionDebug.record(_)
    }
    isSVGElement = function(_) {
        return _ instanceof SVGElement && _.tagName !== "svg"
    }, animateSingleValue = function(_, _e, et) {
        const tt = isMotionValue(_) ? _ : motionValue(_);
        return tt.start(animateMotionValue("", tt, _e, et)), tt.animation
    };
    const transformAxes = ["", "X", "Y", "Z"],
        animationTarget = 1e3;
    let id$1 = 0;
    const projectionFrameData = {
        type: "projectionFrame",
        totalNodes: 0,
        resolvedTargetDeltas: 0,
        recalculatedProjection: 0
    };

    function createProjectionNode({
        attachResizeListener: _,
        defaultParent: _e,
        measureScroll: et,
        checkIsScrollRoot: tt,
        resetTransform: nt
    }) {
        return class {
            constructor(ot = {}, at = _e == null ? void 0 : _e()) {
                this.id = id$1++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {
                    x: 1,
                    y: 1
                }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.checkUpdateFailed = () => {
                    this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
                }, this.updateProjection = () => {
                    projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), record(projectionFrameData)
                }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = ot, this.root = at ? at.root || at : this, this.path = at ? [...at.path, at] : [], this.parent = at, this.depth = at ? at.depth + 1 : 0;
                for (let st = 0; st < this.path.length; st++) this.path[st].shouldResetTransform = !0;
                this.root === this && (this.nodes = new FlatTree)
            }
            addEventListener(ot, at) {
                return this.eventHandlers.has(ot) || this.eventHandlers.set(ot, new SubscriptionManager), this.eventHandlers.get(ot).add(at)
            }
            notifyListeners(ot, ...at) {
                const st = this.eventHandlers.get(ot);
                st && st.notify(...at)
            }
            hasListeners(ot) {
                return this.eventHandlers.has(ot)
            }
            mount(ot, at = this.root.hasTreeAnimated) {
                if (this.instance) return;
                this.isSVG = isSVGElement(ot), this.instance = ot;
                const {
                    layoutId: st,
                    layout: lt,
                    visualElement: ut
                } = this.options;
                if (ut && !ut.current && ut.mount(ot), this.root.nodes.add(this), this.parent && this.parent.children.add(this), at && (lt || st) && (this.isLayoutDirty = !0), _) {
                    let dt;
                    const ct = () => this.root.updateBlockedByResize = !1;
                    _(ot, () => {
                        this.root.updateBlockedByResize = !0, dt && dt(), dt = delay$1(ct, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation))
                    })
                }
                st && this.root.registerSharedNode(st, this), this.options.animate !== !1 && ut && (st || lt) && this.addEventListener("didUpdate", ({
                    delta: dt,
                    hasLayoutChanged: ct,
                    hasRelativeTargetChanged: pt,
                    layout: ft
                }) => {
                    if (this.isTreeAnimationBlocked()) {
                        this.target = void 0, this.relativeTarget = void 0;
                        return
                    }
                    const ht = this.options.transition || ut.getDefaultTransition() || defaultLayoutTransition,
                        {
                            onLayoutAnimationStart: mt,
                            onLayoutAnimationComplete: bt
                        } = ut.getProps(),
                        gt = !this.targetLayout || !boxEqualsRounded(this.targetLayout, ft) || pt,
                        vt = !ct && pt;
                    if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || vt || ct && (gt || !this.currentAnimation)) {
                        this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(dt, vt);
                        const xt = Bt(kt({}, getValueTransition(ht, "layout")), {
                            onPlay: mt,
                            onComplete: bt
                        });
                        (ut.shouldReduceMotion || this.options.layoutRoot) && (xt.delay = 0, xt.type = !1), this.startAnimation(xt)
                    } else ct || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                    this.targetLayout = ft
                })
            }
            unmount() {
                this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
                const ot = this.getStack();
                ot && ot.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection)
            }
            blockUpdate() {
                this.updateManuallyBlocked = !0
            }
            unblockUpdate() {
                this.updateManuallyBlocked = !1
            }
            isUpdateBlocked() {
                return this.updateManuallyBlocked || this.updateBlockedByResize
            }
            isTreeAnimationBlocked() {
                return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
            }
            startUpdate() {
                this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetRotation), this.animationId++)
            }
            getTransformTemplate() {
                const {
                    visualElement: ot
                } = this.options;
                return ot && ot.getProps().transformTemplate
            }
            willUpdate(ot = !0) {
                if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                    this.options.onExitComplete && this.options.onExitComplete();
                    return
                }
                if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
                this.isLayoutDirty = !0;
                for (let ut = 0; ut < this.path.length; ut++) {
                    const dt = this.path[ut];
                    dt.shouldResetTransform = !0, dt.updateScroll("snapshot"), dt.options.layoutRoot && dt.willUpdate(!1)
                }
                const {
                    layoutId: at,
                    layout: st
                } = this.options;
                if (at === void 0 && !st) return;
                const lt = this.getTransformTemplate();
                this.prevTransformTemplateValue = lt ? lt(this.latestValues, "") : void 0, this.updateSnapshot(), ot && this.notifyListeners("willUpdate")
            }
            update() {
                if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                    this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
                    return
                }
                this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots();
                const ot = performance.now();
                frameData.delta = clamp(0, 1e3 / 60, ot - frameData.timestamp), frameData.timestamp = ot, frameData.isProcessing = !0, steps.update.process(frameData), steps.preRender.process(frameData), steps.render.process(frameData), frameData.isProcessing = !1
            }
            didUpdate() {
                this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()))
            }
            clearAllSnapshots() {
                this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots)
            }
            scheduleUpdateProjection() {
                frame.preRender(this.updateProjection, !1, !0)
            }
            scheduleCheckAfterUnmount() {
                frame.postRender(() => {
                    this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
                })
            }
            updateSnapshot() {
                this.snapshot || !this.instance || (this.snapshot = this.measure())
            }
            updateLayout() {
                if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
                if (this.resumeFrom && !this.resumeFrom.instance)
                    for (let st = 0; st < this.path.length; st++) this.path[st].updateScroll();
                const ot = this.layout;
                this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
                const {
                    visualElement: at
                } = this.options;
                at && at.notify("LayoutMeasure", this.layout.layoutBox, ot ? ot.layoutBox : void 0)
            }
            updateScroll(ot = "measure") {
                let at = !!(this.options.layoutScroll && this.instance);
                this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === ot && (at = !1), at && (this.scroll = {
                    animationId: this.root.animationId,
                    phase: ot,
                    isRoot: tt(this.instance),
                    offset: et(this.instance)
                })
            }
            resetTransform() {
                if (!nt) return;
                const ot = this.isLayoutDirty || this.shouldResetTransform,
                    at = this.projectionDelta && !isDeltaZero(this.projectionDelta),
                    st = this.getTransformTemplate(),
                    lt = st ? st(this.latestValues, "") : void 0,
                    ut = lt !== this.prevTransformTemplateValue;
                ot && (at || hasTransform(this.latestValues) || ut) && (nt(this.instance, lt), this.shouldResetTransform = !1, this.scheduleRender())
            }
            measure(ot = !0) {
                const at = this.measurePageBox();
                let st = this.removeElementScroll(at);
                return ot && (st = this.removeTransform(st)), roundBox(st), {
                    animationId: this.root.animationId,
                    measuredBox: at,
                    layoutBox: st,
                    latestValues: {},
                    source: this.id
                }
            }
            measurePageBox() {
                const {
                    visualElement: ot
                } = this.options;
                if (!ot) return createBox();
                const at = ot.measureViewportBox(),
                    {
                        scroll: st
                    } = this.root;
                return st && (translateAxis(at.x, st.offset.x), translateAxis(at.y, st.offset.y)), at
            }
            removeElementScroll(ot) {
                const at = createBox();
                copyBoxInto(at, ot);
                for (let st = 0; st < this.path.length; st++) {
                    const lt = this.path[st],
                        {
                            scroll: ut,
                            options: dt
                        } = lt;
                    if (lt !== this.root && ut && dt.layoutScroll) {
                        if (ut.isRoot) {
                            copyBoxInto(at, ot);
                            const {
                                scroll: ct
                            } = this.root;
                            ct && (translateAxis(at.x, -ct.offset.x), translateAxis(at.y, -ct.offset.y))
                        }
                        translateAxis(at.x, ut.offset.x), translateAxis(at.y, ut.offset.y)
                    }
                }
                return at
            }
            applyTransform(ot, at = !1) {
                const st = createBox();
                copyBoxInto(st, ot);
                for (let lt = 0; lt < this.path.length; lt++) {
                    const ut = this.path[lt];
                    !at && ut.options.layoutScroll && ut.scroll && ut !== ut.root && transformBox(st, {
                        x: -ut.scroll.offset.x,
                        y: -ut.scroll.offset.y
                    }), hasTransform(ut.latestValues) && transformBox(st, ut.latestValues)
                }
                return hasTransform(this.latestValues) && transformBox(st, this.latestValues), st
            }
            removeTransform(ot) {
                const at = createBox();
                copyBoxInto(at, ot);
                for (let st = 0; st < this.path.length; st++) {
                    const lt = this.path[st];
                    if (!lt.instance || !hasTransform(lt.latestValues)) continue;
                    hasScale(lt.latestValues) && lt.updateSnapshot();
                    const ut = createBox(),
                        dt = lt.measurePageBox();
                    copyBoxInto(ut, dt), removeBoxTransforms(at, lt.latestValues, lt.snapshot ? lt.snapshot.layoutBox : void 0, ut)
                }
                return hasTransform(this.latestValues) && removeBoxTransforms(at, this.latestValues), at
            }
            setTargetDelta(ot) {
                this.targetDelta = ot, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
            }
            setOptions(ot) {
                this.options = Bt(kt(kt({}, this.options), ot), {
                    crossfade: ot.crossfade !== void 0 ? ot.crossfade : !0
                })
            }
            clearMeasurements() {
                this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
            }
            forceRelativeParentToResolveTarget() {
                this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
            }
            resolveTargetDelta(ot = !1) {
                var at;
                const st = this.getLead();
                this.isProjectionDirty || (this.isProjectionDirty = st.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = st.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = st.isSharedProjectionDirty);
                const lt = !!this.resumingFrom || this !== st;
                if (!(ot || lt && this.isSharedProjectionDirty || this.isProjectionDirty || !((at = this.parent) === null || at === void 0) && at.isProjectionDirty || this.attemptToResolveRelativeTarget)) return;
                const {
                    layout: ut,
                    layoutId: dt
                } = this.options;
                if (!(!this.layout || !(ut || dt))) {
                    if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
                        const ct = this.getClosestProjectingParent();
                        ct && ct.layout && this.animationProgress !== 1 ? (this.relativeParent = ct, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, ct.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    if (!(!this.relativeTarget && !this.targetDelta)) {
                        if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                            this.attemptToResolveRelativeTarget = !1;
                            const ct = this.getClosestProjectingParent();
                            ct && !!ct.resumingFrom == !!this.resumingFrom && !ct.options.layoutScroll && ct.target && this.animationProgress !== 1 ? (this.relativeParent = ct, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, ct.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                        }
                        projectionFrameData.resolvedTargetDeltas++
                    }
                }
            }
            getClosestProjectingParent() {
                if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
            }
            isProjecting() {
                return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
            }
            calcProjection() {
                var ot;
                const at = this.getLead(),
                    st = !!this.resumingFrom || this !== at;
                let lt = !0;
                if ((this.isProjectionDirty || !((ot = this.parent) === null || ot === void 0) && ot.isProjectionDirty) && (lt = !1), st && (this.isSharedProjectionDirty || this.isTransformDirty) && (lt = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (lt = !1), lt) return;
                const {
                    layout: ut,
                    layoutId: dt
                } = this.options;
                if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(ut || dt)) return;
                copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
                const ct = this.treeScale.x,
                    pt = this.treeScale.y;
                applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, st), at.layout && !at.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (at.target = at.layout.layoutBox);
                const {
                    target: ft
                } = at;
                if (!ft) {
                    this.projectionTransform && (this.projectionDelta = createDelta(), this.projectionTransform = "none", this.scheduleRender());
                    return
                }
                this.projectionDelta || (this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta());
                const ht = this.projectionTransform;
                calcBoxDelta(this.projectionDelta, this.layoutCorrected, ft, this.latestValues), this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale), (this.projectionTransform !== ht || this.treeScale.x !== ct || this.treeScale.y !== pt) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", ft)), projectionFrameData.recalculatedProjection++
            }
            hide() {
                this.isVisible = !1
            }
            show() {
                this.isVisible = !0
            }
            scheduleRender(ot = !0) {
                if (this.options.scheduleRender && this.options.scheduleRender(), ot) {
                    const at = this.getStack();
                    at && at.scheduleRender()
                }
                this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
            }
            setAnimationOrigin(ot, at = !1) {
                const st = this.snapshot,
                    lt = st ? st.latestValues : {},
                    ut = kt({}, this.latestValues),
                    dt = createDelta();
                (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !at;
                const ct = createBox(),
                    pt = st ? st.source : void 0,
                    ft = this.layout ? this.layout.source : void 0,
                    ht = pt !== ft,
                    mt = this.getStack(),
                    bt = !mt || mt.members.length <= 1,
                    gt = !!(ht && !bt && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
                this.animationProgress = 0;
                let vt;
                this.mixTargetDelta = xt => {
                    const yt = xt / 1e3;
                    mixAxisDelta(dt.x, ot.x, yt), mixAxisDelta(dt.y, ot.y, yt), this.setTargetDelta(dt), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(ct, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, ct, yt), vt && boxEquals(this.relativeTarget, vt) && (this.isProjectionDirty = !1), vt || (vt = createBox()), copyBoxInto(vt, this.relativeTarget)), ht && (this.animationValues = ut, mixValues(ut, lt, this.latestValues, yt, gt, bt)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = yt
                }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
            }
            startAnimation(ot) {
                this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
                    globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, Bt(kt({}, ot), {
                        onUpdate: at => {
                            this.mixTargetDelta(at), ot.onUpdate && ot.onUpdate(at)
                        },
                        onComplete: () => {
                            ot.onComplete && ot.onComplete(), this.completeAnimation()
                        }
                    })), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
                })
            }
            completeAnimation() {
                this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
                const ot = this.getStack();
                ot && ot.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
            }
            finishAnimation() {
                this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation()
            }
            applyTransformsToTarget() {
                const ot = this.getLead();
                let {
                    targetWithTransforms: at,
                    target: st,
                    layout: lt,
                    latestValues: ut
                } = ot;
                if (!(!at || !st || !lt)) {
                    if (this !== ot && this.layout && lt && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, lt.layoutBox)) {
                        st = this.target || createBox();
                        const dt = calcLength(this.layout.layoutBox.x);
                        st.x.min = ot.target.x.min, st.x.max = st.x.min + dt;
                        const ct = calcLength(this.layout.layoutBox.y);
                        st.y.min = ot.target.y.min, st.y.max = st.y.min + ct
                    }
                    copyBoxInto(at, st), transformBox(at, ut), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, at, ut)
                }
            }
            registerSharedNode(ot, at) {
                this.sharedNodes.has(ot) || this.sharedNodes.set(ot, new NodeStack), this.sharedNodes.get(ot).add(at);
                const st = at.options.initialPromotionConfig;
                at.promote({
                    transition: st ? st.transition : void 0,
                    preserveFollowOpacity: st && st.shouldPreserveFollowOpacity ? st.shouldPreserveFollowOpacity(at) : void 0
                })
            }
            isLead() {
                const ot = this.getStack();
                return ot ? ot.lead === this : !0
            }
            getLead() {
                var ot;
                const {
                    layoutId: at
                } = this.options;
                return at ? ((ot = this.getStack()) === null || ot === void 0 ? void 0 : ot.lead) || this : this
            }
            getPrevLead() {
                var ot;
                const {
                    layoutId: at
                } = this.options;
                return at ? (ot = this.getStack()) === null || ot === void 0 ? void 0 : ot.prevLead : void 0
            }
            getStack() {
                const {
                    layoutId: ot
                } = this.options;
                if (ot) return this.root.sharedNodes.get(ot)
            }
            promote({
                needsReset: ot,
                transition: at,
                preserveFollowOpacity: st
            } = {}) {
                const lt = this.getStack();
                lt && lt.promote(this, st), ot && (this.projectionDelta = void 0, this.needsReset = !0), at && this.setOptions({
                    transition: at
                })
            }
            relegate() {
                const ot = this.getStack();
                return ot ? ot.relegate(this) : !1
            }
            resetRotation() {
                const {
                    visualElement: ot
                } = this.options;
                if (!ot) return;
                let at = !1;
                const {
                    latestValues: st
                } = ot;
                if ((st.rotate || st.rotateX || st.rotateY || st.rotateZ) && (at = !0), !at) return;
                const lt = {};
                for (let ut = 0; ut < transformAxes.length; ut++) {
                    const dt = "rotate" + transformAxes[ut];
                    st[dt] && (lt[dt] = st[dt], ot.setStaticValue(dt, 0))
                }
                ot.render();
                for (const ut in lt) ot.setStaticValue(ut, lt[ut]);
                ot.scheduleRender()
            }
            getProjectionStyles(ot = {}) {
                var at, st;
                const lt = {};
                if (!this.instance || this.isSVG) return lt;
                if (this.isVisible) lt.visibility = "";
                else return {
                    visibility: "hidden"
                };
                const ut = this.getTransformTemplate();
                if (this.needsReset) return this.needsReset = !1, lt.opacity = "", lt.pointerEvents = resolveMotionValue(ot.pointerEvents) || "", lt.transform = ut ? ut(this.latestValues, "") : "none", lt;
                const dt = this.getLead();
                if (!this.projectionDelta || !this.layout || !dt.target) {
                    const ht = {};
                    return this.options.layoutId && (ht.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, ht.pointerEvents = resolveMotionValue(ot.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (ht.transform = ut ? ut({}, "") : "none", this.hasProjected = !1), ht
                }
                const ct = dt.animationValues || dt.latestValues;
                this.applyTransformsToTarget(), lt.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, ct), ut && (lt.transform = ut(ct, lt.transform));
                const {
                    x: pt,
                    y: ft
                } = this.projectionDelta;
                lt.transformOrigin = `${pt.origin*100}% ${ft.origin*100}% 0`, dt.animationValues ? lt.opacity = dt === this ? (st = (at = ct.opacity) !== null && at !== void 0 ? at : this.latestValues.opacity) !== null && st !== void 0 ? st : 1 : this.preserveOpacity ? this.latestValues.opacity : ct.opacityExit : lt.opacity = dt === this ? ct.opacity !== void 0 ? ct.opacity : "" : ct.opacityExit !== void 0 ? ct.opacityExit : 0;
                for (const ht in scaleCorrectors) {
                    if (ct[ht] === void 0) continue;
                    const {
                        correct: mt,
                        applyTo: bt
                    } = scaleCorrectors[ht], gt = lt.transform === "none" ? ct[ht] : mt(ct[ht], dt);
                    if (bt) {
                        const vt = bt.length;
                        for (let xt = 0; xt < vt; xt++) lt[bt[xt]] = gt
                    } else lt[ht] = gt
                }
                return this.options.layoutId && (lt.pointerEvents = dt === this ? resolveMotionValue(ot.pointerEvents) || "" : "none"), lt
            }
            clearSnapshot() {
                this.resumeFrom = this.snapshot = void 0
            }
            resetTree() {
                this.root.nodes.forEach(ot => {
                    var at;
                    return (at = ot.currentAnimation) === null || at === void 0 ? void 0 : at.stop()
                }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear()
            }
        }
    }

    function updateLayout(_) {
        _.updateLayout()
    }

    function notifyLayoutUpdate(_) {
        var _e;
        const et = ((_e = _.resumeFrom) === null || _e === void 0 ? void 0 : _e.snapshot) || _.snapshot;
        if (_.isLead() && _.layout && et && _.hasListeners("didUpdate")) {
            const {
                layoutBox: tt,
                measuredBox: nt
            } = _.layout, {
                animationType: ot
            } = _.options, at = et.source !== _.layout.source;
            ot === "size" ? eachAxis(ct => {
                const pt = at ? et.measuredBox[ct] : et.layoutBox[ct],
                    ft = calcLength(pt);
                pt.min = tt[ct].min, pt.max = pt.min + ft
            }) : shouldAnimatePositionOnly(ot, et.layoutBox, tt) && eachAxis(ct => {
                const pt = at ? et.measuredBox[ct] : et.layoutBox[ct],
                    ft = calcLength(tt[ct]);
                pt.max = pt.min + ft, _.relativeTarget && !_.currentAnimation && (_.isProjectionDirty = !0, _.relativeTarget[ct].max = _.relativeTarget[ct].min + ft)
            });
            const st = createDelta();
            calcBoxDelta(st, tt, et.layoutBox);
            const lt = createDelta();
            at ? calcBoxDelta(lt, _.applyTransform(nt, !0), et.measuredBox) : calcBoxDelta(lt, tt, et.layoutBox);
            const ut = !isDeltaZero(st);
            let dt = !1;
            if (!_.resumeFrom) {
                const ct = _.getClosestProjectingParent();
                if (ct && !ct.resumeFrom) {
                    const {
                        snapshot: pt,
                        layout: ft
                    } = ct;
                    if (pt && ft) {
                        const ht = createBox();
                        calcRelativePosition(ht, et.layoutBox, pt.layoutBox);
                        const mt = createBox();
                        calcRelativePosition(mt, tt, ft.layoutBox), boxEqualsRounded(ht, mt) || (dt = !0), ct.options.layoutRoot && (_.relativeTarget = mt, _.relativeTargetOrigin = ht, _.relativeParent = ct)
                    }
                }
            }
            _.notifyListeners("didUpdate", {
                layout: tt,
                snapshot: et,
                delta: lt,
                layoutDelta: st,
                hasLayoutChanged: ut,
                hasRelativeTargetChanged: dt
            })
        } else if (_.isLead()) {
            const {
                onExitComplete: tt
            } = _.options;
            tt && tt()
        }
        _.options.transition = void 0
    }

    function propagateDirtyNodes(_) {
        projectionFrameData.totalNodes++, _.parent && (_.isProjecting() || (_.isProjectionDirty = _.parent.isProjectionDirty), _.isSharedProjectionDirty || (_.isSharedProjectionDirty = !!(_.isProjectionDirty || _.parent.isProjectionDirty || _.parent.isSharedProjectionDirty)), _.isTransformDirty || (_.isTransformDirty = _.parent.isTransformDirty))
    }

    function cleanDirtyNodes(_) {
        _.isProjectionDirty = _.isSharedProjectionDirty = _.isTransformDirty = !1
    }

    function clearSnapshot(_) {
        _.clearSnapshot()
    }

    function clearMeasurements(_) {
        _.clearMeasurements()
    }

    function clearIsLayoutDirty(_) {
        _.isLayoutDirty = !1
    }

    function resetTransformStyle(_) {
        const {
            visualElement: _e
        } = _.options;
        _e && _e.getProps().onBeforeLayoutMeasure && _e.notify("BeforeLayoutMeasure"), _.resetTransform()
    }

    function finishAnimation(_) {
        _.finishAnimation(), _.targetDelta = _.relativeTarget = _.target = void 0, _.isProjectionDirty = !0
    }

    function resolveTargetDelta(_) {
        _.resolveTargetDelta()
    }

    function calcProjection(_) {
        _.calcProjection()
    }

    function resetRotation(_) {
        _.resetRotation()
    }

    function removeLeadSnapshots(_) {
        _.removeLeadSnapshot()
    }

    function mixAxisDelta(_, _e, et) {
        _.translate = mix(_e.translate, 0, et), _.scale = mix(_e.scale, 1, et), _.origin = _e.origin, _.originPoint = _e.originPoint
    }

    function mixAxis(_, _e, et, tt) {
        _.min = mix(_e.min, et.min, tt), _.max = mix(_e.max, et.max, tt)
    }

    function mixBox(_, _e, et, tt) {
        mixAxis(_.x, _e.x, et.x, tt), mixAxis(_.y, _e.y, et.y, tt)
    }

    function hasOpacityCrossfade(_) {
        return _.animationValues && _.animationValues.opacityExit !== void 0
    }
    const defaultLayoutTransition = {
            duration: .45,
            ease: [.4, 0, .1, 1]
        },
        userAgentContains = _ => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(_),
        roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$4;

    function roundAxis(_) {
        _.min = roundPoint(_.min), _.max = roundPoint(_.max)
    }

    function roundBox(_) {
        roundAxis(_.x), roundAxis(_.y)
    }

    function shouldAnimatePositionOnly(_, _e, et) {
        return _ === "position" || _ === "preserve-aspect" && !isNear(aspectRatio(_e), aspectRatio(et), .2)
    }
    let DocumentProjectionNode, HTMLProjectionNode, splitCSSVariableRegex;
    DocumentProjectionNode = createProjectionNode({
        attachResizeListener: (_, _e) => addDomEvent(_, "resize", _e),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }), rootProjectionNode = {
        current: void 0
    }, HTMLProjectionNode = createProjectionNode({
        measureScroll: _ => ({
            x: _.scrollLeft,
            y: _.scrollTop
        }),
        defaultParent: () => {
            if (!rootProjectionNode.current) {
                const _ = new DocumentProjectionNode({});
                _.mount(window), _.setOptions({
                    layoutScroll: !0
                }), rootProjectionNode.current = _
            }
            return rootProjectionNode.current
        },
        resetTransform: (_, _e) => {
            _.style.transform = _e !== void 0 ? _e : "none"
        },
        checkIsScrollRoot: _ => window.getComputedStyle(_).position === "fixed"
    }), drag = {
        pan: {
            Feature: PanGesture
        },
        drag: {
            Feature: DragGesture,
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout
        }
    }, splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

    function parseCSSVariable(_) {
        const _e = splitCSSVariableRegex.exec(_);
        if (!_e) return [, ];
        const [, et, tt] = _e;
        return [et, tt]
    }

    function getVariableValue(_, _e, et = 1) {
        const [tt, nt] = parseCSSVariable(_);
        if (!tt) return;
        const ot = window.getComputedStyle(_e).getPropertyValue(tt);
        if (ot) {
            const at = ot.trim();
            return isNumericalString(at) ? parseFloat(at) : at
        } else return isCSSVariableToken(nt) ? getVariableValue(nt, _e, et + 1) : nt
    }

    function resolveCSSVariables(_, tt, et) {
        var _e = Wt(tt, []);
        const nt = _.current;
        if (!(nt instanceof Element)) return {
            target: _e,
            transitionEnd: et
        };
        et && (et = kt({}, et)), _.values.forEach(ot => {
            const at = ot.get();
            if (!isCSSVariableToken(at)) return;
            const st = getVariableValue(at, nt);
            st && ot.set(st)
        });
        for (const ot in _e) {
            const at = _e[ot];
            if (!isCSSVariableToken(at)) continue;
            const st = getVariableValue(at, nt);
            st && (_e[ot] = st, et || (et = {}), et[ot] === void 0 && (et[ot] = at))
        }
        return {
            target: _e,
            transitionEnd: et
        }
    }
    const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
        isPositionalKey = _ => positionalKeys.has(_),
        hasPositionalKey = _ => Object.keys(_).some(isPositionalKey),
        isNumOrPxType = _ => _ === number || _ === px,
        getPosFromMatrix = (_, _e) => parseFloat(_.split(", ")[_e]),
        getTranslateFromMatrix = (_, _e) => (et, {
            transform: tt
        }) => {
            if (tt === "none" || !tt) return 0;
            const nt = tt.match(/^matrix3d\((.+)\)$/);
            if (nt) return getPosFromMatrix(nt[1], _e); {
                const ot = tt.match(/^matrix\((.+)\)$/);
                return ot ? getPosFromMatrix(ot[1], _) : 0
            }
        },
        transformKeys = new Set(["x", "y", "z"]),
        nonTranslationalTransformKeys = transformPropOrder.filter(_ => !transformKeys.has(_));

    function removeNonTranslationalTransform(_) {
        const _e = [];
        return nonTranslationalTransformKeys.forEach(et => {
            const tt = _.getValue(et);
            tt !== void 0 && (_e.push([et, tt.get()]), tt.set(et.startsWith("scale") ? 1 : 0))
        }), _e.length && _.render(), _e
    }
    const positionalValues = {
        width: ({
            x: _
        }, {
            paddingLeft: _e = "0",
            paddingRight: et = "0"
        }) => _.max - _.min - parseFloat(_e) - parseFloat(et),
        height: ({
            y: _
        }, {
            paddingTop: _e = "0",
            paddingBottom: et = "0"
        }) => _.max - _.min - parseFloat(_e) - parseFloat(et),
        top: (_, {
            top: _e
        }) => parseFloat(_e),
        left: (_, {
            left: _e
        }) => parseFloat(_e),
        bottom: ({
            y: _
        }, {
            top: _e
        }) => parseFloat(_e) + (_.max - _.min),
        right: ({
            x: _
        }, {
            left: _e
        }) => parseFloat(_e) + (_.max - _.min),
        x: getTranslateFromMatrix(4, 13),
        y: getTranslateFromMatrix(5, 14)
    };
    positionalValues.translateX = positionalValues.x, positionalValues.translateY = positionalValues.y;
    const convertChangedValueTypes = (_, _e, et) => {
            const tt = _e.measureViewportBox(),
                nt = _e.current,
                ot = getComputedStyle(nt),
                {
                    display: at
                } = ot,
                st = {};
            at === "none" && _e.setStaticValue("display", _.display || "block"), et.forEach(ut => {
                st[ut] = positionalValues[ut](tt, ot)
            }), _e.render();
            const lt = _e.measureViewportBox();
            return et.forEach(ut => {
                const dt = _e.getValue(ut);
                dt && dt.jump(st[ut]), _[ut] = positionalValues[ut](lt, ot)
            }), _
        },
        checkAndConvertChangedValueTypes = (_, _e, et = {}, tt = {}) => {
            _e = kt({}, _e), tt = kt({}, tt);
            const nt = Object.keys(_e).filter(isPositionalKey);
            let ot = [],
                at = !1;
            const st = [];
            if (nt.forEach(lt => {
                    const ut = _.getValue(lt);
                    if (!_.hasValue(lt)) return;
                    let dt = et[lt],
                        ct = findDimensionValueType(dt);
                    const pt = _e[lt];
                    let ft;
                    if (isKeyframesTarget(pt)) {
                        const ht = pt.length,
                            mt = pt[0] === null ? 1 : 0;
                        dt = pt[mt], ct = findDimensionValueType(dt);
                        for (let bt = mt; bt < ht && pt[bt] !== null; bt++) ft ? invariant$1(findDimensionValueType(pt[bt]) === ft) : ft = findDimensionValueType(pt[bt])
                    } else ft = findDimensionValueType(pt);
                    if (ct !== ft)
                        if (isNumOrPxType(ct) && isNumOrPxType(ft)) {
                            const ht = ut.get();
                            typeof ht == "string" && ut.set(parseFloat(ht)), typeof pt == "string" ? _e[lt] = parseFloat(pt) : Array.isArray(pt) && ft === px && (_e[lt] = pt.map(parseFloat))
                        } else ct != null && ct.transform && (ft != null && ft.transform) && (dt === 0 || pt === 0) ? dt === 0 ? ut.set(ft.transform(dt)) : _e[lt] = ct.transform(pt) : (at || (ot = removeNonTranslationalTransform(_), at = !0), st.push(lt), tt[lt] = tt[lt] !== void 0 ? tt[lt] : _e[lt], ut.jump(pt))
                }), st.length) {
                const lt = st.indexOf("height") >= 0 ? window.pageYOffset : null,
                    ut = convertChangedValueTypes(_e, _, st);
                return ot.length && ot.forEach(([dt, ct]) => {
                    _.getValue(dt).set(ct)
                }), _.render(), isBrowser$1 && lt !== null && window.scrollTo({
                    top: lt
                }), {
                    target: ut,
                    transitionEnd: tt
                }
            } else return {
                target: _e,
                transitionEnd: tt
            }
        };

    function unitConversion(_, _e, et, tt) {
        return hasPositionalKey(_e) ? checkAndConvertChangedValueTypes(_, _e, et, tt) : {
            target: _e,
            transitionEnd: tt
        }
    }
    let parseDomVariant;
    parseDomVariant = (_, _e, et, tt) => {
        const nt = resolveCSSVariables(_, _e, tt);
        return _e = nt.target, tt = nt.transitionEnd, unitConversion(_, _e, et, tt)
    }, prefersReducedMotion = {
        current: null
    }, hasReducedMotionListener = {
        current: !1
    }, initPrefersReducedMotion = function() {
        if (hasReducedMotionListener.current = !0, !!isBrowser$1)
            if (window.matchMedia) {
                const _ = window.matchMedia("(prefers-reduced-motion)"),
                    _e = () => prefersReducedMotion.current = _.matches;
                _.addListener(_e), _e()
            } else prefersReducedMotion.current = !1
    };

    function updateMotionValuesFromProps(_, _e, et) {
        const {
            willChange: tt
        } = _e;
        for (const nt in _e) {
            const ot = _e[nt],
                at = et[nt];
            if (isMotionValue(ot)) _.addValue(nt, ot), isWillChangeMotionValue(tt) && tt.add(nt);
            else if (isMotionValue(at)) _.addValue(nt, motionValue(ot, {
                owner: _
            })), isWillChangeMotionValue(tt) && tt.remove(nt);
            else if (at !== ot)
                if (_.hasValue(nt)) {
                    const st = _.getValue(nt);
                    !st.hasAnimated && st.set(ot)
                } else {
                    const st = _.getStaticValue(nt);
                    _.addValue(nt, motionValue(st !== void 0 ? st : ot, {
                        owner: _
                    }))
                }
        }
        for (const nt in et) _e[nt] === void 0 && _.removeValue(nt);
        return _e
    }
    let featureNames, numFeatures, propEventHandlers, numVariantProps;
    visualElementStore = new WeakMap, featureNames = Object.keys(featureDefinitions), numFeatures = featureNames.length, propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], numVariantProps = variantProps.length, VisualElement = class {
        constructor({
            parent: _,
            props: _e,
            presenceContext: et,
            reducedMotionConfig: tt,
            visualState: nt
        }, ot = {}) {
            this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
                this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
            }, this.scheduleRender = () => frame.render(this.render, !1, !0);
            const {
                latestValues: at,
                renderState: st
            } = nt;
            this.latestValues = at, this.baseTarget = kt({}, at), this.initialValues = _e.initial ? kt({}, at) : {}, this.renderState = st, this.parent = _, this.props = _e, this.presenceContext = et, this.depth = _ ? _.depth + 1 : 0, this.reducedMotionConfig = tt, this.options = ot, this.isControllingVariants = isControllingVariants(_e), this.isVariantNode = isVariantNode(_e), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(_ && _.current);
            const dt = this.scrapeMotionValuesFromProps(_e, {}),
                {
                    willChange: lt
                } = dt,
                ut = Wt(dt, ["willChange"]);
            for (const ct in ut) {
                const pt = ut[ct];
                at[ct] !== void 0 && isMotionValue(pt) && (pt.set(at[ct], !1), isWillChangeMotionValue(lt) && lt.add(ct))
            }
        }
        scrapeMotionValuesFromProps(_, _e) {
            return {}
        }
        mount(_) {
            this.current = _, visualElementStore.set(_, this), this.projection && !this.projection.instance && this.projection.mount(_), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((_e, et) => this.bindToMotionValue(et, _e)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
        }
        unmount() {
            visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach(_ => _()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
            for (const _ in this.events) this.events[_].clear();
            for (const _ in this.features) this.features[_].unmount();
            this.current = null
        }
        bindToMotionValue(_, _e) {
            const et = transformProps.has(_),
                tt = _e.on("change", ot => {
                    this.latestValues[_] = ot, this.props.onUpdate && frame.update(this.notifyUpdate, !1, !0), et && this.projection && (this.projection.isTransformDirty = !0)
                }),
                nt = _e.on("renderRequest", this.scheduleRender);
            this.valueSubscriptions.set(_, () => {
                tt(), nt()
            })
        }
        sortNodePosition(_) {
            return !this.current || !this.sortInstanceNodePosition || this.type !== _.type ? 0 : this.sortInstanceNodePosition(this.current, _.current)
        }
        loadFeatures(ot, et, tt, nt) {
            var at = ot,
                {
                    children: _
                } = at,
                _e = Wt(at, ["children"]);
            let st, lt;
            for (let ut = 0; ut < numFeatures; ut++) {
                const dt = featureNames[ut],
                    {
                        isEnabled: ct,
                        Feature: pt,
                        ProjectionNode: ft,
                        MeasureLayout: ht
                    } = featureDefinitions[dt];
                ft && (st = ft), ct(_e) && (!this.features[dt] && pt && (this.features[dt] = new pt(this)), ht && (lt = ht))
            }
            if (!this.projection && st) {
                this.projection = new st(this.latestValues, this.parent && this.parent.projection);
                const {
                    layoutId: ut,
                    layout: dt,
                    drag: ct,
                    dragConstraints: pt,
                    layoutScroll: ft,
                    layoutRoot: ht
                } = _e;
                this.projection.setOptions({
                    layoutId: ut,
                    layout: dt,
                    alwaysMeasureLayout: !!ct || pt && isRefObject(pt),
                    visualElement: this,
                    scheduleRender: () => this.scheduleRender(),
                    animationType: typeof dt == "string" ? dt : "both",
                    initialPromotionConfig: nt,
                    layoutScroll: ft,
                    layoutRoot: ht
                })
            }
            return lt
        }
        updateFeatures() {
            for (const _ in this.features) {
                const _e = this.features[_];
                _e.isMounted ? _e.update() : (_e.mount(), _e.isMounted = !0)
            }
        }
        triggerBuild() {
            this.build(this.renderState, this.latestValues, this.options, this.props)
        }
        measureViewportBox() {
            return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
        }
        getStaticValue(_) {
            return this.latestValues[_]
        }
        setStaticValue(_, _e) {
            this.latestValues[_] = _e
        }
        makeTargetAnimatable(_, _e = !0) {
            return this.makeTargetAnimatableFromInstance(_, this.props, _e)
        }
        update(_, _e) {
            (_.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = _, this.prevPresenceContext = this.presenceContext, this.presenceContext = _e;
            for (let et = 0; et < propEventHandlers.length; et++) {
                const tt = propEventHandlers[et];
                this.propEventSubscriptions[tt] && (this.propEventSubscriptions[tt](), delete this.propEventSubscriptions[tt]);
                const nt = _["on" + tt];
                nt && (this.propEventSubscriptions[tt] = this.on(tt, nt))
            }
            this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(_, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
        }
        getProps() {
            return this.props
        }
        getVariant(_) {
            return this.props.variants ? this.props.variants[_] : void 0
        }
        getDefaultTransition() {
            return this.props.transition
        }
        getTransformPagePoint() {
            return this.props.transformPagePoint
        }
        getClosestVariantNode() {
            return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
        }
        getVariantContext(_ = !1) {
            if (_) return this.parent ? this.parent.getVariantContext() : void 0;
            if (!this.isControllingVariants) {
                const et = this.parent ? this.parent.getVariantContext() || {} : {};
                return this.props.initial !== void 0 && (et.initial = this.props.initial), et
            }
            const _e = {};
            for (let et = 0; et < numVariantProps; et++) {
                const tt = variantProps[et],
                    nt = this.props[tt];
                (isVariantLabel(nt) || nt === !1) && (_e[tt] = nt)
            }
            return _e
        }
        addVariantChild(_) {
            const _e = this.getClosestVariantNode();
            if (_e) return _e.variantChildren && _e.variantChildren.add(_), () => _e.variantChildren.delete(_)
        }
        addValue(_, _e) {
            _e !== this.values.get(_) && (this.removeValue(_), this.bindToMotionValue(_, _e)), this.values.set(_, _e), this.latestValues[_] = _e.get()
        }
        removeValue(_) {
            this.values.delete(_);
            const _e = this.valueSubscriptions.get(_);
            _e && (_e(), this.valueSubscriptions.delete(_)), delete this.latestValues[_], this.removeValueFromRenderState(_, this.renderState)
        }
        hasValue(_) {
            return this.values.has(_)
        }
        getValue(_, _e) {
            if (this.props.values && this.props.values[_]) return this.props.values[_];
            let et = this.values.get(_);
            return et === void 0 && _e !== void 0 && (et = motionValue(_e, {
                owner: this
            }), this.addValue(_, et)), et
        }
        readValue(_) {
            var _e;
            return this.latestValues[_] !== void 0 || !this.current ? this.latestValues[_] : (_e = this.getBaseTargetFromProps(this.props, _)) !== null && _e !== void 0 ? _e : this.readValueFromInstance(this.current, _, this.options)
        }
        setBaseTarget(_, _e) {
            this.baseTarget[_] = _e
        }
        getBaseTarget(_) {
            var _e;
            const {
                initial: et
            } = this.props, tt = typeof et == "string" || typeof et == "object" ? (_e = resolveVariantFromProps(this.props, et)) === null || _e === void 0 ? void 0 : _e[_] : void 0;
            if (et && tt !== void 0) return tt;
            const nt = this.getBaseTargetFromProps(this.props, _);
            return nt !== void 0 && !isMotionValue(nt) ? nt : this.initialValues[_] !== void 0 && tt === void 0 ? void 0 : this.baseTarget[_]
        }
        on(_, _e) {
            return this.events[_] || (this.events[_] = new SubscriptionManager), this.events[_].add(_e)
        }
        notify(_, ..._e) {
            this.events[_] && this.events[_].notify(..._e)
        }
    };
    class DOMVisualElement extends VisualElement {
        sortInstanceNodePosition(_e, et) {
            return _e.compareDocumentPosition(et) & 2 ? 1 : -1
        }
        getBaseTargetFromProps(_e, et) {
            return _e.style ? _e.style[et] : void 0
        }
        removeValueFromRenderState(_e, {
            vars: et,
            style: tt
        }) {
            delete et[_e], delete tt[_e]
        }
        makeTargetAnimatableFromInstance(at, {
            transformValues: nt
        }, ot) {
            var st = at,
                {
                    transition: _e,
                    transitionEnd: et
                } = st,
                tt = Wt(st, ["transition", "transitionEnd"]);
            let lt = getOrigin(tt, _e || {}, this);
            if (nt && (et && (et = nt(et)), tt && (tt = nt(tt)), lt && (lt = nt(lt))), ot) {
                checkTargetForNewValues(this, tt, lt);
                const ut = parseDomVariant(this, tt, lt, et);
                et = ut.transitionEnd, tt = ut.target
            }
            return kt({
                transition: _e,
                transitionEnd: et
            }, tt)
        }
    }

    function getComputedStyle$1(_) {
        return window.getComputedStyle(_)
    }
    HTMLVisualElement = class extends DOMVisualElement {
        readValueFromInstance(_, _e) {
            if (transformProps.has(_e)) {
                const et = getDefaultValueType(_e);
                return et && et.default || 0
            } else {
                const et = getComputedStyle$1(_),
                    tt = (isCSSVariableName(_e) ? et.getPropertyValue(_e) : et[_e]) || 0;
                return typeof tt == "string" ? tt.trim() : tt
            }
        }
        measureInstanceViewportBox(_, {
            transformPagePoint: _e
        }) {
            return measureViewportBox(_, _e)
        }
        build(_, _e, et, tt) {
            buildHTMLStyles(_, _e, et, tt.transformTemplate)
        }
        scrapeMotionValuesFromProps(_, _e) {
            return scrapeMotionValuesFromProps$1(_, _e)
        }
        handleChildMotionValue() {
            this.childSubscription && (this.childSubscription(), delete this.childSubscription);
            const {
                children: _
            } = this.props;
            isMotionValue(_) && (this.childSubscription = _.on("change", _e => {
                this.current && (this.current.textContent = `${_e}`)
            }))
        }
        renderInstance(_, _e, et, tt) {
            renderHTML(_, _e, et, tt)
        }
    }, SVGVisualElement = class extends DOMVisualElement {
        constructor() {
            super(...arguments), this.isSVGTag = !1
        }
        getBaseTargetFromProps(_, _e) {
            return _[_e]
        }
        readValueFromInstance(_, _e) {
            if (transformProps.has(_e)) {
                const et = getDefaultValueType(_e);
                return et && et.default || 0
            }
            return _e = camelCaseAttributes.has(_e) ? _e : camelToDash(_e), _.getAttribute(_e)
        }
        measureInstanceViewportBox() {
            return createBox()
        }
        scrapeMotionValuesFromProps(_, _e) {
            return scrapeMotionValuesFromProps(_, _e)
        }
        build(_, _e, et, tt) {
            buildSVGAttrs(_, _e, et, this.isSVGTag, tt.transformTemplate)
        }
        renderInstance(_, _e, et, tt) {
            renderSVG(_, _e, et, tt)
        }
        mount(_) {
            this.isSVGTag = isSVGTag(_.tagName), super.mount(_)
        }
    };
    let preloadedFeatures;
    createDomVisualElement = (_, _e) => isSVGComponent(_) ? new SVGVisualElement(_e, {
        enableHardwareAcceleration: !1
    }) : new HTMLVisualElement(_e, {
        enableHardwareAcceleration: !0
    }), layout = {
        layout: {
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout
        }
    }, preloadedFeatures = kt(kt(kt(kt({}, animations), gestureAnimations), drag), layout), motion = createMotionProxy((_, _e) => createDomMotionConfig(_, _e, preloadedFeatures, createDomVisualElement)), createDomMotionComponent = function(_) {
        return createMotionComponent(createDomMotionConfig(_, {
            forwardMotionProps: !1
        }, preloadedFeatures, createDomVisualElement))
    };

    function useIsMounted() {
        const _ = reactExports.useRef(!1);
        return useIsomorphicLayoutEffect$2(() => (_.current = !0, () => {
            _.current = !1
        }), []), _
    }
    useForceUpdate$1 = function() {
        const _ = useIsMounted(),
            [_e, et] = reactExports.useState(0),
            tt = reactExports.useCallback(() => {
                _.current && et(_e + 1)
            }, [_e]);
        return [reactExports.useCallback(() => frame.postRender(tt), [tt]), _e]
    };
    class PopChildMeasure extends reactExports.Component {
        getSnapshotBeforeUpdate(_e) {
            const et = this.props.childRef.current;
            if (et && _e.isPresent && !this.props.isPresent) {
                const tt = this.props.sizeRef.current;
                tt.height = et.offsetHeight || 0, tt.width = et.offsetWidth || 0, tt.top = et.offsetTop, tt.left = et.offsetLeft
            }
            return null
        }
        componentDidUpdate() {}
        render() {
            return this.props.children
        }
    }

    function PopChild({
        children: _,
        isPresent: _e
    }) {
        const et = reactExports.useId(),
            tt = reactExports.useRef(null),
            nt = reactExports.useRef({
                width: 0,
                height: 0,
                top: 0,
                left: 0
            });
        return reactExports.useInsertionEffect(() => {
            const {
                width: ot,
                height: at,
                top: st,
                left: lt
            } = nt.current;
            if (_e || !tt.current || !ot || !at) return;
            tt.current.dataset.motionPopId = et;
            const ut = document.createElement("style");
            return document.head.appendChild(ut), ut.sheet && ut.sheet.insertRule(`
          [data-motion-pop-id="${et}"] {
            position: absolute !important;
            width: ${ot}px !important;
            height: ${at}px !important;
            top: ${st}px !important;
            left: ${lt}px !important;
          }
        `), () => {
                document.head.removeChild(ut)
            }
        }, [_e]), reactExports.createElement(PopChildMeasure, {
            isPresent: _e,
            childRef: tt,
            sizeRef: nt
        }, reactExports.cloneElement(_, {
            ref: tt
        }))
    }
    const PresenceChild = ({
        children: _,
        initial: _e,
        isPresent: et,
        onExitComplete: tt,
        custom: nt,
        presenceAffectsLayout: ot,
        mode: at
    }) => {
        const st = useConstant(newChildrenMap),
            lt = reactExports.useId(),
            ut = reactExports.useMemo(() => ({
                id: lt,
                initial: _e,
                isPresent: et,
                custom: nt,
                onExitComplete: dt => {
                    st.set(dt, !0);
                    for (const ct of st.values())
                        if (!ct) return;
                    tt && tt()
                },
                register: dt => (st.set(dt, !1), () => st.delete(dt))
            }), ot ? void 0 : [et]);
        return reactExports.useMemo(() => {
            st.forEach((dt, ct) => st.set(ct, !1))
        }, [et]), reactExports.useEffect(() => {
            !et && !st.size && tt && tt()
        }, [et]), at === "popLayout" && (_ = reactExports.createElement(PopChild, {
            isPresent: et
        }, _)), reactExports.createElement(PresenceContext.Provider, {
            value: ut
        }, _)
    };

    function newChildrenMap() {
        return new Map
    }
    useUnmountEffect = function(_) {
        return reactExports.useEffect(() => () => _(), [])
    };
    const getChildKey = _ => _.key || "";

    function updateChildLookup(_, _e) {
        _.forEach(et => {
            const tt = getChildKey(et);
            _e.set(tt, et)
        })
    }

    function onlyElements(_) {
        const _e = [];
        return reactExports.Children.forEach(_, et => {
            reactExports.isValidElement(et) && _e.push(et)
        }), _e
    }
    AnimatePresence = ({
        children: _,
        custom: _e,
        initial: et = !0,
        onExitComplete: tt,
        exitBeforeEnter: nt,
        presenceAffectsLayout: ot = !0,
        mode: at = "sync"
    }) => {
        const st = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate$1()[0],
            lt = useIsMounted(),
            ut = onlyElements(_);
        let dt = ut;
        const ct = reactExports.useRef(new Map).current,
            pt = reactExports.useRef(dt),
            ft = reactExports.useRef(new Map).current,
            ht = reactExports.useRef(!0);
        if (useIsomorphicLayoutEffect$2(() => {
                ht.current = !1, updateChildLookup(ut, ft), pt.current = dt
            }), useUnmountEffect(() => {
                ht.current = !0, ft.clear(), ct.clear()
            }), ht.current) return reactExports.createElement(reactExports.Fragment, null, dt.map(vt => reactExports.createElement(PresenceChild, {
            key: getChildKey(vt),
            isPresent: !0,
            initial: et ? void 0 : !1,
            presenceAffectsLayout: ot,
            mode: at
        }, vt)));
        dt = [...dt];
        const mt = pt.current.map(getChildKey),
            bt = ut.map(getChildKey),
            gt = mt.length;
        for (let vt = 0; vt < gt; vt++) {
            const xt = mt[vt];
            bt.indexOf(xt) === -1 && !ct.has(xt) && ct.set(xt, void 0)
        }
        return at === "wait" && ct.size && (dt = []), ct.forEach((vt, xt) => {
            if (bt.indexOf(xt) !== -1) return;
            const yt = ft.get(xt);
            if (!yt) return;
            const Et = mt.indexOf(xt);
            let wt = vt;
            if (!wt) {
                const St = () => {
                    ft.delete(xt), ct.delete(xt);
                    const $t = pt.current.findIndex(Ct => Ct.key === xt);
                    if (pt.current.splice($t, 1), !ct.size) {
                        if (pt.current = ut, lt.current === !1) return;
                        st(), tt && tt()
                    }
                };
                wt = reactExports.createElement(PresenceChild, {
                    key: getChildKey(yt),
                    isPresent: !1,
                    onExitComplete: St,
                    custom: _e,
                    presenceAffectsLayout: ot,
                    mode: at
                }, yt), ct.set(xt, wt)
            }
            dt.splice(Et, 0, wt)
        }), dt = dt.map(vt => {
            const xt = vt.key;
            return ct.has(xt) ? vt : reactExports.createElement(PresenceChild, {
                key: getChildKey(vt),
                isPresent: !0,
                presenceAffectsLayout: ot,
                mode: at
            }, vt)
        }), reactExports.createElement(reactExports.Fragment, null, ct.size ? dt : dt.map(vt => reactExports.cloneElement(vt)))
    };

    function stopAnimation(_) {
        _.values.forEach(_e => _e.stop())
    }
    animationControls = function() {
        const _ = new Set,
            _e = {
                subscribe(et) {
                    return _.add(et), () => void _.delete(et)
                },
                start(et, tt) {
                    const nt = [];
                    return _.forEach(ot => {
                        nt.push(animateVisualElement(ot, et, {
                            transitionOverride: tt
                        }))
                    }), Promise.all(nt)
                },
                set(et) {
                    return _.forEach(tt => {
                        setValues(tt, et)
                    })
                },
                stop() {
                    _.forEach(et => {
                        stopAnimation(et)
                    })
                },
                mount() {
                    return () => {
                        _e.stop()
                    }
                }
            };
        return _e
    }, useAnimationControls = function() {
        const _ = useConstant(animationControls);
        return useIsomorphicLayoutEffect$2(_.mount, []), _
    }, useAnimation = useAnimationControls, DragControls = class {
        constructor() {
            this.componentControls = new Set
        }
        subscribe(_) {
            return this.componentControls.add(_), () => this.componentControls.delete(_)
        }
        start(_, _e) {
            this.componentControls.forEach(et => {
                et.start(_.nativeEvent || _, _e)
            })
        }
    };
    const createDragControls = () => new DragControls;
    useDragControls = function() {
        return useConstant(createDragControls)
    };
    var reactDom = {
            exports: {}
        },
        reactDom_production_min = {},
        scheduler = {
            exports: {}
        },
        scheduler_production_min = {};
    (function(_) {
        function _e(Mt, Ft) {
            var Vt = Mt.length;
            Mt.push(Ft);
            e: for (; 0 < Vt;) {
                var Zt = Vt - 1 >>> 1,
                    Jt = Mt[Zt];
                if (0 < nt(Jt, Ft)) Mt[Zt] = Ft, Mt[Vt] = Jt, Vt = Zt;
                else break e
            }
        }

        function et(Mt) {
            return Mt.length === 0 ? null : Mt[0]
        }

        function tt(Mt) {
            if (Mt.length === 0) return null;
            var Ft = Mt[0],
                Vt = Mt.pop();
            if (Vt !== Ft) {
                Mt[0] = Vt;
                e: for (var Zt = 0, Jt = Mt.length, qt = Jt >>> 1; Zt < qt;) {
                    var Kt = 2 * (Zt + 1) - 1,
                        mr = Mt[Kt],
                        pr = Kt + 1,
                        xr = Mt[pr];
                    if (0 > nt(mr, Vt)) pr < Jt && 0 > nt(xr, mr) ? (Mt[Zt] = xr, Mt[pr] = Vt, Zt = pr) : (Mt[Zt] = mr, Mt[Kt] = Vt, Zt = Kt);
                    else if (pr < Jt && 0 > nt(xr, Vt)) Mt[Zt] = xr, Mt[pr] = Vt, Zt = pr;
                    else break e
                }
            }
            return Ft
        }

        function nt(Mt, Ft) {
            var Vt = Mt.sortIndex - Ft.sortIndex;
            return Vt !== 0 ? Vt : Mt.id - Ft.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var ot = performance;
            _.unstable_now = function() {
                return ot.now()
            }
        } else {
            var at = Date,
                st = at.now();
            _.unstable_now = function() {
                return at.now() - st
            }
        }
        var lt = [],
            ut = [],
            dt = 1,
            ct = null,
            pt = 3,
            ft = !1,
            ht = !1,
            mt = !1,
            bt = typeof setTimeout == "function" ? setTimeout : null,
            gt = typeof clearTimeout == "function" ? clearTimeout : null,
            vt = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

        function xt(Mt) {
            for (var Ft = et(ut); Ft !== null;) {
                if (Ft.callback === null) tt(ut);
                else if (Ft.startTime <= Mt) tt(ut), Ft.sortIndex = Ft.expirationTime, _e(lt, Ft);
                else break;
                Ft = et(ut)
            }
        }

        function yt(Mt) {
            if (mt = !1, xt(Mt), !ht)
                if (et(lt) !== null) ht = !0, jt(Et);
                else {
                    var Ft = et(ut);
                    Ft !== null && Ht(yt, Ft.startTime - Mt)
                }
        }

        function Et(Mt, Ft) {
            ht = !1, mt && (mt = !1, gt($t), $t = -1), ft = !0;
            var Vt = pt;
            try {
                for (xt(Ft), ct = et(lt); ct !== null && (!(ct.expirationTime > Ft) || Mt && !Pt());) {
                    var Zt = ct.callback;
                    if (typeof Zt == "function") {
                        ct.callback = null, pt = ct.priorityLevel;
                        var Jt = Zt(ct.expirationTime <= Ft);
                        Ft = _.unstable_now(), typeof Jt == "function" ? ct.callback = Jt : ct === et(lt) && tt(lt), xt(Ft)
                    } else tt(lt);
                    ct = et(lt)
                }
                if (ct !== null) var qt = !0;
                else {
                    var Kt = et(ut);
                    Kt !== null && Ht(yt, Kt.startTime - Ft), qt = !1
                }
                return qt
            } finally {
                ct = null, pt = Vt, ft = !1
            }
        }
        var wt = !1,
            St = null,
            $t = -1,
            Ct = 5,
            Rt = -1;

        function Pt() {
            return !(_.unstable_now() - Rt < Ct)
        }

        function Tt() {
            if (St !== null) {
                var Mt = _.unstable_now();
                Rt = Mt;
                var Ft = !0;
                try {
                    Ft = St(!0, Mt)
                } finally {
                    Ft ? It() : (wt = !1, St = null)
                }
            } else wt = !1
        }
        var It;
        if (typeof vt == "function") It = function() {
            vt(Tt)
        };
        else if (typeof MessageChannel < "u") {
            var Ot = new MessageChannel,
                Dt = Ot.port2;
            Ot.port1.onmessage = Tt, It = function() {
                Dt.postMessage(null)
            }
        } else It = function() {
            bt(Tt, 0)
        };

        function jt(Mt) {
            St = Mt, wt || (wt = !0, It())
        }

        function Ht(Mt, Ft) {
            $t = bt(function() {
                Mt(_.unstable_now())
            }, Ft)
        }
        _.unstable_IdlePriority = 5, _.unstable_ImmediatePriority = 1, _.unstable_LowPriority = 4, _.unstable_NormalPriority = 3, _.unstable_Profiling = null, _.unstable_UserBlockingPriority = 2, _.unstable_cancelCallback = function(Mt) {
            Mt.callback = null
        }, _.unstable_continueExecution = function() {
            ht || ft || (ht = !0, jt(Et))
        }, _.unstable_forceFrameRate = function(Mt) {
            0 > Mt || 125 < Mt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ct = 0 < Mt ? Math.floor(1e3 / Mt) : 5
        }, _.unstable_getCurrentPriorityLevel = function() {
            return pt
        }, _.unstable_getFirstCallbackNode = function() {
            return et(lt)
        }, _.unstable_next = function(Mt) {
            switch (pt) {
                case 1:
                case 2:
                case 3:
                    var Ft = 3;
                    break;
                default:
                    Ft = pt
            }
            var Vt = pt;
            pt = Ft;
            try {
                return Mt()
            } finally {
                pt = Vt
            }
        }, _.unstable_pauseExecution = function() {}, _.unstable_requestPaint = function() {}, _.unstable_runWithPriority = function(Mt, Ft) {
            switch (Mt) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    Mt = 3
            }
            var Vt = pt;
            pt = Mt;
            try {
                return Ft()
            } finally {
                pt = Vt
            }
        }, _.unstable_scheduleCallback = function(Mt, Ft, Vt) {
            var Zt = _.unstable_now();
            switch (typeof Vt == "object" && Vt !== null ? (Vt = Vt.delay, Vt = typeof Vt == "number" && 0 < Vt ? Zt + Vt : Zt) : Vt = Zt, Mt) {
                case 1:
                    var Jt = -1;
                    break;
                case 2:
                    Jt = 250;
                    break;
                case 5:
                    Jt = 1073741823;
                    break;
                case 4:
                    Jt = 1e4;
                    break;
                default:
                    Jt = 5e3
            }
            return Jt = Vt + Jt, Mt = {
                id: dt++,
                callback: Ft,
                priorityLevel: Mt,
                startTime: Vt,
                expirationTime: Jt,
                sortIndex: -1
            }, Vt > Zt ? (Mt.sortIndex = Vt, _e(ut, Mt), et(lt) === null && Mt === et(ut) && (mt ? (gt($t), $t = -1) : mt = !0, Ht(yt, Vt - Zt))) : (Mt.sortIndex = Jt, _e(lt, Mt), ht || ft || (ht = !0, jt(Et))), Mt
        }, _.unstable_shouldYield = Pt, _.unstable_wrapCallback = function(Mt) {
            var Ft = pt;
            return function() {
                var Vt = pt;
                pt = Ft;
                try {
                    return Mt.apply(this, arguments)
                } finally {
                    pt = Vt
                }
            }
        }
    })(scheduler_production_min), scheduler.exports = scheduler_production_min;
    var schedulerExports = scheduler.exports,
        aa = reactExports,
        ca = schedulerExports;

    function p$2(_) {
        for (var _e = "https://reactjs.org/docs/error-decoder.html?invariant=" + _, et = 1; et < arguments.length; et++) _e += "&args[]=" + encodeURIComponent(arguments[et]);
        return "Minified React error #" + _ + "; visit " + _e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var da = new Set,
        ea = {};

    function fa(_, _e) {
        ha(_, _e), ha(_ + "Capture", _e)
    }

    function ha(_, _e) {
        for (ea[_] = _e, _ = 0; _ < _e.length; _++) da.add(_e[_])
    }
    var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
        ja = Object.prototype.hasOwnProperty,
        ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
        la = {},
        ma = {};

    function oa(_) {
        return ja.call(ma, _) ? !0 : ja.call(la, _) ? !1 : ka.test(_) ? ma[_] = !0 : (la[_] = !0, !1)
    }

    function pa(_, _e, et, tt) {
        if (et !== null && et.type === 0) return !1;
        switch (typeof _e) {
            case "function":
            case "symbol":
                return !0;
            case "boolean":
                return tt ? !1 : et !== null ? !et.acceptsBooleans : (_ = _.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-");
            default:
                return !1
        }
    }

    function qa(_, _e, et, tt) {
        if (_e === null || typeof _e > "u" || pa(_, _e, et, tt)) return !0;
        if (tt) return !1;
        if (et !== null) switch (et.type) {
            case 3:
                return !_e;
            case 4:
                return _e === !1;
            case 5:
                return isNaN(_e);
            case 6:
                return isNaN(_e) || 1 > _e
        }
        return !1
    }

    function v$1(_, _e, et, tt, nt, ot, at) {
        this.acceptsBooleans = _e === 2 || _e === 3 || _e === 4, this.attributeName = tt, this.attributeNamespace = nt, this.mustUseProperty = et, this.propertyName = _, this.type = _e, this.sanitizeURL = ot, this.removeEmptyString = at
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(_) {
        z[_] = new v$1(_, 0, !1, _, null, !1, !1)
    }), [
        ["acceptCharset", "accept-charset"],
        ["className", "class"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"]
    ].forEach(function(_) {
        var _e = _[0];
        z[_e] = new v$1(_e, 1, !1, _[1], null, !1, !1)
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(_) {
        z[_] = new v$1(_, 2, !1, _.toLowerCase(), null, !1, !1)
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(_) {
        z[_] = new v$1(_, 2, !1, _, null, !1, !1)
    }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(_) {
        z[_] = new v$1(_, 3, !1, _.toLowerCase(), null, !1, !1)
    }), ["checked", "multiple", "muted", "selected"].forEach(function(_) {
        z[_] = new v$1(_, 3, !0, _, null, !1, !1)
    }), ["capture", "download"].forEach(function(_) {
        z[_] = new v$1(_, 4, !1, _, null, !1, !1)
    }), ["cols", "rows", "size", "span"].forEach(function(_) {
        z[_] = new v$1(_, 6, !1, _, null, !1, !1)
    }), ["rowSpan", "start"].forEach(function(_) {
        z[_] = new v$1(_, 5, !1, _.toLowerCase(), null, !1, !1)
    });
    var ra = /[\-:]([a-z])/g;

    function sa(_) {
        return _[1].toUpperCase()
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(_) {
        var _e = _.replace(ra, sa);
        z[_e] = new v$1(_e, 1, !1, _, null, !1, !1)
    }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(_) {
        var _e = _.replace(ra, sa);
        z[_e] = new v$1(_e, 1, !1, _, "http://www.w3.org/1999/xlink", !1, !1)
    }), ["xml:base", "xml:lang", "xml:space"].forEach(function(_) {
        var _e = _.replace(ra, sa);
        z[_e] = new v$1(_e, 1, !1, _, "http://www.w3.org/XML/1998/namespace", !1, !1)
    }), ["tabIndex", "crossOrigin"].forEach(function(_) {
        z[_] = new v$1(_, 1, !1, _.toLowerCase(), null, !1, !1)
    }), z.xlinkHref = new v$1("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(_) {
        z[_] = new v$1(_, 1, !1, _.toLowerCase(), null, !0, !0)
    });

    function ta(_, _e, et, tt) {
        var nt = z.hasOwnProperty(_e) ? z[_e] : null;
        (nt !== null ? nt.type !== 0 : tt || !(2 < _e.length) || _e[0] !== "o" && _e[0] !== "O" || _e[1] !== "n" && _e[1] !== "N") && (qa(_e, et, nt, tt) && (et = null), tt || nt === null ? oa(_e) && (et === null ? _.removeAttribute(_e) : _.setAttribute(_e, "" + et)) : nt.mustUseProperty ? _[nt.propertyName] = et === null ? nt.type === 3 ? !1 : "" : et : (_e = nt.attributeName, tt = nt.attributeNamespace, et === null ? _.removeAttribute(_e) : (nt = nt.type, et = nt === 3 || nt === 4 && et === !0 ? "" : "" + et, tt ? _.setAttributeNS(tt, _e, et) : _.setAttribute(_e, et))))
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        va = Symbol.for("react.element"),
        wa = Symbol.for("react.portal"),
        ya = Symbol.for("react.fragment"),
        za = Symbol.for("react.strict_mode"),
        Aa = Symbol.for("react.profiler"),
        Ba = Symbol.for("react.provider"),
        Ca = Symbol.for("react.context"),
        Da = Symbol.for("react.forward_ref"),
        Ea = Symbol.for("react.suspense"),
        Fa = Symbol.for("react.suspense_list"),
        Ga = Symbol.for("react.memo"),
        Ha = Symbol.for("react.lazy"),
        Ia = Symbol.for("react.offscreen"),
        Ja = Symbol.iterator;

    function Ka(_) {
        return _ === null || typeof _ != "object" ? null : (_ = Ja && _[Ja] || _["@@iterator"], typeof _ == "function" ? _ : null)
    }
    var A = Object.assign,
        La;

    function Ma(_) {
        if (La === void 0) try {
            throw Error()
        } catch (et) {
            var _e = et.stack.trim().match(/\n( *(at )?)/);
            La = _e && _e[1] || ""
        }
        return `
` + La + _
    }
    var Na = !1;

    function Oa(_, _e) {
        if (!_ || Na) return "";
        Na = !0;
        var et = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (_e)
                if (_e = function() {
                        throw Error()
                    }, Object.defineProperty(_e.prototype, "props", {
                        set: function() {
                            throw Error()
                        }
                    }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(_e, [])
                    } catch (ut) {
                        var tt = ut
                    }
                    Reflect.construct(_, [], _e)
                } else {
                    try {
                        _e.call()
                    } catch (ut) {
                        tt = ut
                    }
                    _.call(_e.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (ut) {
                    tt = ut
                }
                _()
            }
        } catch (ut) {
            if (ut && tt && typeof ut.stack == "string") {
                for (var nt = ut.stack.split(`
`), ot = tt.stack.split(`
`), at = nt.length - 1, st = ot.length - 1; 1 <= at && 0 <= st && nt[at] !== ot[st];) st--;
                for (; 1 <= at && 0 <= st; at--, st--)
                    if (nt[at] !== ot[st]) {
                        if (at !== 1 || st !== 1)
                            do
                                if (at--, st--, 0 > st || nt[at] !== ot[st]) {
                                    var lt = `
` + nt[at].replace(" at new ", " at ");
                                    return _.displayName && lt.includes("<anonymous>") && (lt = lt.replace("<anonymous>", _.displayName)), lt
                                }
                        while (1 <= at && 0 <= st);
                        break
                    }
            }
        } finally {
            Na = !1, Error.prepareStackTrace = et
        }
        return (_ = _ ? _.displayName || _.name : "") ? Ma(_) : ""
    }

    function Pa(_) {
        switch (_.tag) {
            case 5:
                return Ma(_.type);
            case 16:
                return Ma("Lazy");
            case 13:
                return Ma("Suspense");
            case 19:
                return Ma("SuspenseList");
            case 0:
            case 2:
            case 15:
                return _ = Oa(_.type, !1), _;
            case 11:
                return _ = Oa(_.type.render, !1), _;
            case 1:
                return _ = Oa(_.type, !0), _;
            default:
                return ""
        }
    }

    function Qa(_) {
        if (_ == null) return null;
        if (typeof _ == "function") return _.displayName || _.name || null;
        if (typeof _ == "string") return _;
        switch (_) {
            case ya:
                return "Fragment";
            case wa:
                return "Portal";
            case Aa:
                return "Profiler";
            case za:
                return "StrictMode";
            case Ea:
                return "Suspense";
            case Fa:
                return "SuspenseList"
        }
        if (typeof _ == "object") switch (_.$$typeof) {
            case Ca:
                return (_.displayName || "Context") + ".Consumer";
            case Ba:
                return (_._context.displayName || "Context") + ".Provider";
            case Da:
                var _e = _.render;
                return _ = _.displayName, _ || (_ = _e.displayName || _e.name || "", _ = _ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef"), _;
            case Ga:
                return _e = _.displayName || null, _e !== null ? _e : Qa(_.type) || "Memo";
            case Ha:
                _e = _._payload, _ = _._init;
                try {
                    return Qa(_(_e))
                } catch (et) {}
        }
        return null
    }

    function Ra(_) {
        var _e = _.type;
        switch (_.tag) {
            case 24:
                return "Cache";
            case 9:
                return (_e.displayName || "Context") + ".Consumer";
            case 10:
                return (_e._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return _ = _e.render, _ = _.displayName || _.name || "", _e.displayName || (_ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return _e;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return Qa(_e);
            case 8:
                return _e === za ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof _e == "function") return _e.displayName || _e.name || null;
                if (typeof _e == "string") return _e
        }
        return null
    }

    function Sa(_) {
        switch (typeof _) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
                return _;
            case "object":
                return _;
            default:
                return ""
        }
    }

    function Ta(_) {
        var _e = _.type;
        return (_ = _.nodeName) && _.toLowerCase() === "input" && (_e === "checkbox" || _e === "radio")
    }

    function Ua(_) {
        var _e = Ta(_) ? "checked" : "value",
            et = Object.getOwnPropertyDescriptor(_.constructor.prototype, _e),
            tt = "" + _[_e];
        if (!_.hasOwnProperty(_e) && typeof et < "u" && typeof et.get == "function" && typeof et.set == "function") {
            var nt = et.get,
                ot = et.set;
            return Object.defineProperty(_, _e, {
                configurable: !0,
                get: function() {
                    return nt.call(this)
                },
                set: function(at) {
                    tt = "" + at, ot.call(this, at)
                }
            }), Object.defineProperty(_, _e, {
                enumerable: et.enumerable
            }), {
                getValue: function() {
                    return tt
                },
                setValue: function(at) {
                    tt = "" + at
                },
                stopTracking: function() {
                    _._valueTracker = null, delete _[_e]
                }
            }
        }
    }

    function Va(_) {
        _._valueTracker || (_._valueTracker = Ua(_))
    }

    function Wa(_) {
        if (!_) return !1;
        var _e = _._valueTracker;
        if (!_e) return !0;
        var et = _e.getValue(),
            tt = "";
        return _ && (tt = Ta(_) ? _.checked ? "true" : "false" : _.value), _ = tt, _ !== et ? (_e.setValue(_), !0) : !1
    }

    function Xa(_) {
        if (_ = _ || (typeof document < "u" ? document : void 0), typeof _ > "u") return null;
        try {
            return _.activeElement || _.body
        } catch (_e) {
            return _.body
        }
    }

    function Ya(_, _e) {
        var et = _e.checked;
        return A({}, _e, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: et != null ? et : _._wrapperState.initialChecked
        })
    }

    function Za(_, _e) {
        var et = _e.defaultValue == null ? "" : _e.defaultValue,
            tt = _e.checked != null ? _e.checked : _e.defaultChecked;
        et = Sa(_e.value != null ? _e.value : et), _._wrapperState = {
            initialChecked: tt,
            initialValue: et,
            controlled: _e.type === "checkbox" || _e.type === "radio" ? _e.checked != null : _e.value != null
        }
    }

    function ab(_, _e) {
        _e = _e.checked, _e != null && ta(_, "checked", _e, !1)
    }

    function bb(_, _e) {
        ab(_, _e);
        var et = Sa(_e.value),
            tt = _e.type;
        if (et != null) tt === "number" ? (et === 0 && _.value === "" || _.value != et) && (_.value = "" + et) : _.value !== "" + et && (_.value = "" + et);
        else if (tt === "submit" || tt === "reset") {
            _.removeAttribute("value");
            return
        }
        _e.hasOwnProperty("value") ? cb(_, _e.type, et) : _e.hasOwnProperty("defaultValue") && cb(_, _e.type, Sa(_e.defaultValue)), _e.checked == null && _e.defaultChecked != null && (_.defaultChecked = !!_e.defaultChecked)
    }

    function db(_, _e, et) {
        if (_e.hasOwnProperty("value") || _e.hasOwnProperty("defaultValue")) {
            var tt = _e.type;
            if (!(tt !== "submit" && tt !== "reset" || _e.value !== void 0 && _e.value !== null)) return;
            _e = "" + _._wrapperState.initialValue, et || _e === _.value || (_.value = _e), _.defaultValue = _e
        }
        et = _.name, et !== "" && (_.name = ""), _.defaultChecked = !!_._wrapperState.initialChecked, et !== "" && (_.name = et)
    }

    function cb(_, _e, et) {
        (_e !== "number" || Xa(_.ownerDocument) !== _) && (et == null ? _.defaultValue = "" + _._wrapperState.initialValue : _.defaultValue !== "" + et && (_.defaultValue = "" + et))
    }
    var eb = Array.isArray;

    function fb(_, _e, et, tt) {
        if (_ = _.options, _e) {
            _e = {};
            for (var nt = 0; nt < et.length; nt++) _e["$" + et[nt]] = !0;
            for (et = 0; et < _.length; et++) nt = _e.hasOwnProperty("$" + _[et].value), _[et].selected !== nt && (_[et].selected = nt), nt && tt && (_[et].defaultSelected = !0)
        } else {
            for (et = "" + Sa(et), _e = null, nt = 0; nt < _.length; nt++) {
                if (_[nt].value === et) {
                    _[nt].selected = !0, tt && (_[nt].defaultSelected = !0);
                    return
                }
                _e !== null || _[nt].disabled || (_e = _[nt])
            }
            _e !== null && (_e.selected = !0)
        }
    }

    function gb(_, _e) {
        if (_e.dangerouslySetInnerHTML != null) throw Error(p$2(91));
        return A({}, _e, {
            value: void 0,
            defaultValue: void 0,
            children: "" + _._wrapperState.initialValue
        })
    }

    function hb(_, _e) {
        var et = _e.value;
        if (et == null) {
            if (et = _e.children, _e = _e.defaultValue, et != null) {
                if (_e != null) throw Error(p$2(92));
                if (eb(et)) {
                    if (1 < et.length) throw Error(p$2(93));
                    et = et[0]
                }
                _e = et
            }
            _e == null && (_e = ""), et = _e
        }
        _._wrapperState = {
            initialValue: Sa(et)
        }
    }

    function ib(_, _e) {
        var et = Sa(_e.value),
            tt = Sa(_e.defaultValue);
        et != null && (et = "" + et, et !== _.value && (_.value = et), _e.defaultValue == null && _.defaultValue !== et && (_.defaultValue = et)), tt != null && (_.defaultValue = "" + tt)
    }

    function jb(_) {
        var _e = _.textContent;
        _e === _._wrapperState.initialValue && _e !== "" && _e !== null && (_.value = _e)
    }

    function kb(_) {
        switch (_) {
            case "svg":
                return "http://www.w3.org/2000/svg";
            case "math":
                return "http://www.w3.org/1998/Math/MathML";
            default:
                return "http://www.w3.org/1999/xhtml"
        }
    }

    function lb(_, _e) {
        return _ == null || _ === "http://www.w3.org/1999/xhtml" ? kb(_e) : _ === "http://www.w3.org/2000/svg" && _e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : _
    }
    var mb, nb = function(_) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(_e, et, tt, nt) {
            MSApp.execUnsafeLocalFunction(function() {
                return _(_e, et, tt, nt)
            })
        } : _
    }(function(_, _e) {
        if (_.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in _) _.innerHTML = _e;
        else {
            for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + _e.valueOf().toString() + "</svg>", _e = mb.firstChild; _.firstChild;) _.removeChild(_.firstChild);
            for (; _e.firstChild;) _.appendChild(_e.firstChild)
        }
    });

    function ob(_, _e) {
        if (_e) {
            var et = _.firstChild;
            if (et && et === _.lastChild && et.nodeType === 3) {
                et.nodeValue = _e;
                return
            }
        }
        _.textContent = _e
    }
    var pb = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0
        },
        qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(_) {
        qb.forEach(function(_e) {
            _e = _e + _.charAt(0).toUpperCase() + _.substring(1), pb[_e] = pb[_]
        })
    });

    function rb(_, _e, et) {
        return _e == null || typeof _e == "boolean" || _e === "" ? "" : et || typeof _e != "number" || _e === 0 || pb.hasOwnProperty(_) && pb[_] ? ("" + _e).trim() : _e + "px"
    }

    function sb(_, _e) {
        _ = _.style;
        for (var et in _e)
            if (_e.hasOwnProperty(et)) {
                var tt = et.indexOf("--") === 0,
                    nt = rb(et, _e[et], tt);
                et === "float" && (et = "cssFloat"), tt ? _.setProperty(et, nt) : _[et] = nt
            }
    }
    var tb = A({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });

    function ub(_, _e) {
        if (_e) {
            if (tb[_] && (_e.children != null || _e.dangerouslySetInnerHTML != null)) throw Error(p$2(137, _));
            if (_e.dangerouslySetInnerHTML != null) {
                if (_e.children != null) throw Error(p$2(60));
                if (typeof _e.dangerouslySetInnerHTML != "object" || !("__html" in _e.dangerouslySetInnerHTML)) throw Error(p$2(61))
            }
            if (_e.style != null && typeof _e.style != "object") throw Error(p$2(62))
        }
    }

    function vb(_, _e) {
        if (_.indexOf("-") === -1) return typeof _e.is == "string";
        switch (_) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
                return !1;
            default:
                return !0
        }
    }
    var wb = null;

    function xb(_) {
        return _ = _.target || _.srcElement || window, _.correspondingUseElement && (_ = _.correspondingUseElement), _.nodeType === 3 ? _.parentNode : _
    }
    var yb = null,
        zb = null,
        Ab = null;

    function Bb(_) {
        if (_ = Cb(_)) {
            if (typeof yb != "function") throw Error(p$2(280));
            var _e = _.stateNode;
            _e && (_e = Db(_e), yb(_.stateNode, _.type, _e))
        }
    }

    function Eb(_) {
        zb ? Ab ? Ab.push(_) : Ab = [_] : zb = _
    }

    function Fb() {
        if (zb) {
            var _ = zb,
                _e = Ab;
            if (Ab = zb = null, Bb(_), _e)
                for (_ = 0; _ < _e.length; _++) Bb(_e[_])
        }
    }

    function Gb(_, _e) {
        return _(_e)
    }

    function Hb() {}
    var Ib = !1;

    function Jb(_, _e, et) {
        if (Ib) return _(_e, et);
        Ib = !0;
        try {
            return Gb(_, _e, et)
        } finally {
            Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb())
        }
    }

    function Kb(_, _e) {
        var et = _.stateNode;
        if (et === null) return null;
        var tt = Db(et);
        if (tt === null) return null;
        et = tt[_e];
        e: switch (_e) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
                (tt = !tt.disabled) || (_ = _.type, tt = !(_ === "button" || _ === "input" || _ === "select" || _ === "textarea")), _ = !tt;
                break e;
            default:
                _ = !1
        }
        if (_) return null;
        if (et && typeof et != "function") throw Error(p$2(231, _e, typeof et));
        return et
    }
    var Lb = !1;
    if (ia) try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb)
    } catch (_) {
        Lb = !1
    }

    function Nb(_, _e, et, tt, nt, ot, at, st, lt) {
        var ut = Array.prototype.slice.call(arguments, 3);
        try {
            _e.apply(et, ut)
        } catch (dt) {
            this.onError(dt)
        }
    }
    var Ob = !1,
        Pb = null,
        Qb = !1,
        Rb = null,
        Sb = {
            onError: function(_) {
                Ob = !0, Pb = _
            }
        };

    function Tb(_, _e, et, tt, nt, ot, at, st, lt) {
        Ob = !1, Pb = null, Nb.apply(Sb, arguments)
    }

    function Ub(_, _e, et, tt, nt, ot, at, st, lt) {
        if (Tb.apply(this, arguments), Ob) {
            if (Ob) {
                var ut = Pb;
                Ob = !1, Pb = null
            } else throw Error(p$2(198));
            Qb || (Qb = !0, Rb = ut)
        }
    }

    function Vb(_) {
        var _e = _,
            et = _;
        if (_.alternate)
            for (; _e.return;) _e = _e.return;
        else {
            _ = _e;
            do _e = _, _e.flags & 4098 && (et = _e.return), _ = _e.return; while (_)
        }
        return _e.tag === 3 ? et : null
    }

    function Wb(_) {
        if (_.tag === 13) {
            var _e = _.memoizedState;
            if (_e === null && (_ = _.alternate, _ !== null && (_e = _.memoizedState)), _e !== null) return _e.dehydrated
        }
        return null
    }

    function Xb(_) {
        if (Vb(_) !== _) throw Error(p$2(188))
    }

    function Yb(_) {
        var _e = _.alternate;
        if (!_e) {
            if (_e = Vb(_), _e === null) throw Error(p$2(188));
            return _e !== _ ? null : _
        }
        for (var et = _, tt = _e;;) {
            var nt = et.return;
            if (nt === null) break;
            var ot = nt.alternate;
            if (ot === null) {
                if (tt = nt.return, tt !== null) {
                    et = tt;
                    continue
                }
                break
            }
            if (nt.child === ot.child) {
                for (ot = nt.child; ot;) {
                    if (ot === et) return Xb(nt), _;
                    if (ot === tt) return Xb(nt), _e;
                    ot = ot.sibling
                }
                throw Error(p$2(188))
            }
            if (et.return !== tt.return) et = nt, tt = ot;
            else {
                for (var at = !1, st = nt.child; st;) {
                    if (st === et) {
                        at = !0, et = nt, tt = ot;
                        break
                    }
                    if (st === tt) {
                        at = !0, tt = nt, et = ot;
                        break
                    }
                    st = st.sibling
                }
                if (!at) {
                    for (st = ot.child; st;) {
                        if (st === et) {
                            at = !0, et = ot, tt = nt;
                            break
                        }
                        if (st === tt) {
                            at = !0, tt = ot, et = nt;
                            break
                        }
                        st = st.sibling
                    }
                    if (!at) throw Error(p$2(189))
                }
            }
            if (et.alternate !== tt) throw Error(p$2(190))
        }
        if (et.tag !== 3) throw Error(p$2(188));
        return et.stateNode.current === et ? _ : _e
    }

    function Zb(_) {
        return _ = Yb(_), _ !== null ? $b(_) : null
    }

    function $b(_) {
        if (_.tag === 5 || _.tag === 6) return _;
        for (_ = _.child; _ !== null;) {
            var _e = $b(_);
            if (_e !== null) return _e;
            _ = _.sibling
        }
        return null
    }
    var ac = ca.unstable_scheduleCallback,
        bc = ca.unstable_cancelCallback,
        cc = ca.unstable_shouldYield,
        dc = ca.unstable_requestPaint,
        B$1 = ca.unstable_now,
        ec = ca.unstable_getCurrentPriorityLevel,
        fc = ca.unstable_ImmediatePriority,
        gc = ca.unstable_UserBlockingPriority,
        hc = ca.unstable_NormalPriority,
        ic = ca.unstable_LowPriority,
        jc = ca.unstable_IdlePriority,
        kc = null,
        lc = null;

    function mc(_) {
        if (lc && typeof lc.onCommitFiberRoot == "function") try {
            lc.onCommitFiberRoot(kc, _, void 0, (_.current.flags & 128) === 128)
        } catch (_e) {}
    }
    var oc = Math.clz32 ? Math.clz32 : nc,
        pc = Math.log,
        qc = Math.LN2;

    function nc(_) {
        return _ >>>= 0, _ === 0 ? 32 : 31 - (pc(_) / qc | 0) | 0
    }
    var rc = 64,
        sc = 4194304;

    function tc(_) {
        switch (_ & -_) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return _ & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return _ & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return _
        }
    }

    function uc(_, _e) {
        var et = _.pendingLanes;
        if (et === 0) return 0;
        var tt = 0,
            nt = _.suspendedLanes,
            ot = _.pingedLanes,
            at = et & 268435455;
        if (at !== 0) {
            var st = at & ~nt;
            st !== 0 ? tt = tc(st) : (ot &= at, ot !== 0 && (tt = tc(ot)))
        } else at = et & ~nt, at !== 0 ? tt = tc(at) : ot !== 0 && (tt = tc(ot));
        if (tt === 0) return 0;
        if (_e !== 0 && _e !== tt && !(_e & nt) && (nt = tt & -tt, ot = _e & -_e, nt >= ot || nt === 16 && (ot & 4194240) !== 0)) return _e;
        if (tt & 4 && (tt |= et & 16), _e = _.entangledLanes, _e !== 0)
            for (_ = _.entanglements, _e &= tt; 0 < _e;) et = 31 - oc(_e), nt = 1 << et, tt |= _[et], _e &= ~nt;
        return tt
    }

    function vc(_, _e) {
        switch (_) {
            case 1:
            case 2:
            case 4:
                return _e + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return _e + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }

    function wc(_, _e) {
        for (var et = _.suspendedLanes, tt = _.pingedLanes, nt = _.expirationTimes, ot = _.pendingLanes; 0 < ot;) {
            var at = 31 - oc(ot),
                st = 1 << at,
                lt = nt[at];
            lt === -1 ? (!(st & et) || st & tt) && (nt[at] = vc(st, _e)) : lt <= _e && (_.expiredLanes |= st), ot &= ~st
        }
    }

    function xc(_) {
        return _ = _.pendingLanes & -1073741825, _ !== 0 ? _ : _ & 1073741824 ? 1073741824 : 0
    }

    function yc() {
        var _ = rc;
        return rc <<= 1, !(rc & 4194240) && (rc = 64), _
    }

    function zc(_) {
        for (var _e = [], et = 0; 31 > et; et++) _e.push(_);
        return _e
    }

    function Ac(_, _e, et) {
        _.pendingLanes |= _e, _e !== 536870912 && (_.suspendedLanes = 0, _.pingedLanes = 0), _ = _.eventTimes, _e = 31 - oc(_e), _[_e] = et
    }

    function Bc(_, _e) {
        var et = _.pendingLanes & ~_e;
        _.pendingLanes = _e, _.suspendedLanes = 0, _.pingedLanes = 0, _.expiredLanes &= _e, _.mutableReadLanes &= _e, _.entangledLanes &= _e, _e = _.entanglements;
        var tt = _.eventTimes;
        for (_ = _.expirationTimes; 0 < et;) {
            var nt = 31 - oc(et),
                ot = 1 << nt;
            _e[nt] = 0, tt[nt] = -1, _[nt] = -1, et &= ~ot
        }
    }

    function Cc(_, _e) {
        var et = _.entangledLanes |= _e;
        for (_ = _.entanglements; et;) {
            var tt = 31 - oc(et),
                nt = 1 << tt;
            nt & _e | _[tt] & _e && (_[tt] |= _e), et &= ~nt
        }
    }
    var C$1 = 0;

    function Dc(_) {
        return _ &= -_, 1 < _ ? 4 < _ ? _ & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = !1,
        Kc = [],
        Lc = null,
        Mc = null,
        Nc = null,
        Oc = new Map,
        Pc = new Map,
        Qc = [],
        Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

    function Sc(_, _e) {
        switch (_) {
            case "focusin":
            case "focusout":
                Lc = null;
                break;
            case "dragenter":
            case "dragleave":
                Mc = null;
                break;
            case "mouseover":
            case "mouseout":
                Nc = null;
                break;
            case "pointerover":
            case "pointerout":
                Oc.delete(_e.pointerId);
                break;
            case "gotpointercapture":
            case "lostpointercapture":
                Pc.delete(_e.pointerId)
        }
    }

    function Tc(_, _e, et, tt, nt, ot) {
        return _ === null || _.nativeEvent !== ot ? (_ = {
            blockedOn: _e,
            domEventName: et,
            eventSystemFlags: tt,
            nativeEvent: ot,
            targetContainers: [nt]
        }, _e !== null && (_e = Cb(_e), _e !== null && Fc(_e)), _) : (_.eventSystemFlags |= tt, _e = _.targetContainers, nt !== null && _e.indexOf(nt) === -1 && _e.push(nt), _)
    }

    function Uc(_, _e, et, tt, nt) {
        switch (_e) {
            case "focusin":
                return Lc = Tc(Lc, _, _e, et, tt, nt), !0;
            case "dragenter":
                return Mc = Tc(Mc, _, _e, et, tt, nt), !0;
            case "mouseover":
                return Nc = Tc(Nc, _, _e, et, tt, nt), !0;
            case "pointerover":
                var ot = nt.pointerId;
                return Oc.set(ot, Tc(Oc.get(ot) || null, _, _e, et, tt, nt)), !0;
            case "gotpointercapture":
                return ot = nt.pointerId, Pc.set(ot, Tc(Pc.get(ot) || null, _, _e, et, tt, nt)), !0
        }
        return !1
    }

    function Vc(_) {
        var _e = Wc(_.target);
        if (_e !== null) {
            var et = Vb(_e);
            if (et !== null) {
                if (_e = et.tag, _e === 13) {
                    if (_e = Wb(et), _e !== null) {
                        _.blockedOn = _e, Ic(_.priority, function() {
                            Gc(et)
                        });
                        return
                    }
                } else if (_e === 3 && et.stateNode.current.memoizedState.isDehydrated) {
                    _.blockedOn = et.tag === 3 ? et.stateNode.containerInfo : null;
                    return
                }
            }
        }
        _.blockedOn = null
    }

    function Xc(_) {
        if (_.blockedOn !== null) return !1;
        for (var _e = _.targetContainers; 0 < _e.length;) {
            var et = Yc(_.domEventName, _.eventSystemFlags, _e[0], _.nativeEvent);
            if (et === null) {
                et = _.nativeEvent;
                var tt = new et.constructor(et.type, et);
                wb = tt, et.target.dispatchEvent(tt), wb = null
            } else return _e = Cb(et), _e !== null && Fc(_e), _.blockedOn = et, !1;
            _e.shift()
        }
        return !0
    }

    function Zc(_, _e, et) {
        Xc(_) && et.delete(_e)
    }

    function $c() {
        Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc)
    }

    function ad(_, _e) {
        _.blockedOn === _e && (_.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
    }

    function bd(_) {
        function _e(nt) {
            return ad(nt, _)
        }
        if (0 < Kc.length) {
            ad(Kc[0], _);
            for (var et = 1; et < Kc.length; et++) {
                var tt = Kc[et];
                tt.blockedOn === _ && (tt.blockedOn = null)
            }
        }
        for (Lc !== null && ad(Lc, _), Mc !== null && ad(Mc, _), Nc !== null && ad(Nc, _), Oc.forEach(_e), Pc.forEach(_e), et = 0; et < Qc.length; et++) tt = Qc[et], tt.blockedOn === _ && (tt.blockedOn = null);
        for (; 0 < Qc.length && (et = Qc[0], et.blockedOn === null);) Vc(et), et.blockedOn === null && Qc.shift()
    }
    var cd = ua.ReactCurrentBatchConfig,
        dd = !0;

    function ed(_, _e, et, tt) {
        var nt = C$1,
            ot = cd.transition;
        cd.transition = null;
        try {
            C$1 = 1, fd(_, _e, et, tt)
        } finally {
            C$1 = nt, cd.transition = ot
        }
    }

    function gd(_, _e, et, tt) {
        var nt = C$1,
            ot = cd.transition;
        cd.transition = null;
        try {
            C$1 = 4, fd(_, _e, et, tt)
        } finally {
            C$1 = nt, cd.transition = ot
        }
    }

    function fd(_, _e, et, tt) {
        if (dd) {
            var nt = Yc(_, _e, et, tt);
            if (nt === null) hd(_, _e, tt, id, et), Sc(_, tt);
            else if (Uc(nt, _, _e, et, tt)) tt.stopPropagation();
            else if (Sc(_, tt), _e & 4 && -1 < Rc.indexOf(_)) {
                for (; nt !== null;) {
                    var ot = Cb(nt);
                    if (ot !== null && Ec(ot), ot = Yc(_, _e, et, tt), ot === null && hd(_, _e, tt, id, et), ot === nt) break;
                    nt = ot
                }
                nt !== null && tt.stopPropagation()
            } else hd(_, _e, tt, null, et)
        }
    }
    var id = null;

    function Yc(_, _e, et, tt) {
        if (id = null, _ = xb(tt), _ = Wc(_), _ !== null)
            if (_e = Vb(_), _e === null) _ = null;
            else if (et = _e.tag, et === 13) {
            if (_ = Wb(_e), _ !== null) return _;
            _ = null
        } else if (et === 3) {
            if (_e.stateNode.current.memoizedState.isDehydrated) return _e.tag === 3 ? _e.stateNode.containerInfo : null;
            _ = null
        } else _e !== _ && (_ = null);
        return id = _, null
    }

    function jd(_) {
        switch (_) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
                return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
                return 4;
            case "message":
                switch (ec()) {
                    case fc:
                        return 1;
                    case gc:
                        return 4;
                    case hc:
                    case ic:
                        return 16;
                    case jc:
                        return 536870912;
                    default:
                        return 16
                }
            default:
                return 16
        }
    }
    var kd = null,
        ld = null,
        md = null;

    function nd() {
        if (md) return md;
        var _, _e = ld,
            et = _e.length,
            tt, nt = "value" in kd ? kd.value : kd.textContent,
            ot = nt.length;
        for (_ = 0; _ < et && _e[_] === nt[_]; _++);
        var at = et - _;
        for (tt = 1; tt <= at && _e[et - tt] === nt[ot - tt]; tt++);
        return md = nt.slice(_, 1 < tt ? 1 - tt : void 0)
    }

    function od(_) {
        var _e = _.keyCode;
        return "charCode" in _ ? (_ = _.charCode, _ === 0 && _e === 13 && (_ = 13)) : _ = _e, _ === 10 && (_ = 13), 32 <= _ || _ === 13 ? _ : 0
    }

    function pd() {
        return !0
    }

    function qd() {
        return !1
    }

    function rd(_) {
        function _e(et, tt, nt, ot, at) {
            this._reactName = et, this._targetInst = nt, this.type = tt, this.nativeEvent = ot, this.target = at, this.currentTarget = null;
            for (var st in _) _.hasOwnProperty(st) && (et = _[st], this[st] = et ? et(ot) : ot[st]);
            return this.isDefaultPrevented = (ot.defaultPrevented != null ? ot.defaultPrevented : ot.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this
        }
        return A(_e.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var et = this.nativeEvent;
                et && (et.preventDefault ? et.preventDefault() : typeof et.returnValue != "unknown" && (et.returnValue = !1), this.isDefaultPrevented = pd)
            },
            stopPropagation: function() {
                var et = this.nativeEvent;
                et && (et.stopPropagation ? et.stopPropagation() : typeof et.cancelBubble != "unknown" && (et.cancelBubble = !0), this.isPropagationStopped = pd)
            },
            persist: function() {},
            isPersistent: pd
        }), _e
    }
    var sd = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(_) {
                return _.timeStamp || Date.now()
            },
            defaultPrevented: 0,
            isTrusted: 0
        },
        td = rd(sd),
        ud = A({}, sd, {
            view: 0,
            detail: 0
        }),
        vd = rd(ud),
        wd, xd, yd, Ad = A({}, ud, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: zd,
            button: 0,
            buttons: 0,
            relatedTarget: function(_) {
                return _.relatedTarget === void 0 ? _.fromElement === _.srcElement ? _.toElement : _.fromElement : _.relatedTarget
            },
            movementX: function(_) {
                return "movementX" in _ ? _.movementX : (_ !== yd && (yd && _.type === "mousemove" ? (wd = _.screenX - yd.screenX, xd = _.screenY - yd.screenY) : xd = wd = 0, yd = _), wd)
            },
            movementY: function(_) {
                return "movementY" in _ ? _.movementY : xd
            }
        }),
        Bd = rd(Ad),
        Cd = A({}, Ad, {
            dataTransfer: 0
        }),
        Dd = rd(Cd),
        Ed = A({}, ud, {
            relatedTarget: 0
        }),
        Fd = rd(Ed),
        Gd = A({}, sd, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }),
        Hd = rd(Gd),
        Id = A({}, sd, {
            clipboardData: function(_) {
                return "clipboardData" in _ ? _.clipboardData : window.clipboardData
            }
        }),
        Jd = rd(Id),
        Kd = A({}, sd, {
            data: 0
        }),
        Ld = rd(Kd),
        Md = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        },
        Nd = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        },
        Od = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };

    function Pd(_) {
        var _e = this.nativeEvent;
        return _e.getModifierState ? _e.getModifierState(_) : (_ = Od[_]) ? !!_e[_] : !1
    }

    function zd() {
        return Pd
    }
    var Qd = A({}, ud, {
            key: function(_) {
                if (_.key) {
                    var _e = Md[_.key] || _.key;
                    if (_e !== "Unidentified") return _e
                }
                return _.type === "keypress" ? (_ = od(_), _ === 13 ? "Enter" : String.fromCharCode(_)) : _.type === "keydown" || _.type === "keyup" ? Nd[_.keyCode] || "Unidentified" : ""
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: zd,
            charCode: function(_) {
                return _.type === "keypress" ? od(_) : 0
            },
            keyCode: function(_) {
                return _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0
            },
            which: function(_) {
                return _.type === "keypress" ? od(_) : _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0
            }
        }),
        Rd = rd(Qd),
        Sd = A({}, Ad, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }),
        Td = rd(Sd),
        Ud = A({}, ud, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: zd
        }),
        Vd = rd(Ud),
        Wd = A({}, sd, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }),
        Xd = rd(Wd),
        Yd = A({}, Ad, {
            deltaX: function(_) {
                return "deltaX" in _ ? _.deltaX : "wheelDeltaX" in _ ? -_.wheelDeltaX : 0
            },
            deltaY: function(_) {
                return "deltaY" in _ ? _.deltaY : "wheelDeltaY" in _ ? -_.wheelDeltaY : "wheelDelta" in _ ? -_.wheelDelta : 0
            },
            deltaZ: 0,
            deltaMode: 0
        }),
        Zd = rd(Yd),
        $d = [9, 13, 27, 32],
        ae = ia && "CompositionEvent" in window,
        be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be,
        de$1 = ia && (!ae || be && 8 < be && 11 >= be),
        ee = String.fromCharCode(32),
        fe = !1;

    function ge(_, _e) {
        switch (_) {
            case "keyup":
                return $d.indexOf(_e.keyCode) !== -1;
            case "keydown":
                return _e.keyCode !== 229;
            case "keypress":
            case "mousedown":
            case "focusout":
                return !0;
            default:
                return !1
        }
    }

    function he(_) {
        return _ = _.detail, typeof _ == "object" && "data" in _ ? _.data : null
    }
    var ie = !1;

    function je(_, _e) {
        switch (_) {
            case "compositionend":
                return he(_e);
            case "keypress":
                return _e.which !== 32 ? null : (fe = !0, ee);
            case "textInput":
                return _ = _e.data, _ === ee && fe ? null : _;
            default:
                return null
        }
    }

    function ke(_, _e) {
        if (ie) return _ === "compositionend" || !ae && ge(_, _e) ? (_ = nd(), md = ld = kd = null, ie = !1, _) : null;
        switch (_) {
            case "paste":
                return null;
            case "keypress":
                if (!(_e.ctrlKey || _e.altKey || _e.metaKey) || _e.ctrlKey && _e.altKey) {
                    if (_e.char && 1 < _e.char.length) return _e.char;
                    if (_e.which) return String.fromCharCode(_e.which)
                }
                return null;
            case "compositionend":
                return de$1 && _e.locale !== "ko" ? null : _e.data;
            default:
                return null
        }
    }
    var le = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };

    function me(_) {
        var _e = _ && _.nodeName && _.nodeName.toLowerCase();
        return _e === "input" ? !!le[_.type] : _e === "textarea"
    }

    function ne(_, _e, et, tt) {
        Eb(tt), _e = oe(_e, "onChange"), 0 < _e.length && (et = new td("onChange", "change", null, et, tt), _.push({
            event: et,
            listeners: _e
        }))
    }
    var pe = null,
        qe = null;

    function re$1(_) {
        se(_, 0)
    }

    function te(_) {
        var _e = ue(_);
        if (Wa(_e)) return _
    }

    function ve(_, _e) {
        if (_ === "change") return _e
    }
    var we$1 = !1;
    if (ia) {
        var xe;
        if (ia) {
            var ye = "oninput" in document;
            if (!ye) {
                var ze = document.createElement("div");
                ze.setAttribute("oninput", "return;"), ye = typeof ze.oninput == "function"
            }
            xe = ye
        } else xe = !1;
        we$1 = xe && (!document.documentMode || 9 < document.documentMode)
    }

    function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null)
    }

    function Be(_) {
        if (_.propertyName === "value" && te(qe)) {
            var _e = [];
            ne(_e, qe, _, xb(_)), Jb(re$1, _e)
        }
    }

    function Ce(_, _e, et) {
        _ === "focusin" ? (Ae(), pe = _e, qe = et, pe.attachEvent("onpropertychange", Be)) : _ === "focusout" && Ae()
    }

    function De(_) {
        if (_ === "selectionchange" || _ === "keyup" || _ === "keydown") return te(qe)
    }

    function Ee(_, _e) {
        if (_ === "click") return te(_e)
    }

    function Fe(_, _e) {
        if (_ === "input" || _ === "change") return te(_e)
    }

    function Ge(_, _e) {
        return _ === _e && (_ !== 0 || 1 / _ === 1 / _e) || _ !== _ && _e !== _e
    }
    var He = typeof Object.is == "function" ? Object.is : Ge;

    function Ie(_, _e) {
        if (He(_, _e)) return !0;
        if (typeof _ != "object" || _ === null || typeof _e != "object" || _e === null) return !1;
        var et = Object.keys(_),
            tt = Object.keys(_e);
        if (et.length !== tt.length) return !1;
        for (tt = 0; tt < et.length; tt++) {
            var nt = et[tt];
            if (!ja.call(_e, nt) || !He(_[nt], _e[nt])) return !1
        }
        return !0
    }

    function Je(_) {
        for (; _ && _.firstChild;) _ = _.firstChild;
        return _
    }

    function Ke(_, _e) {
        var et = Je(_);
        _ = 0;
        for (var tt; et;) {
            if (et.nodeType === 3) {
                if (tt = _ + et.textContent.length, _ <= _e && tt >= _e) return {
                    node: et,
                    offset: _e - _
                };
                _ = tt
            }
            e: {
                for (; et;) {
                    if (et.nextSibling) {
                        et = et.nextSibling;
                        break e
                    }
                    et = et.parentNode
                }
                et = void 0
            }
            et = Je(et)
        }
    }

    function Le(_, _e) {
        return _ && _e ? _ === _e ? !0 : _ && _.nodeType === 3 ? !1 : _e && _e.nodeType === 3 ? Le(_, _e.parentNode) : "contains" in _ ? _.contains(_e) : _.compareDocumentPosition ? !!(_.compareDocumentPosition(_e) & 16) : !1 : !1
    }

    function Me() {
        for (var _ = window, _e = Xa(); _e instanceof _.HTMLIFrameElement;) {
            try {
                var et = typeof _e.contentWindow.location.href == "string"
            } catch (tt) {
                et = !1
            }
            if (et) _ = _e.contentWindow;
            else break;
            _e = Xa(_.document)
        }
        return _e
    }

    function Ne(_) {
        var _e = _ && _.nodeName && _.nodeName.toLowerCase();
        return _e && (_e === "input" && (_.type === "text" || _.type === "search" || _.type === "tel" || _.type === "url" || _.type === "password") || _e === "textarea" || _.contentEditable === "true")
    }

    function Oe(_) {
        var _e = Me(),
            et = _.focusedElem,
            tt = _.selectionRange;
        if (_e !== et && et && et.ownerDocument && Le(et.ownerDocument.documentElement, et)) {
            if (tt !== null && Ne(et)) {
                if (_e = tt.start, _ = tt.end, _ === void 0 && (_ = _e), "selectionStart" in et) et.selectionStart = _e, et.selectionEnd = Math.min(_, et.value.length);
                else if (_ = (_e = et.ownerDocument || document) && _e.defaultView || window, _.getSelection) {
                    _ = _.getSelection();
                    var nt = et.textContent.length,
                        ot = Math.min(tt.start, nt);
                    tt = tt.end === void 0 ? ot : Math.min(tt.end, nt), !_.extend && ot > tt && (nt = tt, tt = ot, ot = nt), nt = Ke(et, ot);
                    var at = Ke(et, tt);
                    nt && at && (_.rangeCount !== 1 || _.anchorNode !== nt.node || _.anchorOffset !== nt.offset || _.focusNode !== at.node || _.focusOffset !== at.offset) && (_e = _e.createRange(), _e.setStart(nt.node, nt.offset), _.removeAllRanges(), ot > tt ? (_.addRange(_e), _.extend(at.node, at.offset)) : (_e.setEnd(at.node, at.offset), _.addRange(_e)))
                }
            }
            for (_e = [], _ = et; _ = _.parentNode;) _.nodeType === 1 && _e.push({
                element: _,
                left: _.scrollLeft,
                top: _.scrollTop
            });
            for (typeof et.focus == "function" && et.focus(), et = 0; et < _e.length; et++) _ = _e[et], _.element.scrollLeft = _.left, _.element.scrollTop = _.top
        }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
        Qe = null,
        Re = null,
        Se = null,
        Te = !1;

    function Ue$1(_, _e, et) {
        var tt = et.window === et ? et.document : et.nodeType === 9 ? et : et.ownerDocument;
        Te || Qe == null || Qe !== Xa(tt) || (tt = Qe, "selectionStart" in tt && Ne(tt) ? tt = {
            start: tt.selectionStart,
            end: tt.selectionEnd
        } : (tt = (tt.ownerDocument && tt.ownerDocument.defaultView || window).getSelection(), tt = {
            anchorNode: tt.anchorNode,
            anchorOffset: tt.anchorOffset,
            focusNode: tt.focusNode,
            focusOffset: tt.focusOffset
        }), Se && Ie(Se, tt) || (Se = tt, tt = oe(Re, "onSelect"), 0 < tt.length && (_e = new td("onSelect", "select", null, _e, et), _.push({
            event: _e,
            listeners: tt
        }), _e.target = Qe)))
    }

    function Ve(_, _e) {
        var et = {};
        return et[_.toLowerCase()] = _e.toLowerCase(), et["Webkit" + _] = "webkit" + _e, et["Moz" + _] = "moz" + _e, et
    }
    var We = {
            animationend: Ve("Animation", "AnimationEnd"),
            animationiteration: Ve("Animation", "AnimationIteration"),
            animationstart: Ve("Animation", "AnimationStart"),
            transitionend: Ve("Transition", "TransitionEnd")
        },
        Xe = {},
        Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);

    function Ze(_) {
        if (Xe[_]) return Xe[_];
        if (!We[_]) return _;
        var _e = We[_],
            et;
        for (et in _e)
            if (_e.hasOwnProperty(et) && et in Ye) return Xe[_] = _e[et];
        return _
    }
    var $e = Ze("animationend"),
        af = Ze("animationiteration"),
        bf = Ze("animationstart"),
        cf = Ze("transitionend"),
        df = new Map,
        ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

    function ff(_, _e) {
        df.set(_, _e), fa(_e, [_])
    }
    for (var gf = 0; gf < ef.length; gf++) {
        var hf = ef[gf],
            jf = hf.toLowerCase(),
            kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf)
    }
    ff($e, "onAnimationEnd"), ff(af, "onAnimationIteration"), ff(bf, "onAnimationStart"), ff("dblclick", "onDoubleClick"), ff("focusin", "onFocus"), ff("focusout", "onBlur"), ff(cf, "onTransitionEnd"), ha("onMouseEnter", ["mouseout", "mouseover"]), ha("onMouseLeave", ["mouseout", "mouseover"]), ha("onPointerEnter", ["pointerout", "pointerover"]), ha("onPointerLeave", ["pointerout", "pointerover"]), fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
        mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));

    function nf(_, _e, et) {
        var tt = _.type || "unknown-event";
        _.currentTarget = et, Ub(tt, _e, void 0, _), _.currentTarget = null
    }

    function se(_, _e) {
        _e = (_e & 4) !== 0;
        for (var et = 0; et < _.length; et++) {
            var tt = _[et],
                nt = tt.event;
            tt = tt.listeners;
            e: {
                var ot = void 0;
                if (_e)
                    for (var at = tt.length - 1; 0 <= at; at--) {
                        var st = tt[at],
                            lt = st.instance,
                            ut = st.currentTarget;
                        if (st = st.listener, lt !== ot && nt.isPropagationStopped()) break e;
                        nf(nt, st, ut), ot = lt
                    } else
                        for (at = 0; at < tt.length; at++) {
                            if (st = tt[at], lt = st.instance, ut = st.currentTarget, st = st.listener, lt !== ot && nt.isPropagationStopped()) break e;
                            nf(nt, st, ut), ot = lt
                        }
            }
        }
        if (Qb) throw _ = Rb, Qb = !1, Rb = null, _
    }

    function D$1(_, _e) {
        var et = _e[ of ];
        et === void 0 && (et = _e[ of ] = new Set);
        var tt = _ + "__bubble";
        et.has(tt) || (pf(_e, _, 2, !1), et.add(tt))
    }

    function qf(_, _e, et) {
        var tt = 0;
        _e && (tt |= 4), pf(et, _, tt, _e)
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);

    function sf(_) {
        if (!_[rf]) {
            _[rf] = !0, da.forEach(function(et) {
                et !== "selectionchange" && (mf.has(et) || qf(et, !1, _), qf(et, !0, _))
            });
            var _e = _.nodeType === 9 ? _ : _.ownerDocument;
            _e === null || _e[rf] || (_e[rf] = !0, qf("selectionchange", !1, _e))
        }
    }

    function pf(_, _e, et, tt) {
        switch (jd(_e)) {
            case 1:
                var nt = ed;
                break;
            case 4:
                nt = gd;
                break;
            default:
                nt = fd
        }
        et = nt.bind(null, _e, et, _), nt = void 0, !Lb || _e !== "touchstart" && _e !== "touchmove" && _e !== "wheel" || (nt = !0), tt ? nt !== void 0 ? _.addEventListener(_e, et, {
            capture: !0,
            passive: nt
        }) : _.addEventListener(_e, et, !0) : nt !== void 0 ? _.addEventListener(_e, et, {
            passive: nt
        }) : _.addEventListener(_e, et, !1)
    }

    function hd(_, _e, et, tt, nt) {
        var ot = tt;
        if (!(_e & 1) && !(_e & 2) && tt !== null) e: for (;;) {
            if (tt === null) return;
            var at = tt.tag;
            if (at === 3 || at === 4) {
                var st = tt.stateNode.containerInfo;
                if (st === nt || st.nodeType === 8 && st.parentNode === nt) break;
                if (at === 4)
                    for (at = tt.return; at !== null;) {
                        var lt = at.tag;
                        if ((lt === 3 || lt === 4) && (lt = at.stateNode.containerInfo, lt === nt || lt.nodeType === 8 && lt.parentNode === nt)) return;
                        at = at.return
                    }
                for (; st !== null;) {
                    if (at = Wc(st), at === null) return;
                    if (lt = at.tag, lt === 5 || lt === 6) {
                        tt = ot = at;
                        continue e
                    }
                    st = st.parentNode
                }
            }
            tt = tt.return
        }
        Jb(function() {
            var ut = ot,
                dt = xb(et),
                ct = [];
            e: {
                var pt = df.get(_);
                if (pt !== void 0) {
                    var ft = td,
                        ht = _;
                    switch (_) {
                        case "keypress":
                            if (od(et) === 0) break e;
                        case "keydown":
                        case "keyup":
                            ft = Rd;
                            break;
                        case "focusin":
                            ht = "focus", ft = Fd;
                            break;
                        case "focusout":
                            ht = "blur", ft = Fd;
                            break;
                        case "beforeblur":
                        case "afterblur":
                            ft = Fd;
                            break;
                        case "click":
                            if (et.button === 2) break e;
                        case "auxclick":
                        case "dblclick":
                        case "mousedown":
                        case "mousemove":
                        case "mouseup":
                        case "mouseout":
                        case "mouseover":
                        case "contextmenu":
                            ft = Bd;
                            break;
                        case "drag":
                        case "dragend":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "dragstart":
                        case "drop":
                            ft = Dd;
                            break;
                        case "touchcancel":
                        case "touchend":
                        case "touchmove":
                        case "touchstart":
                            ft = Vd;
                            break;
                        case $e:
                        case af:
                        case bf:
                            ft = Hd;
                            break;
                        case cf:
                            ft = Xd;
                            break;
                        case "scroll":
                            ft = vd;
                            break;
                        case "wheel":
                            ft = Zd;
                            break;
                        case "copy":
                        case "cut":
                        case "paste":
                            ft = Jd;
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerup":
                            ft = Td
                    }
                    var mt = (_e & 4) !== 0,
                        bt = !mt && _ === "scroll",
                        gt = mt ? pt !== null ? pt + "Capture" : null : pt;
                    mt = [];
                    for (var vt = ut, xt; vt !== null;) {
                        xt = vt;
                        var yt = xt.stateNode;
                        if (xt.tag === 5 && yt !== null && (xt = yt, gt !== null && (yt = Kb(vt, gt), yt != null && mt.push(tf(vt, yt, xt)))), bt) break;
                        vt = vt.return
                    }
                    0 < mt.length && (pt = new ft(pt, ht, null, et, dt), ct.push({
                        event: pt,
                        listeners: mt
                    }))
                }
            }
            if (!(_e & 7)) {
                e: {
                    if (pt = _ === "mouseover" || _ === "pointerover", ft = _ === "mouseout" || _ === "pointerout", pt && et !== wb && (ht = et.relatedTarget || et.fromElement) && (Wc(ht) || ht[uf])) break e;
                    if ((ft || pt) && (pt = dt.window === dt ? dt : (pt = dt.ownerDocument) ? pt.defaultView || pt.parentWindow : window, ft ? (ht = et.relatedTarget || et.toElement, ft = ut, ht = ht ? Wc(ht) : null, ht !== null && (bt = Vb(ht), ht !== bt || ht.tag !== 5 && ht.tag !== 6) && (ht = null)) : (ft = null, ht = ut), ft !== ht)) {
                        if (mt = Bd, yt = "onMouseLeave", gt = "onMouseEnter", vt = "mouse", (_ === "pointerout" || _ === "pointerover") && (mt = Td, yt = "onPointerLeave", gt = "onPointerEnter", vt = "pointer"), bt = ft == null ? pt : ue(ft), xt = ht == null ? pt : ue(ht), pt = new mt(yt, vt + "leave", ft, et, dt), pt.target = bt, pt.relatedTarget = xt, yt = null, Wc(dt) === ut && (mt = new mt(gt, vt + "enter", ht, et, dt), mt.target = xt, mt.relatedTarget = bt, yt = mt), bt = yt, ft && ht) t: {
                            for (mt = ft, gt = ht, vt = 0, xt = mt; xt; xt = vf(xt)) vt++;
                            for (xt = 0, yt = gt; yt; yt = vf(yt)) xt++;
                            for (; 0 < vt - xt;) mt = vf(mt),
                            vt--;
                            for (; 0 < xt - vt;) gt = vf(gt),
                            xt--;
                            for (; vt--;) {
                                if (mt === gt || gt !== null && mt === gt.alternate) break t;
                                mt = vf(mt), gt = vf(gt)
                            }
                            mt = null
                        }
                        else mt = null;
                        ft !== null && wf(ct, pt, ft, mt, !1), ht !== null && bt !== null && wf(ct, bt, ht, mt, !0)
                    }
                }
                e: {
                    if (pt = ut ? ue(ut) : window, ft = pt.nodeName && pt.nodeName.toLowerCase(), ft === "select" || ft === "input" && pt.type === "file") var Et = ve;
                    else if (me(pt))
                        if (we$1) Et = Fe;
                        else {
                            Et = De;
                            var wt = Ce
                        }
                    else(ft = pt.nodeName) && ft.toLowerCase() === "input" && (pt.type === "checkbox" || pt.type === "radio") && (Et = Ee);
                    if (Et && (Et = Et(_, ut))) {
                        ne(ct, Et, et, dt);
                        break e
                    }
                    wt && wt(_, pt, ut),
                    _ === "focusout" && (wt = pt._wrapperState) && wt.controlled && pt.type === "number" && cb(pt, "number", pt.value)
                }
                switch (wt = ut ? ue(ut) : window, _) {
                    case "focusin":
                        (me(wt) || wt.contentEditable === "true") && (Qe = wt, Re = ut, Se = null);
                        break;
                    case "focusout":
                        Se = Re = Qe = null;
                        break;
                    case "mousedown":
                        Te = !0;
                        break;
                    case "contextmenu":
                    case "mouseup":
                    case "dragend":
                        Te = !1, Ue$1(ct, et, dt);
                        break;
                    case "selectionchange":
                        if (Pe) break;
                    case "keydown":
                    case "keyup":
                        Ue$1(ct, et, dt)
                }
                var St;
                if (ae) e: {
                    switch (_) {
                        case "compositionstart":
                            var $t = "onCompositionStart";
                            break e;
                        case "compositionend":
                            $t = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            $t = "onCompositionUpdate";
                            break e
                    }
                    $t = void 0
                }
                else ie ? ge(_, et) && ($t = "onCompositionEnd") : _ === "keydown" && et.keyCode === 229 && ($t = "onCompositionStart");$t && (de$1 && et.locale !== "ko" && (ie || $t !== "onCompositionStart" ? $t === "onCompositionEnd" && ie && (St = nd()) : (kd = dt, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), wt = oe(ut, $t), 0 < wt.length && ($t = new Ld($t, _, null, et, dt), ct.push({
                    event: $t,
                    listeners: wt
                }), St ? $t.data = St : (St = he(et), St !== null && ($t.data = St)))),
                (St = ce ? je(_, et) : ke(_, et)) && (ut = oe(ut, "onBeforeInput"), 0 < ut.length && (dt = new Ld("onBeforeInput", "beforeinput", null, et, dt), ct.push({
                    event: dt,
                    listeners: ut
                }), dt.data = St))
            }
            se(ct, _e)
        })
    }

    function tf(_, _e, et) {
        return {
            instance: _,
            listener: _e,
            currentTarget: et
        }
    }

    function oe(_, _e) {
        for (var et = _e + "Capture", tt = []; _ !== null;) {
            var nt = _,
                ot = nt.stateNode;
            nt.tag === 5 && ot !== null && (nt = ot, ot = Kb(_, et), ot != null && tt.unshift(tf(_, ot, nt)), ot = Kb(_, _e), ot != null && tt.push(tf(_, ot, nt))), _ = _.return
        }
        return tt
    }

    function vf(_) {
        if (_ === null) return null;
        do _ = _.return; while (_ && _.tag !== 5);
        return _ || null
    }

    function wf(_, _e, et, tt, nt) {
        for (var ot = _e._reactName, at = []; et !== null && et !== tt;) {
            var st = et,
                lt = st.alternate,
                ut = st.stateNode;
            if (lt !== null && lt === tt) break;
            st.tag === 5 && ut !== null && (st = ut, nt ? (lt = Kb(et, ot), lt != null && at.unshift(tf(et, lt, st))) : nt || (lt = Kb(et, ot), lt != null && at.push(tf(et, lt, st)))), et = et.return
        }
        at.length !== 0 && _.push({
            event: _e,
            listeners: at
        })
    }
    var xf = /\r\n?/g,
        yf = /\u0000|\uFFFD/g;

    function zf(_) {
        return (typeof _ == "string" ? _ : "" + _).replace(xf, `
`).replace(yf, "")
    }

    function Af(_, _e, et) {
        if (_e = zf(_e), zf(_) !== _e && et) throw Error(p$2(425))
    }

    function Bf() {}
    var Cf = null,
        Df = null;

    function Ef(_, _e) {
        return _ === "textarea" || _ === "noscript" || typeof _e.children == "string" || typeof _e.children == "number" || typeof _e.dangerouslySetInnerHTML == "object" && _e.dangerouslySetInnerHTML !== null && _e.dangerouslySetInnerHTML.__html != null
    }
    var Ff = typeof setTimeout == "function" ? setTimeout : void 0,
        Gf = typeof clearTimeout == "function" ? clearTimeout : void 0,
        Hf = typeof Promise == "function" ? Promise : void 0,
        Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(_) {
            return Hf.resolve(null).then(_).catch(If)
        } : Ff;

    function If(_) {
        setTimeout(function() {
            throw _
        })
    }

    function Kf(_, _e) {
        var et = _e,
            tt = 0;
        do {
            var nt = et.nextSibling;
            if (_.removeChild(et), nt && nt.nodeType === 8)
                if (et = nt.data, et === "/$") {
                    if (tt === 0) {
                        _.removeChild(nt), bd(_e);
                        return
                    }
                    tt--
                } else et !== "$" && et !== "$?" && et !== "$!" || tt++;
            et = nt
        } while (et);
        bd(_e)
    }

    function Lf(_) {
        for (; _ != null; _ = _.nextSibling) {
            var _e = _.nodeType;
            if (_e === 1 || _e === 3) break;
            if (_e === 8) {
                if (_e = _.data, _e === "$" || _e === "$!" || _e === "$?") break;
                if (_e === "/$") return null
            }
        }
        return _
    }

    function Mf(_) {
        _ = _.previousSibling;
        for (var _e = 0; _;) {
            if (_.nodeType === 8) {
                var et = _.data;
                if (et === "$" || et === "$!" || et === "$?") {
                    if (_e === 0) return _;
                    _e--
                } else et === "/$" && _e++
            }
            _ = _.previousSibling
        }
        return null
    }
    var Nf = Math.random().toString(36).slice(2),
        Of = "__reactFiber$" + Nf,
        Pf = "__reactProps$" + Nf,
        uf = "__reactContainer$" + Nf,
        of = "__reactEvents$" + Nf,
        Qf = "__reactListeners$" + Nf,
        Rf = "__reactHandles$" + Nf;

    function Wc(_) {
        var _e = _[Of];
        if (_e) return _e;
        for (var et = _.parentNode; et;) {
            if (_e = et[uf] || et[Of]) {
                if (et = _e.alternate, _e.child !== null || et !== null && et.child !== null)
                    for (_ = Mf(_); _ !== null;) {
                        if (et = _[Of]) return et;
                        _ = Mf(_)
                    }
                return _e
            }
            _ = et, et = _.parentNode
        }
        return null
    }

    function Cb(_) {
        return _ = _[Of] || _[uf], !_ || _.tag !== 5 && _.tag !== 6 && _.tag !== 13 && _.tag !== 3 ? null : _
    }

    function ue(_) {
        if (_.tag === 5 || _.tag === 6) return _.stateNode;
        throw Error(p$2(33))
    }

    function Db(_) {
        return _[Pf] || null
    }
    var Sf = [],
        Tf = -1;

    function Uf(_) {
        return {
            current: _
        }
    }

    function E$1(_) {
        0 > Tf || (_.current = Sf[Tf], Sf[Tf] = null, Tf--)
    }

    function G(_, _e) {
        Tf++, Sf[Tf] = _.current, _.current = _e
    }
    var Vf = {},
        H = Uf(Vf),
        Wf = Uf(!1),
        Xf = Vf;

    function Yf(_, _e) {
        var et = _.type.contextTypes;
        if (!et) return Vf;
        var tt = _.stateNode;
        if (tt && tt.__reactInternalMemoizedUnmaskedChildContext === _e) return tt.__reactInternalMemoizedMaskedChildContext;
        var nt = {},
            ot;
        for (ot in et) nt[ot] = _e[ot];
        return tt && (_ = _.stateNode, _.__reactInternalMemoizedUnmaskedChildContext = _e, _.__reactInternalMemoizedMaskedChildContext = nt), nt
    }

    function Zf(_) {
        return _ = _.childContextTypes, _ != null
    }

    function $f() {
        E$1(Wf), E$1(H)
    }

    function ag(_, _e, et) {
        if (H.current !== Vf) throw Error(p$2(168));
        G(H, _e), G(Wf, et)
    }

    function bg(_, _e, et) {
        var tt = _.stateNode;
        if (_e = _e.childContextTypes, typeof tt.getChildContext != "function") return et;
        tt = tt.getChildContext();
        for (var nt in tt)
            if (!(nt in _e)) throw Error(p$2(108, Ra(_) || "Unknown", nt));
        return A({}, et, tt)
    }

    function cg(_) {
        return _ = (_ = _.stateNode) && _.__reactInternalMemoizedMergedChildContext || Vf, Xf = H.current, G(H, _), G(Wf, Wf.current), !0
    }

    function dg(_, _e, et) {
        var tt = _.stateNode;
        if (!tt) throw Error(p$2(169));
        et ? (_ = bg(_, _e, Xf), tt.__reactInternalMemoizedMergedChildContext = _, E$1(Wf), E$1(H), G(H, _)) : E$1(Wf), G(Wf, et)
    }
    var eg = null,
        fg = !1,
        gg = !1;

    function hg(_) {
        eg === null ? eg = [_] : eg.push(_)
    }

    function ig(_) {
        fg = !0, hg(_)
    }

    function jg() {
        if (!gg && eg !== null) {
            gg = !0;
            var _ = 0,
                _e = C$1;
            try {
                var et = eg;
                for (C$1 = 1; _ < et.length; _++) {
                    var tt = et[_];
                    do tt = tt(!0); while (tt !== null)
                }
                eg = null, fg = !1
            } catch (nt) {
                throw eg !== null && (eg = eg.slice(_ + 1)), ac(fc, jg), nt
            } finally {
                C$1 = _e, gg = !1
            }
        }
        return null
    }
    var kg = [],
        lg = 0,
        mg = null,
        ng = 0,
        og = [],
        pg = 0,
        qg = null,
        rg = 1,
        sg = "";

    function tg(_, _e) {
        kg[lg++] = ng, kg[lg++] = mg, mg = _, ng = _e
    }

    function ug(_, _e, et) {
        og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = _;
        var tt = rg;
        _ = sg;
        var nt = 32 - oc(tt) - 1;
        tt &= ~(1 << nt), et += 1;
        var ot = 32 - oc(_e) + nt;
        if (30 < ot) {
            var at = nt - nt % 5;
            ot = (tt & (1 << at) - 1).toString(32), tt >>= at, nt -= at, rg = 1 << 32 - oc(_e) + nt | et << nt | tt, sg = ot + _
        } else rg = 1 << ot | et << nt | tt, sg = _
    }

    function vg(_) {
        _.return !== null && (tg(_, 1), ug(_, 1, 0))
    }

    function wg(_) {
        for (; _ === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; _ === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null
    }
    var xg = null,
        yg = null,
        I = !1,
        zg = null;

    function Ag(_, _e) {
        var et = Bg(5, null, null, 0);
        et.elementType = "DELETED", et.stateNode = _e, et.return = _, _e = _.deletions, _e === null ? (_.deletions = [et], _.flags |= 16) : _e.push(et)
    }

    function Cg(_, _e) {
        switch (_.tag) {
            case 5:
                var et = _.type;
                return _e = _e.nodeType !== 1 || et.toLowerCase() !== _e.nodeName.toLowerCase() ? null : _e, _e !== null ? (_.stateNode = _e, xg = _, yg = Lf(_e.firstChild), !0) : !1;
            case 6:
                return _e = _.pendingProps === "" || _e.nodeType !== 3 ? null : _e, _e !== null ? (_.stateNode = _e, xg = _, yg = null, !0) : !1;
            case 13:
                return _e = _e.nodeType !== 8 ? null : _e, _e !== null ? (et = qg !== null ? {
                    id: rg,
                    overflow: sg
                } : null, _.memoizedState = {
                    dehydrated: _e,
                    treeContext: et,
                    retryLane: 1073741824
                }, et = Bg(18, null, null, 0), et.stateNode = _e, et.return = _, _.child = et, xg = _, yg = null, !0) : !1;
            default:
                return !1
        }
    }

    function Dg(_) {
        return (_.mode & 1) !== 0 && (_.flags & 128) === 0
    }

    function Eg(_) {
        if (I) {
            var _e = yg;
            if (_e) {
                var et = _e;
                if (!Cg(_, _e)) {
                    if (Dg(_)) throw Error(p$2(418));
                    _e = Lf(et.nextSibling);
                    var tt = xg;
                    _e && Cg(_, _e) ? Ag(tt, et) : (_.flags = _.flags & -4097 | 2, I = !1, xg = _)
                }
            } else {
                if (Dg(_)) throw Error(p$2(418));
                _.flags = _.flags & -4097 | 2, I = !1, xg = _
            }
        }
    }

    function Fg(_) {
        for (_ = _.return; _ !== null && _.tag !== 5 && _.tag !== 3 && _.tag !== 13;) _ = _.return;
        xg = _
    }

    function Gg(_) {
        if (_ !== xg) return !1;
        if (!I) return Fg(_), I = !0, !1;
        var _e;
        if ((_e = _.tag !== 3) && !(_e = _.tag !== 5) && (_e = _.type, _e = _e !== "head" && _e !== "body" && !Ef(_.type, _.memoizedProps)), _e && (_e = yg)) {
            if (Dg(_)) throw Hg(), Error(p$2(418));
            for (; _e;) Ag(_, _e), _e = Lf(_e.nextSibling)
        }
        if (Fg(_), _.tag === 13) {
            if (_ = _.memoizedState, _ = _ !== null ? _.dehydrated : null, !_) throw Error(p$2(317));
            e: {
                for (_ = _.nextSibling, _e = 0; _;) {
                    if (_.nodeType === 8) {
                        var et = _.data;
                        if (et === "/$") {
                            if (_e === 0) {
                                yg = Lf(_.nextSibling);
                                break e
                            }
                            _e--
                        } else et !== "$" && et !== "$!" && et !== "$?" || _e++
                    }
                    _ = _.nextSibling
                }
                yg = null
            }
        } else yg = xg ? Lf(_.stateNode.nextSibling) : null;
        return !0
    }

    function Hg() {
        for (var _ = yg; _;) _ = Lf(_.nextSibling)
    }

    function Ig() {
        yg = xg = null, I = !1
    }

    function Jg(_) {
        zg === null ? zg = [_] : zg.push(_)
    }
    var Kg = ua.ReactCurrentBatchConfig;

    function Lg(_, _e) {
        if (_ && _.defaultProps) {
            _e = A({}, _e), _ = _.defaultProps;
            for (var et in _) _e[et] === void 0 && (_e[et] = _[et]);
            return _e
        }
        return _e
    }
    var Mg = Uf(null),
        Ng = null,
        Og = null,
        Pg = null;

    function Qg() {
        Pg = Og = Ng = null
    }

    function Rg(_) {
        var _e = Mg.current;
        E$1(Mg), _._currentValue = _e
    }

    function Sg(_, _e, et) {
        for (; _ !== null;) {
            var tt = _.alternate;
            if ((_.childLanes & _e) !== _e ? (_.childLanes |= _e, tt !== null && (tt.childLanes |= _e)) : tt !== null && (tt.childLanes & _e) !== _e && (tt.childLanes |= _e), _ === et) break;
            _ = _.return
        }
    }

    function Tg(_, _e) {
        Ng = _, Pg = Og = null, _ = _.dependencies, _ !== null && _.firstContext !== null && (_.lanes & _e && (Ug = !0), _.firstContext = null)
    }

    function Vg(_) {
        var _e = _._currentValue;
        if (Pg !== _)
            if (_ = {
                    context: _,
                    memoizedValue: _e,
                    next: null
                }, Og === null) {
                if (Ng === null) throw Error(p$2(308));
                Og = _, Ng.dependencies = {
                    lanes: 0,
                    firstContext: _
                }
            } else Og = Og.next = _;
        return _e
    }
    var Wg = null;

    function Xg(_) {
        Wg === null ? Wg = [_] : Wg.push(_)
    }

    function Yg(_, _e, et, tt) {
        var nt = _e.interleaved;
        return nt === null ? (et.next = et, Xg(_e)) : (et.next = nt.next, nt.next = et), _e.interleaved = et, Zg(_, tt)
    }

    function Zg(_, _e) {
        _.lanes |= _e;
        var et = _.alternate;
        for (et !== null && (et.lanes |= _e), et = _, _ = _.return; _ !== null;) _.childLanes |= _e, et = _.alternate, et !== null && (et.childLanes |= _e), et = _, _ = _.return;
        return et.tag === 3 ? et.stateNode : null
    }
    var $g = !1;

    function ah(_) {
        _.updateQueue = {
            baseState: _.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }

    function bh(_, _e) {
        _ = _.updateQueue, _e.updateQueue === _ && (_e.updateQueue = {
            baseState: _.baseState,
            firstBaseUpdate: _.firstBaseUpdate,
            lastBaseUpdate: _.lastBaseUpdate,
            shared: _.shared,
            effects: _.effects
        })
    }

    function ch(_, _e) {
        return {
            eventTime: _,
            lane: _e,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }

    function dh(_, _e, et) {
        var tt = _.updateQueue;
        if (tt === null) return null;
        if (tt = tt.shared, K & 2) {
            var nt = tt.pending;
            return nt === null ? _e.next = _e : (_e.next = nt.next, nt.next = _e), tt.pending = _e, Zg(_, et)
        }
        return nt = tt.interleaved, nt === null ? (_e.next = _e, Xg(tt)) : (_e.next = nt.next, nt.next = _e), tt.interleaved = _e, Zg(_, et)
    }

    function eh(_, _e, et) {
        if (_e = _e.updateQueue, _e !== null && (_e = _e.shared, (et & 4194240) !== 0)) {
            var tt = _e.lanes;
            tt &= _.pendingLanes, et |= tt, _e.lanes = et, Cc(_, et)
        }
    }

    function fh(_, _e) {
        var et = _.updateQueue,
            tt = _.alternate;
        if (tt !== null && (tt = tt.updateQueue, et === tt)) {
            var nt = null,
                ot = null;
            if (et = et.firstBaseUpdate, et !== null) {
                do {
                    var at = {
                        eventTime: et.eventTime,
                        lane: et.lane,
                        tag: et.tag,
                        payload: et.payload,
                        callback: et.callback,
                        next: null
                    };
                    ot === null ? nt = ot = at : ot = ot.next = at, et = et.next
                } while (et !== null);
                ot === null ? nt = ot = _e : ot = ot.next = _e
            } else nt = ot = _e;
            et = {
                baseState: tt.baseState,
                firstBaseUpdate: nt,
                lastBaseUpdate: ot,
                shared: tt.shared,
                effects: tt.effects
            }, _.updateQueue = et;
            return
        }
        _ = et.lastBaseUpdate, _ === null ? et.firstBaseUpdate = _e : _.next = _e, et.lastBaseUpdate = _e
    }

    function gh(_, _e, et, tt) {
        var nt = _.updateQueue;
        $g = !1;
        var ot = nt.firstBaseUpdate,
            at = nt.lastBaseUpdate,
            st = nt.shared.pending;
        if (st !== null) {
            nt.shared.pending = null;
            var lt = st,
                ut = lt.next;
            lt.next = null, at === null ? ot = ut : at.next = ut, at = lt;
            var dt = _.alternate;
            dt !== null && (dt = dt.updateQueue, st = dt.lastBaseUpdate, st !== at && (st === null ? dt.firstBaseUpdate = ut : st.next = ut, dt.lastBaseUpdate = lt))
        }
        if (ot !== null) {
            var ct = nt.baseState;
            at = 0, dt = ut = lt = null, st = ot;
            do {
                var pt = st.lane,
                    ft = st.eventTime;
                if ((tt & pt) === pt) {
                    dt !== null && (dt = dt.next = {
                        eventTime: ft,
                        lane: 0,
                        tag: st.tag,
                        payload: st.payload,
                        callback: st.callback,
                        next: null
                    });
                    e: {
                        var ht = _,
                            mt = st;
                        switch (pt = _e, ft = et, mt.tag) {
                            case 1:
                                if (ht = mt.payload, typeof ht == "function") {
                                    ct = ht.call(ft, ct, pt);
                                    break e
                                }
                                ct = ht;
                                break e;
                            case 3:
                                ht.flags = ht.flags & -65537 | 128;
                            case 0:
                                if (ht = mt.payload, pt = typeof ht == "function" ? ht.call(ft, ct, pt) : ht, pt == null) break e;
                                ct = A({}, ct, pt);
                                break e;
                            case 2:
                                $g = !0
                        }
                    }
                    st.callback !== null && st.lane !== 0 && (_.flags |= 64, pt = nt.effects, pt === null ? nt.effects = [st] : pt.push(st))
                } else ft = {
                    eventTime: ft,
                    lane: pt,
                    tag: st.tag,
                    payload: st.payload,
                    callback: st.callback,
                    next: null
                }, dt === null ? (ut = dt = ft, lt = ct) : dt = dt.next = ft, at |= pt;
                if (st = st.next, st === null) {
                    if (st = nt.shared.pending, st === null) break;
                    pt = st, st = pt.next, pt.next = null, nt.lastBaseUpdate = pt, nt.shared.pending = null
                }
            } while (1);
            if (dt === null && (lt = ct), nt.baseState = lt, nt.firstBaseUpdate = ut, nt.lastBaseUpdate = dt, _e = nt.shared.interleaved, _e !== null) {
                nt = _e;
                do at |= nt.lane, nt = nt.next; while (nt !== _e)
            } else ot === null && (nt.shared.lanes = 0);
            hh |= at, _.lanes = at, _.memoizedState = ct
        }
    }

    function ih(_, _e, et) {
        if (_ = _e.effects, _e.effects = null, _ !== null)
            for (_e = 0; _e < _.length; _e++) {
                var tt = _[_e],
                    nt = tt.callback;
                if (nt !== null) {
                    if (tt.callback = null, tt = et, typeof nt != "function") throw Error(p$2(191, nt));
                    nt.call(tt)
                }
            }
    }
    var jh = new aa.Component().refs;

    function kh(_, _e, et, tt) {
        _e = _.memoizedState, et = et(tt, _e), et = et == null ? _e : A({}, _e, et), _.memoizedState = et, _.lanes === 0 && (_.updateQueue.baseState = et)
    }
    var nh = {
        isMounted: function(_) {
            return (_ = _._reactInternals) ? Vb(_) === _ : !1
        },
        enqueueSetState: function(_, _e, et) {
            _ = _._reactInternals;
            var tt = L(),
                nt = lh(_),
                ot = ch(tt, nt);
            ot.payload = _e, et != null && (ot.callback = et), _e = dh(_, ot, nt), _e !== null && (mh(_e, _, nt, tt), eh(_e, _, nt))
        },
        enqueueReplaceState: function(_, _e, et) {
            _ = _._reactInternals;
            var tt = L(),
                nt = lh(_),
                ot = ch(tt, nt);
            ot.tag = 1, ot.payload = _e, et != null && (ot.callback = et), _e = dh(_, ot, nt), _e !== null && (mh(_e, _, nt, tt), eh(_e, _, nt))
        },
        enqueueForceUpdate: function(_, _e) {
            _ = _._reactInternals;
            var et = L(),
                tt = lh(_),
                nt = ch(et, tt);
            nt.tag = 2, _e != null && (nt.callback = _e), _e = dh(_, nt, tt), _e !== null && (mh(_e, _, tt, et), eh(_e, _, tt))
        }
    };

    function oh(_, _e, et, tt, nt, ot, at) {
        return _ = _.stateNode, typeof _.shouldComponentUpdate == "function" ? _.shouldComponentUpdate(tt, ot, at) : _e.prototype && _e.prototype.isPureReactComponent ? !Ie(et, tt) || !Ie(nt, ot) : !0
    }

    function ph(_, _e, et) {
        var tt = !1,
            nt = Vf,
            ot = _e.contextType;
        return typeof ot == "object" && ot !== null ? ot = Vg(ot) : (nt = Zf(_e) ? Xf : H.current, tt = _e.contextTypes, ot = (tt = tt != null) ? Yf(_, nt) : Vf), _e = new _e(et, ot), _.memoizedState = _e.state !== null && _e.state !== void 0 ? _e.state : null, _e.updater = nh, _.stateNode = _e, _e._reactInternals = _, tt && (_ = _.stateNode, _.__reactInternalMemoizedUnmaskedChildContext = nt, _.__reactInternalMemoizedMaskedChildContext = ot), _e
    }

    function qh(_, _e, et, tt) {
        _ = _e.state, typeof _e.componentWillReceiveProps == "function" && _e.componentWillReceiveProps(et, tt), typeof _e.UNSAFE_componentWillReceiveProps == "function" && _e.UNSAFE_componentWillReceiveProps(et, tt), _e.state !== _ && nh.enqueueReplaceState(_e, _e.state, null)
    }

    function rh(_, _e, et, tt) {
        var nt = _.stateNode;
        nt.props = et, nt.state = _.memoizedState, nt.refs = jh, ah(_);
        var ot = _e.contextType;
        typeof ot == "object" && ot !== null ? nt.context = Vg(ot) : (ot = Zf(_e) ? Xf : H.current, nt.context = Yf(_, ot)), nt.state = _.memoizedState, ot = _e.getDerivedStateFromProps, typeof ot == "function" && (kh(_, _e, ot, et), nt.state = _.memoizedState), typeof _e.getDerivedStateFromProps == "function" || typeof nt.getSnapshotBeforeUpdate == "function" || typeof nt.UNSAFE_componentWillMount != "function" && typeof nt.componentWillMount != "function" || (_e = nt.state, typeof nt.componentWillMount == "function" && nt.componentWillMount(), typeof nt.UNSAFE_componentWillMount == "function" && nt.UNSAFE_componentWillMount(), _e !== nt.state && nh.enqueueReplaceState(nt, nt.state, null), gh(_, et, nt, tt), nt.state = _.memoizedState), typeof nt.componentDidMount == "function" && (_.flags |= 4194308)
    }

    function sh(_, _e, et) {
        if (_ = et.ref, _ !== null && typeof _ != "function" && typeof _ != "object") {
            if (et._owner) {
                if (et = et._owner, et) {
                    if (et.tag !== 1) throw Error(p$2(309));
                    var tt = et.stateNode
                }
                if (!tt) throw Error(p$2(147, _));
                var nt = tt,
                    ot = "" + _;
                return _e !== null && _e.ref !== null && typeof _e.ref == "function" && _e.ref._stringRef === ot ? _e.ref : (_e = function(at) {
                    var st = nt.refs;
                    st === jh && (st = nt.refs = {}), at === null ? delete st[ot] : st[ot] = at
                }, _e._stringRef = ot, _e)
            }
            if (typeof _ != "string") throw Error(p$2(284));
            if (!et._owner) throw Error(p$2(290, _))
        }
        return _
    }

    function th(_, _e) {
        throw _ = Object.prototype.toString.call(_e), Error(p$2(31, _ === "[object Object]" ? "object with keys {" + Object.keys(_e).join(", ") + "}" : _))
    }

    function uh(_) {
        var _e = _._init;
        return _e(_._payload)
    }

    function vh(_) {
        function _e(gt, vt) {
            if (_) {
                var xt = gt.deletions;
                xt === null ? (gt.deletions = [vt], gt.flags |= 16) : xt.push(vt)
            }
        }

        function et(gt, vt) {
            if (!_) return null;
            for (; vt !== null;) _e(gt, vt), vt = vt.sibling;
            return null
        }

        function tt(gt, vt) {
            for (gt = new Map; vt !== null;) vt.key !== null ? gt.set(vt.key, vt) : gt.set(vt.index, vt), vt = vt.sibling;
            return gt
        }

        function nt(gt, vt) {
            return gt = wh(gt, vt), gt.index = 0, gt.sibling = null, gt
        }

        function ot(gt, vt, xt) {
            return gt.index = xt, _ ? (xt = gt.alternate, xt !== null ? (xt = xt.index, xt < vt ? (gt.flags |= 2, vt) : xt) : (gt.flags |= 2, vt)) : (gt.flags |= 1048576, vt)
        }

        function at(gt) {
            return _ && gt.alternate === null && (gt.flags |= 2), gt
        }

        function st(gt, vt, xt, yt) {
            return vt === null || vt.tag !== 6 ? (vt = xh(xt, gt.mode, yt), vt.return = gt, vt) : (vt = nt(vt, xt), vt.return = gt, vt)
        }

        function lt(gt, vt, xt, yt) {
            var Et = xt.type;
            return Et === ya ? dt(gt, vt, xt.props.children, yt, xt.key) : vt !== null && (vt.elementType === Et || typeof Et == "object" && Et !== null && Et.$$typeof === Ha && uh(Et) === vt.type) ? (yt = nt(vt, xt.props), yt.ref = sh(gt, vt, xt), yt.return = gt, yt) : (yt = yh(xt.type, xt.key, xt.props, null, gt.mode, yt), yt.ref = sh(gt, vt, xt), yt.return = gt, yt)
        }

        function ut(gt, vt, xt, yt) {
            return vt === null || vt.tag !== 4 || vt.stateNode.containerInfo !== xt.containerInfo || vt.stateNode.implementation !== xt.implementation ? (vt = zh(xt, gt.mode, yt), vt.return = gt, vt) : (vt = nt(vt, xt.children || []), vt.return = gt, vt)
        }

        function dt(gt, vt, xt, yt, Et) {
            return vt === null || vt.tag !== 7 ? (vt = Ah(xt, gt.mode, yt, Et), vt.return = gt, vt) : (vt = nt(vt, xt), vt.return = gt, vt)
        }

        function ct(gt, vt, xt) {
            if (typeof vt == "string" && vt !== "" || typeof vt == "number") return vt = xh("" + vt, gt.mode, xt), vt.return = gt, vt;
            if (typeof vt == "object" && vt !== null) {
                switch (vt.$$typeof) {
                    case va:
                        return xt = yh(vt.type, vt.key, vt.props, null, gt.mode, xt), xt.ref = sh(gt, null, vt), xt.return = gt, xt;
                    case wa:
                        return vt = zh(vt, gt.mode, xt), vt.return = gt, vt;
                    case Ha:
                        var yt = vt._init;
                        return ct(gt, yt(vt._payload), xt)
                }
                if (eb(vt) || Ka(vt)) return vt = Ah(vt, gt.mode, xt, null), vt.return = gt, vt;
                th(gt, vt)
            }
            return null
        }

        function pt(gt, vt, xt, yt) {
            var Et = vt !== null ? vt.key : null;
            if (typeof xt == "string" && xt !== "" || typeof xt == "number") return Et !== null ? null : st(gt, vt, "" + xt, yt);
            if (typeof xt == "object" && xt !== null) {
                switch (xt.$$typeof) {
                    case va:
                        return xt.key === Et ? lt(gt, vt, xt, yt) : null;
                    case wa:
                        return xt.key === Et ? ut(gt, vt, xt, yt) : null;
                    case Ha:
                        return Et = xt._init, pt(gt, vt, Et(xt._payload), yt)
                }
                if (eb(xt) || Ka(xt)) return Et !== null ? null : dt(gt, vt, xt, yt, null);
                th(gt, xt)
            }
            return null
        }

        function ft(gt, vt, xt, yt, Et) {
            if (typeof yt == "string" && yt !== "" || typeof yt == "number") return gt = gt.get(xt) || null, st(vt, gt, "" + yt, Et);
            if (typeof yt == "object" && yt !== null) {
                switch (yt.$$typeof) {
                    case va:
                        return gt = gt.get(yt.key === null ? xt : yt.key) || null, lt(vt, gt, yt, Et);
                    case wa:
                        return gt = gt.get(yt.key === null ? xt : yt.key) || null, ut(vt, gt, yt, Et);
                    case Ha:
                        var wt = yt._init;
                        return ft(gt, vt, xt, wt(yt._payload), Et)
                }
                if (eb(yt) || Ka(yt)) return gt = gt.get(xt) || null, dt(vt, gt, yt, Et, null);
                th(vt, yt)
            }
            return null
        }

        function ht(gt, vt, xt, yt) {
            for (var Et = null, wt = null, St = vt, $t = vt = 0, Ct = null; St !== null && $t < xt.length; $t++) {
                St.index > $t ? (Ct = St, St = null) : Ct = St.sibling;
                var Rt = pt(gt, St, xt[$t], yt);
                if (Rt === null) {
                    St === null && (St = Ct);
                    break
                }
                _ && St && Rt.alternate === null && _e(gt, St), vt = ot(Rt, vt, $t), wt === null ? Et = Rt : wt.sibling = Rt, wt = Rt, St = Ct
            }
            if ($t === xt.length) return et(gt, St), I && tg(gt, $t), Et;
            if (St === null) {
                for (; $t < xt.length; $t++) St = ct(gt, xt[$t], yt), St !== null && (vt = ot(St, vt, $t), wt === null ? Et = St : wt.sibling = St, wt = St);
                return I && tg(gt, $t), Et
            }
            for (St = tt(gt, St); $t < xt.length; $t++) Ct = ft(St, gt, $t, xt[$t], yt), Ct !== null && (_ && Ct.alternate !== null && St.delete(Ct.key === null ? $t : Ct.key), vt = ot(Ct, vt, $t), wt === null ? Et = Ct : wt.sibling = Ct, wt = Ct);
            return _ && St.forEach(function(Pt) {
                return _e(gt, Pt)
            }), I && tg(gt, $t), Et
        }

        function mt(gt, vt, xt, yt) {
            var Et = Ka(xt);
            if (typeof Et != "function") throw Error(p$2(150));
            if (xt = Et.call(xt), xt == null) throw Error(p$2(151));
            for (var wt = Et = null, St = vt, $t = vt = 0, Ct = null, Rt = xt.next(); St !== null && !Rt.done; $t++, Rt = xt.next()) {
                St.index > $t ? (Ct = St, St = null) : Ct = St.sibling;
                var Pt = pt(gt, St, Rt.value, yt);
                if (Pt === null) {
                    St === null && (St = Ct);
                    break
                }
                _ && St && Pt.alternate === null && _e(gt, St), vt = ot(Pt, vt, $t), wt === null ? Et = Pt : wt.sibling = Pt, wt = Pt, St = Ct
            }
            if (Rt.done) return et(gt, St), I && tg(gt, $t), Et;
            if (St === null) {
                for (; !Rt.done; $t++, Rt = xt.next()) Rt = ct(gt, Rt.value, yt), Rt !== null && (vt = ot(Rt, vt, $t), wt === null ? Et = Rt : wt.sibling = Rt, wt = Rt);
                return I && tg(gt, $t), Et
            }
            for (St = tt(gt, St); !Rt.done; $t++, Rt = xt.next()) Rt = ft(St, gt, $t, Rt.value, yt), Rt !== null && (_ && Rt.alternate !== null && St.delete(Rt.key === null ? $t : Rt.key), vt = ot(Rt, vt, $t), wt === null ? Et = Rt : wt.sibling = Rt, wt = Rt);
            return _ && St.forEach(function(Tt) {
                return _e(gt, Tt)
            }), I && tg(gt, $t), Et
        }

        function bt(gt, vt, xt, yt) {
            if (typeof xt == "object" && xt !== null && xt.type === ya && xt.key === null && (xt = xt.props.children), typeof xt == "object" && xt !== null) {
                switch (xt.$$typeof) {
                    case va:
                        e: {
                            for (var Et = xt.key, wt = vt; wt !== null;) {
                                if (wt.key === Et) {
                                    if (Et = xt.type, Et === ya) {
                                        if (wt.tag === 7) {
                                            et(gt, wt.sibling), vt = nt(wt, xt.props.children), vt.return = gt, gt = vt;
                                            break e
                                        }
                                    } else if (wt.elementType === Et || typeof Et == "object" && Et !== null && Et.$$typeof === Ha && uh(Et) === wt.type) {
                                        et(gt, wt.sibling), vt = nt(wt, xt.props), vt.ref = sh(gt, wt, xt), vt.return = gt, gt = vt;
                                        break e
                                    }
                                    et(gt, wt);
                                    break
                                } else _e(gt, wt);
                                wt = wt.sibling
                            }
                            xt.type === ya ? (vt = Ah(xt.props.children, gt.mode, yt, xt.key), vt.return = gt, gt = vt) : (yt = yh(xt.type, xt.key, xt.props, null, gt.mode, yt), yt.ref = sh(gt, vt, xt), yt.return = gt, gt = yt)
                        }
                        return at(gt);
                    case wa:
                        e: {
                            for (wt = xt.key; vt !== null;) {
                                if (vt.key === wt)
                                    if (vt.tag === 4 && vt.stateNode.containerInfo === xt.containerInfo && vt.stateNode.implementation === xt.implementation) {
                                        et(gt, vt.sibling), vt = nt(vt, xt.children || []), vt.return = gt, gt = vt;
                                        break e
                                    } else {
                                        et(gt, vt);
                                        break
                                    }
                                else _e(gt, vt);
                                vt = vt.sibling
                            }
                            vt = zh(xt, gt.mode, yt),
                            vt.return = gt,
                            gt = vt
                        }
                        return at(gt);
                    case Ha:
                        return wt = xt._init, bt(gt, vt, wt(xt._payload), yt)
                }
                if (eb(xt)) return ht(gt, vt, xt, yt);
                if (Ka(xt)) return mt(gt, vt, xt, yt);
                th(gt, xt)
            }
            return typeof xt == "string" && xt !== "" || typeof xt == "number" ? (xt = "" + xt, vt !== null && vt.tag === 6 ? (et(gt, vt.sibling), vt = nt(vt, xt), vt.return = gt, gt = vt) : (et(gt, vt), vt = xh(xt, gt.mode, yt), vt.return = gt, gt = vt), at(gt)) : et(gt, vt)
        }
        return bt
    }
    var Bh = vh(!0),
        Ch = vh(!1),
        Dh = {},
        Eh = Uf(Dh),
        Fh = Uf(Dh),
        Gh = Uf(Dh);

    function Hh(_) {
        if (_ === Dh) throw Error(p$2(174));
        return _
    }

    function Ih(_, _e) {
        switch (G(Gh, _e), G(Fh, _), G(Eh, Dh), _ = _e.nodeType, _) {
            case 9:
            case 11:
                _e = (_e = _e.documentElement) ? _e.namespaceURI : lb(null, "");
                break;
            default:
                _ = _ === 8 ? _e.parentNode : _e, _e = _.namespaceURI || null, _ = _.tagName, _e = lb(_e, _)
        }
        E$1(Eh), G(Eh, _e)
    }

    function Jh() {
        E$1(Eh), E$1(Fh), E$1(Gh)
    }

    function Kh(_) {
        Hh(Gh.current);
        var _e = Hh(Eh.current),
            et = lb(_e, _.type);
        _e !== et && (G(Fh, _), G(Eh, et))
    }

    function Lh(_) {
        Fh.current === _ && (E$1(Eh), E$1(Fh))
    }
    var M = Uf(0);

    function Mh(_) {
        for (var _e = _; _e !== null;) {
            if (_e.tag === 13) {
                var et = _e.memoizedState;
                if (et !== null && (et = et.dehydrated, et === null || et.data === "$?" || et.data === "$!")) return _e
            } else if (_e.tag === 19 && _e.memoizedProps.revealOrder !== void 0) {
                if (_e.flags & 128) return _e
            } else if (_e.child !== null) {
                _e.child.return = _e, _e = _e.child;
                continue
            }
            if (_e === _) break;
            for (; _e.sibling === null;) {
                if (_e.return === null || _e.return === _) return null;
                _e = _e.return
            }
            _e.sibling.return = _e.return, _e = _e.sibling
        }
        return null
    }
    var Nh = [];

    function Oh() {
        for (var _ = 0; _ < Nh.length; _++) Nh[_]._workInProgressVersionPrimary = null;
        Nh.length = 0
    }
    var Ph = ua.ReactCurrentDispatcher,
        Qh = ua.ReactCurrentBatchConfig,
        Rh = 0,
        N = null,
        O$1 = null,
        P$2 = null,
        Sh = !1,
        Th = !1,
        Uh = 0,
        Vh = 0;

    function Q() {
        throw Error(p$2(321))
    }

    function Wh(_, _e) {
        if (_e === null) return !1;
        for (var et = 0; et < _e.length && et < _.length; et++)
            if (!He(_[et], _e[et])) return !1;
        return !0
    }

    function Xh(_, _e, et, tt, nt, ot) {
        if (Rh = ot, N = _e, _e.memoizedState = null, _e.updateQueue = null, _e.lanes = 0, Ph.current = _ === null || _.memoizedState === null ? Yh : Zh, _ = et(tt, nt), Th) {
            ot = 0;
            do {
                if (Th = !1, Uh = 0, 25 <= ot) throw Error(p$2(301));
                ot += 1, P$2 = O$1 = null, _e.updateQueue = null, Ph.current = $h, _ = et(tt, nt)
            } while (Th)
        }
        if (Ph.current = ai, _e = O$1 !== null && O$1.next !== null, Rh = 0, P$2 = O$1 = N = null, Sh = !1, _e) throw Error(p$2(300));
        return _
    }

    function bi() {
        var _ = Uh !== 0;
        return Uh = 0, _
    }

    function ci() {
        var _ = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return P$2 === null ? N.memoizedState = P$2 = _ : P$2 = P$2.next = _, P$2
    }

    function di() {
        if (O$1 === null) {
            var _ = N.alternate;
            _ = _ !== null ? _.memoizedState : null
        } else _ = O$1.next;
        var _e = P$2 === null ? N.memoizedState : P$2.next;
        if (_e !== null) P$2 = _e, O$1 = _;
        else {
            if (_ === null) throw Error(p$2(310));
            O$1 = _, _ = {
                memoizedState: O$1.memoizedState,
                baseState: O$1.baseState,
                baseQueue: O$1.baseQueue,
                queue: O$1.queue,
                next: null
            }, P$2 === null ? N.memoizedState = P$2 = _ : P$2 = P$2.next = _
        }
        return P$2
    }

    function ei(_, _e) {
        return typeof _e == "function" ? _e(_) : _e
    }

    function fi(_) {
        var _e = di(),
            et = _e.queue;
        if (et === null) throw Error(p$2(311));
        et.lastRenderedReducer = _;
        var tt = O$1,
            nt = tt.baseQueue,
            ot = et.pending;
        if (ot !== null) {
            if (nt !== null) {
                var at = nt.next;
                nt.next = ot.next, ot.next = at
            }
            tt.baseQueue = nt = ot, et.pending = null
        }
        if (nt !== null) {
            ot = nt.next, tt = tt.baseState;
            var st = at = null,
                lt = null,
                ut = ot;
            do {
                var dt = ut.lane;
                if ((Rh & dt) === dt) lt !== null && (lt = lt.next = {
                    lane: 0,
                    action: ut.action,
                    hasEagerState: ut.hasEagerState,
                    eagerState: ut.eagerState,
                    next: null
                }), tt = ut.hasEagerState ? ut.eagerState : _(tt, ut.action);
                else {
                    var ct = {
                        lane: dt,
                        action: ut.action,
                        hasEagerState: ut.hasEagerState,
                        eagerState: ut.eagerState,
                        next: null
                    };
                    lt === null ? (st = lt = ct, at = tt) : lt = lt.next = ct, N.lanes |= dt, hh |= dt
                }
                ut = ut.next
            } while (ut !== null && ut !== ot);
            lt === null ? at = tt : lt.next = st, He(tt, _e.memoizedState) || (Ug = !0), _e.memoizedState = tt, _e.baseState = at, _e.baseQueue = lt, et.lastRenderedState = tt
        }
        if (_ = et.interleaved, _ !== null) {
            nt = _;
            do ot = nt.lane, N.lanes |= ot, hh |= ot, nt = nt.next; while (nt !== _)
        } else nt === null && (et.lanes = 0);
        return [_e.memoizedState, et.dispatch]
    }

    function gi(_) {
        var _e = di(),
            et = _e.queue;
        if (et === null) throw Error(p$2(311));
        et.lastRenderedReducer = _;
        var tt = et.dispatch,
            nt = et.pending,
            ot = _e.memoizedState;
        if (nt !== null) {
            et.pending = null;
            var at = nt = nt.next;
            do ot = _(ot, at.action), at = at.next; while (at !== nt);
            He(ot, _e.memoizedState) || (Ug = !0), _e.memoizedState = ot, _e.baseQueue === null && (_e.baseState = ot), et.lastRenderedState = ot
        }
        return [ot, tt]
    }

    function hi() {}

    function ii(_, _e) {
        var et = N,
            tt = di(),
            nt = _e(),
            ot = !He(tt.memoizedState, nt);
        if (ot && (tt.memoizedState = nt, Ug = !0), tt = tt.queue, ji(ki.bind(null, et, tt, _), [_]), tt.getSnapshot !== _e || ot || P$2 !== null && P$2.memoizedState.tag & 1) {
            if (et.flags |= 2048, li(9, mi.bind(null, et, tt, nt, _e), void 0, null), R$1 === null) throw Error(p$2(349));
            Rh & 30 || ni(et, _e, nt)
        }
        return nt
    }

    function ni(_, _e, et) {
        _.flags |= 16384, _ = {
            getSnapshot: _e,
            value: et
        }, _e = N.updateQueue, _e === null ? (_e = {
            lastEffect: null,
            stores: null
        }, N.updateQueue = _e, _e.stores = [_]) : (et = _e.stores, et === null ? _e.stores = [_] : et.push(_))
    }

    function mi(_, _e, et, tt) {
        _e.value = et, _e.getSnapshot = tt, oi(_e) && pi(_)
    }

    function ki(_, _e, et) {
        return et(function() {
            oi(_e) && pi(_)
        })
    }

    function oi(_) {
        var _e = _.getSnapshot;
        _ = _.value;
        try {
            var et = _e();
            return !He(_, et)
        } catch (tt) {
            return !0
        }
    }

    function pi(_) {
        var _e = Zg(_, 1);
        _e !== null && mh(_e, _, 1, -1)
    }

    function qi(_) {
        var _e = ci();
        return typeof _ == "function" && (_ = _()), _e.memoizedState = _e.baseState = _, _ = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: ei,
            lastRenderedState: _
        }, _e.queue = _, _ = _.dispatch = ri.bind(null, N, _), [_e.memoizedState, _]
    }

    function li(_, _e, et, tt) {
        return _ = {
            tag: _,
            create: _e,
            destroy: et,
            deps: tt,
            next: null
        }, _e = N.updateQueue, _e === null ? (_e = {
            lastEffect: null,
            stores: null
        }, N.updateQueue = _e, _e.lastEffect = _.next = _) : (et = _e.lastEffect, et === null ? _e.lastEffect = _.next = _ : (tt = et.next, et.next = _, _.next = tt, _e.lastEffect = _)), _
    }

    function si() {
        return di().memoizedState
    }

    function ti(_, _e, et, tt) {
        var nt = ci();
        N.flags |= _, nt.memoizedState = li(1 | _e, et, void 0, tt === void 0 ? null : tt)
    }

    function ui(_, _e, et, tt) {
        var nt = di();
        tt = tt === void 0 ? null : tt;
        var ot = void 0;
        if (O$1 !== null) {
            var at = O$1.memoizedState;
            if (ot = at.destroy, tt !== null && Wh(tt, at.deps)) {
                nt.memoizedState = li(_e, et, ot, tt);
                return
            }
        }
        N.flags |= _, nt.memoizedState = li(1 | _e, et, ot, tt)
    }

    function vi(_, _e) {
        return ti(8390656, 8, _, _e)
    }

    function ji(_, _e) {
        return ui(2048, 8, _, _e)
    }

    function wi(_, _e) {
        return ui(4, 2, _, _e)
    }

    function xi(_, _e) {
        return ui(4, 4, _, _e)
    }

    function yi(_, _e) {
        if (typeof _e == "function") return _ = _(), _e(_),
            function() {
                _e(null)
            };
        if (_e != null) return _ = _(), _e.current = _,
            function() {
                _e.current = null
            }
    }

    function zi(_, _e, et) {
        return et = et != null ? et.concat([_]) : null, ui(4, 4, yi.bind(null, _e, _), et)
    }

    function Ai() {}

    function Bi(_, _e) {
        var et = di();
        _e = _e === void 0 ? null : _e;
        var tt = et.memoizedState;
        return tt !== null && _e !== null && Wh(_e, tt[1]) ? tt[0] : (et.memoizedState = [_, _e], _)
    }

    function Ci(_, _e) {
        var et = di();
        _e = _e === void 0 ? null : _e;
        var tt = et.memoizedState;
        return tt !== null && _e !== null && Wh(_e, tt[1]) ? tt[0] : (_ = _(), et.memoizedState = [_, _e], _)
    }

    function Di(_, _e, et) {
        return Rh & 21 ? (He(et, _e) || (et = yc(), N.lanes |= et, hh |= et, _.baseState = !0), _e) : (_.baseState && (_.baseState = !1, Ug = !0), _.memoizedState = et)
    }

    function Ei(_, _e) {
        var et = C$1;
        C$1 = et !== 0 && 4 > et ? et : 4, _(!0);
        var tt = Qh.transition;
        Qh.transition = {};
        try {
            _(!1), _e()
        } finally {
            C$1 = et, Qh.transition = tt
        }
    }

    function Fi() {
        return di().memoizedState
    }

    function Gi(_, _e, et) {
        var tt = lh(_);
        if (et = {
                lane: tt,
                action: et,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, Hi(_)) Ii(_e, et);
        else if (et = Yg(_, _e, et, tt), et !== null) {
            var nt = L();
            mh(et, _, tt, nt), Ji(et, _e, tt)
        }
    }

    function ri(_, _e, et) {
        var tt = lh(_),
            nt = {
                lane: tt,
                action: et,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
        if (Hi(_)) Ii(_e, nt);
        else {
            var ot = _.alternate;
            if (_.lanes === 0 && (ot === null || ot.lanes === 0) && (ot = _e.lastRenderedReducer, ot !== null)) try {
                var at = _e.lastRenderedState,
                    st = ot(at, et);
                if (nt.hasEagerState = !0, nt.eagerState = st, He(st, at)) {
                    var lt = _e.interleaved;
                    lt === null ? (nt.next = nt, Xg(_e)) : (nt.next = lt.next, lt.next = nt), _e.interleaved = nt;
                    return
                }
            } catch (ut) {} finally {}
            et = Yg(_, _e, nt, tt), et !== null && (nt = L(), mh(et, _, tt, nt), Ji(et, _e, tt))
        }
    }

    function Hi(_) {
        var _e = _.alternate;
        return _ === N || _e !== null && _e === N
    }

    function Ii(_, _e) {
        Th = Sh = !0;
        var et = _.pending;
        et === null ? _e.next = _e : (_e.next = et.next, et.next = _e), _.pending = _e
    }

    function Ji(_, _e, et) {
        if (et & 4194240) {
            var tt = _e.lanes;
            tt &= _.pendingLanes, et |= tt, _e.lanes = et, Cc(_, et)
        }
    }
    var ai = {
            readContext: Vg,
            useCallback: Q,
            useContext: Q,
            useEffect: Q,
            useImperativeHandle: Q,
            useInsertionEffect: Q,
            useLayoutEffect: Q,
            useMemo: Q,
            useReducer: Q,
            useRef: Q,
            useState: Q,
            useDebugValue: Q,
            useDeferredValue: Q,
            useTransition: Q,
            useMutableSource: Q,
            useSyncExternalStore: Q,
            useId: Q,
            unstable_isNewReconciler: !1
        },
        Yh = {
            readContext: Vg,
            useCallback: function(_, _e) {
                return ci().memoizedState = [_, _e === void 0 ? null : _e], _
            },
            useContext: Vg,
            useEffect: vi,
            useImperativeHandle: function(_, _e, et) {
                return et = et != null ? et.concat([_]) : null, ti(4194308, 4, yi.bind(null, _e, _), et)
            },
            useLayoutEffect: function(_, _e) {
                return ti(4194308, 4, _, _e)
            },
            useInsertionEffect: function(_, _e) {
                return ti(4, 2, _, _e)
            },
            useMemo: function(_, _e) {
                var et = ci();
                return _e = _e === void 0 ? null : _e, _ = _(), et.memoizedState = [_, _e], _
            },
            useReducer: function(_, _e, et) {
                var tt = ci();
                return _e = et !== void 0 ? et(_e) : _e, tt.memoizedState = tt.baseState = _e, _ = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: _,
                    lastRenderedState: _e
                }, tt.queue = _, _ = _.dispatch = Gi.bind(null, N, _), [tt.memoizedState, _]
            },
            useRef: function(_) {
                var _e = ci();
                return _ = {
                    current: _
                }, _e.memoizedState = _
            },
            useState: qi,
            useDebugValue: Ai,
            useDeferredValue: function(_) {
                return ci().memoizedState = _
            },
            useTransition: function() {
                var _ = qi(!1),
                    _e = _[0];
                return _ = Ei.bind(null, _[1]), ci().memoizedState = _, [_e, _]
            },
            useMutableSource: function() {},
            useSyncExternalStore: function(_, _e, et) {
                var tt = N,
                    nt = ci();
                if (I) {
                    if (et === void 0) throw Error(p$2(407));
                    et = et()
                } else {
                    if (et = _e(), R$1 === null) throw Error(p$2(349));
                    Rh & 30 || ni(tt, _e, et)
                }
                nt.memoizedState = et;
                var ot = {
                    value: et,
                    getSnapshot: _e
                };
                return nt.queue = ot, vi(ki.bind(null, tt, ot, _), [_]), tt.flags |= 2048, li(9, mi.bind(null, tt, ot, et, _e), void 0, null), et
            },
            useId: function() {
                var _ = ci(),
                    _e = R$1.identifierPrefix;
                if (I) {
                    var et = sg,
                        tt = rg;
                    et = (tt & ~(1 << 32 - oc(tt) - 1)).toString(32) + et, _e = ":" + _e + "R" + et, et = Uh++, 0 < et && (_e += "H" + et.toString(32)), _e += ":"
                } else et = Vh++, _e = ":" + _e + "r" + et.toString(32) + ":";
                return _.memoizedState = _e
            },
            unstable_isNewReconciler: !1
        },
        Zh = {
            readContext: Vg,
            useCallback: Bi,
            useContext: Vg,
            useEffect: ji,
            useImperativeHandle: zi,
            useInsertionEffect: wi,
            useLayoutEffect: xi,
            useMemo: Ci,
            useReducer: fi,
            useRef: si,
            useState: function() {
                return fi(ei)
            },
            useDebugValue: Ai,
            useDeferredValue: function(_) {
                var _e = di();
                return Di(_e, O$1.memoizedState, _)
            },
            useTransition: function() {
                var _ = fi(ei)[0],
                    _e = di().memoizedState;
                return [_, _e]
            },
            useMutableSource: hi,
            useSyncExternalStore: ii,
            useId: Fi,
            unstable_isNewReconciler: !1
        },
        $h = {
            readContext: Vg,
            useCallback: Bi,
            useContext: Vg,
            useEffect: ji,
            useImperativeHandle: zi,
            useInsertionEffect: wi,
            useLayoutEffect: xi,
            useMemo: Ci,
            useReducer: gi,
            useRef: si,
            useState: function() {
                return gi(ei)
            },
            useDebugValue: Ai,
            useDeferredValue: function(_) {
                var _e = di();
                return O$1 === null ? _e.memoizedState = _ : Di(_e, O$1.memoizedState, _)
            },
            useTransition: function() {
                var _ = gi(ei)[0],
                    _e = di().memoizedState;
                return [_, _e]
            },
            useMutableSource: hi,
            useSyncExternalStore: ii,
            useId: Fi,
            unstable_isNewReconciler: !1
        };

    function Ki(_, _e) {
        try {
            var et = "",
                tt = _e;
            do et += Pa(tt), tt = tt.return; while (tt);
            var nt = et
        } catch (ot) {
            nt = `
Error generating stack: ` + ot.message + `
` + ot.stack
        }
        return {
            value: _,
            source: _e,
            stack: nt,
            digest: null
        }
    }

    function Li(_, _e, et) {
        return {
            value: _,
            source: null,
            stack: et != null ? et : null,
            digest: _e != null ? _e : null
        }
    }

    function Mi(_, _e) {
        try {
            console.error(_e.value)
        } catch (et) {
            setTimeout(function() {
                throw et
            })
        }
    }
    var Ni = typeof WeakMap == "function" ? WeakMap : Map;

    function Oi(_, _e, et) {
        et = ch(-1, et), et.tag = 3, et.payload = {
            element: null
        };
        var tt = _e.value;
        return et.callback = function() {
            Pi || (Pi = !0, Qi = tt), Mi(_, _e)
        }, et
    }

    function Ri(_, _e, et) {
        et = ch(-1, et), et.tag = 3;
        var tt = _.type.getDerivedStateFromError;
        if (typeof tt == "function") {
            var nt = _e.value;
            et.payload = function() {
                return tt(nt)
            }, et.callback = function() {
                Mi(_, _e)
            }
        }
        var ot = _.stateNode;
        return ot !== null && typeof ot.componentDidCatch == "function" && (et.callback = function() {
            Mi(_, _e), typeof tt != "function" && (Si === null ? Si = new Set([this]) : Si.add(this));
            var at = _e.stack;
            this.componentDidCatch(_e.value, {
                componentStack: at !== null ? at : ""
            })
        }), et
    }

    function Ti(_, _e, et) {
        var tt = _.pingCache;
        if (tt === null) {
            tt = _.pingCache = new Ni;
            var nt = new Set;
            tt.set(_e, nt)
        } else nt = tt.get(_e), nt === void 0 && (nt = new Set, tt.set(_e, nt));
        nt.has(et) || (nt.add(et), _ = Ui.bind(null, _, _e, et), _e.then(_, _))
    }

    function Vi(_) {
        do {
            var _e;
            if ((_e = _.tag === 13) && (_e = _.memoizedState, _e = _e !== null ? _e.dehydrated !== null : !0), _e) return _;
            _ = _.return
        } while (_ !== null);
        return null
    }

    function Wi(_, _e, et, tt, nt) {
        return _.mode & 1 ? (_.flags |= 65536, _.lanes = nt, _) : (_ === _e ? _.flags |= 65536 : (_.flags |= 128, et.flags |= 131072, et.flags &= -52805, et.tag === 1 && (et.alternate === null ? et.tag = 17 : (_e = ch(-1, 1), _e.tag = 2, dh(et, _e, 1))), et.lanes |= 1), _)
    }
    var Xi = ua.ReactCurrentOwner,
        Ug = !1;

    function Yi(_, _e, et, tt) {
        _e.child = _ === null ? Ch(_e, null, et, tt) : Bh(_e, _.child, et, tt)
    }

    function Zi(_, _e, et, tt, nt) {
        et = et.render;
        var ot = _e.ref;
        return Tg(_e, nt), tt = Xh(_, _e, et, tt, ot, nt), et = bi(), _ !== null && !Ug ? (_e.updateQueue = _.updateQueue, _e.flags &= -2053, _.lanes &= ~nt, $i(_, _e, nt)) : (I && et && vg(_e), _e.flags |= 1, Yi(_, _e, tt, nt), _e.child)
    }

    function aj(_, _e, et, tt, nt) {
        if (_ === null) {
            var ot = et.type;
            return typeof ot == "function" && !bj(ot) && ot.defaultProps === void 0 && et.compare === null && et.defaultProps === void 0 ? (_e.tag = 15, _e.type = ot, cj(_, _e, ot, tt, nt)) : (_ = yh(et.type, null, tt, _e, _e.mode, nt), _.ref = _e.ref, _.return = _e, _e.child = _)
        }
        if (ot = _.child, !(_.lanes & nt)) {
            var at = ot.memoizedProps;
            if (et = et.compare, et = et !== null ? et : Ie, et(at, tt) && _.ref === _e.ref) return $i(_, _e, nt)
        }
        return _e.flags |= 1, _ = wh(ot, tt), _.ref = _e.ref, _.return = _e, _e.child = _
    }

    function cj(_, _e, et, tt, nt) {
        if (_ !== null) {
            var ot = _.memoizedProps;
            if (Ie(ot, tt) && _.ref === _e.ref)
                if (Ug = !1, _e.pendingProps = tt = ot, (_.lanes & nt) !== 0) _.flags & 131072 && (Ug = !0);
                else return _e.lanes = _.lanes, $i(_, _e, nt)
        }
        return dj(_, _e, et, tt, nt)
    }

    function ej(_, _e, et) {
        var tt = _e.pendingProps,
            nt = tt.children,
            ot = _ !== null ? _.memoizedState : null;
        if (tt.mode === "hidden")
            if (!(_e.mode & 1)) _e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, G(fj, gj), gj |= et;
            else {
                if (!(et & 1073741824)) return _ = ot !== null ? ot.baseLanes | et : et, _e.lanes = _e.childLanes = 1073741824, _e.memoizedState = {
                    baseLanes: _,
                    cachePool: null,
                    transitions: null
                }, _e.updateQueue = null, G(fj, gj), gj |= _, null;
                _e.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                }, tt = ot !== null ? ot.baseLanes : et, G(fj, gj), gj |= tt
            }
        else ot !== null ? (tt = ot.baseLanes | et, _e.memoizedState = null) : tt = et, G(fj, gj), gj |= tt;
        return Yi(_, _e, nt, et), _e.child
    }

    function hj(_, _e) {
        var et = _e.ref;
        (_ === null && et !== null || _ !== null && _.ref !== et) && (_e.flags |= 512, _e.flags |= 2097152)
    }

    function dj(_, _e, et, tt, nt) {
        var ot = Zf(et) ? Xf : H.current;
        return ot = Yf(_e, ot), Tg(_e, nt), et = Xh(_, _e, et, tt, ot, nt), tt = bi(), _ !== null && !Ug ? (_e.updateQueue = _.updateQueue, _e.flags &= -2053, _.lanes &= ~nt, $i(_, _e, nt)) : (I && tt && vg(_e), _e.flags |= 1, Yi(_, _e, et, nt), _e.child)
    }

    function ij(_, _e, et, tt, nt) {
        if (Zf(et)) {
            var ot = !0;
            cg(_e)
        } else ot = !1;
        if (Tg(_e, nt), _e.stateNode === null) jj(_, _e), ph(_e, et, tt), rh(_e, et, tt, nt), tt = !0;
        else if (_ === null) {
            var at = _e.stateNode,
                st = _e.memoizedProps;
            at.props = st;
            var lt = at.context,
                ut = et.contextType;
            typeof ut == "object" && ut !== null ? ut = Vg(ut) : (ut = Zf(et) ? Xf : H.current, ut = Yf(_e, ut));
            var dt = et.getDerivedStateFromProps,
                ct = typeof dt == "function" || typeof at.getSnapshotBeforeUpdate == "function";
            ct || typeof at.UNSAFE_componentWillReceiveProps != "function" && typeof at.componentWillReceiveProps != "function" || (st !== tt || lt !== ut) && qh(_e, at, tt, ut), $g = !1;
            var pt = _e.memoizedState;
            at.state = pt, gh(_e, tt, at, nt), lt = _e.memoizedState, st !== tt || pt !== lt || Wf.current || $g ? (typeof dt == "function" && (kh(_e, et, dt, tt), lt = _e.memoizedState), (st = $g || oh(_e, et, st, tt, pt, lt, ut)) ? (ct || typeof at.UNSAFE_componentWillMount != "function" && typeof at.componentWillMount != "function" || (typeof at.componentWillMount == "function" && at.componentWillMount(), typeof at.UNSAFE_componentWillMount == "function" && at.UNSAFE_componentWillMount()), typeof at.componentDidMount == "function" && (_e.flags |= 4194308)) : (typeof at.componentDidMount == "function" && (_e.flags |= 4194308), _e.memoizedProps = tt, _e.memoizedState = lt), at.props = tt, at.state = lt, at.context = ut, tt = st) : (typeof at.componentDidMount == "function" && (_e.flags |= 4194308), tt = !1)
        } else {
            at = _e.stateNode, bh(_, _e), st = _e.memoizedProps, ut = _e.type === _e.elementType ? st : Lg(_e.type, st), at.props = ut, ct = _e.pendingProps, pt = at.context, lt = et.contextType, typeof lt == "object" && lt !== null ? lt = Vg(lt) : (lt = Zf(et) ? Xf : H.current, lt = Yf(_e, lt));
            var ft = et.getDerivedStateFromProps;
            (dt = typeof ft == "function" || typeof at.getSnapshotBeforeUpdate == "function") || typeof at.UNSAFE_componentWillReceiveProps != "function" && typeof at.componentWillReceiveProps != "function" || (st !== ct || pt !== lt) && qh(_e, at, tt, lt), $g = !1, pt = _e.memoizedState, at.state = pt, gh(_e, tt, at, nt);
            var ht = _e.memoizedState;
            st !== ct || pt !== ht || Wf.current || $g ? (typeof ft == "function" && (kh(_e, et, ft, tt), ht = _e.memoizedState), (ut = $g || oh(_e, et, ut, tt, pt, ht, lt) || !1) ? (dt || typeof at.UNSAFE_componentWillUpdate != "function" && typeof at.componentWillUpdate != "function" || (typeof at.componentWillUpdate == "function" && at.componentWillUpdate(tt, ht, lt), typeof at.UNSAFE_componentWillUpdate == "function" && at.UNSAFE_componentWillUpdate(tt, ht, lt)), typeof at.componentDidUpdate == "function" && (_e.flags |= 4), typeof at.getSnapshotBeforeUpdate == "function" && (_e.flags |= 1024)) : (typeof at.componentDidUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 4), typeof at.getSnapshotBeforeUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 1024), _e.memoizedProps = tt, _e.memoizedState = ht), at.props = tt, at.state = ht, at.context = lt, tt = ut) : (typeof at.componentDidUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 4), typeof at.getSnapshotBeforeUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 1024), tt = !1)
        }
        return kj(_, _e, et, tt, ot, nt)
    }

    function kj(_, _e, et, tt, nt, ot) {
        hj(_, _e);
        var at = (_e.flags & 128) !== 0;
        if (!tt && !at) return nt && dg(_e, et, !1), $i(_, _e, ot);
        tt = _e.stateNode, Xi.current = _e;
        var st = at && typeof et.getDerivedStateFromError != "function" ? null : tt.render();
        return _e.flags |= 1, _ !== null && at ? (_e.child = Bh(_e, _.child, null, ot), _e.child = Bh(_e, null, st, ot)) : Yi(_, _e, st, ot), _e.memoizedState = tt.state, nt && dg(_e, et, !0), _e.child
    }

    function lj(_) {
        var _e = _.stateNode;
        _e.pendingContext ? ag(_, _e.pendingContext, _e.pendingContext !== _e.context) : _e.context && ag(_, _e.context, !1), Ih(_, _e.containerInfo)
    }

    function mj(_, _e, et, tt, nt) {
        return Ig(), Jg(nt), _e.flags |= 256, Yi(_, _e, et, tt), _e.child
    }
    var nj = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };

    function oj(_) {
        return {
            baseLanes: _,
            cachePool: null,
            transitions: null
        }
    }

    function pj(_, _e, et) {
        var tt = _e.pendingProps,
            nt = M.current,
            ot = !1,
            at = (_e.flags & 128) !== 0,
            st;
        if ((st = at) || (st = _ !== null && _.memoizedState === null ? !1 : (nt & 2) !== 0), st ? (ot = !0, _e.flags &= -129) : (_ === null || _.memoizedState !== null) && (nt |= 1), G(M, nt & 1), _ === null) return Eg(_e), _ = _e.memoizedState, _ !== null && (_ = _.dehydrated, _ !== null) ? (_e.mode & 1 ? _.data === "$!" ? _e.lanes = 8 : _e.lanes = 1073741824 : _e.lanes = 1, null) : (at = tt.children, _ = tt.fallback, ot ? (tt = _e.mode, ot = _e.child, at = {
            mode: "hidden",
            children: at
        }, !(tt & 1) && ot !== null ? (ot.childLanes = 0, ot.pendingProps = at) : ot = qj(at, tt, 0, null), _ = Ah(_, tt, et, null), ot.return = _e, _.return = _e, ot.sibling = _, _e.child = ot, _e.child.memoizedState = oj(et), _e.memoizedState = nj, _) : rj(_e, at));
        if (nt = _.memoizedState, nt !== null && (st = nt.dehydrated, st !== null)) return sj(_, _e, at, tt, st, nt, et);
        if (ot) {
            ot = tt.fallback, at = _e.mode, nt = _.child, st = nt.sibling;
            var lt = {
                mode: "hidden",
                children: tt.children
            };
            return !(at & 1) && _e.child !== nt ? (tt = _e.child, tt.childLanes = 0, tt.pendingProps = lt, _e.deletions = null) : (tt = wh(nt, lt), tt.subtreeFlags = nt.subtreeFlags & 14680064), st !== null ? ot = wh(st, ot) : (ot = Ah(ot, at, et, null), ot.flags |= 2), ot.return = _e, tt.return = _e, tt.sibling = ot, _e.child = tt, tt = ot, ot = _e.child, at = _.child.memoizedState, at = at === null ? oj(et) : {
                baseLanes: at.baseLanes | et,
                cachePool: null,
                transitions: at.transitions
            }, ot.memoizedState = at, ot.childLanes = _.childLanes & ~et, _e.memoizedState = nj, tt
        }
        return ot = _.child, _ = ot.sibling, tt = wh(ot, {
            mode: "visible",
            children: tt.children
        }), !(_e.mode & 1) && (tt.lanes = et), tt.return = _e, tt.sibling = null, _ !== null && (et = _e.deletions, et === null ? (_e.deletions = [_], _e.flags |= 16) : et.push(_)), _e.child = tt, _e.memoizedState = null, tt
    }

    function rj(_, _e) {
        return _e = qj({
            mode: "visible",
            children: _e
        }, _.mode, 0, null), _e.return = _, _.child = _e
    }

    function tj(_, _e, et, tt) {
        return tt !== null && Jg(tt), Bh(_e, _.child, null, et), _ = rj(_e, _e.pendingProps.children), _.flags |= 2, _e.memoizedState = null, _
    }

    function sj(_, _e, et, tt, nt, ot, at) {
        if (et) return _e.flags & 256 ? (_e.flags &= -257, tt = Li(Error(p$2(422))), tj(_, _e, at, tt)) : _e.memoizedState !== null ? (_e.child = _.child, _e.flags |= 128, null) : (ot = tt.fallback, nt = _e.mode, tt = qj({
            mode: "visible",
            children: tt.children
        }, nt, 0, null), ot = Ah(ot, nt, at, null), ot.flags |= 2, tt.return = _e, ot.return = _e, tt.sibling = ot, _e.child = tt, _e.mode & 1 && Bh(_e, _.child, null, at), _e.child.memoizedState = oj(at), _e.memoizedState = nj, ot);
        if (!(_e.mode & 1)) return tj(_, _e, at, null);
        if (nt.data === "$!") {
            if (tt = nt.nextSibling && nt.nextSibling.dataset, tt) var st = tt.dgst;
            return tt = st, ot = Error(p$2(419)), tt = Li(ot, tt, void 0), tj(_, _e, at, tt)
        }
        if (st = (at & _.childLanes) !== 0, Ug || st) {
            if (tt = R$1, tt !== null) {
                switch (at & -at) {
                    case 4:
                        nt = 2;
                        break;
                    case 16:
                        nt = 8;
                        break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        nt = 32;
                        break;
                    case 536870912:
                        nt = 268435456;
                        break;
                    default:
                        nt = 0
                }
                nt = nt & (tt.suspendedLanes | at) ? 0 : nt, nt !== 0 && nt !== ot.retryLane && (ot.retryLane = nt, Zg(_, nt), mh(tt, _, nt, -1))
            }
            return uj(), tt = Li(Error(p$2(421))), tj(_, _e, at, tt)
        }
        return nt.data === "$?" ? (_e.flags |= 128, _e.child = _.child, _e = vj.bind(null, _), nt._reactRetry = _e, null) : (_ = ot.treeContext, yg = Lf(nt.nextSibling), xg = _e, I = !0, zg = null, _ !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = _.id, sg = _.overflow, qg = _e), _e = rj(_e, tt.children), _e.flags |= 4096, _e)
    }

    function wj(_, _e, et) {
        _.lanes |= _e;
        var tt = _.alternate;
        tt !== null && (tt.lanes |= _e), Sg(_.return, _e, et)
    }

    function xj(_, _e, et, tt, nt) {
        var ot = _.memoizedState;
        ot === null ? _.memoizedState = {
            isBackwards: _e,
            rendering: null,
            renderingStartTime: 0,
            last: tt,
            tail: et,
            tailMode: nt
        } : (ot.isBackwards = _e, ot.rendering = null, ot.renderingStartTime = 0, ot.last = tt, ot.tail = et, ot.tailMode = nt)
    }

    function yj(_, _e, et) {
        var tt = _e.pendingProps,
            nt = tt.revealOrder,
            ot = tt.tail;
        if (Yi(_, _e, tt.children, et), tt = M.current, tt & 2) tt = tt & 1 | 2, _e.flags |= 128;
        else {
            if (_ !== null && _.flags & 128) e: for (_ = _e.child; _ !== null;) {
                if (_.tag === 13) _.memoizedState !== null && wj(_, et, _e);
                else if (_.tag === 19) wj(_, et, _e);
                else if (_.child !== null) {
                    _.child.return = _, _ = _.child;
                    continue
                }
                if (_ === _e) break e;
                for (; _.sibling === null;) {
                    if (_.return === null || _.return === _e) break e;
                    _ = _.return
                }
                _.sibling.return = _.return, _ = _.sibling
            }
            tt &= 1
        }
        if (G(M, tt), !(_e.mode & 1)) _e.memoizedState = null;
        else switch (nt) {
            case "forwards":
                for (et = _e.child, nt = null; et !== null;) _ = et.alternate, _ !== null && Mh(_) === null && (nt = et), et = et.sibling;
                et = nt, et === null ? (nt = _e.child, _e.child = null) : (nt = et.sibling, et.sibling = null), xj(_e, !1, nt, et, ot);
                break;
            case "backwards":
                for (et = null, nt = _e.child, _e.child = null; nt !== null;) {
                    if (_ = nt.alternate, _ !== null && Mh(_) === null) {
                        _e.child = nt;
                        break
                    }
                    _ = nt.sibling, nt.sibling = et, et = nt, nt = _
                }
                xj(_e, !0, et, null, ot);
                break;
            case "together":
                xj(_e, !1, null, null, void 0);
                break;
            default:
                _e.memoizedState = null
        }
        return _e.child
    }

    function jj(_, _e) {
        !(_e.mode & 1) && _ !== null && (_.alternate = null, _e.alternate = null, _e.flags |= 2)
    }

    function $i(_, _e, et) {
        if (_ !== null && (_e.dependencies = _.dependencies), hh |= _e.lanes, !(et & _e.childLanes)) return null;
        if (_ !== null && _e.child !== _.child) throw Error(p$2(153));
        if (_e.child !== null) {
            for (_ = _e.child, et = wh(_, _.pendingProps), _e.child = et, et.return = _e; _.sibling !== null;) _ = _.sibling, et = et.sibling = wh(_, _.pendingProps), et.return = _e;
            et.sibling = null
        }
        return _e.child
    }

    function zj(_, _e, et) {
        switch (_e.tag) {
            case 3:
                lj(_e), Ig();
                break;
            case 5:
                Kh(_e);
                break;
            case 1:
                Zf(_e.type) && cg(_e);
                break;
            case 4:
                Ih(_e, _e.stateNode.containerInfo);
                break;
            case 10:
                var tt = _e.type._context,
                    nt = _e.memoizedProps.value;
                G(Mg, tt._currentValue), tt._currentValue = nt;
                break;
            case 13:
                if (tt = _e.memoizedState, tt !== null) return tt.dehydrated !== null ? (G(M, M.current & 1), _e.flags |= 128, null) : et & _e.child.childLanes ? pj(_, _e, et) : (G(M, M.current & 1), _ = $i(_, _e, et), _ !== null ? _.sibling : null);
                G(M, M.current & 1);
                break;
            case 19:
                if (tt = (et & _e.childLanes) !== 0, _.flags & 128) {
                    if (tt) return yj(_, _e, et);
                    _e.flags |= 128
                }
                if (nt = _e.memoizedState, nt !== null && (nt.rendering = null, nt.tail = null, nt.lastEffect = null), G(M, M.current), tt) break;
                return null;
            case 22:
            case 23:
                return _e.lanes = 0, ej(_, _e, et)
        }
        return $i(_, _e, et)
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(_, _e) {
        for (var et = _e.child; et !== null;) {
            if (et.tag === 5 || et.tag === 6) _.appendChild(et.stateNode);
            else if (et.tag !== 4 && et.child !== null) {
                et.child.return = et, et = et.child;
                continue
            }
            if (et === _e) break;
            for (; et.sibling === null;) {
                if (et.return === null || et.return === _e) return;
                et = et.return
            }
            et.sibling.return = et.return, et = et.sibling
        }
    }, Bj = function() {}, Cj = function(_, _e, et, tt) {
        var nt = _.memoizedProps;
        if (nt !== tt) {
            _ = _e.stateNode, Hh(Eh.current);
            var ot = null;
            switch (et) {
                case "input":
                    nt = Ya(_, nt), tt = Ya(_, tt), ot = [];
                    break;
                case "select":
                    nt = A({}, nt, {
                        value: void 0
                    }), tt = A({}, tt, {
                        value: void 0
                    }), ot = [];
                    break;
                case "textarea":
                    nt = gb(_, nt), tt = gb(_, tt), ot = [];
                    break;
                default:
                    typeof nt.onClick != "function" && typeof tt.onClick == "function" && (_.onclick = Bf)
            }
            ub(et, tt);
            var at;
            et = null;
            for (ut in nt)
                if (!tt.hasOwnProperty(ut) && nt.hasOwnProperty(ut) && nt[ut] != null)
                    if (ut === "style") {
                        var st = nt[ut];
                        for (at in st) st.hasOwnProperty(at) && (et || (et = {}), et[at] = "")
                    } else ut !== "dangerouslySetInnerHTML" && ut !== "children" && ut !== "suppressContentEditableWarning" && ut !== "suppressHydrationWarning" && ut !== "autoFocus" && (ea.hasOwnProperty(ut) ? ot || (ot = []) : (ot = ot || []).push(ut, null));
            for (ut in tt) {
                var lt = tt[ut];
                if (st = nt == null ? void 0 : nt[ut], tt.hasOwnProperty(ut) && lt !== st && (lt != null || st != null))
                    if (ut === "style")
                        if (st) {
                            for (at in st) !st.hasOwnProperty(at) || lt && lt.hasOwnProperty(at) || (et || (et = {}), et[at] = "");
                            for (at in lt) lt.hasOwnProperty(at) && st[at] !== lt[at] && (et || (et = {}), et[at] = lt[at])
                        } else et || (ot || (ot = []), ot.push(ut, et)), et = lt;
                else ut === "dangerouslySetInnerHTML" ? (lt = lt ? lt.__html : void 0, st = st ? st.__html : void 0, lt != null && st !== lt && (ot = ot || []).push(ut, lt)) : ut === "children" ? typeof lt != "string" && typeof lt != "number" || (ot = ot || []).push(ut, "" + lt) : ut !== "suppressContentEditableWarning" && ut !== "suppressHydrationWarning" && (ea.hasOwnProperty(ut) ? (lt != null && ut === "onScroll" && D$1("scroll", _), ot || st === lt || (ot = [])) : (ot = ot || []).push(ut, lt))
            }
            et && (ot = ot || []).push("style", et);
            var ut = ot;
            (_e.updateQueue = ut) && (_e.flags |= 4)
        }
    }, Dj = function(_, _e, et, tt) {
        et !== tt && (_e.flags |= 4)
    };

    function Ej(_, _e) {
        if (!I) switch (_.tailMode) {
            case "hidden":
                _e = _.tail;
                for (var et = null; _e !== null;) _e.alternate !== null && (et = _e), _e = _e.sibling;
                et === null ? _.tail = null : et.sibling = null;
                break;
            case "collapsed":
                et = _.tail;
                for (var tt = null; et !== null;) et.alternate !== null && (tt = et), et = et.sibling;
                tt === null ? _e || _.tail === null ? _.tail = null : _.tail.sibling = null : tt.sibling = null
        }
    }

    function S$1(_) {
        var _e = _.alternate !== null && _.alternate.child === _.child,
            et = 0,
            tt = 0;
        if (_e)
            for (var nt = _.child; nt !== null;) et |= nt.lanes | nt.childLanes, tt |= nt.subtreeFlags & 14680064, tt |= nt.flags & 14680064, nt.return = _, nt = nt.sibling;
        else
            for (nt = _.child; nt !== null;) et |= nt.lanes | nt.childLanes, tt |= nt.subtreeFlags, tt |= nt.flags, nt.return = _, nt = nt.sibling;
        return _.subtreeFlags |= tt, _.childLanes = et, _e
    }

    function Fj(_, _e, et) {
        var tt = _e.pendingProps;
        switch (wg(_e), _e.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return S$1(_e), null;
            case 1:
                return Zf(_e.type) && $f(), S$1(_e), null;
            case 3:
                return tt = _e.stateNode, Jh(), E$1(Wf), E$1(H), Oh(), tt.pendingContext && (tt.context = tt.pendingContext, tt.pendingContext = null), (_ === null || _.child === null) && (Gg(_e) ? _e.flags |= 4 : _ === null || _.memoizedState.isDehydrated && !(_e.flags & 256) || (_e.flags |= 1024, zg !== null && (Gj(zg), zg = null))), Bj(_, _e), S$1(_e), null;
            case 5:
                Lh(_e);
                var nt = Hh(Gh.current);
                if (et = _e.type, _ !== null && _e.stateNode != null) Cj(_, _e, et, tt, nt), _.ref !== _e.ref && (_e.flags |= 512, _e.flags |= 2097152);
                else {
                    if (!tt) {
                        if (_e.stateNode === null) throw Error(p$2(166));
                        return S$1(_e), null
                    }
                    if (_ = Hh(Eh.current), Gg(_e)) {
                        tt = _e.stateNode, et = _e.type;
                        var ot = _e.memoizedProps;
                        switch (tt[Of] = _e, tt[Pf] = ot, _ = (_e.mode & 1) !== 0, et) {
                            case "dialog":
                                D$1("cancel", tt), D$1("close", tt);
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                D$1("load", tt);
                                break;
                            case "video":
                            case "audio":
                                for (nt = 0; nt < lf.length; nt++) D$1(lf[nt], tt);
                                break;
                            case "source":
                                D$1("error", tt);
                                break;
                            case "img":
                            case "image":
                            case "link":
                                D$1("error", tt), D$1("load", tt);
                                break;
                            case "details":
                                D$1("toggle", tt);
                                break;
                            case "input":
                                Za(tt, ot), D$1("invalid", tt);
                                break;
                            case "select":
                                tt._wrapperState = {
                                    wasMultiple: !!ot.multiple
                                }, D$1("invalid", tt);
                                break;
                            case "textarea":
                                hb(tt, ot), D$1("invalid", tt)
                        }
                        ub(et, ot), nt = null;
                        for (var at in ot)
                            if (ot.hasOwnProperty(at)) {
                                var st = ot[at];
                                at === "children" ? typeof st == "string" ? tt.textContent !== st && (ot.suppressHydrationWarning !== !0 && Af(tt.textContent, st, _), nt = ["children", st]) : typeof st == "number" && tt.textContent !== "" + st && (ot.suppressHydrationWarning !== !0 && Af(tt.textContent, st, _), nt = ["children", "" + st]) : ea.hasOwnProperty(at) && st != null && at === "onScroll" && D$1("scroll", tt)
                            }
                        switch (et) {
                            case "input":
                                Va(tt), db(tt, ot, !0);
                                break;
                            case "textarea":
                                Va(tt), jb(tt);
                                break;
                            case "select":
                            case "option":
                                break;
                            default:
                                typeof ot.onClick == "function" && (tt.onclick = Bf)
                        }
                        tt = nt, _e.updateQueue = tt, tt !== null && (_e.flags |= 4)
                    } else {
                        at = nt.nodeType === 9 ? nt : nt.ownerDocument, _ === "http://www.w3.org/1999/xhtml" && (_ = kb(et)), _ === "http://www.w3.org/1999/xhtml" ? et === "script" ? (_ = at.createElement("div"), _.innerHTML = "<script><\/script>", _ = _.removeChild(_.firstChild)) : typeof tt.is == "string" ? _ = at.createElement(et, {
                            is: tt.is
                        }) : (_ = at.createElement(et), et === "select" && (at = _, tt.multiple ? at.multiple = !0 : tt.size && (at.size = tt.size))) : _ = at.createElementNS(_, et), _[Of] = _e, _[Pf] = tt, Aj(_, _e, !1, !1), _e.stateNode = _;
                        e: {
                            switch (at = vb(et, tt), et) {
                                case "dialog":
                                    D$1("cancel", _), D$1("close", _), nt = tt;
                                    break;
                                case "iframe":
                                case "object":
                                case "embed":
                                    D$1("load", _), nt = tt;
                                    break;
                                case "video":
                                case "audio":
                                    for (nt = 0; nt < lf.length; nt++) D$1(lf[nt], _);
                                    nt = tt;
                                    break;
                                case "source":
                                    D$1("error", _), nt = tt;
                                    break;
                                case "img":
                                case "image":
                                case "link":
                                    D$1("error", _), D$1("load", _), nt = tt;
                                    break;
                                case "details":
                                    D$1("toggle", _), nt = tt;
                                    break;
                                case "input":
                                    Za(_, tt), nt = Ya(_, tt), D$1("invalid", _);
                                    break;
                                case "option":
                                    nt = tt;
                                    break;
                                case "select":
                                    _._wrapperState = {
                                        wasMultiple: !!tt.multiple
                                    }, nt = A({}, tt, {
                                        value: void 0
                                    }), D$1("invalid", _);
                                    break;
                                case "textarea":
                                    hb(_, tt), nt = gb(_, tt), D$1("invalid", _);
                                    break;
                                default:
                                    nt = tt
                            }
                            ub(et, nt),
                            st = nt;
                            for (ot in st)
                                if (st.hasOwnProperty(ot)) {
                                    var lt = st[ot];
                                    ot === "style" ? sb(_, lt) : ot === "dangerouslySetInnerHTML" ? (lt = lt ? lt.__html : void 0, lt != null && nb(_, lt)) : ot === "children" ? typeof lt == "string" ? (et !== "textarea" || lt !== "") && ob(_, lt) : typeof lt == "number" && ob(_, "" + lt) : ot !== "suppressContentEditableWarning" && ot !== "suppressHydrationWarning" && ot !== "autoFocus" && (ea.hasOwnProperty(ot) ? lt != null && ot === "onScroll" && D$1("scroll", _) : lt != null && ta(_, ot, lt, at))
                                }
                            switch (et) {
                                case "input":
                                    Va(_), db(_, tt, !1);
                                    break;
                                case "textarea":
                                    Va(_), jb(_);
                                    break;
                                case "option":
                                    tt.value != null && _.setAttribute("value", "" + Sa(tt.value));
                                    break;
                                case "select":
                                    _.multiple = !!tt.multiple, ot = tt.value, ot != null ? fb(_, !!tt.multiple, ot, !1) : tt.defaultValue != null && fb(_, !!tt.multiple, tt.defaultValue, !0);
                                    break;
                                default:
                                    typeof nt.onClick == "function" && (_.onclick = Bf)
                            }
                            switch (et) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    tt = !!tt.autoFocus;
                                    break e;
                                case "img":
                                    tt = !0;
                                    break e;
                                default:
                                    tt = !1
                            }
                        }
                        tt && (_e.flags |= 4)
                    }
                    _e.ref !== null && (_e.flags |= 512, _e.flags |= 2097152)
                }
                return S$1(_e), null;
            case 6:
                if (_ && _e.stateNode != null) Dj(_, _e, _.memoizedProps, tt);
                else {
                    if (typeof tt != "string" && _e.stateNode === null) throw Error(p$2(166));
                    if (et = Hh(Gh.current), Hh(Eh.current), Gg(_e)) {
                        if (tt = _e.stateNode, et = _e.memoizedProps, tt[Of] = _e, (ot = tt.nodeValue !== et) && (_ = xg, _ !== null)) switch (_.tag) {
                            case 3:
                                Af(tt.nodeValue, et, (_.mode & 1) !== 0);
                                break;
                            case 5:
                                _.memoizedProps.suppressHydrationWarning !== !0 && Af(tt.nodeValue, et, (_.mode & 1) !== 0)
                        }
                        ot && (_e.flags |= 4)
                    } else tt = (et.nodeType === 9 ? et : et.ownerDocument).createTextNode(tt), tt[Of] = _e, _e.stateNode = tt
                }
                return S$1(_e), null;
            case 13:
                if (E$1(M), tt = _e.memoizedState, _ === null || _.memoizedState !== null && _.memoizedState.dehydrated !== null) {
                    if (I && yg !== null && _e.mode & 1 && !(_e.flags & 128)) Hg(), Ig(), _e.flags |= 98560, ot = !1;
                    else if (ot = Gg(_e), tt !== null && tt.dehydrated !== null) {
                        if (_ === null) {
                            if (!ot) throw Error(p$2(318));
                            if (ot = _e.memoizedState, ot = ot !== null ? ot.dehydrated : null, !ot) throw Error(p$2(317));
                            ot[Of] = _e
                        } else Ig(), !(_e.flags & 128) && (_e.memoizedState = null), _e.flags |= 4;
                        S$1(_e), ot = !1
                    } else zg !== null && (Gj(zg), zg = null), ot = !0;
                    if (!ot) return _e.flags & 65536 ? _e : null
                }
                return _e.flags & 128 ? (_e.lanes = et, _e) : (tt = tt !== null, tt !== (_ !== null && _.memoizedState !== null) && tt && (_e.child.flags |= 8192, _e.mode & 1 && (_ === null || M.current & 1 ? T$1 === 0 && (T$1 = 3) : uj())), _e.updateQueue !== null && (_e.flags |= 4), S$1(_e), null);
            case 4:
                return Jh(), Bj(_, _e), _ === null && sf(_e.stateNode.containerInfo), S$1(_e), null;
            case 10:
                return Rg(_e.type._context), S$1(_e), null;
            case 17:
                return Zf(_e.type) && $f(), S$1(_e), null;
            case 19:
                if (E$1(M), ot = _e.memoizedState, ot === null) return S$1(_e), null;
                if (tt = (_e.flags & 128) !== 0, at = ot.rendering, at === null)
                    if (tt) Ej(ot, !1);
                    else {
                        if (T$1 !== 0 || _ !== null && _.flags & 128)
                            for (_ = _e.child; _ !== null;) {
                                if (at = Mh(_), at !== null) {
                                    for (_e.flags |= 128, Ej(ot, !1), tt = at.updateQueue, tt !== null && (_e.updateQueue = tt, _e.flags |= 4), _e.subtreeFlags = 0, tt = et, et = _e.child; et !== null;) ot = et, _ = tt, ot.flags &= 14680066, at = ot.alternate, at === null ? (ot.childLanes = 0, ot.lanes = _, ot.child = null, ot.subtreeFlags = 0, ot.memoizedProps = null, ot.memoizedState = null, ot.updateQueue = null, ot.dependencies = null, ot.stateNode = null) : (ot.childLanes = at.childLanes, ot.lanes = at.lanes, ot.child = at.child, ot.subtreeFlags = 0, ot.deletions = null, ot.memoizedProps = at.memoizedProps, ot.memoizedState = at.memoizedState, ot.updateQueue = at.updateQueue, ot.type = at.type, _ = at.dependencies, ot.dependencies = _ === null ? null : {
                                        lanes: _.lanes,
                                        firstContext: _.firstContext
                                    }), et = et.sibling;
                                    return G(M, M.current & 1 | 2), _e.child
                                }
                                _ = _.sibling
                            }
                        ot.tail !== null && B$1() > Hj && (_e.flags |= 128, tt = !0, Ej(ot, !1), _e.lanes = 4194304)
                    }
                else {
                    if (!tt)
                        if (_ = Mh(at), _ !== null) {
                            if (_e.flags |= 128, tt = !0, et = _.updateQueue, et !== null && (_e.updateQueue = et, _e.flags |= 4), Ej(ot, !0), ot.tail === null && ot.tailMode === "hidden" && !at.alternate && !I) return S$1(_e), null
                        } else 2 * B$1() - ot.renderingStartTime > Hj && et !== 1073741824 && (_e.flags |= 128, tt = !0, Ej(ot, !1), _e.lanes = 4194304);
                    ot.isBackwards ? (at.sibling = _e.child, _e.child = at) : (et = ot.last, et !== null ? et.sibling = at : _e.child = at, ot.last = at)
                }
                return ot.tail !== null ? (_e = ot.tail, ot.rendering = _e, ot.tail = _e.sibling, ot.renderingStartTime = B$1(), _e.sibling = null, et = M.current, G(M, tt ? et & 1 | 2 : et & 1), _e) : (S$1(_e), null);
            case 22:
            case 23:
                return Ij(), tt = _e.memoizedState !== null, _ !== null && _.memoizedState !== null !== tt && (_e.flags |= 8192), tt && _e.mode & 1 ? gj & 1073741824 && (S$1(_e), _e.subtreeFlags & 6 && (_e.flags |= 8192)) : S$1(_e), null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(p$2(156, _e.tag))
    }

    function Jj(_, _e) {
        switch (wg(_e), _e.tag) {
            case 1:
                return Zf(_e.type) && $f(), _ = _e.flags, _ & 65536 ? (_e.flags = _ & -65537 | 128, _e) : null;
            case 3:
                return Jh(), E$1(Wf), E$1(H), Oh(), _ = _e.flags, _ & 65536 && !(_ & 128) ? (_e.flags = _ & -65537 | 128, _e) : null;
            case 5:
                return Lh(_e), null;
            case 13:
                if (E$1(M), _ = _e.memoizedState, _ !== null && _.dehydrated !== null) {
                    if (_e.alternate === null) throw Error(p$2(340));
                    Ig()
                }
                return _ = _e.flags, _ & 65536 ? (_e.flags = _ & -65537 | 128, _e) : null;
            case 19:
                return E$1(M), null;
            case 4:
                return Jh(), null;
            case 10:
                return Rg(_e.type._context), null;
            case 22:
            case 23:
                return Ij(), null;
            case 24:
                return null;
            default:
                return null
        }
    }
    var Kj = !1,
        U$1 = !1,
        Lj = typeof WeakSet == "function" ? WeakSet : Set,
        V$1 = null;

    function Mj(_, _e) {
        var et = _.ref;
        if (et !== null)
            if (typeof et == "function") try {
                et(null)
            } catch (tt) {
                W(_, _e, tt)
            } else et.current = null
    }

    function Nj(_, _e, et) {
        try {
            et()
        } catch (tt) {
            W(_, _e, tt)
        }
    }
    var Oj = !1;

    function Pj(_, _e) {
        if (Cf = dd, _ = Me(), Ne(_)) {
            if ("selectionStart" in _) var et = {
                start: _.selectionStart,
                end: _.selectionEnd
            };
            else e: {
                et = (et = _.ownerDocument) && et.defaultView || window;
                var tt = et.getSelection && et.getSelection();
                if (tt && tt.rangeCount !== 0) {
                    et = tt.anchorNode;
                    var nt = tt.anchorOffset,
                        ot = tt.focusNode;
                    tt = tt.focusOffset;
                    try {
                        et.nodeType, ot.nodeType
                    } catch (yt) {
                        et = null;
                        break e
                    }
                    var at = 0,
                        st = -1,
                        lt = -1,
                        ut = 0,
                        dt = 0,
                        ct = _,
                        pt = null;
                    t: for (;;) {
                        for (var ft; ct !== et || nt !== 0 && ct.nodeType !== 3 || (st = at + nt), ct !== ot || tt !== 0 && ct.nodeType !== 3 || (lt = at + tt), ct.nodeType === 3 && (at += ct.nodeValue.length), (ft = ct.firstChild) !== null;) pt = ct, ct = ft;
                        for (;;) {
                            if (ct === _) break t;
                            if (pt === et && ++ut === nt && (st = at), pt === ot && ++dt === tt && (lt = at), (ft = ct.nextSibling) !== null) break;
                            ct = pt, pt = ct.parentNode
                        }
                        ct = ft
                    }
                    et = st === -1 || lt === -1 ? null : {
                        start: st,
                        end: lt
                    }
                } else et = null
            }
            et = et || {
                start: 0,
                end: 0
            }
        } else et = null;
        for (Df = {
                focusedElem: _,
                selectionRange: et
            }, dd = !1, V$1 = _e; V$1 !== null;)
            if (_e = V$1, _ = _e.child, (_e.subtreeFlags & 1028) !== 0 && _ !== null) _.return = _e, V$1 = _;
            else
                for (; V$1 !== null;) {
                    _e = V$1;
                    try {
                        var ht = _e.alternate;
                        if (_e.flags & 1024) switch (_e.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (ht !== null) {
                                    var mt = ht.memoizedProps,
                                        bt = ht.memoizedState,
                                        gt = _e.stateNode,
                                        vt = gt.getSnapshotBeforeUpdate(_e.elementType === _e.type ? mt : Lg(_e.type, mt), bt);
                                    gt.__reactInternalSnapshotBeforeUpdate = vt
                                }
                                break;
                            case 3:
                                var xt = _e.stateNode.containerInfo;
                                xt.nodeType === 1 ? xt.textContent = "" : xt.nodeType === 9 && xt.documentElement && xt.removeChild(xt.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(p$2(163))
                        }
                    } catch (yt) {
                        W(_e, _e.return, yt)
                    }
                    if (_ = _e.sibling, _ !== null) {
                        _.return = _e.return, V$1 = _;
                        break
                    }
                    V$1 = _e.return
                }
        return ht = Oj, Oj = !1, ht
    }

    function Qj(_, _e, et) {
        var tt = _e.updateQueue;
        if (tt = tt !== null ? tt.lastEffect : null, tt !== null) {
            var nt = tt = tt.next;
            do {
                if ((nt.tag & _) === _) {
                    var ot = nt.destroy;
                    nt.destroy = void 0, ot !== void 0 && Nj(_e, et, ot)
                }
                nt = nt.next
            } while (nt !== tt)
        }
    }

    function Rj(_, _e) {
        if (_e = _e.updateQueue, _e = _e !== null ? _e.lastEffect : null, _e !== null) {
            var et = _e = _e.next;
            do {
                if ((et.tag & _) === _) {
                    var tt = et.create;
                    et.destroy = tt()
                }
                et = et.next
            } while (et !== _e)
        }
    }

    function Sj(_) {
        var _e = _.ref;
        if (_e !== null) {
            var et = _.stateNode;
            switch (_.tag) {
                case 5:
                    _ = et;
                    break;
                default:
                    _ = et
            }
            typeof _e == "function" ? _e(_) : _e.current = _
        }
    }

    function Tj(_) {
        var _e = _.alternate;
        _e !== null && (_.alternate = null, Tj(_e)), _.child = null, _.deletions = null, _.sibling = null, _.tag === 5 && (_e = _.stateNode, _e !== null && (delete _e[Of], delete _e[Pf], delete _e[ of ], delete _e[Qf], delete _e[Rf])), _.stateNode = null, _.return = null, _.dependencies = null, _.memoizedProps = null, _.memoizedState = null, _.pendingProps = null, _.stateNode = null, _.updateQueue = null
    }

    function Uj(_) {
        return _.tag === 5 || _.tag === 3 || _.tag === 4
    }

    function Vj(_) {
        e: for (;;) {
            for (; _.sibling === null;) {
                if (_.return === null || Uj(_.return)) return null;
                _ = _.return
            }
            for (_.sibling.return = _.return, _ = _.sibling; _.tag !== 5 && _.tag !== 6 && _.tag !== 18;) {
                if (_.flags & 2 || _.child === null || _.tag === 4) continue e;
                _.child.return = _, _ = _.child
            }
            if (!(_.flags & 2)) return _.stateNode
        }
    }

    function Wj(_, _e, et) {
        var tt = _.tag;
        if (tt === 5 || tt === 6) _ = _.stateNode, _e ? et.nodeType === 8 ? et.parentNode.insertBefore(_, _e) : et.insertBefore(_, _e) : (et.nodeType === 8 ? (_e = et.parentNode, _e.insertBefore(_, et)) : (_e = et, _e.appendChild(_)), et = et._reactRootContainer, et != null || _e.onclick !== null || (_e.onclick = Bf));
        else if (tt !== 4 && (_ = _.child, _ !== null))
            for (Wj(_, _e, et), _ = _.sibling; _ !== null;) Wj(_, _e, et), _ = _.sibling
    }

    function Xj(_, _e, et) {
        var tt = _.tag;
        if (tt === 5 || tt === 6) _ = _.stateNode, _e ? et.insertBefore(_, _e) : et.appendChild(_);
        else if (tt !== 4 && (_ = _.child, _ !== null))
            for (Xj(_, _e, et), _ = _.sibling; _ !== null;) Xj(_, _e, et), _ = _.sibling
    }
    var X = null,
        Yj = !1;

    function Zj(_, _e, et) {
        for (et = et.child; et !== null;) ak(_, _e, et), et = et.sibling
    }

    function ak(_, _e, et) {
        if (lc && typeof lc.onCommitFiberUnmount == "function") try {
            lc.onCommitFiberUnmount(kc, et)
        } catch (st) {}
        switch (et.tag) {
            case 5:
                U$1 || Mj(et, _e);
            case 6:
                var tt = X,
                    nt = Yj;
                X = null, Zj(_, _e, et), X = tt, Yj = nt, X !== null && (Yj ? (_ = X, et = et.stateNode, _.nodeType === 8 ? _.parentNode.removeChild(et) : _.removeChild(et)) : X.removeChild(et.stateNode));
                break;
            case 18:
                X !== null && (Yj ? (_ = X, et = et.stateNode, _.nodeType === 8 ? Kf(_.parentNode, et) : _.nodeType === 1 && Kf(_, et), bd(_)) : Kf(X, et.stateNode));
                break;
            case 4:
                tt = X, nt = Yj, X = et.stateNode.containerInfo, Yj = !0, Zj(_, _e, et), X = tt, Yj = nt;
                break;
            case 0:
            case 11:
            case 14:
            case 15:
                if (!U$1 && (tt = et.updateQueue, tt !== null && (tt = tt.lastEffect, tt !== null))) {
                    nt = tt = tt.next;
                    do {
                        var ot = nt,
                            at = ot.destroy;
                        ot = ot.tag, at !== void 0 && (ot & 2 || ot & 4) && Nj(et, _e, at), nt = nt.next
                    } while (nt !== tt)
                }
                Zj(_, _e, et);
                break;
            case 1:
                if (!U$1 && (Mj(et, _e), tt = et.stateNode, typeof tt.componentWillUnmount == "function")) try {
                    tt.props = et.memoizedProps, tt.state = et.memoizedState, tt.componentWillUnmount()
                } catch (st) {
                    W(et, _e, st)
                }
                Zj(_, _e, et);
                break;
            case 21:
                Zj(_, _e, et);
                break;
            case 22:
                et.mode & 1 ? (U$1 = (tt = U$1) || et.memoizedState !== null, Zj(_, _e, et), U$1 = tt) : Zj(_, _e, et);
                break;
            default:
                Zj(_, _e, et)
        }
    }

    function bk(_) {
        var _e = _.updateQueue;
        if (_e !== null) {
            _.updateQueue = null;
            var et = _.stateNode;
            et === null && (et = _.stateNode = new Lj), _e.forEach(function(tt) {
                var nt = ck.bind(null, _, tt);
                et.has(tt) || (et.add(tt), tt.then(nt, nt))
            })
        }
    }

    function dk(_, _e) {
        var et = _e.deletions;
        if (et !== null)
            for (var tt = 0; tt < et.length; tt++) {
                var nt = et[tt];
                try {
                    var ot = _,
                        at = _e,
                        st = at;
                    e: for (; st !== null;) {
                        switch (st.tag) {
                            case 5:
                                X = st.stateNode, Yj = !1;
                                break e;
                            case 3:
                                X = st.stateNode.containerInfo, Yj = !0;
                                break e;
                            case 4:
                                X = st.stateNode.containerInfo, Yj = !0;
                                break e
                        }
                        st = st.return
                    }
                    if (X === null) throw Error(p$2(160));
                    ak(ot, at, nt), X = null, Yj = !1;
                    var lt = nt.alternate;
                    lt !== null && (lt.return = null), nt.return = null
                } catch (ut) {
                    W(nt, _e, ut)
                }
            }
        if (_e.subtreeFlags & 12854)
            for (_e = _e.child; _e !== null;) ek(_e, _), _e = _e.sibling
    }

    function ek(_, _e) {
        var et = _.alternate,
            tt = _.flags;
        switch (_.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (dk(_e, _), fk(_), tt & 4) {
                    try {
                        Qj(3, _, _.return), Rj(3, _)
                    } catch (mt) {
                        W(_, _.return, mt)
                    }
                    try {
                        Qj(5, _, _.return)
                    } catch (mt) {
                        W(_, _.return, mt)
                    }
                }
                break;
            case 1:
                dk(_e, _), fk(_), tt & 512 && et !== null && Mj(et, et.return);
                break;
            case 5:
                if (dk(_e, _), fk(_), tt & 512 && et !== null && Mj(et, et.return), _.flags & 32) {
                    var nt = _.stateNode;
                    try {
                        ob(nt, "")
                    } catch (mt) {
                        W(_, _.return, mt)
                    }
                }
                if (tt & 4 && (nt = _.stateNode, nt != null)) {
                    var ot = _.memoizedProps,
                        at = et !== null ? et.memoizedProps : ot,
                        st = _.type,
                        lt = _.updateQueue;
                    if (_.updateQueue = null, lt !== null) try {
                        st === "input" && ot.type === "radio" && ot.name != null && ab(nt, ot), vb(st, at);
                        var ut = vb(st, ot);
                        for (at = 0; at < lt.length; at += 2) {
                            var dt = lt[at],
                                ct = lt[at + 1];
                            dt === "style" ? sb(nt, ct) : dt === "dangerouslySetInnerHTML" ? nb(nt, ct) : dt === "children" ? ob(nt, ct) : ta(nt, dt, ct, ut)
                        }
                        switch (st) {
                            case "input":
                                bb(nt, ot);
                                break;
                            case "textarea":
                                ib(nt, ot);
                                break;
                            case "select":
                                var pt = nt._wrapperState.wasMultiple;
                                nt._wrapperState.wasMultiple = !!ot.multiple;
                                var ft = ot.value;
                                ft != null ? fb(nt, !!ot.multiple, ft, !1) : pt !== !!ot.multiple && (ot.defaultValue != null ? fb(nt, !!ot.multiple, ot.defaultValue, !0) : fb(nt, !!ot.multiple, ot.multiple ? [] : "", !1))
                        }
                        nt[Pf] = ot
                    } catch (mt) {
                        W(_, _.return, mt)
                    }
                }
                break;
            case 6:
                if (dk(_e, _), fk(_), tt & 4) {
                    if (_.stateNode === null) throw Error(p$2(162));
                    nt = _.stateNode, ot = _.memoizedProps;
                    try {
                        nt.nodeValue = ot
                    } catch (mt) {
                        W(_, _.return, mt)
                    }
                }
                break;
            case 3:
                if (dk(_e, _), fk(_), tt & 4 && et !== null && et.memoizedState.isDehydrated) try {
                    bd(_e.containerInfo)
                } catch (mt) {
                    W(_, _.return, mt)
                }
                break;
            case 4:
                dk(_e, _), fk(_);
                break;
            case 13:
                dk(_e, _), fk(_), nt = _.child, nt.flags & 8192 && (ot = nt.memoizedState !== null, nt.stateNode.isHidden = ot, !ot || nt.alternate !== null && nt.alternate.memoizedState !== null || (gk = B$1())), tt & 4 && bk(_);
                break;
            case 22:
                if (dt = et !== null && et.memoizedState !== null, _.mode & 1 ? (U$1 = (ut = U$1) || dt, dk(_e, _), U$1 = ut) : dk(_e, _), fk(_), tt & 8192) {
                    if (ut = _.memoizedState !== null, (_.stateNode.isHidden = ut) && !dt && _.mode & 1)
                        for (V$1 = _, dt = _.child; dt !== null;) {
                            for (ct = V$1 = dt; V$1 !== null;) {
                                switch (pt = V$1, ft = pt.child, pt.tag) {
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        Qj(4, pt, pt.return);
                                        break;
                                    case 1:
                                        Mj(pt, pt.return);
                                        var ht = pt.stateNode;
                                        if (typeof ht.componentWillUnmount == "function") {
                                            tt = pt, et = pt.return;
                                            try {
                                                _e = tt, ht.props = _e.memoizedProps, ht.state = _e.memoizedState, ht.componentWillUnmount()
                                            } catch (mt) {
                                                W(tt, et, mt)
                                            }
                                        }
                                        break;
                                    case 5:
                                        Mj(pt, pt.return);
                                        break;
                                    case 22:
                                        if (pt.memoizedState !== null) {
                                            hk(ct);
                                            continue
                                        }
                                }
                                ft !== null ? (ft.return = pt, V$1 = ft) : hk(ct)
                            }
                            dt = dt.sibling
                        }
                    e: for (dt = null, ct = _;;) {
                        if (ct.tag === 5) {
                            if (dt === null) {
                                dt = ct;
                                try {
                                    nt = ct.stateNode, ut ? (ot = nt.style, typeof ot.setProperty == "function" ? ot.setProperty("display", "none", "important") : ot.display = "none") : (st = ct.stateNode, lt = ct.memoizedProps.style, at = lt != null && lt.hasOwnProperty("display") ? lt.display : null, st.style.display = rb("display", at))
                                } catch (mt) {
                                    W(_, _.return, mt)
                                }
                            }
                        } else if (ct.tag === 6) {
                            if (dt === null) try {
                                ct.stateNode.nodeValue = ut ? "" : ct.memoizedProps
                            } catch (mt) {
                                W(_, _.return, mt)
                            }
                        } else if ((ct.tag !== 22 && ct.tag !== 23 || ct.memoizedState === null || ct === _) && ct.child !== null) {
                            ct.child.return = ct, ct = ct.child;
                            continue
                        }
                        if (ct === _) break e;
                        for (; ct.sibling === null;) {
                            if (ct.return === null || ct.return === _) break e;
                            dt === ct && (dt = null), ct = ct.return
                        }
                        dt === ct && (dt = null), ct.sibling.return = ct.return, ct = ct.sibling
                    }
                }
                break;
            case 19:
                dk(_e, _), fk(_), tt & 4 && bk(_);
                break;
            case 21:
                break;
            default:
                dk(_e, _), fk(_)
        }
    }

    function fk(_) {
        var _e = _.flags;
        if (_e & 2) {
            try {
                e: {
                    for (var et = _.return; et !== null;) {
                        if (Uj(et)) {
                            var tt = et;
                            break e
                        }
                        et = et.return
                    }
                    throw Error(p$2(160))
                }
                switch (tt.tag) {
                    case 5:
                        var nt = tt.stateNode;
                        tt.flags & 32 && (ob(nt, ""), tt.flags &= -33);
                        var ot = Vj(_);
                        Xj(_, ot, nt);
                        break;
                    case 3:
                    case 4:
                        var at = tt.stateNode.containerInfo,
                            st = Vj(_);
                        Wj(_, st, at);
                        break;
                    default:
                        throw Error(p$2(161))
                }
            }
            catch (lt) {
                W(_, _.return, lt)
            }
            _.flags &= -3
        }
        _e & 4096 && (_.flags &= -4097)
    }

    function ik(_, _e, et) {
        V$1 = _, jk(_)
    }

    function jk(_, _e, et) {
        for (var tt = (_.mode & 1) !== 0; V$1 !== null;) {
            var nt = V$1,
                ot = nt.child;
            if (nt.tag === 22 && tt) {
                var at = nt.memoizedState !== null || Kj;
                if (!at) {
                    var st = nt.alternate,
                        lt = st !== null && st.memoizedState !== null || U$1;
                    st = Kj;
                    var ut = U$1;
                    if (Kj = at, (U$1 = lt) && !ut)
                        for (V$1 = nt; V$1 !== null;) at = V$1, lt = at.child, at.tag === 22 && at.memoizedState !== null ? kk(nt) : lt !== null ? (lt.return = at, V$1 = lt) : kk(nt);
                    for (; ot !== null;) V$1 = ot, jk(ot), ot = ot.sibling;
                    V$1 = nt, Kj = st, U$1 = ut
                }
                lk(_)
            } else nt.subtreeFlags & 8772 && ot !== null ? (ot.return = nt, V$1 = ot) : lk(_)
        }
    }

    function lk(_) {
        for (; V$1 !== null;) {
            var _e = V$1;
            if (_e.flags & 8772) {
                var et = _e.alternate;
                try {
                    if (_e.flags & 8772) switch (_e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            U$1 || Rj(5, _e);
                            break;
                        case 1:
                            var tt = _e.stateNode;
                            if (_e.flags & 4 && !U$1)
                                if (et === null) tt.componentDidMount();
                                else {
                                    var nt = _e.elementType === _e.type ? et.memoizedProps : Lg(_e.type, et.memoizedProps);
                                    tt.componentDidUpdate(nt, et.memoizedState, tt.__reactInternalSnapshotBeforeUpdate)
                                }
                            var ot = _e.updateQueue;
                            ot !== null && ih(_e, ot, tt);
                            break;
                        case 3:
                            var at = _e.updateQueue;
                            if (at !== null) {
                                if (et = null, _e.child !== null) switch (_e.child.tag) {
                                    case 5:
                                        et = _e.child.stateNode;
                                        break;
                                    case 1:
                                        et = _e.child.stateNode
                                }
                                ih(_e, at, et)
                            }
                            break;
                        case 5:
                            var st = _e.stateNode;
                            if (et === null && _e.flags & 4) {
                                et = st;
                                var lt = _e.memoizedProps;
                                switch (_e.type) {
                                    case "button":
                                    case "input":
                                    case "select":
                                    case "textarea":
                                        lt.autoFocus && et.focus();
                                        break;
                                    case "img":
                                        lt.src && (et.src = lt.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (_e.memoizedState === null) {
                                var ut = _e.alternate;
                                if (ut !== null) {
                                    var dt = ut.memoizedState;
                                    if (dt !== null) {
                                        var ct = dt.dehydrated;
                                        ct !== null && bd(ct)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(p$2(163))
                    }
                    U$1 || _e.flags & 512 && Sj(_e)
                } catch (pt) {
                    W(_e, _e.return, pt)
                }
            }
            if (_e === _) {
                V$1 = null;
                break
            }
            if (et = _e.sibling, et !== null) {
                et.return = _e.return, V$1 = et;
                break
            }
            V$1 = _e.return
        }
    }

    function hk(_) {
        for (; V$1 !== null;) {
            var _e = V$1;
            if (_e === _) {
                V$1 = null;
                break
            }
            var et = _e.sibling;
            if (et !== null) {
                et.return = _e.return, V$1 = et;
                break
            }
            V$1 = _e.return
        }
    }

    function kk(_) {
        for (; V$1 !== null;) {
            var _e = V$1;
            try {
                switch (_e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var et = _e.return;
                        try {
                            Rj(4, _e)
                        } catch (lt) {
                            W(_e, et, lt)
                        }
                        break;
                    case 1:
                        var tt = _e.stateNode;
                        if (typeof tt.componentDidMount == "function") {
                            var nt = _e.return;
                            try {
                                tt.componentDidMount()
                            } catch (lt) {
                                W(_e, nt, lt)
                            }
                        }
                        var ot = _e.return;
                        try {
                            Sj(_e)
                        } catch (lt) {
                            W(_e, ot, lt)
                        }
                        break;
                    case 5:
                        var at = _e.return;
                        try {
                            Sj(_e)
                        } catch (lt) {
                            W(_e, at, lt)
                        }
                }
            } catch (lt) {
                W(_e, _e.return, lt)
            }
            if (_e === _) {
                V$1 = null;
                break
            }
            var st = _e.sibling;
            if (st !== null) {
                st.return = _e.return, V$1 = st;
                break
            }
            V$1 = _e.return
        }
    }
    var mk = Math.ceil,
        nk = ua.ReactCurrentDispatcher,
        ok = ua.ReactCurrentOwner,
        pk = ua.ReactCurrentBatchConfig,
        K = 0,
        R$1 = null,
        Y = null,
        Z = 0,
        gj = 0,
        fj = Uf(0),
        T$1 = 0,
        qk = null,
        hh = 0,
        rk = 0,
        sk = 0,
        tk = null,
        uk = null,
        gk = 0,
        Hj = 1 / 0,
        vk = null,
        Pi = !1,
        Qi = null,
        Si = null,
        wk = !1,
        xk = null,
        yk = 0,
        zk = 0,
        Ak = null,
        Bk = -1,
        Ck = 0;

    function L() {
        return K & 6 ? B$1() : Bk !== -1 ? Bk : Bk = B$1()
    }

    function lh(_) {
        return _.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Ck === 0 && (Ck = yc()), Ck) : (_ = C$1, _ !== 0 || (_ = window.event, _ = _ === void 0 ? 16 : jd(_.type)), _) : 1
    }

    function mh(_, _e, et, tt) {
        if (50 < zk) throw zk = 0, Ak = null, Error(p$2(185));
        Ac(_, et, tt), (!(K & 2) || _ !== R$1) && (_ === R$1 && (!(K & 2) && (rk |= et), T$1 === 4 && Dk(_, Z)), Ek(_, tt), et === 1 && K === 0 && !(_e.mode & 1) && (Hj = B$1() + 500, fg && jg()))
    }

    function Ek(_, _e) {
        var et = _.callbackNode;
        wc(_, _e);
        var tt = uc(_, _ === R$1 ? Z : 0);
        if (tt === 0) et !== null && bc(et), _.callbackNode = null, _.callbackPriority = 0;
        else if (_e = tt & -tt, _.callbackPriority !== _e) {
            if (et != null && bc(et), _e === 1) _.tag === 0 ? ig(Fk.bind(null, _)) : hg(Fk.bind(null, _)), Jf(function() {
                !(K & 6) && jg()
            }), et = null;
            else {
                switch (Dc(tt)) {
                    case 1:
                        et = fc;
                        break;
                    case 4:
                        et = gc;
                        break;
                    case 16:
                        et = hc;
                        break;
                    case 536870912:
                        et = jc;
                        break;
                    default:
                        et = hc
                }
                et = Gk(et, Hk.bind(null, _))
            }
            _.callbackPriority = _e, _.callbackNode = et
        }
    }

    function Hk(_, _e) {
        if (Bk = -1, Ck = 0, K & 6) throw Error(p$2(327));
        var et = _.callbackNode;
        if (Ik() && _.callbackNode !== et) return null;
        var tt = uc(_, _ === R$1 ? Z : 0);
        if (tt === 0) return null;
        if (tt & 30 || tt & _.expiredLanes || _e) _e = Jk(_, tt);
        else {
            _e = tt;
            var nt = K;
            K |= 2;
            var ot = Kk();
            (R$1 !== _ || Z !== _e) && (vk = null, Hj = B$1() + 500, Lk(_, _e));
            do try {
                Mk();
                break
            } catch (st) {
                Nk(_, st)
            }
            while (1);
            Qg(), nk.current = ot, K = nt, Y !== null ? _e = 0 : (R$1 = null, Z = 0, _e = T$1)
        }
        if (_e !== 0) {
            if (_e === 2 && (nt = xc(_), nt !== 0 && (tt = nt, _e = Ok(_, nt))), _e === 1) throw et = qk, Lk(_, 0), Dk(_, tt), Ek(_, B$1()), et;
            if (_e === 6) Dk(_, tt);
            else {
                if (nt = _.current.alternate, !(tt & 30) && !Pk(nt) && (_e = Jk(_, tt), _e === 2 && (ot = xc(_), ot !== 0 && (tt = ot, _e = Ok(_, ot))), _e === 1)) throw et = qk, Lk(_, 0), Dk(_, tt), Ek(_, B$1()), et;
                switch (_.finishedWork = nt, _.finishedLanes = tt, _e) {
                    case 0:
                    case 1:
                        throw Error(p$2(345));
                    case 2:
                        Qk(_, uk, vk);
                        break;
                    case 3:
                        if (Dk(_, tt), (tt & 130023424) === tt && (_e = gk + 500 - B$1(), 10 < _e)) {
                            if (uc(_, 0) !== 0) break;
                            if (nt = _.suspendedLanes, (nt & tt) !== tt) {
                                L(), _.pingedLanes |= _.suspendedLanes & nt;
                                break
                            }
                            _.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), _e);
                            break
                        }
                        Qk(_, uk, vk);
                        break;
                    case 4:
                        if (Dk(_, tt), (tt & 4194240) === tt) break;
                        for (_e = _.eventTimes, nt = -1; 0 < tt;) {
                            var at = 31 - oc(tt);
                            ot = 1 << at, at = _e[at], at > nt && (nt = at), tt &= ~ot
                        }
                        if (tt = nt, tt = B$1() - tt, tt = (120 > tt ? 120 : 480 > tt ? 480 : 1080 > tt ? 1080 : 1920 > tt ? 1920 : 3e3 > tt ? 3e3 : 4320 > tt ? 4320 : 1960 * mk(tt / 1960)) - tt, 10 < tt) {
                            _.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), tt);
                            break
                        }
                        Qk(_, uk, vk);
                        break;
                    case 5:
                        Qk(_, uk, vk);
                        break;
                    default:
                        throw Error(p$2(329))
                }
            }
        }
        return Ek(_, B$1()), _.callbackNode === et ? Hk.bind(null, _) : null
    }

    function Ok(_, _e) {
        var et = tk;
        return _.current.memoizedState.isDehydrated && (Lk(_, _e).flags |= 256), _ = Jk(_, _e), _ !== 2 && (_e = uk, uk = et, _e !== null && Gj(_e)), _
    }

    function Gj(_) {
        uk === null ? uk = _ : uk.push.apply(uk, _)
    }

    function Pk(_) {
        for (var _e = _;;) {
            if (_e.flags & 16384) {
                var et = _e.updateQueue;
                if (et !== null && (et = et.stores, et !== null))
                    for (var tt = 0; tt < et.length; tt++) {
                        var nt = et[tt],
                            ot = nt.getSnapshot;
                        nt = nt.value;
                        try {
                            if (!He(ot(), nt)) return !1
                        } catch (at) {
                            return !1
                        }
                    }
            }
            if (et = _e.child, _e.subtreeFlags & 16384 && et !== null) et.return = _e, _e = et;
            else {
                if (_e === _) break;
                for (; _e.sibling === null;) {
                    if (_e.return === null || _e.return === _) return !0;
                    _e = _e.return
                }
                _e.sibling.return = _e.return, _e = _e.sibling
            }
        }
        return !0
    }

    function Dk(_, _e) {
        for (_e &= ~sk, _e &= ~rk, _.suspendedLanes |= _e, _.pingedLanes &= ~_e, _ = _.expirationTimes; 0 < _e;) {
            var et = 31 - oc(_e),
                tt = 1 << et;
            _[et] = -1, _e &= ~tt
        }
    }

    function Fk(_) {
        if (K & 6) throw Error(p$2(327));
        Ik();
        var _e = uc(_, 0);
        if (!(_e & 1)) return Ek(_, B$1()), null;
        var et = Jk(_, _e);
        if (_.tag !== 0 && et === 2) {
            var tt = xc(_);
            tt !== 0 && (_e = tt, et = Ok(_, tt))
        }
        if (et === 1) throw et = qk, Lk(_, 0), Dk(_, _e), Ek(_, B$1()), et;
        if (et === 6) throw Error(p$2(345));
        return _.finishedWork = _.current.alternate, _.finishedLanes = _e, Qk(_, uk, vk), Ek(_, B$1()), null
    }

    function Rk(_, _e) {
        var et = K;
        K |= 1;
        try {
            return _(_e)
        } finally {
            K = et, K === 0 && (Hj = B$1() + 500, fg && jg())
        }
    }

    function Sk(_) {
        xk !== null && xk.tag === 0 && !(K & 6) && Ik();
        var _e = K;
        K |= 1;
        var et = pk.transition,
            tt = C$1;
        try {
            if (pk.transition = null, C$1 = 1, _) return _()
        } finally {
            C$1 = tt, pk.transition = et, K = _e, !(K & 6) && jg()
        }
    }

    function Ij() {
        gj = fj.current, E$1(fj)
    }

    function Lk(_, _e) {
        _.finishedWork = null, _.finishedLanes = 0;
        var et = _.timeoutHandle;
        if (et !== -1 && (_.timeoutHandle = -1, Gf(et)), Y !== null)
            for (et = Y.return; et !== null;) {
                var tt = et;
                switch (wg(tt), tt.tag) {
                    case 1:
                        tt = tt.type.childContextTypes, tt != null && $f();
                        break;
                    case 3:
                        Jh(), E$1(Wf), E$1(H), Oh();
                        break;
                    case 5:
                        Lh(tt);
                        break;
                    case 4:
                        Jh();
                        break;
                    case 13:
                        E$1(M);
                        break;
                    case 19:
                        E$1(M);
                        break;
                    case 10:
                        Rg(tt.type._context);
                        break;
                    case 22:
                    case 23:
                        Ij()
                }
                et = et.return
            }
        if (R$1 = _, Y = _ = wh(_.current, null), Z = gj = _e, T$1 = 0, qk = null, sk = rk = hh = 0, uk = tk = null, Wg !== null) {
            for (_e = 0; _e < Wg.length; _e++)
                if (et = Wg[_e], tt = et.interleaved, tt !== null) {
                    et.interleaved = null;
                    var nt = tt.next,
                        ot = et.pending;
                    if (ot !== null) {
                        var at = ot.next;
                        ot.next = nt, tt.next = at
                    }
                    et.pending = tt
                }
            Wg = null
        }
        return _
    }

    function Nk(_, _e) {
        do {
            var et = Y;
            try {
                if (Qg(), Ph.current = ai, Sh) {
                    for (var tt = N.memoizedState; tt !== null;) {
                        var nt = tt.queue;
                        nt !== null && (nt.pending = null), tt = tt.next
                    }
                    Sh = !1
                }
                if (Rh = 0, P$2 = O$1 = N = null, Th = !1, Uh = 0, ok.current = null, et === null || et.return === null) {
                    T$1 = 1, qk = _e, Y = null;
                    break
                }
                e: {
                    var ot = _,
                        at = et.return,
                        st = et,
                        lt = _e;
                    if (_e = Z, st.flags |= 32768, lt !== null && typeof lt == "object" && typeof lt.then == "function") {
                        var ut = lt,
                            dt = st,
                            ct = dt.tag;
                        if (!(dt.mode & 1) && (ct === 0 || ct === 11 || ct === 15)) {
                            var pt = dt.alternate;
                            pt ? (dt.updateQueue = pt.updateQueue, dt.memoizedState = pt.memoizedState, dt.lanes = pt.lanes) : (dt.updateQueue = null, dt.memoizedState = null)
                        }
                        var ft = Vi(at);
                        if (ft !== null) {
                            ft.flags &= -257, Wi(ft, at, st, ot, _e), ft.mode & 1 && Ti(ot, ut, _e), _e = ft, lt = ut;
                            var ht = _e.updateQueue;
                            if (ht === null) {
                                var mt = new Set;
                                mt.add(lt), _e.updateQueue = mt
                            } else ht.add(lt);
                            break e
                        } else {
                            if (!(_e & 1)) {
                                Ti(ot, ut, _e), uj();
                                break e
                            }
                            lt = Error(p$2(426))
                        }
                    } else if (I && st.mode & 1) {
                        var bt = Vi(at);
                        if (bt !== null) {
                            !(bt.flags & 65536) && (bt.flags |= 256), Wi(bt, at, st, ot, _e), Jg(Ki(lt, st));
                            break e
                        }
                    }
                    ot = lt = Ki(lt, st),
                    T$1 !== 4 && (T$1 = 2),
                    tk === null ? tk = [ot] : tk.push(ot),
                    ot = at;do {
                        switch (ot.tag) {
                            case 3:
                                ot.flags |= 65536, _e &= -_e, ot.lanes |= _e;
                                var gt = Oi(ot, lt, _e);
                                fh(ot, gt);
                                break e;
                            case 1:
                                st = lt;
                                var vt = ot.type,
                                    xt = ot.stateNode;
                                if (!(ot.flags & 128) && (typeof vt.getDerivedStateFromError == "function" || xt !== null && typeof xt.componentDidCatch == "function" && (Si === null || !Si.has(xt)))) {
                                    ot.flags |= 65536, _e &= -_e, ot.lanes |= _e;
                                    var yt = Ri(ot, st, _e);
                                    fh(ot, yt);
                                    break e
                                }
                        }
                        ot = ot.return
                    } while (ot !== null)
                }
                Tk(et)
            } catch (Et) {
                _e = Et, Y === et && et !== null && (Y = et = et.return);
                continue
            }
            break
        } while (1)
    }

    function Kk() {
        var _ = nk.current;
        return nk.current = ai, _ === null ? ai : _
    }

    function uj() {
        (T$1 === 0 || T$1 === 3 || T$1 === 2) && (T$1 = 4), R$1 === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R$1, Z)
    }

    function Jk(_, _e) {
        var et = K;
        K |= 2;
        var tt = Kk();
        (R$1 !== _ || Z !== _e) && (vk = null, Lk(_, _e));
        do try {
            Uk();
            break
        } catch (nt) {
            Nk(_, nt)
        }
        while (1);
        if (Qg(), K = et, nk.current = tt, Y !== null) throw Error(p$2(261));
        return R$1 = null, Z = 0, T$1
    }

    function Uk() {
        for (; Y !== null;) Vk(Y)
    }

    function Mk() {
        for (; Y !== null && !cc();) Vk(Y)
    }

    function Vk(_) {
        var _e = Wk(_.alternate, _, gj);
        _.memoizedProps = _.pendingProps, _e === null ? Tk(_) : Y = _e, ok.current = null
    }

    function Tk(_) {
        var _e = _;
        do {
            var et = _e.alternate;
            if (_ = _e.return, _e.flags & 32768) {
                if (et = Jj(et, _e), et !== null) {
                    et.flags &= 32767, Y = et;
                    return
                }
                if (_ !== null) _.flags |= 32768, _.subtreeFlags = 0, _.deletions = null;
                else {
                    T$1 = 6, Y = null;
                    return
                }
            } else if (et = Fj(et, _e, gj), et !== null) {
                Y = et;
                return
            }
            if (_e = _e.sibling, _e !== null) {
                Y = _e;
                return
            }
            Y = _e = _
        } while (_e !== null);
        T$1 === 0 && (T$1 = 5)
    }

    function Qk(_, _e, et) {
        var tt = C$1,
            nt = pk.transition;
        try {
            pk.transition = null, C$1 = 1, Xk(_, _e, et, tt)
        } finally {
            pk.transition = nt, C$1 = tt
        }
        return null
    }

    function Xk(_, _e, et, tt) {
        do Ik(); while (xk !== null);
        if (K & 6) throw Error(p$2(327));
        et = _.finishedWork;
        var nt = _.finishedLanes;
        if (et === null) return null;
        if (_.finishedWork = null, _.finishedLanes = 0, et === _.current) throw Error(p$2(177));
        _.callbackNode = null, _.callbackPriority = 0;
        var ot = et.lanes | et.childLanes;
        if (Bc(_, ot), _ === R$1 && (Y = R$1 = null, Z = 0), !(et.subtreeFlags & 2064) && !(et.flags & 2064) || wk || (wk = !0, Gk(hc, function() {
                return Ik(), null
            })), ot = (et.flags & 15990) !== 0, et.subtreeFlags & 15990 || ot) {
            ot = pk.transition, pk.transition = null;
            var at = C$1;
            C$1 = 1;
            var st = K;
            K |= 4, ok.current = null, Pj(_, et), ek(et, _), Oe(Df), dd = !!Cf, Df = Cf = null, _.current = et, ik(et), dc(), K = st, C$1 = at, pk.transition = ot
        } else _.current = et;
        if (wk && (wk = !1, xk = _, yk = nt), ot = _.pendingLanes, ot === 0 && (Si = null), mc(et.stateNode), Ek(_, B$1()), _e !== null)
            for (tt = _.onRecoverableError, et = 0; et < _e.length; et++) nt = _e[et], tt(nt.value, {
                componentStack: nt.stack,
                digest: nt.digest
            });
        if (Pi) throw Pi = !1, _ = Qi, Qi = null, _;
        return yk & 1 && _.tag !== 0 && Ik(), ot = _.pendingLanes, ot & 1 ? _ === Ak ? zk++ : (zk = 0, Ak = _) : zk = 0, jg(), null
    }

    function Ik() {
        if (xk !== null) {
            var _ = Dc(yk),
                _e = pk.transition,
                et = C$1;
            try {
                if (pk.transition = null, C$1 = 16 > _ ? 16 : _, xk === null) var tt = !1;
                else {
                    if (_ = xk, xk = null, yk = 0, K & 6) throw Error(p$2(331));
                    var nt = K;
                    for (K |= 4, V$1 = _.current; V$1 !== null;) {
                        var ot = V$1,
                            at = ot.child;
                        if (V$1.flags & 16) {
                            var st = ot.deletions;
                            if (st !== null) {
                                for (var lt = 0; lt < st.length; lt++) {
                                    var ut = st[lt];
                                    for (V$1 = ut; V$1 !== null;) {
                                        var dt = V$1;
                                        switch (dt.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                Qj(8, dt, ot)
                                        }
                                        var ct = dt.child;
                                        if (ct !== null) ct.return = dt, V$1 = ct;
                                        else
                                            for (; V$1 !== null;) {
                                                dt = V$1;
                                                var pt = dt.sibling,
                                                    ft = dt.return;
                                                if (Tj(dt), dt === ut) {
                                                    V$1 = null;
                                                    break
                                                }
                                                if (pt !== null) {
                                                    pt.return = ft, V$1 = pt;
                                                    break
                                                }
                                                V$1 = ft
                                            }
                                    }
                                }
                                var ht = ot.alternate;
                                if (ht !== null) {
                                    var mt = ht.child;
                                    if (mt !== null) {
                                        ht.child = null;
                                        do {
                                            var bt = mt.sibling;
                                            mt.sibling = null, mt = bt
                                        } while (mt !== null)
                                    }
                                }
                                V$1 = ot
                            }
                        }
                        if (ot.subtreeFlags & 2064 && at !== null) at.return = ot, V$1 = at;
                        else e: for (; V$1 !== null;) {
                            if (ot = V$1, ot.flags & 2048) switch (ot.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Qj(9, ot, ot.return)
                            }
                            var gt = ot.sibling;
                            if (gt !== null) {
                                gt.return = ot.return, V$1 = gt;
                                break e
                            }
                            V$1 = ot.return
                        }
                    }
                    var vt = _.current;
                    for (V$1 = vt; V$1 !== null;) {
                        at = V$1;
                        var xt = at.child;
                        if (at.subtreeFlags & 2064 && xt !== null) xt.return = at, V$1 = xt;
                        else e: for (at = vt; V$1 !== null;) {
                            if (st = V$1, st.flags & 2048) try {
                                switch (st.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Rj(9, st)
                                }
                            } catch (Et) {
                                W(st, st.return, Et)
                            }
                            if (st === at) {
                                V$1 = null;
                                break e
                            }
                            var yt = st.sibling;
                            if (yt !== null) {
                                yt.return = st.return, V$1 = yt;
                                break e
                            }
                            V$1 = st.return
                        }
                    }
                    if (K = nt, jg(), lc && typeof lc.onPostCommitFiberRoot == "function") try {
                        lc.onPostCommitFiberRoot(kc, _)
                    } catch (Et) {}
                    tt = !0
                }
                return tt
            } finally {
                C$1 = et, pk.transition = _e
            }
        }
        return !1
    }

    function Yk(_, _e, et) {
        _e = Ki(et, _e), _e = Oi(_, _e, 1), _ = dh(_, _e, 1), _e = L(), _ !== null && (Ac(_, 1, _e), Ek(_, _e))
    }

    function W(_, _e, et) {
        if (_.tag === 3) Yk(_, _, et);
        else
            for (; _e !== null;) {
                if (_e.tag === 3) {
                    Yk(_e, _, et);
                    break
                } else if (_e.tag === 1) {
                    var tt = _e.stateNode;
                    if (typeof _e.type.getDerivedStateFromError == "function" || typeof tt.componentDidCatch == "function" && (Si === null || !Si.has(tt))) {
                        _ = Ki(et, _), _ = Ri(_e, _, 1), _e = dh(_e, _, 1), _ = L(), _e !== null && (Ac(_e, 1, _), Ek(_e, _));
                        break
                    }
                }
                _e = _e.return
            }
    }

    function Ui(_, _e, et) {
        var tt = _.pingCache;
        tt !== null && tt.delete(_e), _e = L(), _.pingedLanes |= _.suspendedLanes & et, R$1 === _ && (Z & et) === et && (T$1 === 4 || T$1 === 3 && (Z & 130023424) === Z && 500 > B$1() - gk ? Lk(_, 0) : sk |= et), Ek(_, _e)
    }

    function Zk(_, _e) {
        _e === 0 && (_.mode & 1 ? (_e = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : _e = 1);
        var et = L();
        _ = Zg(_, _e), _ !== null && (Ac(_, _e, et), Ek(_, et))
    }

    function vj(_) {
        var _e = _.memoizedState,
            et = 0;
        _e !== null && (et = _e.retryLane), Zk(_, et)
    }

    function ck(_, _e) {
        var et = 0;
        switch (_.tag) {
            case 13:
                var tt = _.stateNode,
                    nt = _.memoizedState;
                nt !== null && (et = nt.retryLane);
                break;
            case 19:
                tt = _.stateNode;
                break;
            default:
                throw Error(p$2(314))
        }
        tt !== null && tt.delete(_e), Zk(_, et)
    }
    var Wk;
    Wk = function(_, _e, et) {
        if (_ !== null)
            if (_.memoizedProps !== _e.pendingProps || Wf.current) Ug = !0;
            else {
                if (!(_.lanes & et) && !(_e.flags & 128)) return Ug = !1, zj(_, _e, et);
                Ug = !!(_.flags & 131072)
            }
        else Ug = !1, I && _e.flags & 1048576 && ug(_e, ng, _e.index);
        switch (_e.lanes = 0, _e.tag) {
            case 2:
                var tt = _e.type;
                jj(_, _e), _ = _e.pendingProps;
                var nt = Yf(_e, H.current);
                Tg(_e, et), nt = Xh(null, _e, tt, _, nt, et);
                var ot = bi();
                return _e.flags |= 1, typeof nt == "object" && nt !== null && typeof nt.render == "function" && nt.$$typeof === void 0 ? (_e.tag = 1, _e.memoizedState = null, _e.updateQueue = null, Zf(tt) ? (ot = !0, cg(_e)) : ot = !1, _e.memoizedState = nt.state !== null && nt.state !== void 0 ? nt.state : null, ah(_e), nt.updater = nh, _e.stateNode = nt, nt._reactInternals = _e, rh(_e, tt, _, et), _e = kj(null, _e, tt, !0, ot, et)) : (_e.tag = 0, I && ot && vg(_e), Yi(null, _e, nt, et), _e = _e.child), _e;
            case 16:
                tt = _e.elementType;
                e: {
                    switch (jj(_, _e), _ = _e.pendingProps, nt = tt._init, tt = nt(tt._payload), _e.type = tt, nt = _e.tag = $k(tt), _ = Lg(tt, _), nt) {
                        case 0:
                            _e = dj(null, _e, tt, _, et);
                            break e;
                        case 1:
                            _e = ij(null, _e, tt, _, et);
                            break e;
                        case 11:
                            _e = Zi(null, _e, tt, _, et);
                            break e;
                        case 14:
                            _e = aj(null, _e, tt, Lg(tt.type, _), et);
                            break e
                    }
                    throw Error(p$2(306, tt, ""))
                }
                return _e;
            case 0:
                return tt = _e.type, nt = _e.pendingProps, nt = _e.elementType === tt ? nt : Lg(tt, nt), dj(_, _e, tt, nt, et);
            case 1:
                return tt = _e.type, nt = _e.pendingProps, nt = _e.elementType === tt ? nt : Lg(tt, nt), ij(_, _e, tt, nt, et);
            case 3:
                e: {
                    if (lj(_e), _ === null) throw Error(p$2(387));tt = _e.pendingProps,
                    ot = _e.memoizedState,
                    nt = ot.element,
                    bh(_, _e),
                    gh(_e, tt, null, et);
                    var at = _e.memoizedState;
                    if (tt = at.element, ot.isDehydrated)
                        if (ot = {
                                element: tt,
                                isDehydrated: !1,
                                cache: at.cache,
                                pendingSuspenseBoundaries: at.pendingSuspenseBoundaries,
                                transitions: at.transitions
                            }, _e.updateQueue.baseState = ot, _e.memoizedState = ot, _e.flags & 256) {
                            nt = Ki(Error(p$2(423)), _e), _e = mj(_, _e, tt, et, nt);
                            break e
                        } else if (tt !== nt) {
                        nt = Ki(Error(p$2(424)), _e), _e = mj(_, _e, tt, et, nt);
                        break e
                    } else
                        for (yg = Lf(_e.stateNode.containerInfo.firstChild), xg = _e, I = !0, zg = null, et = Ch(_e, null, tt, et), _e.child = et; et;) et.flags = et.flags & -3 | 4096, et = et.sibling;
                    else {
                        if (Ig(), tt === nt) {
                            _e = $i(_, _e, et);
                            break e
                        }
                        Yi(_, _e, tt, et)
                    }
                    _e = _e.child
                }
                return _e;
            case 5:
                return Kh(_e), _ === null && Eg(_e), tt = _e.type, nt = _e.pendingProps, ot = _ !== null ? _.memoizedProps : null, at = nt.children, Ef(tt, nt) ? at = null : ot !== null && Ef(tt, ot) && (_e.flags |= 32), hj(_, _e), Yi(_, _e, at, et), _e.child;
            case 6:
                return _ === null && Eg(_e), null;
            case 13:
                return pj(_, _e, et);
            case 4:
                return Ih(_e, _e.stateNode.containerInfo), tt = _e.pendingProps, _ === null ? _e.child = Bh(_e, null, tt, et) : Yi(_, _e, tt, et), _e.child;
            case 11:
                return tt = _e.type, nt = _e.pendingProps, nt = _e.elementType === tt ? nt : Lg(tt, nt), Zi(_, _e, tt, nt, et);
            case 7:
                return Yi(_, _e, _e.pendingProps, et), _e.child;
            case 8:
                return Yi(_, _e, _e.pendingProps.children, et), _e.child;
            case 12:
                return Yi(_, _e, _e.pendingProps.children, et), _e.child;
            case 10:
                e: {
                    if (tt = _e.type._context, nt = _e.pendingProps, ot = _e.memoizedProps, at = nt.value, G(Mg, tt._currentValue), tt._currentValue = at, ot !== null)
                        if (He(ot.value, at)) {
                            if (ot.children === nt.children && !Wf.current) {
                                _e = $i(_, _e, et);
                                break e
                            }
                        } else
                            for (ot = _e.child, ot !== null && (ot.return = _e); ot !== null;) {
                                var st = ot.dependencies;
                                if (st !== null) {
                                    at = ot.child;
                                    for (var lt = st.firstContext; lt !== null;) {
                                        if (lt.context === tt) {
                                            if (ot.tag === 1) {
                                                lt = ch(-1, et & -et), lt.tag = 2;
                                                var ut = ot.updateQueue;
                                                if (ut !== null) {
                                                    ut = ut.shared;
                                                    var dt = ut.pending;
                                                    dt === null ? lt.next = lt : (lt.next = dt.next, dt.next = lt), ut.pending = lt
                                                }
                                            }
                                            ot.lanes |= et, lt = ot.alternate, lt !== null && (lt.lanes |= et), Sg(ot.return, et, _e), st.lanes |= et;
                                            break
                                        }
                                        lt = lt.next
                                    }
                                } else if (ot.tag === 10) at = ot.type === _e.type ? null : ot.child;
                                else if (ot.tag === 18) {
                                    if (at = ot.return, at === null) throw Error(p$2(341));
                                    at.lanes |= et, st = at.alternate, st !== null && (st.lanes |= et), Sg(at, et, _e), at = ot.sibling
                                } else at = ot.child;
                                if (at !== null) at.return = ot;
                                else
                                    for (at = ot; at !== null;) {
                                        if (at === _e) {
                                            at = null;
                                            break
                                        }
                                        if (ot = at.sibling, ot !== null) {
                                            ot.return = at.return, at = ot;
                                            break
                                        }
                                        at = at.return
                                    }
                                ot = at
                            }
                    Yi(_, _e, nt.children, et),
                    _e = _e.child
                }
                return _e;
            case 9:
                return nt = _e.type, tt = _e.pendingProps.children, Tg(_e, et), nt = Vg(nt), tt = tt(nt), _e.flags |= 1, Yi(_, _e, tt, et), _e.child;
            case 14:
                return tt = _e.type, nt = Lg(tt, _e.pendingProps), nt = Lg(tt.type, nt), aj(_, _e, tt, nt, et);
            case 15:
                return cj(_, _e, _e.type, _e.pendingProps, et);
            case 17:
                return tt = _e.type, nt = _e.pendingProps, nt = _e.elementType === tt ? nt : Lg(tt, nt), jj(_, _e), _e.tag = 1, Zf(tt) ? (_ = !0, cg(_e)) : _ = !1, Tg(_e, et), ph(_e, tt, nt), rh(_e, tt, nt, et), kj(null, _e, tt, !0, _, et);
            case 19:
                return yj(_, _e, et);
            case 22:
                return ej(_, _e, et)
        }
        throw Error(p$2(156, _e.tag))
    };

    function Gk(_, _e) {
        return ac(_, _e)
    }

    function al(_, _e, et, tt) {
        this.tag = _, this.key = et, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = _e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = tt, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
    }

    function Bg(_, _e, et, tt) {
        return new al(_, _e, et, tt)
    }

    function bj(_) {
        return _ = _.prototype, !(!_ || !_.isReactComponent)
    }

    function $k(_) {
        if (typeof _ == "function") return bj(_) ? 1 : 0;
        if (_ != null) {
            if (_ = _.$$typeof, _ === Da) return 11;
            if (_ === Ga) return 14
        }
        return 2
    }

    function wh(_, _e) {
        var et = _.alternate;
        return et === null ? (et = Bg(_.tag, _e, _.key, _.mode), et.elementType = _.elementType, et.type = _.type, et.stateNode = _.stateNode, et.alternate = _, _.alternate = et) : (et.pendingProps = _e, et.type = _.type, et.flags = 0, et.subtreeFlags = 0, et.deletions = null), et.flags = _.flags & 14680064, et.childLanes = _.childLanes, et.lanes = _.lanes, et.child = _.child, et.memoizedProps = _.memoizedProps, et.memoizedState = _.memoizedState, et.updateQueue = _.updateQueue, _e = _.dependencies, et.dependencies = _e === null ? null : {
            lanes: _e.lanes,
            firstContext: _e.firstContext
        }, et.sibling = _.sibling, et.index = _.index, et.ref = _.ref, et
    }

    function yh(_, _e, et, tt, nt, ot) {
        var at = 2;
        if (tt = _, typeof _ == "function") bj(_) && (at = 1);
        else if (typeof _ == "string") at = 5;
        else e: switch (_) {
            case ya:
                return Ah(et.children, nt, ot, _e);
            case za:
                at = 8, nt |= 8;
                break;
            case Aa:
                return _ = Bg(12, et, _e, nt | 2), _.elementType = Aa, _.lanes = ot, _;
            case Ea:
                return _ = Bg(13, et, _e, nt), _.elementType = Ea, _.lanes = ot, _;
            case Fa:
                return _ = Bg(19, et, _e, nt), _.elementType = Fa, _.lanes = ot, _;
            case Ia:
                return qj(et, nt, ot, _e);
            default:
                if (typeof _ == "object" && _ !== null) switch (_.$$typeof) {
                    case Ba:
                        at = 10;
                        break e;
                    case Ca:
                        at = 9;
                        break e;
                    case Da:
                        at = 11;
                        break e;
                    case Ga:
                        at = 14;
                        break e;
                    case Ha:
                        at = 16, tt = null;
                        break e
                }
                throw Error(p$2(130, _ == null ? _ : typeof _, ""))
        }
        return _e = Bg(at, et, _e, nt), _e.elementType = _, _e.type = tt, _e.lanes = ot, _e
    }

    function Ah(_, _e, et, tt) {
        return _ = Bg(7, _, tt, _e), _.lanes = et, _
    }

    function qj(_, _e, et, tt) {
        return _ = Bg(22, _, tt, _e), _.elementType = Ia, _.lanes = et, _.stateNode = {
            isHidden: !1
        }, _
    }

    function xh(_, _e, et) {
        return _ = Bg(6, _, null, _e), _.lanes = et, _
    }

    function zh(_, _e, et) {
        return _e = Bg(4, _.children !== null ? _.children : [], _.key, _e), _e.lanes = et, _e.stateNode = {
            containerInfo: _.containerInfo,
            pendingChildren: null,
            implementation: _.implementation
        }, _e
    }

    function bl(_, _e, et, tt, nt) {
        this.tag = _e, this.containerInfo = _, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = tt, this.onRecoverableError = nt, this.mutableSourceEagerHydrationData = null
    }

    function cl(_, _e, et, tt, nt, ot, at, st, lt) {
        return _ = new bl(_, _e, et, st, lt), _e === 1 ? (_e = 1, ot === !0 && (_e |= 8)) : _e = 0, ot = Bg(3, null, null, _e), _.current = ot, ot.stateNode = _, ot.memoizedState = {
            element: tt,
            isDehydrated: et,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        }, ah(ot), _
    }

    function dl(_, _e, et) {
        var tt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: wa,
            key: tt == null ? null : "" + tt,
            children: _,
            containerInfo: _e,
            implementation: et
        }
    }

    function el(_) {
        if (!_) return Vf;
        _ = _._reactInternals;
        e: {
            if (Vb(_) !== _ || _.tag !== 1) throw Error(p$2(170));
            var _e = _;do {
                switch (_e.tag) {
                    case 3:
                        _e = _e.stateNode.context;
                        break e;
                    case 1:
                        if (Zf(_e.type)) {
                            _e = _e.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                _e = _e.return
            } while (_e !== null);
            throw Error(p$2(171))
        }
        if (_.tag === 1) {
            var et = _.type;
            if (Zf(et)) return bg(_, et, _e)
        }
        return _e
    }

    function fl(_, _e, et, tt, nt, ot, at, st, lt) {
        return _ = cl(et, tt, !0, _, nt, ot, at, st, lt), _.context = el(null), et = _.current, tt = L(), nt = lh(et), ot = ch(tt, nt), ot.callback = _e != null ? _e : null, dh(et, ot, nt), _.current.lanes = nt, Ac(_, nt, tt), Ek(_, tt), _
    }

    function gl(_, _e, et, tt) {
        var nt = _e.current,
            ot = L(),
            at = lh(nt);
        return et = el(et), _e.context === null ? _e.context = et : _e.pendingContext = et, _e = ch(ot, at), _e.payload = {
            element: _
        }, tt = tt === void 0 ? null : tt, tt !== null && (_e.callback = tt), _ = dh(nt, _e, at), _ !== null && (mh(_, nt, at, ot), eh(_, nt, at)), at
    }

    function hl(_) {
        if (_ = _.current, !_.child) return null;
        switch (_.child.tag) {
            case 5:
                return _.child.stateNode;
            default:
                return _.child.stateNode
        }
    }

    function il(_, _e) {
        if (_ = _.memoizedState, _ !== null && _.dehydrated !== null) {
            var et = _.retryLane;
            _.retryLane = et !== 0 && et < _e ? et : _e
        }
    }

    function jl(_, _e) {
        il(_, _e), (_ = _.alternate) && il(_, _e)
    }

    function kl() {
        return null
    }
    var ll = typeof reportError == "function" ? reportError : function(_) {
        console.error(_)
    };

    function ml(_) {
        this._internalRoot = _
    }
    nl.prototype.render = ml.prototype.render = function(_) {
        var _e = this._internalRoot;
        if (_e === null) throw Error(p$2(409));
        gl(_, _e, null, null)
    }, nl.prototype.unmount = ml.prototype.unmount = function() {
        var _ = this._internalRoot;
        if (_ !== null) {
            this._internalRoot = null;
            var _e = _.containerInfo;
            Sk(function() {
                gl(null, _, null, null)
            }), _e[uf] = null
        }
    };

    function nl(_) {
        this._internalRoot = _
    }
    nl.prototype.unstable_scheduleHydration = function(_) {
        if (_) {
            var _e = Hc();
            _ = {
                blockedOn: null,
                target: _,
                priority: _e
            };
            for (var et = 0; et < Qc.length && _e !== 0 && _e < Qc[et].priority; et++);
            Qc.splice(et, 0, _), et === 0 && Vc(_)
        }
    };

    function ol(_) {
        return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11)
    }

    function pl(_) {
        return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11 && (_.nodeType !== 8 || _.nodeValue !== " react-mount-point-unstable "))
    }

    function ql() {}

    function rl(_, _e, et, tt, nt) {
        if (nt) {
            if (typeof tt == "function") {
                var ot = tt;
                tt = function() {
                    var ut = hl(at);
                    ot.call(ut)
                }
            }
            var at = fl(_e, tt, _, 0, null, !1, !1, "", ql);
            return _._reactRootContainer = at, _[uf] = at.current, sf(_.nodeType === 8 ? _.parentNode : _), Sk(), at
        }
        for (; nt = _.lastChild;) _.removeChild(nt);
        if (typeof tt == "function") {
            var st = tt;
            tt = function() {
                var ut = hl(lt);
                st.call(ut)
            }
        }
        var lt = cl(_, 0, !1, null, null, !1, !1, "", ql);
        return _._reactRootContainer = lt, _[uf] = lt.current, sf(_.nodeType === 8 ? _.parentNode : _), Sk(function() {
            gl(_e, lt, et, tt)
        }), lt
    }

    function sl(_, _e, et, tt, nt) {
        var ot = et._reactRootContainer;
        if (ot) {
            var at = ot;
            if (typeof nt == "function") {
                var st = nt;
                nt = function() {
                    var lt = hl(at);
                    st.call(lt)
                }
            }
            gl(_e, at, _, nt)
        } else at = rl(et, _e, _, nt, tt);
        return hl(at)
    }
    Ec = function(_) {
        switch (_.tag) {
            case 3:
                var _e = _.stateNode;
                if (_e.current.memoizedState.isDehydrated) {
                    var et = tc(_e.pendingLanes);
                    et !== 0 && (Cc(_e, et | 1), Ek(_e, B$1()), !(K & 6) && (Hj = B$1() + 500, jg()))
                }
                break;
            case 13:
                Sk(function() {
                    var tt = Zg(_, 1);
                    if (tt !== null) {
                        var nt = L();
                        mh(tt, _, 1, nt)
                    }
                }), jl(_, 1)
        }
    }, Fc = function(_) {
        if (_.tag === 13) {
            var _e = Zg(_, 134217728);
            if (_e !== null) {
                var et = L();
                mh(_e, _, 134217728, et)
            }
            jl(_, 134217728)
        }
    }, Gc = function(_) {
        if (_.tag === 13) {
            var _e = lh(_),
                et = Zg(_, _e);
            if (et !== null) {
                var tt = L();
                mh(et, _, _e, tt)
            }
            jl(_, _e)
        }
    }, Hc = function() {
        return C$1
    }, Ic = function(_, _e) {
        var et = C$1;
        try {
            return C$1 = _, _e()
        } finally {
            C$1 = et
        }
    }, yb = function(_, _e, et) {
        switch (_e) {
            case "input":
                if (bb(_, et), _e = et.name, et.type === "radio" && _e != null) {
                    for (et = _; et.parentNode;) et = et.parentNode;
                    for (et = et.querySelectorAll("input[name=" + JSON.stringify("" + _e) + '][type="radio"]'), _e = 0; _e < et.length; _e++) {
                        var tt = et[_e];
                        if (tt !== _ && tt.form === _.form) {
                            var nt = Db(tt);
                            if (!nt) throw Error(p$2(90));
                            Wa(tt), bb(tt, nt)
                        }
                    }
                }
                break;
            case "textarea":
                ib(_, et);
                break;
            case "select":
                _e = et.value, _e != null && fb(_, !!et.multiple, _e, !1)
        }
    }, Gb = Rk, Hb = Sk;
    var tl = {
            usingClientEntryPoint: !1,
            Events: [Cb, ue, Db, Eb, Fb, Rk]
        },
        ul = {
            findFiberByHostInstance: Wc,
            bundleType: 0,
            version: "18.2.0",
            rendererPackageName: "react-dom"
        },
        vl = {
            bundleType: ul.bundleType,
            version: ul.version,
            rendererPackageName: ul.rendererPackageName,
            rendererConfig: ul.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: ua.ReactCurrentDispatcher,
            findHostInstanceByFiber: function(_) {
                return _ = Zb(_), _ === null ? null : _.stateNode
            },
            findFiberByHostInstance: ul.findFiberByHostInstance || kl,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
        };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!wl.isDisabled && wl.supportsFiber) try {
            kc = wl.inject(vl), lc = wl
        } catch (_) {}
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl, reactDom_production_min.createPortal = function(_, _e) {
        var et = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!ol(_e)) throw Error(p$2(200));
        return dl(_, _e, null, et)
    }, reactDom_production_min.createRoot = function(_, _e) {
        if (!ol(_)) throw Error(p$2(299));
        var et = !1,
            tt = "",
            nt = ll;
        return _e != null && (_e.unstable_strictMode === !0 && (et = !0), _e.identifierPrefix !== void 0 && (tt = _e.identifierPrefix), _e.onRecoverableError !== void 0 && (nt = _e.onRecoverableError)), _e = cl(_, 1, !1, null, null, et, !1, tt, nt), _[uf] = _e.current, sf(_.nodeType === 8 ? _.parentNode : _), new ml(_e)
    }, reactDom_production_min.findDOMNode = function(_) {
        if (_ == null) return null;
        if (_.nodeType === 1) return _;
        var _e = _._reactInternals;
        if (_e === void 0) throw typeof _.render == "function" ? Error(p$2(188)) : (_ = Object.keys(_).join(","), Error(p$2(268, _)));
        return _ = Zb(_e), _ = _ === null ? null : _.stateNode, _
    }, reactDom_production_min.flushSync = function(_) {
        return Sk(_)
    }, reactDom_production_min.hydrate = function(_, _e, et) {
        if (!pl(_e)) throw Error(p$2(200));
        return sl(null, _, _e, !0, et)
    }, reactDom_production_min.hydrateRoot = function(_, _e, et) {
        if (!ol(_)) throw Error(p$2(405));
        var tt = et != null && et.hydratedSources || null,
            nt = !1,
            ot = "",
            at = ll;
        if (et != null && (et.unstable_strictMode === !0 && (nt = !0), et.identifierPrefix !== void 0 && (ot = et.identifierPrefix), et.onRecoverableError !== void 0 && (at = et.onRecoverableError)), _e = fl(_e, null, _, 1, et != null ? et : null, nt, !1, ot, at), _[uf] = _e.current, sf(_), tt)
            for (_ = 0; _ < tt.length; _++) et = tt[_], nt = et._getVersion, nt = nt(et._source), _e.mutableSourceEagerHydrationData == null ? _e.mutableSourceEagerHydrationData = [et, nt] : _e.mutableSourceEagerHydrationData.push(et, nt);
        return new nl(_e)
    }, reactDom_production_min.render = function(_, _e, et) {
        if (!pl(_e)) throw Error(p$2(200));
        return sl(null, _, _e, !1, et)
    }, reactDom_production_min.unmountComponentAtNode = function(_) {
        if (!pl(_)) throw Error(p$2(40));
        return _._reactRootContainer ? (Sk(function() {
            sl(null, null, _, !1, function() {
                _._reactRootContainer = null, _[uf] = null
            })
        }), !0) : !1
    }, reactDom_production_min.unstable_batchedUpdates = Rk, reactDom_production_min.unstable_renderSubtreeIntoContainer = function(_, _e, et, tt) {
        if (!pl(et)) throw Error(p$2(200));
        if (_ == null || _._reactInternals === void 0) throw Error(p$2(38));
        return sl(_, _e, et, !1, tt)
    }, reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";

    function checkDCE() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (_) {
            console.error(_)
        }
    }
    checkDCE(), reactDom.exports = reactDom_production_min, reactDomExports = reactDom.exports, ReactDOM = getDefaultExportFromCjs$1(reactDomExports), react_dom = _mergeNamespaces({
        __proto__: null,
        default: ReactDOM
    }, [reactDomExports]);

    function _extends$4() {
        return _extends$4 = Object.assign ? Object.assign.bind() : function(_) {
            for (var _e = 1; _e < arguments.length; _e++) {
                var et = arguments[_e];
                for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (_[tt] = et[tt])
            }
            return _
        }, _extends$4.apply(this, arguments)
    }(function(_) {
        _.Pop = "POP", _.Push = "PUSH", _.Replace = "REPLACE"
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    createMemoryHistory = function(_) {
        _ === void 0 && (_ = {});
        let {
            initialEntries: _e = ["/"],
            initialIndex: et,
            v5Compat: tt = !1
        } = _, nt;
        nt = _e.map((pt, ft) => dt(pt, typeof pt == "string" ? null : pt.state, ft === 0 ? "default" : void 0));
        let ot = lt(et != null ? et : nt.length - 1),
            at = Action.Pop,
            st = null;

        function lt(pt) {
            return Math.min(Math.max(pt, 0), nt.length - 1)
        }

        function ut() {
            return nt[ot]
        }

        function dt(pt, ft, ht) {
            ft === void 0 && (ft = null);
            let mt = createLocation(nt ? ut().pathname : "/", pt, ft, ht);
            return warning(mt.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(pt)), mt
        }

        function ct(pt) {
            return typeof pt == "string" ? pt : createPath(pt)
        }
        return {
            get index() {
                return ot
            },
            get action() {
                return at
            },
            get location() {
                return ut()
            },
            createHref: ct,
            createURL(pt) {
                return new URL(ct(pt), "http://localhost")
            },
            encodeLocation(pt) {
                let ft = typeof pt == "string" ? parsePath(pt) : pt;
                return {
                    pathname: ft.pathname || "",
                    search: ft.search || "",
                    hash: ft.hash || ""
                }
            },
            push(pt, ft) {
                at = Action.Push;
                let ht = dt(pt, ft);
                ot += 1, nt.splice(ot, nt.length, ht), tt && st && st({
                    action: at,
                    location: ht,
                    delta: 1
                })
            },
            replace(pt, ft) {
                at = Action.Replace;
                let ht = dt(pt, ft);
                nt[ot] = ht, tt && st && st({
                    action: at,
                    location: ht,
                    delta: 0
                })
            },
            go(pt) {
                at = Action.Pop;
                let ft = lt(ot + pt),
                    ht = nt[ft];
                ot = ft, st && st({
                    action: at,
                    location: ht,
                    delta: pt
                })
            },
            listen(pt) {
                return st = pt, () => {
                    st = null
                }
            }
        }
    };

    function createBrowserHistory(_) {
        _ === void 0 && (_ = {});

        function _e(tt, nt) {
            let {
                pathname: ot,
                search: at,
                hash: st
            } = tt.location;
            return createLocation("", {
                pathname: ot,
                search: at,
                hash: st
            }, nt.state && nt.state.usr || null, nt.state && nt.state.key || "default")
        }

        function et(tt, nt) {
            return typeof nt == "string" ? nt : createPath(nt)
        }
        return getUrlBasedHistory(_e, et, null, _)
    }

    function createHashHistory(_) {
        _ === void 0 && (_ = {});

        function _e(nt, ot) {
            let {
                pathname: at = "/",
                search: st = "",
                hash: lt = ""
            } = parsePath(nt.location.hash.substr(1));
            return !at.startsWith("/") && !at.startsWith(".") && (at = "/" + at), createLocation("", {
                pathname: at,
                search: st,
                hash: lt
            }, ot.state && ot.state.usr || null, ot.state && ot.state.key || "default")
        }

        function et(nt, ot) {
            let at = nt.document.querySelector("base"),
                st = "";
            if (at && at.getAttribute("href")) {
                let lt = nt.location.href,
                    ut = lt.indexOf("#");
                st = ut === -1 ? lt : lt.slice(0, ut)
            }
            return st + "#" + (typeof ot == "string" ? ot : createPath(ot))
        }

        function tt(nt, ot) {
            warning(nt.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(ot) + ")")
        }
        return getUrlBasedHistory(_e, et, tt, _)
    }

    function invariant(_, _e) {
        if (_ === !1 || _ === null || typeof _ > "u") throw new Error(_e)
    }

    function warning(_, _e) {
        if (!_) {
            typeof console < "u" && console.warn(_e);
            try {
                throw new Error(_e)
            } catch (et) {}
        }
    }

    function createKey() {
        return Math.random().toString(36).substr(2, 8)
    }

    function getHistoryState(_, _e) {
        return {
            usr: _.state,
            key: _.key,
            idx: _e
        }
    }

    function createLocation(_, _e, et, tt) {
        return et === void 0 && (et = null), _extends$4({
            pathname: typeof _ == "string" ? _ : _.pathname,
            search: "",
            hash: ""
        }, typeof _e == "string" ? parsePath(_e) : _e, {
            state: et,
            key: _e && _e.key || tt || createKey()
        })
    }
    createPath = function(_) {
        let {
            pathname: _e = "/",
            search: et = "",
            hash: tt = ""
        } = _;
        return et && et !== "?" && (_e += et.charAt(0) === "?" ? et : "?" + et), tt && tt !== "#" && (_e += tt.charAt(0) === "#" ? tt : "#" + tt), _e
    }, parsePath = function(_) {
        let _e = {};
        if (_) {
            let et = _.indexOf("#");
            et >= 0 && (_e.hash = _.substr(et), _ = _.substr(0, et));
            let tt = _.indexOf("?");
            tt >= 0 && (_e.search = _.substr(tt), _ = _.substr(0, tt)), _ && (_e.pathname = _)
        }
        return _e
    };

    function getUrlBasedHistory(_, _e, et, tt) {
        tt === void 0 && (tt = {});
        let {
            window: nt = document.defaultView,
            v5Compat: ot = !1
        } = tt, at = nt.history, st = Action.Pop, lt = null, ut = dt();
        ut == null && (ut = 0, at.replaceState(_extends$4({}, at.state, {
            idx: ut
        }), ""));

        function dt() {
            return (at.state || {
                idx: null
            }).idx
        }

        function ct() {
            st = Action.Pop;
            let bt = dt(),
                gt = bt == null ? null : bt - ut;
            ut = bt, lt && lt({
                action: st,
                location: mt.location,
                delta: gt
            })
        }

        function pt(bt, gt) {
            st = Action.Push;
            let vt = createLocation(mt.location, bt, gt);
            et && et(vt, bt), ut = dt() + 1;
            let xt = getHistoryState(vt, ut),
                yt = mt.createHref(vt);
            try {
                at.pushState(xt, "", yt)
            } catch (Et) {
                if (Et instanceof DOMException && Et.name === "DataCloneError") throw Et;
                nt.location.assign(yt)
            }
            ot && lt && lt({
                action: st,
                location: mt.location,
                delta: 1
            })
        }

        function ft(bt, gt) {
            st = Action.Replace;
            let vt = createLocation(mt.location, bt, gt);
            et && et(vt, bt), ut = dt();
            let xt = getHistoryState(vt, ut),
                yt = mt.createHref(vt);
            at.replaceState(xt, "", yt), ot && lt && lt({
                action: st,
                location: mt.location,
                delta: 0
            })
        }

        function ht(bt) {
            let gt = nt.location.origin !== "null" ? nt.location.origin : nt.location.href,
                vt = typeof bt == "string" ? bt : createPath(bt);
            return invariant(gt, "No window.location.(origin|href) available to create URL for href: " + vt), new URL(vt, gt)
        }
        let mt = {
            get action() {
                return st
            },
            get location() {
                return _(nt, at)
            },
            listen(bt) {
                if (lt) throw new Error("A history only accepts one active listener");
                return nt.addEventListener(PopStateEventType, ct), lt = bt, () => {
                    nt.removeEventListener(PopStateEventType, ct), lt = null
                }
            },
            createHref(bt) {
                return _e(nt, bt)
            },
            createURL: ht,
            encodeLocation(bt) {
                let gt = ht(bt);
                return {
                    pathname: gt.pathname,
                    search: gt.search,
                    hash: gt.hash
                }
            },
            push: pt,
            replace: ft,
            go(bt) {
                return at.go(bt)
            }
        };
        return mt
    }
    var ResultType;
    (function(_) {
        _.data = "data", _.deferred = "deferred", _.redirect = "redirect", _.error = "error"
    })(ResultType || (ResultType = {}));
    const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

    function isIndexRoute(_) {
        return _.index === !0
    }

    function convertRoutesToDataRoutes(_, _e, et, tt) {
        return et === void 0 && (et = []), tt === void 0 && (tt = {}), _.map((nt, ot) => {
            let at = [...et, ot],
                st = typeof nt.id == "string" ? nt.id : at.join("-");
            if (invariant(nt.index !== !0 || !nt.children, "Cannot specify children on an index route"), invariant(!tt[st], 'Found a route id collision on id "' + st + `".  Route id's must be globally unique within Data Router usages`), isIndexRoute(nt)) {
                let lt = _extends$4({}, nt, _e(nt), {
                    id: st
                });
                return tt[st] = lt, lt
            } else {
                let lt = _extends$4({}, nt, _e(nt), {
                    id: st,
                    children: void 0
                });
                return tt[st] = lt, nt.children && (lt.children = convertRoutesToDataRoutes(nt.children, _e, at, tt)), lt
            }
        })
    }

    function matchRoutes(_, _e, et) {
        et === void 0 && (et = "/");
        let tt = typeof _e == "string" ? parsePath(_e) : _e,
            nt = stripBasename(tt.pathname || "/", et);
        if (nt == null) return null;
        let ot = flattenRoutes(_);
        rankRouteBranches(ot);
        let at = null;
        for (let st = 0; at == null && st < ot.length; ++st) at = matchRouteBranch(ot[st], safelyDecodeURI(nt));
        return at
    }

    function flattenRoutes(_, _e, et, tt) {
        _e === void 0 && (_e = []), et === void 0 && (et = []), tt === void 0 && (tt = "");
        let nt = (ot, at, st) => {
            let lt = {
                relativePath: st === void 0 ? ot.path || "" : st,
                caseSensitive: ot.caseSensitive === !0,
                childrenIndex: at,
                route: ot
            };
            lt.relativePath.startsWith("/") && (invariant(lt.relativePath.startsWith(tt), 'Absolute route path "' + lt.relativePath + '" nested under path ' + ('"' + tt + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), lt.relativePath = lt.relativePath.slice(tt.length));
            let ut = joinPaths([tt, lt.relativePath]),
                dt = et.concat(lt);
            ot.children && ot.children.length > 0 && (invariant(ot.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + ut + '".')), flattenRoutes(ot.children, _e, dt, ut)), !(ot.path == null && !ot.index) && _e.push({
                path: ut,
                score: computeScore(ut, ot.index),
                routesMeta: dt
            })
        };
        return _.forEach((ot, at) => {
            var st;
            if (ot.path === "" || !((st = ot.path) != null && st.includes("?"))) nt(ot, at);
            else
                for (let lt of explodeOptionalSegments(ot.path)) nt(ot, at, lt)
        }), _e
    }

    function explodeOptionalSegments(_) {
        let _e = _.split("/");
        if (_e.length === 0) return [];
        let [et, ...tt] = _e, nt = et.endsWith("?"), ot = et.replace(/\?$/, "");
        if (tt.length === 0) return nt ? [ot, ""] : [ot];
        let at = explodeOptionalSegments(tt.join("/")),
            st = [];
        return st.push(...at.map(lt => lt === "" ? ot : [ot, lt].join("/"))), nt && st.push(...at), st.map(lt => _.startsWith("/") && lt === "" ? "/" : lt)
    }

    function rankRouteBranches(_) {
        _.sort((_e, et) => _e.score !== et.score ? et.score - _e.score : compareIndexes(_e.routesMeta.map(tt => tt.childrenIndex), et.routesMeta.map(tt => tt.childrenIndex)))
    }
    const paramRe = /^:\w+$/,
        dynamicSegmentValue = 3,
        indexRouteValue = 2,
        emptySegmentValue = 1,
        staticSegmentValue = 10,
        splatPenalty = -2,
        isSplat = _ => _ === "*";

    function computeScore(_, _e) {
        let et = _.split("/"),
            tt = et.length;
        return et.some(isSplat) && (tt += splatPenalty), _e && (tt += indexRouteValue), et.filter(nt => !isSplat(nt)).reduce((nt, ot) => nt + (paramRe.test(ot) ? dynamicSegmentValue : ot === "" ? emptySegmentValue : staticSegmentValue), tt)
    }

    function compareIndexes(_, _e) {
        return _.length === _e.length && _.slice(0, -1).every((et, tt) => et === _e[tt]) ? _[_.length - 1] - _e[_e.length - 1] : 0
    }

    function matchRouteBranch(_, _e) {
        let {
            routesMeta: et
        } = _, tt = {}, nt = "/", ot = [];
        for (let at = 0; at < et.length; ++at) {
            let st = et[at],
                lt = at === et.length - 1,
                ut = nt === "/" ? _e : _e.slice(nt.length) || "/",
                dt = matchPath({
                    path: st.relativePath,
                    caseSensitive: st.caseSensitive,
                    end: lt
                }, ut);
            if (!dt) return null;
            Object.assign(tt, dt.params);
            let ct = st.route;
            ot.push({
                params: tt,
                pathname: joinPaths([nt, dt.pathname]),
                pathnameBase: normalizePathname(joinPaths([nt, dt.pathnameBase])),
                route: ct
            }), dt.pathnameBase !== "/" && (nt = joinPaths([nt, dt.pathnameBase]))
        }
        return ot
    }

    function generatePath(_, _e) {
        _e === void 0 && (_e = {});
        let et = _;
        et.endsWith("*") && et !== "*" && !et.endsWith("/*") && (warning(!1, 'Route path "' + et + '" will be treated as if it were ' + ('"' + et.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + et.replace(/\*$/, "/*") + '".')), et = et.replace(/\*$/, "/*"));
        const tt = et.startsWith("/") ? "/" : "",
            nt = at => at == null ? "" : typeof at == "string" ? at : String(at),
            ot = et.split(/\/+/).map((at, st, lt) => {
                if (st === lt.length - 1 && at === "*") return nt(_e["*"]);
                const ut = at.match(/^:(\w+)(\??)$/);
                if (ut) {
                    const [, dt, ct] = ut;
                    let pt = _e[dt];
                    return invariant(ct === "?" || pt != null, 'Missing ":' + dt + '" param'), nt(pt)
                }
                return at.replace(/\?$/g, "")
            }).filter(at => !!at);
        return tt + ot.join("/")
    }

    function matchPath(_, _e) {
        typeof _ == "string" && (_ = {
            path: _,
            caseSensitive: !1,
            end: !0
        });
        let [et, tt] = compilePath(_.path, _.caseSensitive, _.end), nt = _e.match(et);
        if (!nt) return null;
        let ot = nt[0],
            at = ot.replace(/(.)\/+$/, "$1"),
            st = nt.slice(1);
        return {
            params: tt.reduce((lt, ut, dt) => {
                if (ut === "*") {
                    let ct = st[dt] || "";
                    at = ot.slice(0, ot.length - ct.length).replace(/(.)\/+$/, "$1")
                }
                return lt[ut] = safelyDecodeURIComponent(st[dt] || "", ut), lt
            }, {}),
            pathname: ot,
            pathnameBase: at,
            pattern: _
        }
    }

    function compilePath(_, _e, et) {
        _e === void 0 && (_e = !1), et === void 0 && (et = !0), warning(_ === "*" || !_.endsWith("*") || _.endsWith("/*"), 'Route path "' + _ + '" will be treated as if it were ' + ('"' + _.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + _.replace(/\*$/, "/*") + '".'));
        let tt = [],
            nt = "^" + _.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (ot, at) => (tt.push(at), "/([^\\/]+)"));
        return _.endsWith("*") ? (tt.push("*"), nt += _ === "*" || _ === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : et ? nt += "\\/*$" : _ !== "" && _ !== "/" && (nt += "(?:(?=\\/|$))"), [new RegExp(nt, _e ? void 0 : "i"), tt]
    }

    function safelyDecodeURI(_) {
        try {
            return decodeURI(_)
        } catch (_e) {
            return warning(!1, 'The URL path "' + _ + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + _e + ").")), _
        }
    }

    function safelyDecodeURIComponent(_, _e) {
        try {
            return decodeURIComponent(_)
        } catch (et) {
            return warning(!1, 'The value for the URL param "' + _e + '" will not be decoded because' + (' the string "' + _ + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + et + ").")), _
        }
    }

    function stripBasename(_, _e) {
        if (_e === "/") return _;
        if (!_.toLowerCase().startsWith(_e.toLowerCase())) return null;
        let et = _e.endsWith("/") ? _e.length - 1 : _e.length,
            tt = _.charAt(et);
        return tt && tt !== "/" ? null : _.slice(et) || "/"
    }

    function resolvePath(_, _e) {
        _e === void 0 && (_e = "/");
        let {
            pathname: et,
            search: tt = "",
            hash: nt = ""
        } = typeof _ == "string" ? parsePath(_) : _;
        return {
            pathname: et ? et.startsWith("/") ? et : resolvePathname(et, _e) : _e,
            search: normalizeSearch(tt),
            hash: normalizeHash(nt)
        }
    }

    function resolvePathname(_, _e) {
        let et = _e.replace(/\/+$/, "").split("/");
        return _.split("/").forEach(tt => {
            tt === ".." ? et.length > 1 && et.pop() : tt !== "." && et.push(tt)
        }), et.length > 1 ? et.join("/") : "/"
    }

    function getInvalidPathError(_, _e, et, tt) {
        return "Cannot include a '" + _ + "' character in a manually specified " + ("`to." + _e + "` field [" + JSON.stringify(tt) + "].  Please separate it out to the ") + ("`to." + et + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
    }

    function getPathContributingMatches(_) {
        return _.filter((_e, et) => et === 0 || _e.route.path && _e.route.path.length > 0)
    }

    function resolveTo(_, _e, et, tt) {
        tt === void 0 && (tt = !1);
        let nt;
        typeof _ == "string" ? nt = parsePath(_) : (nt = _extends$4({}, _), invariant(!nt.pathname || !nt.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", nt)), invariant(!nt.pathname || !nt.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", nt)), invariant(!nt.search || !nt.search.includes("#"), getInvalidPathError("#", "search", "hash", nt)));
        let ot = _ === "" || nt.pathname === "",
            at = ot ? "/" : nt.pathname,
            st;
        if (tt || at == null) st = et;
        else {
            let ct = _e.length - 1;
            if (at.startsWith("..")) {
                let pt = at.split("/");
                for (; pt[0] === "..";) pt.shift(), ct -= 1;
                nt.pathname = pt.join("/")
            }
            st = ct >= 0 ? _e[ct] : "/"
        }
        let lt = resolvePath(nt, st),
            ut = at && at !== "/" && at.endsWith("/"),
            dt = (ot || at === ".") && et.endsWith("/");
        return !lt.pathname.endsWith("/") && (ut || dt) && (lt.pathname += "/"), lt
    }
    const joinPaths = _ => _.join("/").replace(/\/\/+/g, "/"),
        normalizePathname = _ => _.replace(/\/+$/, "").replace(/^\/*/, "/"),
        normalizeSearch = _ => !_ || _ === "?" ? "" : _.startsWith("?") ? _ : "?" + _,
        normalizeHash = _ => !_ || _ === "#" ? "" : _.startsWith("#") ? _ : "#" + _,
        json = function(_, _e) {
            _e === void 0 && (_e = {});
            let et = typeof _e == "number" ? {
                    status: _e
                } : _e,
                tt = new Headers(et.headers);
            return tt.has("Content-Type") || tt.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(_), _extends$4({}, et, {
                headers: tt
            }))
        };
    class AbortedDeferredError extends Error {}
    class DeferredData {
        constructor(_e, et) {
            this.pendingKeysSet = new Set, this.subscribers = new Set, this.deferredKeys = [], invariant(_e && typeof _e == "object" && !Array.isArray(_e), "defer() only accepts plain objects");
            let tt;
            this.abortPromise = new Promise((ot, at) => tt = at), this.controller = new AbortController;
            let nt = () => tt(new AbortedDeferredError("Deferred data aborted"));
            this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", nt), this.controller.signal.addEventListener("abort", nt), this.data = Object.entries(_e).reduce((ot, at) => {
                let [st, lt] = at;
                return Object.assign(ot, {
                    [st]: this.trackPromise(st, lt)
                })
            }, {}), this.done && this.unlistenAbortSignal(), this.init = et
        }
        trackPromise(_e, et) {
            if (!(et instanceof Promise)) return et;
            this.deferredKeys.push(_e), this.pendingKeysSet.add(_e);
            let tt = Promise.race([et, this.abortPromise]).then(nt => this.onSettle(tt, _e, void 0, nt), nt => this.onSettle(tt, _e, nt));
            return tt.catch(() => {}), Object.defineProperty(tt, "_tracked", {
                get: () => !0
            }), tt
        }
        onSettle(_e, et, tt, nt) {
            if (this.controller.signal.aborted && tt instanceof AbortedDeferredError) return this.unlistenAbortSignal(), Object.defineProperty(_e, "_error", {
                get: () => tt
            }), Promise.reject(tt);
            if (this.pendingKeysSet.delete(et), this.done && this.unlistenAbortSignal(), tt === void 0 && nt === void 0) {
                let ot = new Error('Deferred data for key "' + et + '" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');
                return Object.defineProperty(_e, "_error", {
                    get: () => ot
                }), this.emit(!1, et), Promise.reject(ot)
            }
            return nt === void 0 ? (Object.defineProperty(_e, "_error", {
                get: () => tt
            }), this.emit(!1, et), Promise.reject(tt)) : (Object.defineProperty(_e, "_data", {
                get: () => nt
            }), this.emit(!1, et), nt)
        }
        emit(_e, et) {
            this.subscribers.forEach(tt => tt(_e, et))
        }
        subscribe(_e) {
            return this.subscribers.add(_e), () => this.subscribers.delete(_e)
        }
        cancel() {
            this.controller.abort(), this.pendingKeysSet.forEach((_e, et) => this.pendingKeysSet.delete(et)), this.emit(!0)
        }
        async resolveData(_e) {
            let et = !1;
            if (!this.done) {
                let tt = () => this.cancel();
                _e.addEventListener("abort", tt), et = await new Promise(nt => {
                    this.subscribe(ot => {
                        _e.removeEventListener("abort", tt), (ot || this.done) && nt(ot)
                    })
                })
            }
            return et
        }
        get done() {
            return this.pendingKeysSet.size === 0
        }
        get unwrappedData() {
            return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((_e, et) => {
                let [tt, nt] = et;
                return Object.assign(_e, {
                    [tt]: unwrapTrackedPromise(nt)
                })
            }, {})
        }
        get pendingKeys() {
            return Array.from(this.pendingKeysSet)
        }
    }

    function isTrackedPromise(_) {
        return _ instanceof Promise && _._tracked === !0
    }

    function unwrapTrackedPromise(_) {
        if (!isTrackedPromise(_)) return _;
        if (_._error) throw _._error;
        return _._data
    }
    const defer$1 = function(_, _e) {
            _e === void 0 && (_e = {});
            let et = typeof _e == "number" ? {
                status: _e
            } : _e;
            return new DeferredData(_, et)
        },
        redirect = function(_, _e) {
            _e === void 0 && (_e = 302);
            let et = _e;
            typeof et == "number" ? et = {
                status: et
            } : typeof et.status > "u" && (et.status = 302);
            let tt = new Headers(et.headers);
            return tt.set("Location", _), new Response(null, _extends$4({}, et, {
                headers: tt
            }))
        },
        redirectDocument = (_, _e) => {
            let et = redirect(_, _e);
            return et.headers.set("X-Remix-Reload-Document", "true"), et
        };
    class ErrorResponse {
        constructor(_e, et, tt, nt) {
            nt === void 0 && (nt = !1), this.status = _e, this.statusText = et || "", this.internal = nt, tt instanceof Error ? (this.data = tt.toString(), this.error = tt) : this.data = tt
        }
    }

    function isRouteErrorResponse(_) {
        return _ != null && typeof _.status == "number" && typeof _.statusText == "string" && typeof _.internal == "boolean" && "data" in _
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"],
        validMutationMethods = new Set(validMutationMethodsArr),
        validRequestMethodsArr = ["get", ...validMutationMethodsArr],
        validRequestMethods = new Set(validRequestMethodsArr),
        redirectStatusCodes = new Set([301, 302, 303, 307, 308]),
        redirectPreserveMethodStatusCodes = new Set([307, 308]),
        IDLE_NAVIGATION = {
            state: "idle",
            location: void 0,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0
        },
        IDLE_FETCHER = {
            state: "idle",
            data: void 0,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0
        },
        IDLE_BLOCKER = {
            state: "unblocked",
            proceed: void 0,
            reset: void 0,
            location: void 0
        },
        ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
        defaultMapRouteProperties = _ => ({
            hasErrorBoundary: !!_.hasErrorBoundary
        });

    function createRouter(_) {
        const _e = _.window ? _.window : typeof window < "u" ? window : void 0,
            et = typeof _e < "u" && typeof _e.document < "u" && typeof _e.document.createElement < "u",
            tt = !et;
        invariant(_.routes.length > 0, "You must provide a non-empty routes array to createRouter");
        let nt;
        if (_.mapRouteProperties) nt = _.mapRouteProperties;
        else if (_.detectErrorBoundary) {
            let At = _.detectErrorBoundary;
            nt = Lt => ({
                hasErrorBoundary: At(Lt)
            })
        } else nt = defaultMapRouteProperties;
        let ot = {},
            at = convertRoutesToDataRoutes(_.routes, nt, void 0, ot),
            st, lt = _.basename || "/",
            ut = _extends$4({
                v7_normalizeFormMethod: !1,
                v7_prependBasename: !1
            }, _.future),
            dt = null,
            ct = new Set,
            pt = null,
            ft = null,
            ht = null,
            mt = _.hydrationData != null,
            bt = matchRoutes(at, _.history.location, lt),
            gt = null;
        if (bt == null) {
            let At = getInternalRouterError(404, {
                    pathname: _.history.location.pathname
                }),
                {
                    matches: Lt,
                    route: Nt
                } = getShortCircuitMatches(at);
            bt = Lt, gt = {
                [Nt.id]: At
            }
        }
        let vt = !bt.some(At => At.route.lazy) && (!bt.some(At => At.route.loader) || _.hydrationData != null),
            xt, yt = {
                historyAction: _.history.action,
                location: _.history.location,
                matches: bt,
                initialized: vt,
                navigation: IDLE_NAVIGATION,
                restoreScrollPosition: _.hydrationData != null ? !1 : null,
                preventScrollReset: !1,
                revalidation: "idle",
                loaderData: _.hydrationData && _.hydrationData.loaderData || {},
                actionData: _.hydrationData && _.hydrationData.actionData || null,
                errors: _.hydrationData && _.hydrationData.errors || gt,
                fetchers: new Map,
                blockers: new Map
            },
            Et = Action.Pop,
            wt = !1,
            St, $t = !1,
            Ct = !1,
            Rt = [],
            Pt = [],
            Tt = new Map,
            It = 0,
            Ot = -1,
            Dt = new Map,
            jt = new Set,
            Ht = new Map,
            Mt = new Map,
            Ft = new Map,
            Vt = !1;

        function Zt() {
            return dt = _.history.listen(At => {
                let {
                    action: Lt,
                    location: Nt,
                    delta: Ut
                } = At;
                if (Vt) {
                    Vt = !1;
                    return
                }
                warning(Ft.size === 0 || Ut != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
                let Qt = Br({
                    currentLocation: yt.location,
                    nextLocation: Nt,
                    historyAction: Lt
                });
                if (Qt && Ut != null) {
                    Vt = !0, _.history.go(Ut * -1), Ar(Qt, {
                        state: "blocked",
                        location: Nt,
                        proceed() {
                            Ar(Qt, {
                                state: "proceeding",
                                proceed: void 0,
                                reset: void 0,
                                location: Nt
                            }), _.history.go(Ut)
                        },
                        reset() {
                            let Xt = new Map(yt.blockers);
                            Xt.set(Qt, IDLE_BLOCKER), Kt({
                                blockers: Xt
                            })
                        }
                    });
                    return
                }
                return er(Lt, Nt)
            }), yt.initialized || er(Action.Pop, yt.location), xt
        }

        function Jt() {
            dt && dt(), ct.clear(), St && St.abort(), yt.fetchers.forEach((At, Lt) => fr(Lt)), yt.blockers.forEach((At, Lt) => Er(Lt))
        }

        function qt(At) {
            return ct.add(At), () => ct.delete(At)
        }

        function Kt(At) {
            yt = _extends$4({}, yt, At), ct.forEach(Lt => Lt(yt))
        }

        function mr(At, Lt) {
            var Nt, Ut;
            let Qt = yt.actionData != null && yt.navigation.formMethod != null && isMutationMethod(yt.navigation.formMethod) && yt.navigation.state === "loading" && ((Nt = At.state) == null ? void 0 : Nt._isRedirect) !== !0,
                Xt;
            Lt.actionData ? Object.keys(Lt.actionData).length > 0 ? Xt = Lt.actionData : Xt = null : Qt ? Xt = yt.actionData : Xt = null;
            let Yt = Lt.loaderData ? mergeLoaderData(yt.loaderData, Lt.loaderData, Lt.matches || [], Lt.errors) : yt.loaderData,
                Gt = yt.blockers;
            Gt.size > 0 && (Gt = new Map(Gt), Gt.forEach((or, gr) => Gt.set(gr, IDLE_BLOCKER)));
            let zt = wt === !0 || yt.navigation.formMethod != null && isMutationMethod(yt.navigation.formMethod) && ((Ut = At.state) == null ? void 0 : Ut._isRedirect) !== !0;
            st && (at = st, st = void 0), $t || Et === Action.Pop || (Et === Action.Push ? _.history.push(At, At.state) : Et === Action.Replace && _.history.replace(At, At.state)), Kt(_extends$4({}, Lt, {
                actionData: Xt,
                loaderData: Yt,
                historyAction: Et,
                location: At,
                initialized: !0,
                navigation: IDLE_NAVIGATION,
                revalidation: "idle",
                restoreScrollPosition: Qr(At, Lt.matches || yt.matches),
                preventScrollReset: zt,
                blockers: Gt
            })), Et = Action.Pop, wt = !1, $t = !1, Ct = !1, Rt = [], Pt = []
        }
        async function pr(At, Lt) {
            if (typeof At == "number") {
                _.history.go(At);
                return
            }
            let Nt = normalizeTo(yt.location, yt.matches, lt, ut.v7_prependBasename, At, Lt == null ? void 0 : Lt.fromRouteId, Lt == null ? void 0 : Lt.relative),
                {
                    path: Ut,
                    submission: Qt,
                    error: Xt
                } = normalizeNavigateOptions(ut.v7_normalizeFormMethod, !1, Nt, Lt),
                Yt = yt.location,
                Gt = createLocation(yt.location, Ut, Lt && Lt.state);
            Gt = _extends$4({}, Gt, _.history.encodeLocation(Gt));
            let zt = Lt && Lt.replace != null ? Lt.replace : void 0,
                or = Action.Push;
            zt === !0 ? or = Action.Replace : zt === !1 || Qt != null && isMutationMethod(Qt.formMethod) && Qt.formAction === yt.location.pathname + yt.location.search && (or = Action.Replace);
            let gr = Lt && "preventScrollReset" in Lt ? Lt.preventScrollReset === !0 : void 0,
                tr = Br({
                    currentLocation: Yt,
                    nextLocation: Gt,
                    historyAction: or
                });
            if (tr) {
                Ar(tr, {
                    state: "blocked",
                    location: Gt,
                    proceed() {
                        Ar(tr, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: Gt
                        }), pr(At, Lt)
                    },
                    reset() {
                        let sr = new Map(yt.blockers);
                        sr.set(tr, IDLE_BLOCKER), Kt({
                            blockers: sr
                        })
                    }
                });
                return
            }
            return await er(or, Gt, {
                submission: Qt,
                pendingError: Xt,
                preventScrollReset: gr,
                replace: Lt && Lt.replace
            })
        }

        function xr() {
            if (_t(), Kt({
                    revalidation: "loading"
                }), yt.navigation.state !== "submitting") {
                if (yt.navigation.state === "idle") {
                    er(yt.historyAction, yt.location, {
                        startUninterruptedRevalidation: !0
                    });
                    return
                }
                er(Et || yt.historyAction, yt.navigation.location, {
                    overrideNavigation: yt.navigation
                })
            }
        }
        async function er(At, Lt, Nt) {
            St && St.abort(), St = null, Et = At, $t = (Nt && Nt.startUninterruptedRevalidation) === !0, rn(yt.location, yt.matches), wt = (Nt && Nt.preventScrollReset) === !0;
            let Ut = st || at,
                Qt = Nt && Nt.overrideNavigation,
                Xt = matchRoutes(Ut, Lt, lt);
            if (!Xt) {
                let sr = getInternalRouterError(404, {
                        pathname: Lt.pathname
                    }),
                    {
                        matches: hr,
                        route: Or
                    } = getShortCircuitMatches(Ut);
                Nr(), mr(Lt, {
                    matches: hr,
                    loaderData: {},
                    errors: {
                        [Or.id]: sr
                    }
                });
                return
            }
            if (yt.initialized && !Ct && isHashChangeOnly(yt.location, Lt) && !(Nt && Nt.submission && isMutationMethod(Nt.submission.formMethod))) {
                mr(Lt, {
                    matches: Xt
                });
                return
            }
            St = new AbortController;
            let Yt = createClientSideRequest(_.history, Lt, St.signal, Nt && Nt.submission),
                Gt, zt;
            if (Nt && Nt.pendingError) zt = {
                [findNearestBoundary(Xt).route.id]: Nt.pendingError
            };
            else if (Nt && Nt.submission && isMutationMethod(Nt.submission.formMethod)) {
                let sr = await wr(Yt, Lt, Nt.submission, Xt, {
                    replace: Nt.replace
                });
                if (sr.shortCircuited) return;
                Gt = sr.pendingActionData, zt = sr.pendingActionError, Qt = getLoadingNavigation(Lt, Nt.submission), Yt = new Request(Yt.url, {
                    signal: Yt.signal
                })
            }
            let {
                shortCircuited: or,
                loaderData: gr,
                errors: tr
            } = await kr(Yt, Lt, Xt, Qt, Nt && Nt.submission, Nt && Nt.fetcherSubmission, Nt && Nt.replace, Gt, zt);
            or || (St = null, mr(Lt, _extends$4({
                matches: Xt
            }, Gt ? {
                actionData: Gt
            } : {}, {
                loaderData: gr,
                errors: tr
            })))
        }
        async function wr(At, Lt, Nt, Ut, Qt) {
            Qt === void 0 && (Qt = {}), _t();
            let Xt = getSubmittingNavigation(Lt, Nt);
            Kt({
                navigation: Xt
            });
            let Yt, Gt = getTargetMatch(Ut, Lt);
            if (!Gt.route.action && !Gt.route.lazy) Yt = {
                type: ResultType.error,
                error: getInternalRouterError(405, {
                    method: At.method,
                    pathname: Lt.pathname,
                    routeId: Gt.route.id
                })
            };
            else if (Yt = await callLoaderOrAction("action", At, Gt, Ut, ot, nt, lt), At.signal.aborted) return {
                shortCircuited: !0
            };
            if (isRedirectResult(Yt)) {
                let zt;
                return Qt && Qt.replace != null ? zt = Qt.replace : zt = Yt.location === yt.location.pathname + yt.location.search, await nr(yt, Yt, {
                    submission: Nt,
                    replace: zt
                }), {
                    shortCircuited: !0
                }
            }
            if (isErrorResult(Yt)) {
                let zt = findNearestBoundary(Ut, Gt.route.id);
                return (Qt && Qt.replace) !== !0 && (Et = Action.Push), {
                    pendingActionData: {},
                    pendingActionError: {
                        [zt.route.id]: Yt.error
                    }
                }
            }
            if (isDeferredResult(Yt)) throw getInternalRouterError(400, {
                type: "defer-action"
            });
            return {
                pendingActionData: {
                    [Gt.route.id]: Yt.data
                }
            }
        }
        async function kr(At, Lt, Nt, Ut, Qt, Xt, Yt, Gt, zt) {
            let or = Ut || getLoadingNavigation(Lt, Qt),
                gr = Qt || Xt || getSubmissionFromNavigation(or),
                tr = st || at,
                [sr, hr] = getMatchesToLoad(_.history, yt, Nt, gr, Lt, Ct, Rt, Pt, Ht, jt, tr, lt, Gt, zt);
            if (Nr(rr => !(Nt && Nt.some(Cr => Cr.route.id === rr)) || sr && sr.some(Cr => Cr.route.id === rr)), Ot = ++It, sr.length === 0 && hr.length === 0) {
                let rr = $r();
                return mr(Lt, _extends$4({
                    matches: Nt,
                    loaderData: {},
                    errors: zt || null
                }, Gt ? {
                    actionData: Gt
                } : {}, rr ? {
                    fetchers: new Map(yt.fetchers)
                } : {})), {
                    shortCircuited: !0
                }
            }
            if (!$t) {
                hr.forEach(Cr => {
                    let Lr = yt.fetchers.get(Cr.key),
                        Kr = getLoadingFetcher(void 0, Lr ? Lr.data : void 0);
                    yt.fetchers.set(Cr.key, Kr)
                });
                let rr = Gt || yt.actionData;
                Kt(_extends$4({
                    navigation: or
                }, rr ? Object.keys(rr).length === 0 ? {
                    actionData: null
                } : {
                    actionData: rr
                } : {}, hr.length > 0 ? {
                    fetchers: new Map(yt.fetchers)
                } : {}))
            }
            hr.forEach(rr => {
                Tt.has(rr.key) && ir(rr.key), rr.controller && Tt.set(rr.key, rr.controller)
            });
            let Or = () => hr.forEach(rr => ir(rr.key));
            St && St.signal.addEventListener("abort", Or);
            let {
                results: Dr,
                loaderResults: Mr,
                fetcherResults: Hr
            } = await ar(yt.matches, Nt, sr, hr, At);
            if (At.signal.aborted) return {
                shortCircuited: !0
            };
            St && St.signal.removeEventListener("abort", Or), hr.forEach(rr => Tt.delete(rr.key));
            let Pr = findRedirect(Dr);
            if (Pr) {
                if (Pr.idx >= sr.length) {
                    let rr = hr[Pr.idx - sr.length].key;
                    jt.add(rr)
                }
                return await nr(yt, Pr.result, {
                    replace: Yt
                }), {
                    shortCircuited: !0
                }
            }
            let {
                loaderData: Tr,
                errors: Vr
            } = processLoaderData(yt, Nt, sr, Mr, zt, hr, Hr, Mt);
            Mt.forEach((rr, Cr) => {
                rr.subscribe(Lr => {
                    (Lr || rr.done) && Mt.delete(Cr)
                })
            });
            let Wr = $r(),
                qr = br(Ot),
                Gr = Wr || qr || hr.length > 0;
            return _extends$4({
                loaderData: Tr,
                errors: Vr
            }, Gr ? {
                fetchers: new Map(yt.fetchers)
            } : {})
        }

        function Sr(At) {
            return yt.fetchers.get(At) || IDLE_FETCHER
        }

        function lr(At, Lt, Nt, Ut) {
            if (tt) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
            Tt.has(At) && ir(At);
            let Qt = st || at,
                Xt = normalizeTo(yt.location, yt.matches, lt, ut.v7_prependBasename, Nt, Lt, Ut == null ? void 0 : Ut.relative),
                Yt = matchRoutes(Qt, Xt, lt);
            if (!Yt) {
                yr(At, Lt, getInternalRouterError(404, {
                    pathname: Xt
                }));
                return
            }
            let {
                path: Gt,
                submission: zt,
                error: or
            } = normalizeNavigateOptions(ut.v7_normalizeFormMethod, !0, Xt, Ut);
            if (or) {
                yr(At, Lt, or);
                return
            }
            let gr = getTargetMatch(Yt, Gt);
            if (wt = (Ut && Ut.preventScrollReset) === !0, zt && isMutationMethod(zt.formMethod)) {
                ur(At, Lt, Gt, gr, Yt, zt);
                return
            }
            Ht.set(At, {
                routeId: Lt,
                path: Gt
            }), Rr(At, Lt, Gt, gr, Yt, zt)
        }
        async function ur(At, Lt, Nt, Ut, Qt, Xt) {
            if (_t(), Ht.delete(At), !Ut.route.action && !Ut.route.lazy) {
                let cr = getInternalRouterError(405, {
                    method: Xt.formMethod,
                    pathname: Nt,
                    routeId: Lt
                });
                yr(At, Lt, cr);
                return
            }
            let Yt = yt.fetchers.get(At),
                Gt = getSubmittingFetcher(Xt, Yt);
            yt.fetchers.set(At, Gt), Kt({
                fetchers: new Map(yt.fetchers)
            });
            let zt = new AbortController,
                or = createClientSideRequest(_.history, Nt, zt.signal, Xt);
            Tt.set(At, zt);
            let gr = It,
                tr = await callLoaderOrAction("action", or, Ut, Qt, ot, nt, lt);
            if (or.signal.aborted) {
                Tt.get(At) === zt && Tt.delete(At);
                return
            }
            if (isRedirectResult(tr))
                if (Tt.delete(At), Ot > gr) {
                    let cr = getDoneFetcher(void 0);
                    yt.fetchers.set(At, cr), Kt({
                        fetchers: new Map(yt.fetchers)
                    });
                    return
                } else {
                    jt.add(At);
                    let cr = getLoadingFetcher(Xt);
                    return yt.fetchers.set(At, cr), Kt({
                        fetchers: new Map(yt.fetchers)
                    }), nr(yt, tr, {
                        submission: Xt,
                        isFetchActionRedirect: !0
                    })
                }
            if (isErrorResult(tr)) {
                yr(At, Lt, tr.error);
                return
            }
            if (isDeferredResult(tr)) throw getInternalRouterError(400, {
                type: "defer-action"
            });
            let sr = yt.navigation.location || yt.location,
                hr = createClientSideRequest(_.history, sr, zt.signal),
                Or = st || at,
                Dr = yt.navigation.state !== "idle" ? matchRoutes(Or, yt.navigation.location, lt) : yt.matches;
            invariant(Dr, "Didn't find any matches after fetcher action");
            let Mr = ++It;
            Dt.set(At, Mr);
            let Hr = getLoadingFetcher(Xt, tr.data);
            yt.fetchers.set(At, Hr);
            let [Pr, Tr] = getMatchesToLoad(_.history, yt, Dr, Xt, sr, Ct, Rt, Pt, Ht, jt, Or, lt, {
                [Ut.route.id]: tr.data
            }, void 0);
            Tr.filter(cr => cr.key !== At).forEach(cr => {
                let Fr = cr.key,
                    Zr = yt.fetchers.get(Fr),
                    an = getLoadingFetcher(void 0, Zr ? Zr.data : void 0);
                yt.fetchers.set(Fr, an), Tt.has(Fr) && ir(Fr), cr.controller && Tt.set(Fr, cr.controller)
            }), Kt({
                fetchers: new Map(yt.fetchers)
            });
            let Vr = () => Tr.forEach(cr => ir(cr.key));
            zt.signal.addEventListener("abort", Vr);
            let {
                results: Wr,
                loaderResults: qr,
                fetcherResults: Gr
            } = await ar(yt.matches, Dr, Pr, Tr, hr);
            if (zt.signal.aborted) return;
            zt.signal.removeEventListener("abort", Vr), Dt.delete(At), Tt.delete(At), Tr.forEach(cr => Tt.delete(cr.key));
            let rr = findRedirect(Wr);
            if (rr) {
                if (rr.idx >= Pr.length) {
                    let cr = Tr[rr.idx - Pr.length].key;
                    jt.add(cr)
                }
                return nr(yt, rr.result)
            }
            let {
                loaderData: Cr,
                errors: Lr
            } = processLoaderData(yt, yt.matches, Pr, qr, void 0, Tr, Gr, Mt);
            if (yt.fetchers.has(At)) {
                let cr = getDoneFetcher(tr.data);
                yt.fetchers.set(At, cr)
            }
            let Kr = br(Mr);
            yt.navigation.state === "loading" && Mr > Ot ? (invariant(Et, "Expected pending action"), St && St.abort(), mr(yt.navigation.location, {
                matches: Dr,
                loaderData: Cr,
                errors: Lr,
                fetchers: new Map(yt.fetchers)
            })) : (Kt(_extends$4({
                errors: Lr,
                loaderData: mergeLoaderData(yt.loaderData, Cr, Dr, Lr)
            }, Kr || Tr.length > 0 ? {
                fetchers: new Map(yt.fetchers)
            } : {})), Ct = !1)
        }
        async function Rr(At, Lt, Nt, Ut, Qt, Xt) {
            let Yt = yt.fetchers.get(At),
                Gt = getLoadingFetcher(Xt, Yt ? Yt.data : void 0);
            yt.fetchers.set(At, Gt), Kt({
                fetchers: new Map(yt.fetchers)
            });
            let zt = new AbortController,
                or = createClientSideRequest(_.history, Nt, zt.signal);
            Tt.set(At, zt);
            let gr = It,
                tr = await callLoaderOrAction("loader", or, Ut, Qt, ot, nt, lt);
            if (isDeferredResult(tr) && (tr = await resolveDeferredData(tr, or.signal, !0) || tr), Tt.get(At) === zt && Tt.delete(At), or.signal.aborted) return;
            if (isRedirectResult(tr))
                if (Ot > gr) {
                    let hr = getDoneFetcher(void 0);
                    yt.fetchers.set(At, hr), Kt({
                        fetchers: new Map(yt.fetchers)
                    });
                    return
                } else {
                    jt.add(At), await nr(yt, tr);
                    return
                }
            if (isErrorResult(tr)) {
                let hr = findNearestBoundary(yt.matches, Lt);
                yt.fetchers.delete(At), Kt({
                    fetchers: new Map(yt.fetchers),
                    errors: {
                        [hr.route.id]: tr.error
                    }
                });
                return
            }
            invariant(!isDeferredResult(tr), "Unhandled fetcher deferred data");
            let sr = getDoneFetcher(tr.data);
            yt.fetchers.set(At, sr), Kt({
                fetchers: new Map(yt.fetchers)
            })
        }
        async function nr(At, Lt, Nt) {
            let {
                submission: Ut,
                replace: Qt,
                isFetchActionRedirect: Xt
            } = Nt === void 0 ? {} : Nt;
            Lt.revalidate && (Ct = !0);
            let Yt = createLocation(At.location, Lt.location, _extends$4({
                _isRedirect: !0
            }, Xt ? {
                _isFetchActionRedirect: !0
            } : {}));
            if (invariant(Yt, "Expected a location on the redirect navigation"), et) {
                let or = !1;
                if (Lt.reloadDocument) or = !0;
                else if (ABSOLUTE_URL_REGEX$1.test(Lt.location)) {
                    const gr = _.history.createURL(Lt.location);
                    or = gr.origin !== _e.location.origin || stripBasename(gr.pathname, lt) == null
                }
                if (or) {
                    Qt ? _e.location.replace(Lt.location) : _e.location.assign(Lt.location);
                    return
                }
            }
            St = null;
            let Gt = Qt === !0 ? Action.Replace : Action.Push,
                zt = Ut || getSubmissionFromNavigation(At.navigation);
            if (redirectPreserveMethodStatusCodes.has(Lt.status) && zt && isMutationMethod(zt.formMethod)) await er(Gt, Yt, {
                submission: _extends$4({}, zt, {
                    formAction: Lt.location
                }),
                preventScrollReset: wt
            });
            else if (Xt) await er(Gt, Yt, {
                overrideNavigation: getLoadingNavigation(Yt),
                fetcherSubmission: zt,
                preventScrollReset: wt
            });
            else {
                let or = getLoadingNavigation(Yt, zt);
                await er(Gt, Yt, {
                    overrideNavigation: or,
                    preventScrollReset: wt
                })
            }
        }
        async function ar(At, Lt, Nt, Ut, Qt) {
            let Xt = await Promise.all([...Nt.map(zt => callLoaderOrAction("loader", Qt, zt, Lt, ot, nt, lt)), ...Ut.map(zt => zt.matches && zt.match && zt.controller ? callLoaderOrAction("loader", createClientSideRequest(_.history, zt.path, zt.controller.signal), zt.match, zt.matches, ot, nt, lt) : {
                    type: ResultType.error,
                    error: getInternalRouterError(404, {
                        pathname: zt.path
                    })
                })]),
                Yt = Xt.slice(0, Nt.length),
                Gt = Xt.slice(Nt.length);
            return await Promise.all([resolveDeferredResults(At, Nt, Yt, Yt.map(() => Qt.signal), !1, yt.loaderData), resolveDeferredResults(At, Ut.map(zt => zt.match), Gt, Ut.map(zt => zt.controller ? zt.controller.signal : null), !0)]), {
                results: Xt,
                loaderResults: Yt,
                fetcherResults: Gt
            }
        }

        function _t() {
            Ct = !0, Rt.push(...Nr()), Ht.forEach((At, Lt) => {
                Tt.has(Lt) && (Pt.push(Lt), ir(Lt))
            })
        }

        function yr(At, Lt, Nt) {
            let Ut = findNearestBoundary(yt.matches, Lt);
            fr(At), Kt({
                errors: {
                    [Ut.route.id]: Nt
                },
                fetchers: new Map(yt.fetchers)
            })
        }

        function fr(At) {
            let Lt = yt.fetchers.get(At);
            Tt.has(At) && !(Lt && Lt.state === "loading" && Dt.has(At)) && ir(At), Ht.delete(At), Dt.delete(At), jt.delete(At), yt.fetchers.delete(At)
        }

        function ir(At) {
            let Lt = Tt.get(At);
            invariant(Lt, "Expected fetch controller: " + At), Lt.abort(), Tt.delete(At)
        }

        function vr(At) {
            for (let Lt of At) {
                let Nt = Sr(Lt),
                    Ut = getDoneFetcher(Nt.data);
                yt.fetchers.set(Lt, Ut)
            }
        }

        function $r() {
            let At = [],
                Lt = !1;
            for (let Nt of jt) {
                let Ut = yt.fetchers.get(Nt);
                invariant(Ut, "Expected fetcher: " + Nt), Ut.state === "loading" && (jt.delete(Nt), At.push(Nt), Lt = !0)
            }
            return vr(At), Lt
        }

        function br(At) {
            let Lt = [];
            for (let [Nt, Ut] of Dt)
                if (Ut < At) {
                    let Qt = yt.fetchers.get(Nt);
                    invariant(Qt, "Expected fetcher: " + Nt), Qt.state === "loading" && (ir(Nt), Dt.delete(Nt), Lt.push(Nt))
                }
            return vr(Lt), Lt.length > 0
        }

        function jr(At, Lt) {
            let Nt = yt.blockers.get(At) || IDLE_BLOCKER;
            return Ft.get(At) !== Lt && Ft.set(At, Lt), Nt
        }

        function Er(At) {
            yt.blockers.delete(At), Ft.delete(At)
        }

        function Ar(At, Lt) {
            let Nt = yt.blockers.get(At) || IDLE_BLOCKER;
            invariant(Nt.state === "unblocked" && Lt.state === "blocked" || Nt.state === "blocked" && Lt.state === "blocked" || Nt.state === "blocked" && Lt.state === "proceeding" || Nt.state === "blocked" && Lt.state === "unblocked" || Nt.state === "proceeding" && Lt.state === "unblocked", "Invalid blocker state transition: " + Nt.state + " -> " + Lt.state);
            let Ut = new Map(yt.blockers);
            Ut.set(At, Lt), Kt({
                blockers: Ut
            })
        }

        function Br(At) {
            let {
                currentLocation: Lt,
                nextLocation: Nt,
                historyAction: Ut
            } = At;
            if (Ft.size === 0) return;
            Ft.size > 1 && warning(!1, "A router only supports one blocker at a time");
            let Qt = Array.from(Ft.entries()),
                [Xt, Yt] = Qt[Qt.length - 1],
                Gt = yt.blockers.get(Xt);
            if (!(Gt && Gt.state === "proceeding") && Yt({
                    currentLocation: Lt,
                    nextLocation: Nt,
                    historyAction: Ut
                })) return Xt
        }

        function Nr(At) {
            let Lt = [];
            return Mt.forEach((Nt, Ut) => {
                (!At || At(Ut)) && (Nt.cancel(), Lt.push(Ut), Mt.delete(Ut))
            }), Lt
        }

        function Ir(At, Lt, Nt) {
            if (pt = At, ht = Lt, ft = Nt || null, !mt && yt.navigation === IDLE_NAVIGATION) {
                mt = !0;
                let Ut = Qr(yt.location, yt.matches);
                Ut != null && Kt({
                    restoreScrollPosition: Ut
                })
            }
            return () => {
                pt = null, ht = null, ft = null
            }
        }

        function Yr(At, Lt) {
            return ft && ft(At, Lt.map(Nt => createUseMatchesMatch(Nt, yt.loaderData))) || At.key
        }

        function rn(At, Lt) {
            if (pt && ht) {
                let Nt = Yr(At, Lt);
                pt[Nt] = ht()
            }
        }

        function Qr(At, Lt) {
            if (pt) {
                let Nt = Yr(At, Lt),
                    Ut = pt[Nt];
                if (typeof Ut == "number") return Ut
            }
            return null
        }

        function nn(At) {
            ot = {}, st = convertRoutesToDataRoutes(At, nt, void 0, ot)
        }
        return xt = {
            get basename() {
                return lt
            },
            get state() {
                return yt
            },
            get routes() {
                return at
            },
            initialize: Zt,
            subscribe: qt,
            enableScrollRestoration: Ir,
            navigate: pr,
            fetch: lr,
            revalidate: xr,
            createHref: At => _.history.createHref(At),
            encodeLocation: At => _.history.encodeLocation(At),
            getFetcher: Sr,
            deleteFetcher: fr,
            dispose: Jt,
            getBlocker: jr,
            deleteBlocker: Er,
            _internalFetchControllers: Tt,
            _internalActiveDeferreds: Mt,
            _internalSetRoutes: nn
        }, xt
    }

    function isSubmissionNavigation(_) {
        return _ != null && ("formData" in _ && _.formData != null || "body" in _ && _.body !== void 0)
    }

    function normalizeTo(_, _e, et, tt, nt, ot, at) {
        let st, lt;
        if (ot != null && at !== "path") {
            st = [];
            for (let dt of _e)
                if (st.push(dt), dt.route.id === ot) {
                    lt = dt;
                    break
                }
        } else st = _e, lt = _e[_e.length - 1];
        let ut = resolveTo(nt || ".", getPathContributingMatches(st).map(dt => dt.pathnameBase), stripBasename(_.pathname, et) || _.pathname, at === "path");
        return nt == null && (ut.search = _.search, ut.hash = _.hash), (nt == null || nt === "" || nt === ".") && lt && lt.route.index && !hasNakedIndexQuery(ut.search) && (ut.search = ut.search ? ut.search.replace(/^\?/, "?index&") : "?index"), tt && et !== "/" && (ut.pathname = ut.pathname === "/" ? et : joinPaths([et, ut.pathname])), createPath(ut)
    }

    function normalizeNavigateOptions(_, _e, et, tt) {
        if (!tt || !isSubmissionNavigation(tt)) return {
            path: et
        };
        if (tt.formMethod && !isValidMethod(tt.formMethod)) return {
            path: et,
            error: getInternalRouterError(405, {
                method: tt.formMethod
            })
        };
        let nt = () => ({
                path: et,
                error: getInternalRouterError(400, {
                    type: "invalid-body"
                })
            }),
            ot = tt.formMethod || "get",
            at = _ ? ot.toUpperCase() : ot.toLowerCase(),
            st = stripHashFromPath(et);
        if (tt.body !== void 0) {
            if (tt.formEncType === "text/plain") {
                if (!isMutationMethod(at)) return nt();
                let pt = typeof tt.body == "string" ? tt.body : tt.body instanceof FormData || tt.body instanceof URLSearchParams ? Array.from(tt.body.entries()).reduce((ft, ht) => {
                    let [mt, bt] = ht;
                    return "" + ft + mt + "=" + bt + `
`
                }, "") : String(tt.body);
                return {
                    path: et,
                    submission: {
                        formMethod: at,
                        formAction: st,
                        formEncType: tt.formEncType,
                        formData: void 0,
                        json: void 0,
                        text: pt
                    }
                }
            } else if (tt.formEncType === "application/json") {
                if (!isMutationMethod(at)) return nt();
                try {
                    let pt = typeof tt.body == "string" ? JSON.parse(tt.body) : tt.body;
                    return {
                        path: et,
                        submission: {
                            formMethod: at,
                            formAction: st,
                            formEncType: tt.formEncType,
                            formData: void 0,
                            json: pt,
                            text: void 0
                        }
                    }
                } catch (pt) {
                    return nt()
                }
            }
        }
        invariant(typeof FormData == "function", "FormData is not available in this environment");
        let lt, ut;
        if (tt.formData) lt = convertFormDataToSearchParams(tt.formData), ut = tt.formData;
        else if (tt.body instanceof FormData) lt = convertFormDataToSearchParams(tt.body), ut = tt.body;
        else if (tt.body instanceof URLSearchParams) lt = tt.body, ut = convertSearchParamsToFormData(lt);
        else if (tt.body == null) lt = new URLSearchParams, ut = new FormData;
        else try {
            lt = new URLSearchParams(tt.body), ut = convertSearchParamsToFormData(lt)
        } catch (pt) {
            return nt()
        }
        let dt = {
            formMethod: at,
            formAction: st,
            formEncType: tt && tt.formEncType || "application/x-www-form-urlencoded",
            formData: ut,
            json: void 0,
            text: void 0
        };
        if (isMutationMethod(dt.formMethod)) return {
            path: et,
            submission: dt
        };
        let ct = parsePath(et);
        return _e && ct.search && hasNakedIndexQuery(ct.search) && lt.append("index", ""), ct.search = "?" + lt, {
            path: createPath(ct),
            submission: dt
        }
    }

    function getLoaderMatchesUntilBoundary(_, _e) {
        let et = _;
        if (_e) {
            let tt = _.findIndex(nt => nt.route.id === _e);
            tt >= 0 && (et = _.slice(0, tt))
        }
        return et
    }

    function getMatchesToLoad(_, _e, et, tt, nt, ot, at, st, lt, ut, dt, ct, pt, ft) {
        let ht = ft ? Object.values(ft)[0] : pt ? Object.values(pt)[0] : void 0,
            mt = _.createURL(_e.location),
            bt = _.createURL(nt),
            gt = ft ? Object.keys(ft)[0] : void 0,
            vt = getLoaderMatchesUntilBoundary(et, gt).filter((yt, Et) => {
                if (yt.route.lazy) return !0;
                if (yt.route.loader == null) return !1;
                if (isNewLoader(_e.loaderData, _e.matches[Et], yt) || at.some($t => $t === yt.route.id)) return !0;
                let wt = _e.matches[Et],
                    St = yt;
                return shouldRevalidateLoader(yt, _extends$4({
                    currentUrl: mt,
                    currentParams: wt.params,
                    nextUrl: bt,
                    nextParams: St.params
                }, tt, {
                    actionResult: ht,
                    defaultShouldRevalidate: ot || mt.pathname + mt.search === bt.pathname + bt.search || mt.search !== bt.search || isNewRouteInstance(wt, St)
                }))
            }),
            xt = [];
        return lt.forEach((yt, Et) => {
            if (!et.some(Rt => Rt.route.id === yt.routeId)) return;
            let wt = matchRoutes(dt, yt.path, ct);
            if (!wt) {
                xt.push({
                    key: Et,
                    routeId: yt.routeId,
                    path: yt.path,
                    matches: null,
                    match: null,
                    controller: null
                });
                return
            }
            let St = _e.fetchers.get(Et),
                $t = getTargetMatch(wt, yt.path),
                Ct = !1;
            ut.has(Et) ? Ct = !1 : st.includes(Et) ? Ct = !0 : St && St.state !== "idle" && St.data === void 0 ? Ct = ot : Ct = shouldRevalidateLoader($t, _extends$4({
                currentUrl: mt,
                currentParams: _e.matches[_e.matches.length - 1].params,
                nextUrl: bt,
                nextParams: et[et.length - 1].params
            }, tt, {
                actionResult: ht,
                defaultShouldRevalidate: ot
            })), Ct && xt.push({
                key: Et,
                routeId: yt.routeId,
                path: yt.path,
                matches: wt,
                match: $t,
                controller: new AbortController
            })
        }), [vt, xt]
    }

    function isNewLoader(_, _e, et) {
        let tt = !_e || et.route.id !== _e.route.id,
            nt = _[et.route.id] === void 0;
        return tt || nt
    }

    function isNewRouteInstance(_, _e) {
        let et = _.route.path;
        return _.pathname !== _e.pathname || et != null && et.endsWith("*") && _.params["*"] !== _e.params["*"]
    }

    function shouldRevalidateLoader(_, _e) {
        if (_.route.shouldRevalidate) {
            let et = _.route.shouldRevalidate(_e);
            if (typeof et == "boolean") return et
        }
        return _e.defaultShouldRevalidate
    }
    async function loadLazyRouteModule(_, _e, et) {
        if (!_.lazy) return;
        let tt = await _.lazy();
        if (!_.lazy) return;
        let nt = et[_.id];
        invariant(nt, "No route found in manifest");
        let ot = {};
        for (let at in tt) {
            let st = nt[at] !== void 0 && at !== "hasErrorBoundary";
            warning(!st, 'Route "' + nt.id + '" has a static property "' + at + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + at + '" will be ignored.')), !st && !immutableRouteKeys.has(at) && (ot[at] = tt[at])
        }
        Object.assign(nt, ot), Object.assign(nt, _extends$4({}, _e(nt), {
            lazy: void 0
        }))
    }
    async function callLoaderOrAction(_, _e, et, tt, nt, ot, at, st) {
        st === void 0 && (st = {});
        let lt, ut, dt, ct = ht => {
            let mt, bt = new Promise((gt, vt) => mt = vt);
            return dt = () => mt(), _e.signal.addEventListener("abort", dt), Promise.race([ht({
                request: _e,
                params: et.params,
                context: st.requestContext
            }), bt])
        };
        try {
            let ht = et.route[_];
            if (et.route.lazy)
                if (ht) ut = (await Promise.all([ct(ht), loadLazyRouteModule(et.route, ot, nt)]))[0];
                else if (await loadLazyRouteModule(et.route, ot, nt), ht = et.route[_], ht) ut = await ct(ht);
            else if (_ === "action") {
                let mt = new URL(_e.url),
                    bt = mt.pathname + mt.search;
                throw getInternalRouterError(405, {
                    method: _e.method,
                    pathname: bt,
                    routeId: et.route.id
                })
            } else return {
                type: ResultType.data,
                data: void 0
            };
            else if (ht) ut = await ct(ht);
            else {
                let mt = new URL(_e.url),
                    bt = mt.pathname + mt.search;
                throw getInternalRouterError(404, {
                    pathname: bt
                })
            }
            invariant(ut !== void 0, "You defined " + (_ === "action" ? "an action" : "a loader") + " for route " + ('"' + et.route.id + "\" but didn't return anything from your `" + _ + "` ") + "function. Please return a value or `null`.")
        } catch (ht) {
            lt = ResultType.error, ut = ht
        } finally {
            dt && _e.signal.removeEventListener("abort", dt)
        }
        if (isResponse(ut)) {
            let ht = ut.status;
            if (redirectStatusCodes.has(ht)) {
                let gt = ut.headers.get("Location");
                if (invariant(gt, "Redirects returned/thrown from loaders/actions must have a Location header"), !ABSOLUTE_URL_REGEX$1.test(gt)) gt = normalizeTo(new URL(_e.url), tt.slice(0, tt.indexOf(et) + 1), at, !0, gt);
                else if (!st.isStaticRequest) {
                    let vt = new URL(_e.url),
                        xt = gt.startsWith("//") ? new URL(vt.protocol + gt) : new URL(gt),
                        yt = stripBasename(xt.pathname, at) != null;
                    xt.origin === vt.origin && yt && (gt = xt.pathname + xt.search + xt.hash)
                }
                if (st.isStaticRequest) throw ut.headers.set("Location", gt), ut;
                return {
                    type: ResultType.redirect,
                    status: ht,
                    location: gt,
                    revalidate: ut.headers.get("X-Remix-Revalidate") !== null,
                    reloadDocument: ut.headers.get("X-Remix-Reload-Document") !== null
                }
            }
            if (st.isRouteRequest) throw {
                type: lt === ResultType.error ? ResultType.error : ResultType.data,
                response: ut
            };
            let mt, bt = ut.headers.get("Content-Type");
            return bt && /\bapplication\/json\b/.test(bt) ? mt = await ut.json() : mt = await ut.text(), lt === ResultType.error ? {
                type: lt,
                error: new ErrorResponse(ht, ut.statusText, mt),
                headers: ut.headers
            } : {
                type: ResultType.data,
                data: mt,
                statusCode: ut.status,
                headers: ut.headers
            }
        }
        if (lt === ResultType.error) return {
            type: lt,
            error: ut
        };
        if (isDeferredData(ut)) {
            var pt, ft;
            return {
                type: ResultType.deferred,
                deferredData: ut,
                statusCode: (pt = ut.init) == null ? void 0 : pt.status,
                headers: ((ft = ut.init) == null ? void 0 : ft.headers) && new Headers(ut.init.headers)
            }
        }
        return {
            type: ResultType.data,
            data: ut
        }
    }

    function createClientSideRequest(_, _e, et, tt) {
        let nt = _.createURL(stripHashFromPath(_e)).toString(),
            ot = {
                signal: et
            };
        if (tt && isMutationMethod(tt.formMethod)) {
            let {
                formMethod: at,
                formEncType: st
            } = tt;
            ot.method = at.toUpperCase(), st === "application/json" ? (ot.headers = new Headers({
                "Content-Type": st
            }), ot.body = JSON.stringify(tt.json)) : st === "text/plain" ? ot.body = tt.text : st === "application/x-www-form-urlencoded" && tt.formData ? ot.body = convertFormDataToSearchParams(tt.formData) : ot.body = tt.formData
        }
        return new Request(nt, ot)
    }

    function convertFormDataToSearchParams(_) {
        let _e = new URLSearchParams;
        for (let [et, tt] of _.entries()) _e.append(et, typeof tt == "string" ? tt : tt.name);
        return _e
    }

    function convertSearchParamsToFormData(_) {
        let _e = new FormData;
        for (let [et, tt] of _.entries()) _e.append(et, tt);
        return _e
    }

    function processRouteLoaderData(_, _e, et, tt, nt) {
        let ot = {},
            at = null,
            st, lt = !1,
            ut = {};
        return et.forEach((dt, ct) => {
            let pt = _e[ct].route.id;
            if (invariant(!isRedirectResult(dt), "Cannot handle redirect results in processLoaderData"), isErrorResult(dt)) {
                let ft = findNearestBoundary(_, pt),
                    ht = dt.error;
                tt && (ht = Object.values(tt)[0], tt = void 0), at = at || {}, at[ft.route.id] == null && (at[ft.route.id] = ht), ot[pt] = void 0, lt || (lt = !0, st = isRouteErrorResponse(dt.error) ? dt.error.status : 500), dt.headers && (ut[pt] = dt.headers)
            } else isDeferredResult(dt) ? (nt.set(pt, dt.deferredData), ot[pt] = dt.deferredData.data) : ot[pt] = dt.data, dt.statusCode != null && dt.statusCode !== 200 && !lt && (st = dt.statusCode), dt.headers && (ut[pt] = dt.headers)
        }), tt && (at = tt, ot[Object.keys(tt)[0]] = void 0), {
            loaderData: ot,
            errors: at,
            statusCode: st || 200,
            loaderHeaders: ut
        }
    }

    function processLoaderData(_, _e, et, tt, nt, ot, at, st) {
        let {
            loaderData: lt,
            errors: ut
        } = processRouteLoaderData(_e, et, tt, nt, st);
        for (let dt = 0; dt < ot.length; dt++) {
            let {
                key: ct,
                match: pt,
                controller: ft
            } = ot[dt];
            invariant(at !== void 0 && at[dt] !== void 0, "Did not find corresponding fetcher result");
            let ht = at[dt];
            if (!(ft && ft.signal.aborted))
                if (isErrorResult(ht)) {
                    let mt = findNearestBoundary(_.matches, pt == null ? void 0 : pt.route.id);
                    ut && ut[mt.route.id] || (ut = _extends$4({}, ut, {
                        [mt.route.id]: ht.error
                    })), _.fetchers.delete(ct)
                } else if (isRedirectResult(ht)) invariant(!1, "Unhandled fetcher revalidation redirect");
            else if (isDeferredResult(ht)) invariant(!1, "Unhandled fetcher deferred data");
            else {
                let mt = getDoneFetcher(ht.data);
                _.fetchers.set(ct, mt)
            }
        }
        return {
            loaderData: lt,
            errors: ut
        }
    }

    function mergeLoaderData(_, _e, et, tt) {
        let nt = _extends$4({}, _e);
        for (let ot of et) {
            let at = ot.route.id;
            if (_e.hasOwnProperty(at) ? _e[at] !== void 0 && (nt[at] = _e[at]) : _[at] !== void 0 && ot.route.loader && (nt[at] = _[at]), tt && tt.hasOwnProperty(at)) break
        }
        return nt
    }

    function findNearestBoundary(_, _e) {
        return (_e ? _.slice(0, _.findIndex(et => et.route.id === _e) + 1) : [..._]).reverse().find(et => et.route.hasErrorBoundary === !0) || _[0]
    }

    function getShortCircuitMatches(_) {
        let _e = _.find(et => et.index || !et.path || et.path === "/") || {
            id: "__shim-error-route__"
        };
        return {
            matches: [{
                params: {},
                pathname: "",
                pathnameBase: "",
                route: _e
            }],
            route: _e
        }
    }

    function getInternalRouterError(_, _e) {
        let {
            pathname: et,
            routeId: tt,
            method: nt,
            type: ot
        } = _e === void 0 ? {} : _e, at = "Unknown Server Error", st = "Unknown @remix-run/router error";
        return _ === 400 ? (at = "Bad Request", nt && et && tt ? st = "You made a " + nt + ' request to "' + et + '" but ' + ('did not provide a `loader` for route "' + tt + '", ') + "so there is no way to handle the request." : ot === "defer-action" ? st = "defer() is not supported in actions" : ot === "invalid-body" && (st = "Unable to encode submission body")) : _ === 403 ? (at = "Forbidden", st = 'Route "' + tt + '" does not match URL "' + et + '"') : _ === 404 ? (at = "Not Found", st = 'No route matches URL "' + et + '"') : _ === 405 && (at = "Method Not Allowed", nt && et && tt ? st = "You made a " + nt.toUpperCase() + ' request to "' + et + '" but ' + ('did not provide an `action` for route "' + tt + '", ') + "so there is no way to handle the request." : nt && (st = 'Invalid request method "' + nt.toUpperCase() + '"')), new ErrorResponse(_ || 500, at, new Error(st), !0)
    }

    function findRedirect(_) {
        for (let _e = _.length - 1; _e >= 0; _e--) {
            let et = _[_e];
            if (isRedirectResult(et)) return {
                result: et,
                idx: _e
            }
        }
    }

    function stripHashFromPath(_) {
        let _e = typeof _ == "string" ? parsePath(_) : _;
        return createPath(_extends$4({}, _e, {
            hash: ""
        }))
    }

    function isHashChangeOnly(_, _e) {
        return _.pathname !== _e.pathname || _.search !== _e.search ? !1 : _.hash === "" ? _e.hash !== "" : _.hash === _e.hash ? !0 : _e.hash !== ""
    }

    function isDeferredResult(_) {
        return _.type === ResultType.deferred
    }

    function isErrorResult(_) {
        return _.type === ResultType.error
    }

    function isRedirectResult(_) {
        return (_ && _.type) === ResultType.redirect
    }

    function isDeferredData(_) {
        let _e = _;
        return _e && typeof _e == "object" && typeof _e.data == "object" && typeof _e.subscribe == "function" && typeof _e.cancel == "function" && typeof _e.resolveData == "function"
    }

    function isResponse(_) {
        return _ != null && typeof _.status == "number" && typeof _.statusText == "string" && typeof _.headers == "object" && typeof _.body < "u"
    }

    function isValidMethod(_) {
        return validRequestMethods.has(_.toLowerCase())
    }

    function isMutationMethod(_) {
        return validMutationMethods.has(_.toLowerCase())
    }
    async function resolveDeferredResults(_, _e, et, tt, nt, ot) {
        for (let at = 0; at < et.length; at++) {
            let st = et[at],
                lt = _e[at];
            if (!lt) continue;
            let ut = _.find(ct => ct.route.id === lt.route.id),
                dt = ut != null && !isNewRouteInstance(ut, lt) && (ot && ot[lt.route.id]) !== void 0;
            if (isDeferredResult(st) && (nt || dt)) {
                let ct = tt[at];
                invariant(ct, "Expected an AbortSignal for revalidating fetcher deferred result"), await resolveDeferredData(st, ct, nt).then(pt => {
                    pt && (et[at] = pt || et[at])
                })
            }
        }
    }
    async function resolveDeferredData(_, _e, et) {
        if (et === void 0 && (et = !1), !await _.deferredData.resolveData(_e)) {
            if (et) try {
                return {
                    type: ResultType.data,
                    data: _.deferredData.unwrappedData
                }
            } catch (tt) {
                return {
                    type: ResultType.error,
                    error: tt
                }
            }
            return {
                type: ResultType.data,
                data: _.deferredData.data
            }
        }
    }

    function hasNakedIndexQuery(_) {
        return new URLSearchParams(_).getAll("index").some(_e => _e === "")
    }

    function createUseMatchesMatch(_, _e) {
        let {
            route: et,
            pathname: tt,
            params: nt
        } = _;
        return {
            id: et.id,
            pathname: tt,
            params: nt,
            data: _e[et.id],
            handle: et.handle
        }
    }

    function getTargetMatch(_, _e) {
        let et = typeof _e == "string" ? parsePath(_e).search : _e.search;
        if (_[_.length - 1].route.index && hasNakedIndexQuery(et || "")) return _[_.length - 1];
        let tt = getPathContributingMatches(_);
        return tt[tt.length - 1]
    }

    function getSubmissionFromNavigation(_) {
        let {
            formMethod: _e,
            formAction: et,
            formEncType: tt,
            text: nt,
            formData: ot,
            json: at
        } = _;
        if (!(!_e || !et || !tt)) {
            if (nt != null) return {
                formMethod: _e,
                formAction: et,
                formEncType: tt,
                formData: void 0,
                json: void 0,
                text: nt
            };
            if (ot != null) return {
                formMethod: _e,
                formAction: et,
                formEncType: tt,
                formData: ot,
                json: void 0,
                text: void 0
            };
            if (at !== void 0) return {
                formMethod: _e,
                formAction: et,
                formEncType: tt,
                formData: void 0,
                json: at,
                text: void 0
            }
        }
    }

    function getLoadingNavigation(_, _e) {
        return _e ? {
            state: "loading",
            location: _,
            formMethod: _e.formMethod,
            formAction: _e.formAction,
            formEncType: _e.formEncType,
            formData: _e.formData,
            json: _e.json,
            text: _e.text
        } : {
            state: "loading",
            location: _,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0
        }
    }

    function getSubmittingNavigation(_, _e) {
        return {
            state: "submitting",
            location: _,
            formMethod: _e.formMethod,
            formAction: _e.formAction,
            formEncType: _e.formEncType,
            formData: _e.formData,
            json: _e.json,
            text: _e.text
        }
    }

    function getLoadingFetcher(_, _e) {
        return _ ? {
            state: "loading",
            formMethod: _.formMethod,
            formAction: _.formAction,
            formEncType: _.formEncType,
            formData: _.formData,
            json: _.json,
            text: _.text,
            data: _e,
            " _hasFetcherDoneAnything ": !0
        } : {
            state: "loading",
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0,
            data: _e,
            " _hasFetcherDoneAnything ": !0
        }
    }

    function getSubmittingFetcher(_, _e) {
        return {
            state: "submitting",
            formMethod: _.formMethod,
            formAction: _.formAction,
            formEncType: _.formEncType,
            formData: _.formData,
            json: _.json,
            text: _.text,
            data: _e ? _e.data : void 0,
            " _hasFetcherDoneAnything ": !0
        }
    }

    function getDoneFetcher(_) {
        return {
            state: "idle",
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0,
            data: _,
            " _hasFetcherDoneAnything ": !0
        }
    }

    function _extends$3() {
        return _extends$3 = Object.assign ? Object.assign.bind() : function(_) {
            for (var _e = 1; _e < arguments.length; _e++) {
                var et = arguments[_e];
                for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (_[tt] = et[tt])
            }
            return _
        }, _extends$3.apply(this, arguments)
    }
    let DataRouterContext, DataRouterStateContext, AwaitContext, NavigationContext, RouteContext, RouteErrorContext;
    DataRouterContext = reactExports.createContext(null), DataRouterStateContext = reactExports.createContext(null), AwaitContext = reactExports.createContext(null), NavigationContext = reactExports.createContext(null), LocationContext = reactExports.createContext(null), RouteContext = reactExports.createContext({
        outlet: null,
        matches: [],
        isDataRoute: !1
    }), RouteErrorContext = reactExports.createContext(null);

    function useHref(_, _e) {
        let {
            relative: et
        } = _e === void 0 ? {} : _e;
        useInRouterContext() || invariant(!1);
        let {
            basename: tt,
            navigator: nt
        } = reactExports.useContext(NavigationContext), {
            hash: ot,
            pathname: at,
            search: st
        } = useResolvedPath(_, {
            relative: et
        }), lt = at;
        return tt !== "/" && (lt = at === "/" ? tt : joinPaths([tt, at])), nt.createHref({
            pathname: lt,
            search: st,
            hash: ot
        })
    }

    function useInRouterContext() {
        return reactExports.useContext(LocationContext) != null
    }
    useLocation$1 = function() {
        return useInRouterContext() || invariant(!1), reactExports.useContext(LocationContext).location
    };

    function useNavigationType() {
        return reactExports.useContext(LocationContext).navigationType
    }

    function useMatch(_) {
        useInRouterContext() || invariant(!1);
        let {
            pathname: _e
        } = useLocation$1();
        return reactExports.useMemo(() => matchPath(_, _e), [_e, _])
    }

    function useIsomorphicLayoutEffect$1(_) {
        reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(_)
    }

    function useNavigate$1() {
        let {
            isDataRoute: _
        } = reactExports.useContext(RouteContext);
        return _ ? useNavigateStable() : useNavigateUnstable()
    }

    function useNavigateUnstable() {
        useInRouterContext() || invariant(!1);
        let _ = reactExports.useContext(DataRouterContext),
            {
                basename: _e,
                navigator: et
            } = reactExports.useContext(NavigationContext),
            {
                matches: tt
            } = reactExports.useContext(RouteContext),
            {
                pathname: nt
            } = useLocation$1(),
            ot = JSON.stringify(getPathContributingMatches(tt).map(st => st.pathnameBase)),
            at = reactExports.useRef(!1);
        return useIsomorphicLayoutEffect$1(() => {
            at.current = !0
        }), reactExports.useCallback(function(st, lt) {
            if (lt === void 0 && (lt = {}), !at.current) return;
            if (typeof st == "number") {
                et.go(st);
                return
            }
            let ut = resolveTo(st, JSON.parse(ot), nt, lt.relative === "path");
            _ == null && _e !== "/" && (ut.pathname = ut.pathname === "/" ? _e : joinPaths([_e, ut.pathname])), (lt.replace ? et.replace : et.push)(ut, lt.state, lt)
        }, [_e, et, ot, nt, _])
    }
    const OutletContext = reactExports.createContext(null);

    function useOutletContext() {
        return reactExports.useContext(OutletContext)
    }

    function useOutlet(_) {
        let _e = reactExports.useContext(RouteContext).outlet;
        return _e && reactExports.createElement(OutletContext.Provider, {
            value: _
        }, _e)
    }
    useParams = function() {
        let {
            matches: _
        } = reactExports.useContext(RouteContext), _e = _[_.length - 1];
        return _e ? _e.params : {}
    };

    function useResolvedPath(_, _e) {
        let {
            relative: et
        } = _e === void 0 ? {} : _e, {
            matches: tt
        } = reactExports.useContext(RouteContext), {
            pathname: nt
        } = useLocation$1(), ot = JSON.stringify(getPathContributingMatches(tt).map(at => at.pathnameBase));
        return reactExports.useMemo(() => resolveTo(_, JSON.parse(ot), nt, et === "path"), [_, ot, nt, et])
    }

    function useRoutes(_, _e) {
        return useRoutesImpl(_, _e)
    }

    function useRoutesImpl(_, _e, et) {
        useInRouterContext() || invariant(!1);
        let {
            navigator: tt
        } = reactExports.useContext(NavigationContext), {
            matches: nt
        } = reactExports.useContext(RouteContext), ot = nt[nt.length - 1], at = ot ? ot.params : {};
        ot && ot.pathname;
        let st = ot ? ot.pathnameBase : "/";
        ot && ot.route;
        let lt = useLocation$1(),
            ut;
        if (_e) {
            var dt;
            let mt = typeof _e == "string" ? parsePath(_e) : _e;
            st === "/" || (dt = mt.pathname) != null && dt.startsWith(st) || invariant(!1), ut = mt
        } else ut = lt;
        let ct = ut.pathname || "/",
            pt = st === "/" ? ct : ct.slice(st.length) || "/",
            ft = matchRoutes(_, {
                pathname: pt
            }),
            ht = _renderMatches(ft && ft.map(mt => Object.assign({}, mt, {
                params: Object.assign({}, at, mt.params),
                pathname: joinPaths([st, tt.encodeLocation ? tt.encodeLocation(mt.pathname).pathname : mt.pathname]),
                pathnameBase: mt.pathnameBase === "/" ? st : joinPaths([st, tt.encodeLocation ? tt.encodeLocation(mt.pathnameBase).pathname : mt.pathnameBase])
            })), nt, et);
        return _e && ht ? reactExports.createElement(LocationContext.Provider, {
            value: {
                location: _extends$3({
                    pathname: "/",
                    search: "",
                    hash: "",
                    state: null,
                    key: "default"
                }, ut),
                navigationType: Action.Pop
            }
        }, ht) : ht
    }

    function DefaultErrorComponent() {
        let _ = useRouteError(),
            _e = isRouteErrorResponse(_) ? _.status + " " + _.statusText : _ instanceof Error ? _.message : JSON.stringify(_),
            et = _ instanceof Error ? _.stack : null,
            tt = {
                padding: "0.5rem",
                backgroundColor: "rgba(200,200,200, 0.5)"
            },
            nt = null;
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
            style: {
                fontStyle: "italic"
            }
        }, _e), et ? reactExports.createElement("pre", {
            style: tt
        }, et) : null, nt)
    }
    const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
        constructor(_e) {
            super(_e), this.state = {
                location: _e.location,
                revalidation: _e.revalidation,
                error: _e.error
            }
        }
        static getDerivedStateFromError(_e) {
            return {
                error: _e
            }
        }
        static getDerivedStateFromProps(_e, et) {
            return et.location !== _e.location || et.revalidation !== "idle" && _e.revalidation === "idle" ? {
                error: _e.error,
                location: _e.location,
                revalidation: _e.revalidation
            } : {
                error: _e.error || et.error,
                location: et.location,
                revalidation: _e.revalidation || et.revalidation
            }
        }
        componentDidCatch(_e, et) {
            console.error("React Router caught the following error during render", _e, et)
        }
        render() {
            return this.state.error ? reactExports.createElement(RouteContext.Provider, {
                value: this.props.routeContext
            }, reactExports.createElement(RouteErrorContext.Provider, {
                value: this.state.error,
                children: this.props.component
            })) : this.props.children
        }
    }

    function RenderedRoute(_) {
        let {
            routeContext: _e,
            match: et,
            children: tt
        } = _, nt = reactExports.useContext(DataRouterContext);
        return nt && nt.static && nt.staticContext && (et.route.errorElement || et.route.ErrorBoundary) && (nt.staticContext._deepestRenderedBoundaryId = et.route.id), reactExports.createElement(RouteContext.Provider, {
            value: _e
        }, tt)
    }

    function _renderMatches(_, _e, et) {
        var tt;
        if (_e === void 0 && (_e = []), et === void 0 && (et = null), _ == null) {
            var nt;
            if ((nt = et) != null && nt.errors) _ = et.matches;
            else return null
        }
        let ot = _,
            at = (tt = et) == null ? void 0 : tt.errors;
        if (at != null) {
            let st = ot.findIndex(lt => lt.route.id && (at == null ? void 0 : at[lt.route.id]));
            st >= 0 || invariant(!1), ot = ot.slice(0, Math.min(ot.length, st + 1))
        }
        return ot.reduceRight((st, lt, ut) => {
            let dt = lt.route.id ? at == null ? void 0 : at[lt.route.id] : null,
                ct = null;
            et && (ct = lt.route.errorElement || defaultErrorElement);
            let pt = _e.concat(ot.slice(0, ut + 1)),
                ft = () => {
                    let ht;
                    return dt ? ht = ct : lt.route.Component ? ht = reactExports.createElement(lt.route.Component, null) : lt.route.element ? ht = lt.route.element : ht = st, reactExports.createElement(RenderedRoute, {
                        match: lt,
                        routeContext: {
                            outlet: st,
                            matches: pt,
                            isDataRoute: et != null
                        },
                        children: ht
                    })
                };
            return et && (lt.route.ErrorBoundary || lt.route.errorElement || ut === 0) ? reactExports.createElement(RenderErrorBoundary, {
                location: et.location,
                revalidation: et.revalidation,
                component: ct,
                error: dt,
                children: ft(),
                routeContext: {
                    outlet: null,
                    matches: pt,
                    isDataRoute: !0
                }
            }) : ft()
        }, null)
    }
    var DataRouterHook$1 = function(_) {
            return _.UseBlocker = "useBlocker", _.UseRevalidator = "useRevalidator", _.UseNavigateStable = "useNavigate", _
        }(DataRouterHook$1 || {}),
        DataRouterStateHook$1 = function(_) {
            return _.UseBlocker = "useBlocker", _.UseLoaderData = "useLoaderData", _.UseActionData = "useActionData", _.UseRouteError = "useRouteError", _.UseNavigation = "useNavigation", _.UseRouteLoaderData = "useRouteLoaderData", _.UseMatches = "useMatches", _.UseRevalidator = "useRevalidator", _.UseNavigateStable = "useNavigate", _.UseRouteId = "useRouteId", _
        }(DataRouterStateHook$1 || {});

    function useDataRouterContext$1(_) {
        let _e = reactExports.useContext(DataRouterContext);
        return _e || invariant(!1), _e
    }

    function useDataRouterState$1(_) {
        let _e = reactExports.useContext(DataRouterStateContext);
        return _e || invariant(!1), _e
    }

    function useRouteContext(_) {
        let _e = reactExports.useContext(RouteContext);
        return _e || invariant(!1), _e
    }

    function useCurrentRouteId(_) {
        let _e = useRouteContext(),
            et = _e.matches[_e.matches.length - 1];
        return et.route.id || invariant(!1), et.route.id
    }

    function useRouteId() {
        return useCurrentRouteId(DataRouterStateHook$1.UseRouteId)
    }

    function useNavigation() {
        return useDataRouterState$1(DataRouterStateHook$1.UseNavigation).navigation
    }

    function useRevalidator() {
        let _ = useDataRouterContext$1(DataRouterHook$1.UseRevalidator),
            _e = useDataRouterState$1(DataRouterStateHook$1.UseRevalidator);
        return reactExports.useMemo(() => ({
            revalidate: _.router.revalidate,
            state: _e.revalidation
        }), [_.router.revalidate, _e.revalidation])
    }

    function useMatches() {
        let {
            matches: _,
            loaderData: _e
        } = useDataRouterState$1(DataRouterStateHook$1.UseMatches);
        return reactExports.useMemo(() => _.map(et => {
            let {
                pathname: tt,
                params: nt
            } = et;
            return {
                id: et.route.id,
                pathname: tt,
                params: nt,
                data: _e[et.route.id],
                handle: et.route.handle
            }
        }), [_, _e])
    }

    function useLoaderData() {
        let _ = useDataRouterState$1(DataRouterStateHook$1.UseLoaderData),
            _e = useCurrentRouteId(DataRouterStateHook$1.UseLoaderData);
        if (_.errors && _.errors[_e] != null) {
            console.error("You cannot `useLoaderData` in an errorElement (routeId: " + _e + ")");
            return
        }
        return _.loaderData[_e]
    }

    function useRouteLoaderData(_) {
        return useDataRouterState$1(DataRouterStateHook$1.UseRouteLoaderData).loaderData[_]
    }

    function useActionData() {
        let _ = useDataRouterState$1(DataRouterStateHook$1.UseActionData);
        return reactExports.useContext(RouteContext) || invariant(!1), Object.values((_ == null ? void 0 : _.actionData) || {})[0]
    }

    function useRouteError() {
        var _;
        let _e = reactExports.useContext(RouteErrorContext),
            et = useDataRouterState$1(DataRouterStateHook$1.UseRouteError),
            tt = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
        return _e || ((_ = et.errors) == null ? void 0 : _[tt])
    }

    function useAsyncValue() {
        let _ = reactExports.useContext(AwaitContext);
        return _ == null ? void 0 : _._data
    }

    function useAsyncError() {
        let _ = reactExports.useContext(AwaitContext);
        return _ == null ? void 0 : _._error
    }
    let blockerId = 0;

    function useBlocker(_) {
        let {
            router: _e,
            basename: et
        } = useDataRouterContext$1(DataRouterHook$1.UseBlocker), tt = useDataRouterState$1(DataRouterStateHook$1.UseBlocker), [nt, ot] = reactExports.useState(""), at = reactExports.useCallback(st => {
            if (typeof _ != "function") return !!_;
            if (et === "/") return _(st);
            let {
                currentLocation: lt,
                nextLocation: ut,
                historyAction: dt
            } = st;
            return _({
                currentLocation: _extends$3({}, lt, {
                    pathname: stripBasename(lt.pathname, et) || lt.pathname
                }),
                nextLocation: _extends$3({}, ut, {
                    pathname: stripBasename(ut.pathname, et) || ut.pathname
                }),
                historyAction: dt
            })
        }, [et, _]);
        return reactExports.useEffect(() => {
            let st = String(++blockerId);
            return ot(st), () => _e.deleteBlocker(st)
        }, [_e]), reactExports.useEffect(() => {
            nt !== "" && _e.getBlocker(nt, at)
        }, [_e, nt, at]), nt && tt.blockers.has(nt) ? tt.blockers.get(nt) : IDLE_BLOCKER
    }

    function useNavigateStable() {
        let {
            router: _
        } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable), _e = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable), et = reactExports.useRef(!1);
        return useIsomorphicLayoutEffect$1(() => {
            et.current = !0
        }), reactExports.useCallback(function(tt, nt) {
            nt === void 0 && (nt = {}), et.current && (typeof tt == "number" ? _.navigate(tt) : _.navigate(tt, _extends$3({
                fromRouteId: _e
            }, nt)))
        }, [_, _e])
    }
    const START_TRANSITION$1 = "startTransition",
        startTransitionImpl$1 = react[START_TRANSITION$1];

    function RouterProvider(_) {
        let {
            fallbackElement: _e,
            router: et,
            future: tt
        } = _, [nt, ot] = reactExports.useState(et.state), {
            v7_startTransition: at
        } = tt || {}, st = reactExports.useCallback(ct => {
            at && startTransitionImpl$1 ? startTransitionImpl$1(() => ot(ct)) : ot(ct)
        }, [ot, at]);
        reactExports.useLayoutEffect(() => et.subscribe(st), [et, st]);
        let lt = reactExports.useMemo(() => ({
                createHref: et.createHref,
                encodeLocation: et.encodeLocation,
                go: ct => et.navigate(ct),
                push: (ct, pt, ft) => et.navigate(ct, {
                    state: pt,
                    preventScrollReset: ft == null ? void 0 : ft.preventScrollReset
                }),
                replace: (ct, pt, ft) => et.navigate(ct, {
                    replace: !0,
                    state: pt,
                    preventScrollReset: ft == null ? void 0 : ft.preventScrollReset
                })
            }), [et]),
            ut = et.basename || "/",
            dt = reactExports.useMemo(() => ({
                router: et,
                navigator: lt,
                static: !1,
                basename: ut
            }), [et, lt, ut]);
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(DataRouterContext.Provider, {
            value: dt
        }, reactExports.createElement(DataRouterStateContext.Provider, {
            value: nt
        }, reactExports.createElement(Router, {
            basename: ut,
            location: nt.location,
            navigationType: nt.historyAction,
            navigator: lt
        }, nt.initialized ? reactExports.createElement(DataRoutes, {
            routes: et.routes,
            state: nt
        }) : _e))), null)
    }

    function DataRoutes(_) {
        let {
            routes: _e,
            state: et
        } = _;
        return useRoutesImpl(_e, void 0, et)
    }

    function MemoryRouter(_) {
        let {
            basename: _e,
            children: et,
            initialEntries: tt,
            initialIndex: nt,
            future: ot
        } = _, at = reactExports.useRef();
        at.current == null && (at.current = createMemoryHistory({
            initialEntries: tt,
            initialIndex: nt,
            v5Compat: !0
        }));
        let st = at.current,
            [lt, ut] = reactExports.useState({
                action: st.action,
                location: st.location
            }),
            {
                v7_startTransition: dt
            } = ot || {},
            ct = reactExports.useCallback(pt => {
                dt && startTransitionImpl$1 ? startTransitionImpl$1(() => ut(pt)) : ut(pt)
            }, [ut, dt]);
        return reactExports.useLayoutEffect(() => st.listen(ct), [st, ct]), reactExports.createElement(Router, {
            basename: _e,
            children: et,
            location: lt.location,
            navigationType: lt.action,
            navigator: st
        })
    }

    function Navigate(_) {
        let {
            to: _e,
            replace: et,
            state: tt,
            relative: nt
        } = _;
        useInRouterContext() || invariant(!1);
        let {
            matches: ot
        } = reactExports.useContext(RouteContext), {
            pathname: at
        } = useLocation$1(), st = useNavigate$1(), lt = resolveTo(_e, getPathContributingMatches(ot).map(dt => dt.pathnameBase), at, nt === "path"), ut = JSON.stringify(lt);
        return reactExports.useEffect(() => st(JSON.parse(ut), {
            replace: et,
            state: tt,
            relative: nt
        }), [st, ut, nt, et, tt]), null
    }

    function Outlet(_) {
        return useOutlet(_.context)
    }
    Route = function(_) {
        invariant(!1)
    }, Router = function(_) {
        let {
            basename: _e = "/",
            children: et = null,
            location: tt,
            navigationType: nt = Action.Pop,
            navigator: ot,
            static: at = !1
        } = _;
        useInRouterContext() && invariant(!1);
        let st = _e.replace(/^\/*/, "/"),
            lt = reactExports.useMemo(() => ({
                basename: st,
                navigator: ot,
                static: at
            }), [st, ot, at]);
        typeof tt == "string" && (tt = parsePath(tt));
        let {
            pathname: ut = "/",
            search: dt = "",
            hash: ct = "",
            state: pt = null,
            key: ft = "default"
        } = tt, ht = reactExports.useMemo(() => {
            let mt = stripBasename(ut, st);
            return mt == null ? null : {
                location: {
                    pathname: mt,
                    search: dt,
                    hash: ct,
                    state: pt,
                    key: ft
                },
                navigationType: nt
            }
        }, [st, ut, dt, ct, pt, ft, nt]);
        return ht == null ? null : reactExports.createElement(NavigationContext.Provider, {
            value: lt
        }, reactExports.createElement(LocationContext.Provider, {
            children: et,
            value: ht
        }))
    }, Routes = function(_) {
        let {
            children: _e,
            location: et
        } = _;
        return useRoutes(createRoutesFromChildren(_e), et)
    };

    function Await(_) {
        let {
            children: _e,
            errorElement: et,
            resolve: tt
        } = _;
        return reactExports.createElement(AwaitErrorBoundary, {
            resolve: tt,
            errorElement: et
        }, reactExports.createElement(ResolveAwait, null, _e))
    }
    var AwaitRenderStatus = function(_) {
        return _[_.pending = 0] = "pending", _[_.success = 1] = "success", _[_.error = 2] = "error", _
    }(AwaitRenderStatus || {});
    const neverSettledPromise = new Promise(() => {});
    class AwaitErrorBoundary extends reactExports.Component {
        constructor(_e) {
            super(_e), this.state = {
                error: null
            }
        }
        static getDerivedStateFromError(_e) {
            return {
                error: _e
            }
        }
        componentDidCatch(_e, et) {
            console.error("<Await> caught the following error during render", _e, et)
        }
        render() {
            let {
                children: _e,
                errorElement: et,
                resolve: tt
            } = this.props, nt = null, ot = AwaitRenderStatus.pending;
            if (!(tt instanceof Promise)) ot = AwaitRenderStatus.success, nt = Promise.resolve(), Object.defineProperty(nt, "_tracked", {
                get: () => !0
            }), Object.defineProperty(nt, "_data", {
                get: () => tt
            });
            else if (this.state.error) {
                ot = AwaitRenderStatus.error;
                let at = this.state.error;
                nt = Promise.reject().catch(() => {}), Object.defineProperty(nt, "_tracked", {
                    get: () => !0
                }), Object.defineProperty(nt, "_error", {
                    get: () => at
                })
            } else tt._tracked ? (nt = tt, ot = nt._error !== void 0 ? AwaitRenderStatus.error : nt._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (ot = AwaitRenderStatus.pending, Object.defineProperty(tt, "_tracked", {
                get: () => !0
            }), nt = tt.then(at => Object.defineProperty(tt, "_data", {
                get: () => at
            }), at => Object.defineProperty(tt, "_error", {
                get: () => at
            })));
            if (ot === AwaitRenderStatus.error && nt._error instanceof AbortedDeferredError) throw neverSettledPromise;
            if (ot === AwaitRenderStatus.error && !et) throw nt._error;
            if (ot === AwaitRenderStatus.error) return reactExports.createElement(AwaitContext.Provider, {
                value: nt,
                children: et
            });
            if (ot === AwaitRenderStatus.success) return reactExports.createElement(AwaitContext.Provider, {
                value: nt,
                children: _e
            });
            throw nt
        }
    }

    function ResolveAwait(_) {
        let {
            children: _e
        } = _, et = useAsyncValue(), tt = typeof _e == "function" ? _e(et) : _e;
        return reactExports.createElement(reactExports.Fragment, null, tt)
    }

    function createRoutesFromChildren(_, _e) {
        _e === void 0 && (_e = []);
        let et = [];
        return reactExports.Children.forEach(_, (tt, nt) => {
            if (!reactExports.isValidElement(tt)) return;
            let ot = [..._e, nt];
            if (tt.type === reactExports.Fragment) {
                et.push.apply(et, createRoutesFromChildren(tt.props.children, ot));
                return
            }
            tt.type !== Route && invariant(!1), !tt.props.index || !tt.props.children || invariant(!1);
            let at = {
                id: tt.props.id || ot.join("-"),
                caseSensitive: tt.props.caseSensitive,
                element: tt.props.element,
                Component: tt.props.Component,
                index: tt.props.index,
                path: tt.props.path,
                loader: tt.props.loader,
                action: tt.props.action,
                errorElement: tt.props.errorElement,
                ErrorBoundary: tt.props.ErrorBoundary,
                hasErrorBoundary: tt.props.ErrorBoundary != null || tt.props.errorElement != null,
                shouldRevalidate: tt.props.shouldRevalidate,
                handle: tt.props.handle,
                lazy: tt.props.lazy
            };
            tt.props.children && (at.children = createRoutesFromChildren(tt.props.children, ot)), et.push(at)
        }), et
    }

    function renderMatches(_) {
        return _renderMatches(_)
    }

    function mapRouteProperties(_) {
        let _e = {
            hasErrorBoundary: _.ErrorBoundary != null || _.errorElement != null
        };
        return _.Component && Object.assign(_e, {
            element: reactExports.createElement(_.Component),
            Component: void 0
        }), _.ErrorBoundary && Object.assign(_e, {
            errorElement: reactExports.createElement(_.ErrorBoundary),
            ErrorBoundary: void 0
        }), _e
    }

    function createMemoryRouter(_, _e) {
        return createRouter({
            basename: _e == null ? void 0 : _e.basename,
            future: _extends$3({}, _e == null ? void 0 : _e.future, {
                v7_prependBasename: !0
            }),
            history: createMemoryHistory({
                initialEntries: _e == null ? void 0 : _e.initialEntries,
                initialIndex: _e == null ? void 0 : _e.initialIndex
            }),
            hydrationData: _e == null ? void 0 : _e.hydrationData,
            routes: _,
            mapRouteProperties
        }).initialize()
    }

    function _extends$2() {
        return _extends$2 = Object.assign ? Object.assign.bind() : function(_) {
            for (var _e = 1; _e < arguments.length; _e++) {
                var et = arguments[_e];
                for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (_[tt] = et[tt])
            }
            return _
        }, _extends$2.apply(this, arguments)
    }

    function _objectWithoutPropertiesLoose$1(_, _e) {
        if (_ == null) return {};
        var et = {},
            tt = Object.keys(_),
            nt, ot;
        for (ot = 0; ot < tt.length; ot++) nt = tt[ot], !(_e.indexOf(nt) >= 0) && (et[nt] = _[nt]);
        return et
    }
    const defaultMethod = "get",
        defaultEncType = "application/x-www-form-urlencoded";

    function isHtmlElement(_) {
        return _ != null && typeof _.tagName == "string"
    }

    function isButtonElement(_) {
        return isHtmlElement(_) && _.tagName.toLowerCase() === "button"
    }

    function isFormElement(_) {
        return isHtmlElement(_) && _.tagName.toLowerCase() === "form"
    }

    function isInputElement(_) {
        return isHtmlElement(_) && _.tagName.toLowerCase() === "input"
    }

    function isModifiedEvent(_) {
        return !!(_.metaKey || _.altKey || _.ctrlKey || _.shiftKey)
    }

    function shouldProcessLinkClick(_, _e) {
        return _.button === 0 && (!_e || _e === "_self") && !isModifiedEvent(_)
    }

    function createSearchParams(_) {
        return _ === void 0 && (_ = ""), new URLSearchParams(typeof _ == "string" || Array.isArray(_) || _ instanceof URLSearchParams ? _ : Object.keys(_).reduce((_e, et) => {
            let tt = _[et];
            return _e.concat(Array.isArray(tt) ? tt.map(nt => [et, nt]) : [
                [et, tt]
            ])
        }, []))
    }

    function getSearchParamsForLocation(_, _e) {
        let et = createSearchParams(_);
        return _e && _e.forEach((tt, nt) => {
            et.has(nt) || _e.getAll(nt).forEach(ot => {
                et.append(nt, ot)
            })
        }), et
    }
    let _formDataSupportsSubmitter = null;

    function isFormDataSubmitterSupported() {
        if (_formDataSupportsSubmitter === null) try {
            new FormData(document.createElement("form"), 0), _formDataSupportsSubmitter = !1
        } catch (_) {
            _formDataSupportsSubmitter = !0
        }
        return _formDataSupportsSubmitter
    }
    const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);

    function getFormEncType(_) {
        return _ != null && !supportedFormEncTypes.has(_) ? null : _
    }

    function getFormSubmissionInfo(_, _e) {
        let et, tt, nt, ot, at;
        if (isFormElement(_)) {
            let st = _.getAttribute("action");
            tt = st ? stripBasename(st, _e) : null, et = _.getAttribute("method") || defaultMethod, nt = getFormEncType(_.getAttribute("enctype")) || defaultEncType, ot = new FormData(_)
        } else if (isButtonElement(_) || isInputElement(_) && (_.type === "submit" || _.type === "image")) {
            let st = _.form;
            if (st == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
            let lt = _.getAttribute("formaction") || st.getAttribute("action");
            if (tt = lt ? stripBasename(lt, _e) : null, et = _.getAttribute("formmethod") || st.getAttribute("method") || defaultMethod, nt = getFormEncType(_.getAttribute("formenctype")) || getFormEncType(st.getAttribute("enctype")) || defaultEncType, ot = new FormData(st, _), !isFormDataSubmitterSupported()) {
                let {
                    name: ut,
                    type: dt,
                    value: ct
                } = _;
                if (dt === "image") {
                    let pt = ut ? ut + "." : "";
                    ot.append(pt + "x", "0"), ot.append(pt + "y", "0")
                } else ut && ot.append(ut, ct)
            }
        } else {
            if (isHtmlElement(_)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
            et = defaultMethod, tt = null, nt = defaultEncType, at = _
        }
        return ot && nt === "text/plain" && (at = ot, ot = void 0), {
            action: tt,
            method: et.toLowerCase(),
            encType: nt,
            formData: ot,
            body: at
        }
    }
    const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
        _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"],
        _excluded3 = ["reloadDocument", "replace", "state", "method", "action", "onSubmit", "submit", "relative", "preventScrollReset"];

    function createBrowserRouter(_, _e) {
        return createRouter({
            basename: _e == null ? void 0 : _e.basename,
            future: _extends$2({}, _e == null ? void 0 : _e.future, {
                v7_prependBasename: !0
            }),
            history: createBrowserHistory({
                window: _e == null ? void 0 : _e.window
            }),
            hydrationData: (_e == null ? void 0 : _e.hydrationData) || parseHydrationData(),
            routes: _,
            mapRouteProperties
        }).initialize()
    }

    function createHashRouter(_, _e) {
        return createRouter({
            basename: _e == null ? void 0 : _e.basename,
            future: _extends$2({}, _e == null ? void 0 : _e.future, {
                v7_prependBasename: !0
            }),
            history: createHashHistory({
                window: _e == null ? void 0 : _e.window
            }),
            hydrationData: (_e == null ? void 0 : _e.hydrationData) || parseHydrationData(),
            routes: _,
            mapRouteProperties
        }).initialize()
    }

    function parseHydrationData() {
        var _;
        let _e = (_ = window) == null ? void 0 : _.__staticRouterHydrationData;
        return _e && _e.errors && (_e = _extends$2({}, _e, {
            errors: deserializeErrors(_e.errors)
        })), _e
    }

    function deserializeErrors(_) {
        if (!_) return null;
        let _e = Object.entries(_),
            et = {};
        for (let [tt, nt] of _e)
            if (nt && nt.__type === "RouteErrorResponse") et[tt] = new ErrorResponse(nt.status, nt.statusText, nt.data, nt.internal === !0);
            else if (nt && nt.__type === "Error") {
            if (nt.__subType) {
                let ot = window[nt.__subType];
                if (typeof ot == "function") try {
                    let at = new ot(nt.message);
                    at.stack = "", et[tt] = at
                } catch (at) {}
            }
            if (et[tt] == null) {
                let ot = new Error(nt.message);
                ot.stack = "", et[tt] = ot
            }
        } else et[tt] = nt;
        return et
    }
    const START_TRANSITION = "startTransition",
        startTransitionImpl = react[START_TRANSITION];

    function BrowserRouter(_) {
        let {
            basename: _e,
            children: et,
            future: tt,
            window: nt
        } = _, ot = reactExports.useRef();
        ot.current == null && (ot.current = createBrowserHistory({
            window: nt,
            v5Compat: !0
        }));
        let at = ot.current,
            [st, lt] = reactExports.useState({
                action: at.action,
                location: at.location
            }),
            {
                v7_startTransition: ut
            } = tt || {},
            dt = reactExports.useCallback(ct => {
                ut && startTransitionImpl ? startTransitionImpl(() => lt(ct)) : lt(ct)
            }, [lt, ut]);
        return reactExports.useLayoutEffect(() => at.listen(dt), [at, dt]), reactExports.createElement(Router, {
            basename: _e,
            children: et,
            location: st.location,
            navigationType: st.action,
            navigator: at
        })
    }

    function HashRouter(_) {
        let {
            basename: _e,
            children: et,
            future: tt,
            window: nt
        } = _, ot = reactExports.useRef();
        ot.current == null && (ot.current = createHashHistory({
            window: nt,
            v5Compat: !0
        }));
        let at = ot.current,
            [st, lt] = reactExports.useState({
                action: at.action,
                location: at.location
            }),
            {
                v7_startTransition: ut
            } = tt || {},
            dt = reactExports.useCallback(ct => {
                ut && startTransitionImpl ? startTransitionImpl(() => lt(ct)) : lt(ct)
            }, [lt, ut]);
        return reactExports.useLayoutEffect(() => at.listen(dt), [at, dt]), reactExports.createElement(Router, {
            basename: _e,
            children: et,
            location: st.location,
            navigationType: st.action,
            navigator: at
        })
    }

    function HistoryRouter(_) {
        let {
            basename: _e,
            children: et,
            future: tt,
            history: nt
        } = _, [ot, at] = reactExports.useState({
            action: nt.action,
            location: nt.location
        }), {
            v7_startTransition: st
        } = tt || {}, lt = reactExports.useCallback(ut => {
            st && startTransitionImpl ? startTransitionImpl(() => at(ut)) : at(ut)
        }, [at, st]);
        return reactExports.useLayoutEffect(() => nt.listen(lt), [nt, lt]), reactExports.createElement(Router, {
            basename: _e,
            children: et,
            location: ot.location,
            navigationType: ot.action,
            navigator: nt
        })
    }
    const isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
        ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
        Link$1 = reactExports.forwardRef(function(_, _e) {
            let {
                onClick: et,
                relative: tt,
                reloadDocument: nt,
                replace: ot,
                state: at,
                target: st,
                to: lt,
                preventScrollReset: ut
            } = _, dt = _objectWithoutPropertiesLoose$1(_, _excluded), {
                basename: ct
            } = reactExports.useContext(NavigationContext), pt, ft = !1;
            if (typeof lt == "string" && ABSOLUTE_URL_REGEX.test(lt) && (pt = lt, isBrowser)) try {
                let gt = new URL(window.location.href),
                    vt = lt.startsWith("//") ? new URL(gt.protocol + lt) : new URL(lt),
                    xt = stripBasename(vt.pathname, ct);
                vt.origin === gt.origin && xt != null ? lt = xt + vt.search + vt.hash : ft = !0
            } catch (gt) {}
            let ht = useHref(lt, {
                    relative: tt
                }),
                mt = useLinkClickHandler(lt, {
                    replace: ot,
                    state: at,
                    target: st,
                    preventScrollReset: ut,
                    relative: tt
                });

            function bt(gt) {
                et && et(gt), gt.defaultPrevented || mt(gt)
            }
            return reactExports.createElement("a", _extends$2({}, dt, {
                href: pt || ht,
                onClick: ft || nt ? et : bt,
                ref: _e,
                target: st
            }))
        }),
        NavLink = reactExports.forwardRef(function(_, _e) {
            let {
                "aria-current": et = "page",
                caseSensitive: tt = !1,
                className: nt = "",
                end: ot = !1,
                style: at,
                to: st,
                children: lt
            } = _, ut = _objectWithoutPropertiesLoose$1(_, _excluded2), dt = useResolvedPath(st, {
                relative: ut.relative
            }), ct = useLocation$1(), pt = reactExports.useContext(DataRouterStateContext), {
                navigator: ft
            } = reactExports.useContext(NavigationContext), ht = ft.encodeLocation ? ft.encodeLocation(dt).pathname : dt.pathname, mt = ct.pathname, bt = pt && pt.navigation && pt.navigation.location ? pt.navigation.location.pathname : null;
            tt || (mt = mt.toLowerCase(), bt = bt ? bt.toLowerCase() : null, ht = ht.toLowerCase());
            let gt = mt === ht || !ot && mt.startsWith(ht) && mt.charAt(ht.length) === "/",
                vt = bt != null && (bt === ht || !ot && bt.startsWith(ht) && bt.charAt(ht.length) === "/"),
                xt = gt ? et : void 0,
                yt;
            typeof nt == "function" ? yt = nt({
                isActive: gt,
                isPending: vt
            }) : yt = [nt, gt ? "active" : null, vt ? "pending" : null].filter(Boolean).join(" ");
            let Et = typeof at == "function" ? at({
                isActive: gt,
                isPending: vt
            }) : at;
            return reactExports.createElement(Link$1, _extends$2({}, ut, {
                "aria-current": xt,
                className: yt,
                ref: _e,
                style: Et,
                to: st
            }), typeof lt == "function" ? lt({
                isActive: gt,
                isPending: vt
            }) : lt)
        }),
        Form = reactExports.forwardRef((_, _e) => {
            let et = useSubmit();
            return reactExports.createElement(FormImpl, _extends$2({}, _, {
                submit: et,
                ref: _e
            }))
        }),
        FormImpl = reactExports.forwardRef((_, _e) => {
            let {
                reloadDocument: et,
                replace: tt,
                state: nt,
                method: ot = defaultMethod,
                action: at,
                onSubmit: st,
                submit: lt,
                relative: ut,
                preventScrollReset: dt
            } = _, ct = _objectWithoutPropertiesLoose$1(_, _excluded3), pt = ot.toLowerCase() === "get" ? "get" : "post", ft = useFormAction(at, {
                relative: ut
            }), ht = mt => {
                if (st && st(mt), mt.defaultPrevented) return;
                mt.preventDefault();
                let bt = mt.nativeEvent.submitter,
                    gt = (bt == null ? void 0 : bt.getAttribute("formmethod")) || ot;
                lt(bt || mt.currentTarget, {
                    method: gt,
                    replace: tt,
                    state: nt,
                    relative: ut,
                    preventScrollReset: dt
                })
            };
            return reactExports.createElement("form", _extends$2({
                ref: _e,
                method: pt,
                action: ft,
                onSubmit: et ? st : ht
            }, ct))
        });

    function ScrollRestoration(_) {
        let {
            getKey: _e,
            storageKey: et
        } = _;
        return useScrollRestoration({
            getKey: _e,
            storageKey: et
        }), null
    }
    var DataRouterHook;
    (function(_) {
        _.UseScrollRestoration = "useScrollRestoration", _.UseSubmit = "useSubmit", _.UseSubmitFetcher = "useSubmitFetcher", _.UseFetcher = "useFetcher"
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(_) {
        _.UseFetchers = "useFetchers", _.UseScrollRestoration = "useScrollRestoration"
    })(DataRouterStateHook || (DataRouterStateHook = {}));

    function useDataRouterContext(_) {
        let _e = reactExports.useContext(DataRouterContext);
        return _e || invariant(!1), _e
    }

    function useDataRouterState(_) {
        let _e = reactExports.useContext(DataRouterStateContext);
        return _e || invariant(!1), _e
    }

    function useLinkClickHandler(_, _e) {
        let {
            target: et,
            replace: tt,
            state: nt,
            preventScrollReset: ot,
            relative: at
        } = _e === void 0 ? {} : _e, st = useNavigate$1(), lt = useLocation$1(), ut = useResolvedPath(_, {
            relative: at
        });
        return reactExports.useCallback(dt => {
            if (shouldProcessLinkClick(dt, et)) {
                dt.preventDefault();
                let ct = tt !== void 0 ? tt : createPath(lt) === createPath(ut);
                st(_, {
                    replace: ct,
                    state: nt,
                    preventScrollReset: ot,
                    relative: at
                })
            }
        }, [lt, st, ut, tt, nt, et, _, ot, at])
    }

    function useSearchParams(_) {
        let _e = reactExports.useRef(createSearchParams(_)),
            et = reactExports.useRef(!1),
            tt = useLocation$1(),
            nt = reactExports.useMemo(() => getSearchParamsForLocation(tt.search, et.current ? null : _e.current), [tt.search]),
            ot = useNavigate$1(),
            at = reactExports.useCallback((st, lt) => {
                const ut = createSearchParams(typeof st == "function" ? st(nt) : st);
                et.current = !0, ot("?" + ut, lt)
            }, [ot, nt]);
        return [nt, at]
    }

    function validateClientSideSubmission() {
        if (typeof document > "u") throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.")
    }

    function useSubmit() {
        let {
            router: _
        } = useDataRouterContext(DataRouterHook.UseSubmit), {
            basename: _e
        } = reactExports.useContext(NavigationContext), et = useRouteId();
        return reactExports.useCallback(function(tt, nt) {
            nt === void 0 && (nt = {}), validateClientSideSubmission();
            let {
                action: ot,
                method: at,
                encType: st,
                formData: lt,
                body: ut
            } = getFormSubmissionInfo(tt, _e);
            _.navigate(nt.action || ot, {
                preventScrollReset: nt.preventScrollReset,
                formData: lt,
                body: ut,
                formMethod: nt.method || at,
                formEncType: nt.encType || st,
                replace: nt.replace,
                state: nt.state,
                fromRouteId: et
            })
        }, [_, _e, et])
    }

    function useSubmitFetcher(_, _e) {
        let {
            router: et
        } = useDataRouterContext(DataRouterHook.UseSubmitFetcher), {
            basename: tt
        } = reactExports.useContext(NavigationContext);
        return reactExports.useCallback(function(nt, ot) {
            ot === void 0 && (ot = {}), validateClientSideSubmission();
            let {
                action: at,
                method: st,
                encType: lt,
                formData: ut,
                body: dt
            } = getFormSubmissionInfo(nt, tt);
            _e == null && invariant(!1), et.fetch(_, _e, ot.action || at, {
                preventScrollReset: ot.preventScrollReset,
                formData: ut,
                body: dt,
                formMethod: ot.method || st,
                formEncType: ot.encType || lt
            })
        }, [et, tt, _, _e])
    }

    function useFormAction(_, _e) {
        let {
            relative: et
        } = _e === void 0 ? {} : _e, {
            basename: tt
        } = reactExports.useContext(NavigationContext), nt = reactExports.useContext(RouteContext);
        nt || invariant(!1);
        let [ot] = nt.matches.slice(-1), at = _extends$2({}, useResolvedPath(_ || ".", {
            relative: et
        })), st = useLocation$1();
        if (_ == null && (at.search = st.search, ot.route.index)) {
            let lt = new URLSearchParams(at.search);
            lt.delete("index"), at.search = lt.toString() ? "?" + lt.toString() : ""
        }
        return (!_ || _ === ".") && ot.route.index && (at.search = at.search ? at.search.replace(/^\?/, "?index&") : "?index"), tt !== "/" && (at.pathname = at.pathname === "/" ? tt : joinPaths([tt, at.pathname])), createPath(at)
    }

    function createFetcherForm(_, _e) {
        return reactExports.forwardRef((et, tt) => {
            let nt = useSubmitFetcher(_, _e);
            return reactExports.createElement(FormImpl, _extends$2({}, et, {
                ref: tt,
                submit: nt
            }))
        })
    }
    let fetcherId = 0;

    function useFetcher() {
        var _;
        let {
            router: _e
        } = useDataRouterContext(DataRouterHook.UseFetcher), et = reactExports.useContext(RouteContext);
        et || invariant(!1);
        let tt = (_ = et.matches[et.matches.length - 1]) == null ? void 0 : _.route.id;
        tt == null && invariant(!1);
        let [nt] = reactExports.useState(() => String(++fetcherId)), [ot] = reactExports.useState(() => (tt || invariant(!1), createFetcherForm(nt, tt))), [at] = reactExports.useState(() => dt => {
            _e || invariant(!1), tt || invariant(!1), _e.fetch(nt, tt, dt)
        }), st = useSubmitFetcher(nt, tt), lt = _e.getFetcher(nt), ut = reactExports.useMemo(() => _extends$2({
            Form: ot,
            submit: st,
            load: at
        }, lt), [lt, ot, st, at]);
        return reactExports.useEffect(() => () => {
            if (!_e) {
                console.warn("No router available to clean up from useFetcher()");
                return
            }
            _e.deleteFetcher(nt)
        }, [_e, nt]), ut
    }

    function useFetchers() {
        return [...useDataRouterState(DataRouterStateHook.UseFetchers).fetchers.values()]
    }
    const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
    let savedScrollPositions = {};

    function useScrollRestoration(_) {
        let {
            getKey: _e,
            storageKey: et
        } = _ === void 0 ? {} : _, {
            router: tt
        } = useDataRouterContext(DataRouterHook.UseScrollRestoration), {
            restoreScrollPosition: nt,
            preventScrollReset: ot
        } = useDataRouterState(DataRouterStateHook.UseScrollRestoration), {
            basename: at
        } = reactExports.useContext(NavigationContext), st = useLocation$1(), lt = useMatches(), ut = useNavigation();
        reactExports.useEffect(() => (window.history.scrollRestoration = "manual", () => {
            window.history.scrollRestoration = "auto"
        }), []), usePageHide(reactExports.useCallback(() => {
            if (ut.state === "idle") {
                let dt = (_e ? _e(st, lt) : null) || st.key;
                savedScrollPositions[dt] = window.scrollY
            }
            sessionStorage.setItem(et || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions)), window.history.scrollRestoration = "auto"
        }, [et, _e, ut.state, st, lt])), typeof document < "u" && (reactExports.useLayoutEffect(() => {
            try {
                let dt = sessionStorage.getItem(et || SCROLL_RESTORATION_STORAGE_KEY);
                dt && (savedScrollPositions = JSON.parse(dt))
            } catch (dt) {}
        }, [et]), reactExports.useLayoutEffect(() => {
            let dt = _e && at !== "/" ? (pt, ft) => _e(_extends$2({}, pt, {
                    pathname: stripBasename(pt.pathname, at) || pt.pathname
                }), ft) : _e,
                ct = tt == null ? void 0 : tt.enableScrollRestoration(savedScrollPositions, () => window.scrollY, dt);
            return () => ct && ct()
        }, [tt, at, _e]), reactExports.useLayoutEffect(() => {
            if (nt !== !1) {
                if (typeof nt == "number") {
                    window.scrollTo(0, nt);
                    return
                }
                if (st.hash) {
                    let dt = document.getElementById(decodeURIComponent(st.hash.slice(1)));
                    if (dt) {
                        dt.scrollIntoView();
                        return
                    }
                }
                ot !== !0 && window.scrollTo(0, 0)
            }
        }, [st, nt, ot]))
    }

    function useBeforeUnload(_, _e) {
        let {
            capture: et
        } = _e || {};
        reactExports.useEffect(() => {
            let tt = et != null ? {
                capture: et
            } : void 0;
            return window.addEventListener("beforeunload", _, tt), () => {
                window.removeEventListener("beforeunload", _, tt)
            }
        }, [_, et])
    }

    function usePageHide(_, _e) {
        let {
            capture: et
        } = _e || {};
        reactExports.useEffect(() => {
            let tt = et != null ? {
                capture: et
            } : void 0;
            return window.addEventListener("pagehide", _, tt), () => {
                window.removeEventListener("pagehide", _, tt)
            }
        }, [_, et])
    }

    function usePrompt(_) {
        let {
            when: _e,
            message: et
        } = _, tt = useBlocker(_e);
        reactExports.useEffect(() => {
            tt.state === "blocked" && (window.confirm(et) ? setTimeout(tt.proceed, 0) : tt.reset())
        }, [tt, et]), reactExports.useEffect(() => {
            tt.state === "blocked" && !_e && tt.reset()
        }, [tt, _e])
    }
    react_router_dom = Object.freeze(Object.defineProperty({
        __proto__: null,
        AbortedDeferredError,
        Await,
        BrowserRouter,
        Form,
        HashRouter,
        Link: Link$1,
        MemoryRouter,
        NavLink,
        Navigate,
        get NavigationType() {
            return Action
        },
        Outlet,
        Route,
        Router,
        RouterProvider,
        Routes,
        ScrollRestoration,
        UNSAFE_DataRouterContext: DataRouterContext,
        UNSAFE_DataRouterStateContext: DataRouterStateContext,
        UNSAFE_LocationContext: LocationContext,
        UNSAFE_NavigationContext: NavigationContext,
        UNSAFE_RouteContext: RouteContext,
        UNSAFE_useRouteId: useRouteId,
        UNSAFE_useScrollRestoration: useScrollRestoration,
        createBrowserRouter,
        createHashRouter,
        createMemoryRouter,
        createPath,
        createRoutesFromChildren,
        createRoutesFromElements: createRoutesFromChildren,
        createSearchParams,
        defer: defer$1,
        generatePath,
        isRouteErrorResponse,
        json,
        matchPath,
        matchRoutes,
        parsePath,
        redirect,
        redirectDocument,
        renderMatches,
        resolvePath,
        unstable_HistoryRouter: HistoryRouter,
        unstable_useBlocker: useBlocker,
        unstable_usePrompt: usePrompt,
        useActionData,
        useAsyncError,
        useAsyncValue,
        useBeforeUnload,
        useFetcher,
        useFetchers,
        useFormAction,
        useHref,
        useInRouterContext,
        useLinkClickHandler,
        useLoaderData,
        useLocation: useLocation$1,
        useMatch,
        useMatches,
        useNavigate: useNavigate$1,
        useNavigation,
        useNavigationType,
        useOutlet,
        useOutletContext,
        useParams,
        useResolvedPath,
        useRevalidator,
        useRouteError,
        useRouteLoaderData,
        useRoutes,
        useSearchParams,
        useSubmit
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var rt = Object.defineProperty,
        it = (_, _e, et) => _e in _ ? rt(_, _e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: et
        }) : _[_e] = et,
        de = (_, _e, et) => (it(_, typeof _e != "symbol" ? _e + "" : _e, et), et);

    function _mergeNamespaces$1(_, _e) {
        for (var et = 0; et < _e.length; et++) {
            const tt = _e[et];
            if (typeof tt != "string" && !Array.isArray(tt)) {
                for (const nt in tt)
                    if (nt !== "default" && !(nt in _)) {
                        const ot = Object.getOwnPropertyDescriptor(tt, nt);
                        ot && Object.defineProperty(_, nt, ot.get ? ot : {
                            enumerable: !0,
                            get: () => tt[nt]
                        })
                    }
            }
        }
        return Object.freeze(Object.defineProperty(_, Symbol.toStringTag, {
            value: "Module"
        }))
    }
    var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function getDefaultExportFromCjs(_) {
        return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
    }

    function getAugmentedNamespace(_) {
        if (_.__esModule) return _;
        var _e = _.default;
        if (typeof _e == "function") {
            var et = function tt() {
                return this instanceof tt ? Reflect.construct(_e, arguments, this.constructor) : _e.apply(this, arguments)
            };
            et.prototype = _e.prototype
        } else et = {};
        return Object.defineProperty(et, "__esModule", {
            value: !0
        }), Object.keys(_).forEach(function(tt) {
            var nt = Object.getOwnPropertyDescriptor(_, tt);
            Object.defineProperty(et, tt, nt.get ? nt : {
                enumerable: !0,
                get: function() {
                    return _[tt]
                }
            })
        }), et
    }
    var indexMinimal$1 = {},
        minimal$4 = {},
        aspromise = asPromise;

    function asPromise(_, _e) {
        for (var et = new Array(arguments.length - 1), tt = 0, nt = 2, ot = !0; nt < arguments.length;) et[tt++] = arguments[nt++];
        return new Promise(function(at, st) {
            et[tt] = function(lt) {
                if (ot)
                    if (ot = !1, lt) st(lt);
                    else {
                        for (var ut = new Array(arguments.length - 1), dt = 0; dt < ut.length;) ut[dt++] = arguments[dt];
                        at.apply(null, ut)
                    }
            };
            try {
                _.apply(_e || null, et)
            } catch (lt) {
                ot && (ot = !1, st(lt))
            }
        })
    }
    var base64$2 = {};
    (function(_) {
        var _e = _;
        _e.length = function(at) {
            var st = at.length;
            if (!st) return 0;
            for (var lt = 0; --st % 4 > 1 && at.charAt(st) === "=";) ++lt;
            return Math.ceil(at.length * 3) / 4 - lt
        };
        for (var et = new Array(64), tt = new Array(123), nt = 0; nt < 64;) tt[et[nt] = nt < 26 ? nt + 65 : nt < 52 ? nt + 71 : nt < 62 ? nt - 4 : nt - 59 | 43] = nt++;
        _e.encode = function(at, st, lt) {
            for (var ut = null, dt = [], ct = 0, pt = 0, ft; st < lt;) {
                var ht = at[st++];
                switch (pt) {
                    case 0:
                        dt[ct++] = et[ht >> 2], ft = (ht & 3) << 4, pt = 1;
                        break;
                    case 1:
                        dt[ct++] = et[ft | ht >> 4], ft = (ht & 15) << 2, pt = 2;
                        break;
                    case 2:
                        dt[ct++] = et[ft | ht >> 6], dt[ct++] = et[ht & 63], pt = 0;
                        break
                }
                ct > 8191 && ((ut || (ut = [])).push(String.fromCharCode.apply(String, dt)), ct = 0)
            }
            return pt && (dt[ct++] = et[ft], dt[ct++] = 61, pt === 1 && (dt[ct++] = 61)), ut ? (ct && ut.push(String.fromCharCode.apply(String, dt.slice(0, ct))), ut.join("")) : String.fromCharCode.apply(String, dt.slice(0, ct))
        };
        var ot = "invalid encoding";
        _e.decode = function(at, st, lt) {
            for (var ut = lt, dt = 0, ct, pt = 0; pt < at.length;) {
                var ft = at.charCodeAt(pt++);
                if (ft === 61 && dt > 1) break;
                if ((ft = tt[ft]) === void 0) throw Error(ot);
                switch (dt) {
                    case 0:
                        ct = ft, dt = 1;
                        break;
                    case 1:
                        st[lt++] = ct << 2 | (ft & 48) >> 4, ct = ft, dt = 2;
                        break;
                    case 2:
                        st[lt++] = (ct & 15) << 4 | (ft & 60) >> 2, ct = ft, dt = 3;
                        break;
                    case 3:
                        st[lt++] = (ct & 3) << 6 | ft, dt = 0;
                        break
                }
            }
            if (dt === 1) throw Error(ot);
            return lt - ut
        }, _e.test = function(at) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(at)
        }
    })(base64$2);
    var eventemitter = EventEmitter$2;

    function EventEmitter$2() {
        this._listeners = {}
    }
    EventEmitter$2.prototype.on = function(_, _e, et) {
        return (this._listeners[_] || (this._listeners[_] = [])).push({
            fn: _e,
            ctx: et || this
        }), this
    }, EventEmitter$2.prototype.off = function(_, _e) {
        if (_ === void 0) this._listeners = {};
        else if (_e === void 0) this._listeners[_] = [];
        else
            for (var et = this._listeners[_], tt = 0; tt < et.length;) et[tt].fn === _e ? et.splice(tt, 1) : ++tt;
        return this
    }, EventEmitter$2.prototype.emit = function(_) {
        var _e = this._listeners[_];
        if (_e) {
            for (var et = [], tt = 1; tt < arguments.length;) et.push(arguments[tt++]);
            for (tt = 0; tt < _e.length;) _e[tt].fn.apply(_e[tt++].ctx, et)
        }
        return this
    };
    var float = factory(factory);

    function factory(_) {
        return typeof Float32Array < "u" ? function() {
            var _e = new Float32Array([-0]),
                et = new Uint8Array(_e.buffer),
                tt = et[3] === 128;

            function nt(lt, ut, dt) {
                _e[0] = lt, ut[dt] = et[0], ut[dt + 1] = et[1], ut[dt + 2] = et[2], ut[dt + 3] = et[3]
            }

            function ot(lt, ut, dt) {
                _e[0] = lt, ut[dt] = et[3], ut[dt + 1] = et[2], ut[dt + 2] = et[1], ut[dt + 3] = et[0]
            }
            _.writeFloatLE = tt ? nt : ot, _.writeFloatBE = tt ? ot : nt;

            function at(lt, ut) {
                return et[0] = lt[ut], et[1] = lt[ut + 1], et[2] = lt[ut + 2], et[3] = lt[ut + 3], _e[0]
            }

            function st(lt, ut) {
                return et[3] = lt[ut], et[2] = lt[ut + 1], et[1] = lt[ut + 2], et[0] = lt[ut + 3], _e[0]
            }
            _.readFloatLE = tt ? at : st, _.readFloatBE = tt ? st : at
        }() : function() {
            function _e(tt, nt, ot, at) {
                var st = nt < 0 ? 1 : 0;
                if (st && (nt = -nt), nt === 0) tt(1 / nt > 0 ? 0 : 2147483648, ot, at);
                else if (isNaN(nt)) tt(2143289344, ot, at);
                else if (nt > 3402823466385289e23) tt((st << 31 | 2139095040) >>> 0, ot, at);
                else if (nt < 11754943508222875e-54) tt((st << 31 | Math.round(nt / 1401298464324817e-60)) >>> 0, ot, at);
                else {
                    var lt = Math.floor(Math.log(nt) / Math.LN2),
                        ut = Math.round(nt * Math.pow(2, -lt) * 8388608) & 8388607;
                    tt((st << 31 | lt + 127 << 23 | ut) >>> 0, ot, at)
                }
            }
            _.writeFloatLE = _e.bind(null, writeUintLE), _.writeFloatBE = _e.bind(null, writeUintBE);

            function et(tt, nt, ot) {
                var at = tt(nt, ot),
                    st = (at >> 31) * 2 + 1,
                    lt = at >>> 23 & 255,
                    ut = at & 8388607;
                return lt === 255 ? ut ? NaN : st * (1 / 0) : lt === 0 ? st * 1401298464324817e-60 * ut : st * Math.pow(2, lt - 150) * (ut + 8388608)
            }
            _.readFloatLE = et.bind(null, readUintLE), _.readFloatBE = et.bind(null, readUintBE)
        }(), typeof Float64Array < "u" ? function() {
            var _e = new Float64Array([-0]),
                et = new Uint8Array(_e.buffer),
                tt = et[7] === 128;

            function nt(lt, ut, dt) {
                _e[0] = lt, ut[dt] = et[0], ut[dt + 1] = et[1], ut[dt + 2] = et[2], ut[dt + 3] = et[3], ut[dt + 4] = et[4], ut[dt + 5] = et[5], ut[dt + 6] = et[6], ut[dt + 7] = et[7]
            }

            function ot(lt, ut, dt) {
                _e[0] = lt, ut[dt] = et[7], ut[dt + 1] = et[6], ut[dt + 2] = et[5], ut[dt + 3] = et[4], ut[dt + 4] = et[3], ut[dt + 5] = et[2], ut[dt + 6] = et[1], ut[dt + 7] = et[0]
            }
            _.writeDoubleLE = tt ? nt : ot, _.writeDoubleBE = tt ? ot : nt;

            function at(lt, ut) {
                return et[0] = lt[ut], et[1] = lt[ut + 1], et[2] = lt[ut + 2], et[3] = lt[ut + 3], et[4] = lt[ut + 4], et[5] = lt[ut + 5], et[6] = lt[ut + 6], et[7] = lt[ut + 7], _e[0]
            }

            function st(lt, ut) {
                return et[7] = lt[ut], et[6] = lt[ut + 1], et[5] = lt[ut + 2], et[4] = lt[ut + 3], et[3] = lt[ut + 4], et[2] = lt[ut + 5], et[1] = lt[ut + 6], et[0] = lt[ut + 7], _e[0]
            }
            _.readDoubleLE = tt ? at : st, _.readDoubleBE = tt ? st : at
        }() : function() {
            function _e(tt, nt, ot, at, st, lt) {
                var ut = at < 0 ? 1 : 0;
                if (ut && (at = -at), at === 0) tt(0, st, lt + nt), tt(1 / at > 0 ? 0 : 2147483648, st, lt + ot);
                else if (isNaN(at)) tt(0, st, lt + nt), tt(2146959360, st, lt + ot);
                else if (at > 17976931348623157e292) tt(0, st, lt + nt), tt((ut << 31 | 2146435072) >>> 0, st, lt + ot);
                else {
                    var dt;
                    if (at < 22250738585072014e-324) dt = at / 5e-324, tt(dt >>> 0, st, lt + nt), tt((ut << 31 | dt / 4294967296) >>> 0, st, lt + ot);
                    else {
                        var ct = Math.floor(Math.log(at) / Math.LN2);
                        ct === 1024 && (ct = 1023), dt = at * Math.pow(2, -ct), tt(dt * 4503599627370496 >>> 0, st, lt + nt), tt((ut << 31 | ct + 1023 << 20 | dt * 1048576 & 1048575) >>> 0, st, lt + ot)
                    }
                }
            }
            _.writeDoubleLE = _e.bind(null, writeUintLE, 0, 4), _.writeDoubleBE = _e.bind(null, writeUintBE, 4, 0);

            function et(tt, nt, ot, at, st) {
                var lt = tt(at, st + nt),
                    ut = tt(at, st + ot),
                    dt = (ut >> 31) * 2 + 1,
                    ct = ut >>> 20 & 2047,
                    pt = 4294967296 * (ut & 1048575) + lt;
                return ct === 2047 ? pt ? NaN : dt * (1 / 0) : ct === 0 ? dt * 5e-324 * pt : dt * Math.pow(2, ct - 1075) * (pt + 4503599627370496)
            }
            _.readDoubleLE = et.bind(null, readUintLE, 0, 4), _.readDoubleBE = et.bind(null, readUintBE, 4, 0)
        }(), _
    }

    function writeUintLE(_, _e, et) {
        _e[et] = _ & 255, _e[et + 1] = _ >>> 8 & 255, _e[et + 2] = _ >>> 16 & 255, _e[et + 3] = _ >>> 24
    }

    function writeUintBE(_, _e, et) {
        _e[et] = _ >>> 24, _e[et + 1] = _ >>> 16 & 255, _e[et + 2] = _ >>> 8 & 255, _e[et + 3] = _ & 255
    }

    function readUintLE(_, _e) {
        return (_[_e] | _[_e + 1] << 8 | _[_e + 2] << 16 | _[_e + 3] << 24) >>> 0
    }

    function readUintBE(_, _e) {
        return (_[_e] << 24 | _[_e + 1] << 16 | _[_e + 2] << 8 | _[_e + 3]) >>> 0
    }
    var inquire_1 = inquire;

    function inquire(moduleName) {
        try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length)) return mod
        } catch (_) {}
        return null
    }
    var utf8$5 = {};
    (function(_) {
        var _e = _;
        _e.length = function(et) {
            for (var tt = 0, nt = 0, ot = 0; ot < et.length; ++ot) nt = et.charCodeAt(ot), nt < 128 ? tt += 1 : nt < 2048 ? tt += 2 : (nt & 64512) === 55296 && (et.charCodeAt(ot + 1) & 64512) === 56320 ? (++ot, tt += 4) : tt += 3;
            return tt
        }, _e.read = function(et, tt, nt) {
            var ot = nt - tt;
            if (ot < 1) return "";
            for (var at = null, st = [], lt = 0, ut; tt < nt;) ut = et[tt++], ut < 128 ? st[lt++] = ut : ut > 191 && ut < 224 ? st[lt++] = (ut & 31) << 6 | et[tt++] & 63 : ut > 239 && ut < 365 ? (ut = ((ut & 7) << 18 | (et[tt++] & 63) << 12 | (et[tt++] & 63) << 6 | et[tt++] & 63) - 65536, st[lt++] = 55296 + (ut >> 10), st[lt++] = 56320 + (ut & 1023)) : st[lt++] = (ut & 15) << 12 | (et[tt++] & 63) << 6 | et[tt++] & 63, lt > 8191 && ((at || (at = [])).push(String.fromCharCode.apply(String, st)), lt = 0);
            return at ? (lt && at.push(String.fromCharCode.apply(String, st.slice(0, lt))), at.join("")) : String.fromCharCode.apply(String, st.slice(0, lt))
        }, _e.write = function(et, tt, nt) {
            for (var ot = nt, at, st, lt = 0; lt < et.length; ++lt) at = et.charCodeAt(lt), at < 128 ? tt[nt++] = at : at < 2048 ? (tt[nt++] = at >> 6 | 192, tt[nt++] = at & 63 | 128) : (at & 64512) === 55296 && ((st = et.charCodeAt(lt + 1)) & 64512) === 56320 ? (at = 65536 + ((at & 1023) << 10) + (st & 1023), ++lt, tt[nt++] = at >> 18 | 240, tt[nt++] = at >> 12 & 63 | 128, tt[nt++] = at >> 6 & 63 | 128, tt[nt++] = at & 63 | 128) : (tt[nt++] = at >> 12 | 224, tt[nt++] = at >> 6 & 63 | 128, tt[nt++] = at & 63 | 128);
            return nt - ot
        }
    })(utf8$5);
    var pool_1 = pool;

    function pool(_, _e, et) {
        var tt = et || 8192,
            nt = tt >>> 1,
            ot = null,
            at = tt;
        return function(st) {
            if (st < 1 || st > nt) return _(st);
            at + st > tt && (ot = _(tt), at = 0);
            var lt = _e.call(ot, at, at += st);
            return at & 7 && (at = (at | 7) + 1), lt
        }
    }
    var longbits$1, hasRequiredLongbits$1;

    function requireLongbits$1() {
        if (hasRequiredLongbits$1) return longbits$1;
        hasRequiredLongbits$1 = 1, longbits$1 = _e;
        var _ = requireMinimal$1();

        function _e(ot, at) {
            this.lo = ot >>> 0, this.hi = at >>> 0
        }
        var et = _e.zero = new _e(0, 0);
        et.toNumber = function() {
            return 0
        }, et.zzEncode = et.zzDecode = function() {
            return this
        }, et.length = function() {
            return 1
        };
        var tt = _e.zeroHash = "\0\0\0\0\0\0\0\0";
        _e.fromNumber = function(ot) {
            if (ot === 0) return et;
            var at = ot < 0;
            at && (ot = -ot);
            var st = ot >>> 0,
                lt = (ot - st) / 4294967296 >>> 0;
            return at && (lt = ~lt >>> 0, st = ~st >>> 0, ++st > 4294967295 && (st = 0, ++lt > 4294967295 && (lt = 0))), new _e(st, lt)
        }, _e.from = function(ot) {
            if (typeof ot == "number") return _e.fromNumber(ot);
            if (_.isString(ot))
                if (_.Long) ot = _.Long.fromString(ot);
                else return _e.fromNumber(parseInt(ot, 10));
            return ot.low || ot.high ? new _e(ot.low >>> 0, ot.high >>> 0) : et
        }, _e.prototype.toNumber = function(ot) {
            if (!ot && this.hi >>> 31) {
                var at = ~this.lo + 1 >>> 0,
                    st = ~this.hi >>> 0;
                return at || (st = st + 1 >>> 0), -(at + st * 4294967296)
            }
            return this.lo + this.hi * 4294967296
        }, _e.prototype.toLong = function(ot) {
            return _.Long ? new _.Long(this.lo | 0, this.hi | 0, !!ot) : {
                low: this.lo | 0,
                high: this.hi | 0,
                unsigned: !!ot
            }
        };
        var nt = String.prototype.charCodeAt;
        return _e.fromHash = function(ot) {
            return ot === tt ? et : new _e((nt.call(ot, 0) | nt.call(ot, 1) << 8 | nt.call(ot, 2) << 16 | nt.call(ot, 3) << 24) >>> 0, (nt.call(ot, 4) | nt.call(ot, 5) << 8 | nt.call(ot, 6) << 16 | nt.call(ot, 7) << 24) >>> 0)
        }, _e.prototype.toHash = function() {
            return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
        }, _e.prototype.zzEncode = function() {
            var ot = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ ot) >>> 0, this.lo = (this.lo << 1 ^ ot) >>> 0, this
        }, _e.prototype.zzDecode = function() {
            var ot = -(this.lo & 1);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ ot) >>> 0, this.hi = (this.hi >>> 1 ^ ot) >>> 0, this
        }, _e.prototype.length = function() {
            var ot = this.lo,
                at = (this.lo >>> 28 | this.hi << 4) >>> 0,
                st = this.hi >>> 24;
            return st === 0 ? at === 0 ? ot < 16384 ? ot < 128 ? 1 : 2 : ot < 2097152 ? 3 : 4 : at < 16384 ? at < 128 ? 5 : 6 : at < 2097152 ? 7 : 8 : st < 128 ? 9 : 10
        }, longbits$1
    }
    var hasRequiredMinimal$1;

    function requireMinimal$1() {
        return hasRequiredMinimal$1 || (hasRequiredMinimal$1 = 1, function(_) {
            var _e = _;
            _e.asPromise = aspromise, _e.base64 = base64$2, _e.EventEmitter = eventemitter, _e.float = float, _e.inquire = inquire_1, _e.utf8 = utf8$5, _e.pool = pool_1, _e.LongBits = requireLongbits$1(), _e.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), _e.global = _e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, _e.emptyArray = Object.freeze ? Object.freeze([]) : [], _e.emptyObject = Object.freeze ? Object.freeze({}) : {}, _e.isInteger = Number.isInteger || function(nt) {
                return typeof nt == "number" && isFinite(nt) && Math.floor(nt) === nt
            }, _e.isString = function(nt) {
                return typeof nt == "string" || nt instanceof String
            }, _e.isObject = function(nt) {
                return nt && typeof nt == "object"
            }, _e.isset = _e.isSet = function(nt, ot) {
                var at = nt[ot];
                return at != null && nt.hasOwnProperty(ot) ? typeof at != "object" || (Array.isArray(at) ? at.length : Object.keys(at).length) > 0 : !1
            }, _e.Buffer = function() {
                try {
                    var nt = _e.inquire("buffer").Buffer;
                    return nt.prototype.utf8Write ? nt : null
                } catch (ot) {
                    return null
                }
            }(), _e._Buffer_from = null, _e._Buffer_allocUnsafe = null, _e.newBuffer = function(nt) {
                return typeof nt == "number" ? _e.Buffer ? _e._Buffer_allocUnsafe(nt) : new _e.Array(nt) : _e.Buffer ? _e._Buffer_from(nt) : typeof Uint8Array > "u" ? nt : new Uint8Array(nt)
            }, _e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, _e.Long = _e.global.dcodeIO && _e.global.dcodeIO.Long || _e.global.Long || _e.inquire("long"), _e.key2Re = /^true|false|0|1$/, _e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, _e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, _e.longToHash = function(nt) {
                return nt ? _e.LongBits.from(nt).toHash() : _e.LongBits.zeroHash
            }, _e.longFromHash = function(nt, ot) {
                var at = _e.LongBits.fromHash(nt);
                return _e.Long ? _e.Long.fromBits(at.lo, at.hi, ot) : at.toNumber(!!ot)
            };

            function et(nt, ot, at) {
                for (var st = Object.keys(ot), lt = 0; lt < st.length; ++lt)(nt[st[lt]] === void 0 || !at) && (nt[st[lt]] = ot[st[lt]]);
                return nt
            }
            _e.merge = et, _e.lcFirst = function(nt) {
                return nt.charAt(0).toLowerCase() + nt.substring(1)
            };

            function tt(nt) {
                function ot(at, st) {
                    if (!(this instanceof ot)) return new ot(at, st);
                    Object.defineProperty(this, "message", {
                        get: function() {
                            return at
                        }
                    }), Error.captureStackTrace ? Error.captureStackTrace(this, ot) : Object.defineProperty(this, "stack", {
                        value: new Error().stack || ""
                    }), st && et(this, st)
                }
                return ot.prototype = Object.create(Error.prototype, {
                    constructor: {
                        value: ot,
                        writable: !0,
                        enumerable: !1,
                        configurable: !0
                    },
                    name: {
                        get: function() {
                            return nt
                        },
                        set: void 0,
                        enumerable: !1,
                        configurable: !0
                    },
                    toString: {
                        value: function() {
                            return this.name + ": " + this.message
                        },
                        writable: !0,
                        enumerable: !1,
                        configurable: !0
                    }
                }), ot
            }
            _e.newError = tt, _e.ProtocolError = tt("ProtocolError"), _e.oneOfGetter = function(nt) {
                for (var ot = {}, at = 0; at < nt.length; ++at) ot[nt[at]] = 1;
                return function() {
                    for (var st = Object.keys(this), lt = st.length - 1; lt > -1; --lt)
                        if (ot[st[lt]] === 1 && this[st[lt]] !== void 0 && this[st[lt]] !== null) return st[lt]
                }
            }, _e.oneOfSetter = function(nt) {
                return function(ot) {
                    for (var at = 0; at < nt.length; ++at) nt[at] !== ot && delete this[nt[at]]
                }
            }, _e.toJSONOptions = {
                longs: String,
                enums: String,
                bytes: String,
                json: !0
            }, _e._configure = function() {
                var nt = _e.Buffer;
                if (!nt) {
                    _e._Buffer_from = _e._Buffer_allocUnsafe = null;
                    return
                }
                _e._Buffer_from = nt.from !== Uint8Array.from && nt.from || function(ot, at) {
                    return new nt(ot, at)
                }, _e._Buffer_allocUnsafe = nt.allocUnsafe || function(ot) {
                    return new nt(ot)
                }
            }
        }(minimal$4)), minimal$4
    }
    var writer$1 = Writer$3,
        util$9 = requireMinimal$1(),
        BufferWriter$3, LongBits$3 = util$9.LongBits,
        base64$1 = util$9.base64,
        utf8$4 = util$9.utf8;

    function Op$1(_, _e, et) {
        this.fn = _, this.len = _e, this.next = void 0, this.val = et
    }

    function noop$3() {}

    function State$2(_) {
        this.head = _.head, this.tail = _.tail, this.len = _.len, this.next = _.states
    }

    function Writer$3() {
        this.len = 0, this.head = new Op$1(noop$3, 0, 0), this.tail = this.head, this.states = null
    }
    var create$3 = function _() {
        return util$9.Buffer ? function() {
            return (Writer$3.create = function() {
                return new BufferWriter$3
            })()
        } : function() {
            return new Writer$3
        }
    };
    Writer$3.create = create$3(), Writer$3.alloc = function _(_e) {
        return new util$9.Array(_e)
    }, util$9.Array !== Array && (Writer$3.alloc = util$9.pool(Writer$3.alloc, util$9.Array.prototype.subarray)), Writer$3.prototype._push = function _(_e, et, tt) {
        return this.tail = this.tail.next = new Op$1(_e, et, tt), this.len += et, this
    };

    function writeByte$1(_, _e, et) {
        _e[et] = _ & 255
    }

    function writeVarint32$1(_, _e, et) {
        for (; _ > 127;) _e[et++] = _ & 127 | 128, _ >>>= 7;
        _e[et] = _
    }

    function VarintOp$1(_, _e) {
        this.len = _, this.next = void 0, this.val = _e
    }
    VarintOp$1.prototype = Object.create(Op$1.prototype), VarintOp$1.prototype.fn = writeVarint32$1, Writer$3.prototype.uint32 = function _(_e) {
        return this.len += (this.tail = this.tail.next = new VarintOp$1((_e = _e >>> 0) < 128 ? 1 : _e < 16384 ? 2 : _e < 2097152 ? 3 : _e < 268435456 ? 4 : 5, _e)).len, this
    }, Writer$3.prototype.int32 = function _(_e) {
        return _e < 0 ? this._push(writeVarint64$1, 10, LongBits$3.fromNumber(_e)) : this.uint32(_e)
    }, Writer$3.prototype.sint32 = function _(_e) {
        return this.uint32((_e << 1 ^ _e >> 31) >>> 0)
    };

    function writeVarint64$1(_, _e, et) {
        for (; _.hi;) _e[et++] = _.lo & 127 | 128, _.lo = (_.lo >>> 7 | _.hi << 25) >>> 0, _.hi >>>= 7;
        for (; _.lo > 127;) _e[et++] = _.lo & 127 | 128, _.lo = _.lo >>> 7;
        _e[et++] = _.lo
    }
    Writer$3.prototype.uint64 = function _(_e) {
        var et = LongBits$3.from(_e);
        return this._push(writeVarint64$1, et.length(), et)
    }, Writer$3.prototype.int64 = Writer$3.prototype.uint64, Writer$3.prototype.sint64 = function _(_e) {
        var et = LongBits$3.from(_e).zzEncode();
        return this._push(writeVarint64$1, et.length(), et)
    }, Writer$3.prototype.bool = function _(_e) {
        return this._push(writeByte$1, 1, _e ? 1 : 0)
    };

    function writeFixed32$1(_, _e, et) {
        _e[et] = _ & 255, _e[et + 1] = _ >>> 8 & 255, _e[et + 2] = _ >>> 16 & 255, _e[et + 3] = _ >>> 24
    }
    Writer$3.prototype.fixed32 = function _(_e) {
        return this._push(writeFixed32$1, 4, _e >>> 0)
    }, Writer$3.prototype.sfixed32 = Writer$3.prototype.fixed32, Writer$3.prototype.fixed64 = function _(_e) {
        var et = LongBits$3.from(_e);
        return this._push(writeFixed32$1, 4, et.lo)._push(writeFixed32$1, 4, et.hi)
    }, Writer$3.prototype.sfixed64 = Writer$3.prototype.fixed64, Writer$3.prototype.float = function _(_e) {
        return this._push(util$9.float.writeFloatLE, 4, _e)
    }, Writer$3.prototype.double = function _(_e) {
        return this._push(util$9.float.writeDoubleLE, 8, _e)
    };
    var writeBytes$1 = util$9.Array.prototype.set ? function _(_e, et, tt) {
        et.set(_e, tt)
    } : function _(_e, et, tt) {
        for (var nt = 0; nt < _e.length; ++nt) et[tt + nt] = _e[nt]
    };
    Writer$3.prototype.bytes = function _(_e) {
        var et = _e.length >>> 0;
        if (!et) return this._push(writeByte$1, 1, 0);
        if (util$9.isString(_e)) {
            var tt = Writer$3.alloc(et = base64$1.length(_e));
            base64$1.decode(_e, tt, 0), _e = tt
        }
        return this.uint32(et)._push(writeBytes$1, et, _e)
    }, Writer$3.prototype.string = function _(_e) {
        var et = utf8$4.length(_e);
        return et ? this.uint32(et)._push(utf8$4.write, et, _e) : this._push(writeByte$1, 1, 0)
    }, Writer$3.prototype.fork = function _() {
        return this.states = new State$2(this), this.head = this.tail = new Op$1(noop$3, 0, 0), this.len = 0, this
    }, Writer$3.prototype.reset = function _() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op$1(noop$3, 0, 0), this.len = 0), this
    }, Writer$3.prototype.ldelim = function _() {
        var _e = this.head,
            et = this.tail,
            tt = this.len;
        return this.reset().uint32(tt), tt && (this.tail.next = _e.next, this.tail = et, this.len += tt), this
    }, Writer$3.prototype.finish = function _() {
        for (var _e = this.head.next, et = this.constructor.alloc(this.len), tt = 0; _e;) _e.fn(_e.val, et, tt), tt += _e.len, _e = _e.next;
        return et
    }, Writer$3._configure = function(_) {
        BufferWriter$3 = _, Writer$3.create = create$3(), BufferWriter$3._configure()
    };
    var writer_buffer$1 = BufferWriter$2,
        Writer$2 = writer$1;
    (BufferWriter$2.prototype = Object.create(Writer$2.prototype)).constructor = BufferWriter$2;
    var util$8 = requireMinimal$1();

    function BufferWriter$2() {
        Writer$2.call(this)
    }
    BufferWriter$2._configure = function() {
        BufferWriter$2.alloc = util$8._Buffer_allocUnsafe, BufferWriter$2.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function(_, _e, et) {
            _e.set(_, et)
        } : function(_, _e, et) {
            if (_.copy) _.copy(_e, et, 0, _.length);
            else
                for (var tt = 0; tt < _.length;) _e[et++] = _[tt++]
        }
    }, BufferWriter$2.prototype.bytes = function _(_e) {
        util$8.isString(_e) && (_e = util$8._Buffer_from(_e, "base64"));
        var et = _e.length >>> 0;
        return this.uint32(et), et && this._push(BufferWriter$2.writeBytesBuffer, et, _e), this
    };

    function writeStringBuffer$1(_, _e, et) {
        _.length < 40 ? util$8.utf8.write(_, _e, et) : _e.utf8Write ? _e.utf8Write(_, et) : _e.write(_, et)
    }
    BufferWriter$2.prototype.string = function _(_e) {
        var et = util$8.Buffer.byteLength(_e);
        return this.uint32(et), et && this._push(writeStringBuffer$1, et, _e), this
    }, BufferWriter$2._configure();
    var reader$1 = Reader$3,
        util$7 = requireMinimal$1(),
        BufferReader$3, LongBits$2 = util$7.LongBits,
        utf8$3 = util$7.utf8;

    function indexOutOfRange$1(_, _e) {
        return RangeError("index out of range: " + _.pos + " + " + (_e || 1) + " > " + _.len)
    }

    function Reader$3(_) {
        this.buf = _, this.pos = 0, this.len = _.length
    }
    var create_array$1 = typeof Uint8Array < "u" ? function _(_e) {
            if (_e instanceof Uint8Array || Array.isArray(_e)) return new Reader$3(_e);
            throw Error("illegal buffer")
        } : function _(_e) {
            if (Array.isArray(_e)) return new Reader$3(_e);
            throw Error("illegal buffer")
        },
        create$2 = function _() {
            return util$7.Buffer ? function(_e) {
                return (Reader$3.create = function(et) {
                    return util$7.Buffer.isBuffer(et) ? new BufferReader$3(et) : create_array$1(et)
                })(_e)
            } : create_array$1
        };
    Reader$3.create = create$2(), Reader$3.prototype._slice = util$7.Array.prototype.subarray || util$7.Array.prototype.slice, Reader$3.prototype.uint32 = function _() {
        var _e = 4294967295;
        return function() {
            if (_e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (_e = (_e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (_e = (_e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (_e = (_e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (_e = (_e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return _e;
            if ((this.pos += 5) > this.len) throw this.pos = this.len, indexOutOfRange$1(this, 10);
            return _e
        }
    }(), Reader$3.prototype.int32 = function _() {
        return this.uint32() | 0
    }, Reader$3.prototype.sint32 = function _() {
        var _e = this.uint32();
        return _e >>> 1 ^ -(_e & 1) | 0
    };

    function readLongVarint$1() {
        var _ = new LongBits$2(0, 0),
            _e = 0;
        if (this.len - this.pos > 4) {
            for (; _e < 4; ++_e)
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << _e * 7) >>> 0, this.buf[this.pos++] < 128) return _;
            if (_.lo = (_.lo | (this.buf[this.pos] & 127) << 28) >>> 0, _.hi = (_.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return _;
            _e = 0
        } else {
            for (; _e < 3; ++_e) {
                if (this.pos >= this.len) throw indexOutOfRange$1(this);
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << _e * 7) >>> 0, this.buf[this.pos++] < 128) return _
            }
            return _.lo = (_.lo | (this.buf[this.pos++] & 127) << _e * 7) >>> 0, _
        }
        if (this.len - this.pos > 4) {
            for (; _e < 5; ++_e)
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << _e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return _
        } else
            for (; _e < 5; ++_e) {
                if (this.pos >= this.len) throw indexOutOfRange$1(this);
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << _e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return _
            }
        throw Error("invalid varint encoding")
    }
    Reader$3.prototype.bool = function _() {
        return this.uint32() !== 0
    };

    function readFixed32_end$1(_, _e) {
        return (_[_e - 4] | _[_e - 3] << 8 | _[_e - 2] << 16 | _[_e - 1] << 24) >>> 0
    }
    Reader$3.prototype.fixed32 = function _() {
        if (this.pos + 4 > this.len) throw indexOutOfRange$1(this, 4);
        return readFixed32_end$1(this.buf, this.pos += 4)
    }, Reader$3.prototype.sfixed32 = function _() {
        if (this.pos + 4 > this.len) throw indexOutOfRange$1(this, 4);
        return readFixed32_end$1(this.buf, this.pos += 4) | 0
    };

    function readFixed64$1() {
        if (this.pos + 8 > this.len) throw indexOutOfRange$1(this, 8);
        return new LongBits$2(readFixed32_end$1(this.buf, this.pos += 4), readFixed32_end$1(this.buf, this.pos += 4))
    }
    Reader$3.prototype.float = function _() {
        if (this.pos + 4 > this.len) throw indexOutOfRange$1(this, 4);
        var _e = util$7.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, _e
    }, Reader$3.prototype.double = function _() {
        if (this.pos + 8 > this.len) throw indexOutOfRange$1(this, 4);
        var _e = util$7.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, _e
    }, Reader$3.prototype.bytes = function _() {
        var _e = this.uint32(),
            et = this.pos,
            tt = this.pos + _e;
        if (tt > this.len) throw indexOutOfRange$1(this, _e);
        if (this.pos += _e, Array.isArray(this.buf)) return this.buf.slice(et, tt);
        if (et === tt) {
            var nt = util$7.Buffer;
            return nt ? nt.alloc(0) : new this.buf.constructor(0)
        }
        return this._slice.call(this.buf, et, tt)
    }, Reader$3.prototype.string = function _() {
        var _e = this.bytes();
        return utf8$3.read(_e, 0, _e.length)
    }, Reader$3.prototype.skip = function _(_e) {
        if (typeof _e == "number") {
            if (this.pos + _e > this.len) throw indexOutOfRange$1(this, _e);
            this.pos += _e
        } else
            do
                if (this.pos >= this.len) throw indexOutOfRange$1(this); while (this.buf[this.pos++] & 128);
        return this
    }, Reader$3.prototype.skipType = function(_) {
        switch (_) {
            case 0:
                this.skip();
                break;
            case 1:
                this.skip(8);
                break;
            case 2:
                this.skip(this.uint32());
                break;
            case 3:
                for (;
                    (_ = this.uint32() & 7) !== 4;) this.skipType(_);
                break;
            case 5:
                this.skip(4);
                break;
            default:
                throw Error("invalid wire type " + _ + " at offset " + this.pos)
        }
        return this
    }, Reader$3._configure = function(_) {
        BufferReader$3 = _, Reader$3.create = create$2(), BufferReader$3._configure();
        var _e = util$7.Long ? "toLong" : "toNumber";
        util$7.merge(Reader$3.prototype, {
            int64: function() {
                return readLongVarint$1.call(this)[_e](!1)
            },
            uint64: function() {
                return readLongVarint$1.call(this)[_e](!0)
            },
            sint64: function() {
                return readLongVarint$1.call(this).zzDecode()[_e](!1)
            },
            fixed64: function() {
                return readFixed64$1.call(this)[_e](!0)
            },
            sfixed64: function() {
                return readFixed64$1.call(this)[_e](!1)
            }
        })
    };
    var reader_buffer$1 = BufferReader$2,
        Reader$2 = reader$1;
    (BufferReader$2.prototype = Object.create(Reader$2.prototype)).constructor = BufferReader$2;
    var util$6 = requireMinimal$1();

    function BufferReader$2(_) {
        Reader$2.call(this, _)
    }
    BufferReader$2._configure = function() {
        util$6.Buffer && (BufferReader$2.prototype._slice = util$6.Buffer.prototype.slice)
    }, BufferReader$2.prototype.string = function _() {
        var _e = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + _e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + _e, this.len))
    }, BufferReader$2._configure();
    var rpc$1 = {},
        service$1 = Service$1,
        util$5 = requireMinimal$1();
    (Service$1.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service$1;

    function Service$1(_, _e, et) {
        if (typeof _ != "function") throw TypeError("rpcImpl must be a function");
        util$5.EventEmitter.call(this), this.rpcImpl = _, this.requestDelimited = !!_e, this.responseDelimited = !!et
    }
    Service$1.prototype.rpcCall = function _(_e, et, tt, nt, ot) {
            if (!nt) throw TypeError("request must be specified");
            var at = this;
            if (!ot) return util$5.asPromise(_, at, _e, et, tt, nt);
            if (!at.rpcImpl) {
                setTimeout(function() {
                    ot(Error("already ended"))
                }, 0);
                return
            }
            try {
                return at.rpcImpl(_e, et[at.requestDelimited ? "encodeDelimited" : "encode"](nt).finish(), function(st, lt) {
                    if (st) return at.emit("error", st, _e), ot(st);
                    if (lt === null) {
                        at.end(!0);
                        return
                    }
                    if (!(lt instanceof tt)) try {
                        lt = tt[at.responseDelimited ? "decodeDelimited" : "decode"](lt)
                    } catch (ut) {
                        return at.emit("error", ut, _e), ot(ut)
                    }
                    return at.emit("data", lt, _e), ot(null, lt)
                })
            } catch (st) {
                at.emit("error", st, _e), setTimeout(function() {
                    ot(st)
                }, 0);
                return
            }
        }, Service$1.prototype.end = function _(_e) {
            return this.rpcImpl && (_e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this
        },
        function(_) {
            var _e = _;
            _e.Service = service$1
        }(rpc$1);
    var roots$1 = {};
    (function(_) {
        var _e = _;
        _e.build = "minimal", _e.Writer = writer$1, _e.BufferWriter = writer_buffer$1, _e.Reader = reader$1, _e.BufferReader = reader_buffer$1, _e.util = requireMinimal$1(), _e.rpc = rpc$1, _e.roots = roots$1, _e.configure = et;

        function et() {
            _e.util._configure(), _e.Writer._configure(_e.BufferWriter), _e.Reader._configure(_e.BufferReader)
        }
        et()
    })(indexMinimal$1);
    var minimal$2 = indexMinimal$1;
    let $protobuf;
    $protobuf = getDefaultExportFromCjs(minimal$2), minimal$3 = _mergeNamespaces$1({
            __proto__: null,
            default: $protobuf
        }, [minimal$2]),
        function() {
            if (typeof window != "object") return;
            if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
                "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                    get: function() {
                        return this.intersectionRatio > 0
                    }
                });
                return
            }

            function _(xt) {
                try {
                    return xt.defaultView && xt.defaultView.frameElement || null
                } catch (yt) {
                    return null
                }
            }
            var _e = function(xt) {
                    for (var yt = xt, Et = _(yt); Et;) yt = Et.ownerDocument, Et = _(yt);
                    return yt
                }(window.document),
                et = [],
                tt = null,
                nt = null;

            function ot(xt) {
                this.time = xt.time, this.target = xt.target, this.rootBounds = ht(xt.rootBounds), this.boundingClientRect = ht(xt.boundingClientRect), this.intersectionRect = ht(xt.intersectionRect || ft()), this.isIntersecting = !!xt.intersectionRect;
                var yt = this.boundingClientRect,
                    Et = yt.width * yt.height,
                    wt = this.intersectionRect,
                    St = wt.width * wt.height;
                Et ? this.intersectionRatio = Number((St / Et).toFixed(4)) : this.intersectionRatio = this.isIntersecting ? 1 : 0
            }

            function at(xt, yt) {
                var Et = yt || {};
                if (typeof xt != "function") throw new Error("callback must be a function");
                if (Et.root && Et.root.nodeType != 1 && Et.root.nodeType != 9) throw new Error("root must be a Document or Element");
                this._checkForIntersections = lt(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT), this._callback = xt, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(Et.rootMargin), this.thresholds = this._initThresholds(Et.threshold), this.root = Et.root || null, this.rootMargin = this._rootMarginValues.map(function(wt) {
                    return wt.value + wt.unit
                }).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = []
            }
            at.prototype.THROTTLE_TIMEOUT = 100, at.prototype.POLL_INTERVAL = null, at.prototype.USE_MUTATION_OBSERVER = !0, at._setupCrossOriginUpdater = function() {
                return tt || (tt = function(xt, yt) {
                    !xt || !yt ? nt = ft() : nt = mt(xt, yt), et.forEach(function(Et) {
                        Et._checkForIntersections()
                    })
                }), tt
            }, at._resetCrossOriginUpdater = function() {
                tt = null, nt = null
            }, at.prototype.observe = function(xt) {
                var yt = this._observationTargets.some(function(Et) {
                    return Et.element == xt
                });
                if (!yt) {
                    if (!(xt && xt.nodeType == 1)) throw new Error("target must be an Element");
                    this._registerInstance(), this._observationTargets.push({
                        element: xt,
                        entry: null
                    }), this._monitorIntersections(xt.ownerDocument), this._checkForIntersections()
                }
            }, at.prototype.unobserve = function(xt) {
                this._observationTargets = this._observationTargets.filter(function(yt) {
                    return yt.element != xt
                }), this._unmonitorIntersections(xt.ownerDocument), this._observationTargets.length == 0 && this._unregisterInstance()
            }, at.prototype.disconnect = function() {
                this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance()
            }, at.prototype.takeRecords = function() {
                var xt = this._queuedEntries.slice();
                return this._queuedEntries = [], xt
            }, at.prototype._initThresholds = function(xt) {
                var yt = xt || [0];
                return Array.isArray(yt) || (yt = [yt]), yt.sort().filter(function(Et, wt, St) {
                    if (typeof Et != "number" || isNaN(Et) || Et < 0 || Et > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                    return Et !== St[wt - 1]
                })
            }, at.prototype._parseRootMargin = function(xt) {
                var yt = xt || "0px",
                    Et = yt.split(/\s+/).map(function(wt) {
                        var St = /^(-?\d*\.?\d+)(px|%)$/.exec(wt);
                        if (!St) throw new Error("rootMargin must be specified in pixels or percent");
                        return {
                            value: parseFloat(St[1]),
                            unit: St[2]
                        }
                    });
                return Et[1] = Et[1] || Et[0], Et[2] = Et[2] || Et[0], Et[3] = Et[3] || Et[1], Et
            }, at.prototype._monitorIntersections = function(xt) {
                var yt = xt.defaultView;
                if (yt && this._monitoringDocuments.indexOf(xt) == -1) {
                    var Et = this._checkForIntersections,
                        wt = null,
                        St = null;
                    this.POLL_INTERVAL ? wt = yt.setInterval(Et, this.POLL_INTERVAL) : (ut(yt, "resize", Et, !0), ut(xt, "scroll", Et, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in yt && (St = new yt.MutationObserver(Et), St.observe(xt, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    }))), this._monitoringDocuments.push(xt), this._monitoringUnsubscribes.push(function() {
                        var Rt = xt.defaultView;
                        Rt && (wt && Rt.clearInterval(wt), dt(Rt, "resize", Et, !0)), dt(xt, "scroll", Et, !0), St && St.disconnect()
                    });
                    var $t = this.root && (this.root.ownerDocument || this.root) || _e;
                    if (xt != $t) {
                        var Ct = _(xt);
                        Ct && this._monitorIntersections(Ct.ownerDocument)
                    }
                }
            }, at.prototype._unmonitorIntersections = function(xt) {
                var yt = this._monitoringDocuments.indexOf(xt);
                if (yt != -1) {
                    var Et = this.root && (this.root.ownerDocument || this.root) || _e,
                        wt = this._observationTargets.some(function(Ct) {
                            var Rt = Ct.element.ownerDocument;
                            if (Rt == xt) return !0;
                            for (; Rt && Rt != Et;) {
                                var Pt = _(Rt);
                                if (Rt = Pt && Pt.ownerDocument, Rt == xt) return !0
                            }
                            return !1
                        });
                    if (!wt) {
                        var St = this._monitoringUnsubscribes[yt];
                        if (this._monitoringDocuments.splice(yt, 1), this._monitoringUnsubscribes.splice(yt, 1), St(), xt != Et) {
                            var $t = _(xt);
                            $t && this._unmonitorIntersections($t.ownerDocument)
                        }
                    }
                }
            }, at.prototype._unmonitorAllIntersections = function() {
                var xt = this._monitoringUnsubscribes.slice(0);
                this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
                for (var yt = 0; yt < xt.length; yt++) xt[yt]()
            }, at.prototype._checkForIntersections = function() {
                if (!(!this.root && tt && !nt)) {
                    var xt = this._rootIsInDom(),
                        yt = xt ? this._getRootRect() : ft();
                    this._observationTargets.forEach(function(Et) {
                        var wt = Et.element,
                            St = pt(wt),
                            $t = this._rootContainsTarget(wt),
                            Ct = Et.entry,
                            Rt = xt && $t && this._computeTargetAndRootIntersection(wt, St, yt),
                            Pt = null;
                        this._rootContainsTarget(wt) ? (!tt || this.root) && (Pt = yt) : Pt = ft();
                        var Tt = Et.entry = new ot({
                            time: st(),
                            target: wt,
                            boundingClientRect: St,
                            rootBounds: Pt,
                            intersectionRect: Rt
                        });
                        Ct ? xt && $t ? this._hasCrossedThreshold(Ct, Tt) && this._queuedEntries.push(Tt) : Ct && Ct.isIntersecting && this._queuedEntries.push(Tt) : this._queuedEntries.push(Tt)
                    }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
                }
            }, at.prototype._computeTargetAndRootIntersection = function(xt, yt, Et) {
                if (window.getComputedStyle(xt).display != "none") {
                    for (var wt = yt, St = gt(xt), $t = !1; !$t && St;) {
                        var Ct = null,
                            Rt = St.nodeType == 1 ? window.getComputedStyle(St) : {};
                        if (Rt.display == "none") return null;
                        if (St == this.root || St.nodeType == 9)
                            if ($t = !0, St == this.root || St == _e) tt && !this.root ? !nt || nt.width == 0 && nt.height == 0 ? (St = null, Ct = null, wt = null) : Ct = nt : Ct = Et;
                            else {
                                var Pt = gt(St),
                                    Tt = Pt && pt(Pt),
                                    It = Pt && this._computeTargetAndRootIntersection(Pt, Tt, Et);
                                Tt && It ? (St = Pt, Ct = mt(Tt, It)) : (St = null, wt = null)
                            }
                        else {
                            var Ot = St.ownerDocument;
                            St != Ot.body && St != Ot.documentElement && Rt.overflow != "visible" && (Ct = pt(St))
                        }
                        if (Ct && (wt = ct(Ct, wt)), !wt) break;
                        St = St && gt(St)
                    }
                    return wt
                }
            }, at.prototype._getRootRect = function() {
                var xt;
                if (this.root && !vt(this.root)) xt = pt(this.root);
                else {
                    var yt = vt(this.root) ? this.root : _e,
                        Et = yt.documentElement,
                        wt = yt.body;
                    xt = {
                        top: 0,
                        left: 0,
                        right: Et.clientWidth || wt.clientWidth,
                        width: Et.clientWidth || wt.clientWidth,
                        bottom: Et.clientHeight || wt.clientHeight,
                        height: Et.clientHeight || wt.clientHeight
                    }
                }
                return this._expandRectByRootMargin(xt)
            }, at.prototype._expandRectByRootMargin = function(xt) {
                var yt = this._rootMarginValues.map(function(wt, St) {
                        return wt.unit == "px" ? wt.value : wt.value * (St % 2 ? xt.width : xt.height) / 100
                    }),
                    Et = {
                        top: xt.top - yt[0],
                        right: xt.right + yt[1],
                        bottom: xt.bottom + yt[2],
                        left: xt.left - yt[3]
                    };
                return Et.width = Et.right - Et.left, Et.height = Et.bottom - Et.top, Et
            }, at.prototype._hasCrossedThreshold = function(xt, yt) {
                var Et = xt && xt.isIntersecting ? xt.intersectionRatio || 0 : -1,
                    wt = yt.isIntersecting ? yt.intersectionRatio || 0 : -1;
                if (Et !== wt)
                    for (var St = 0; St < this.thresholds.length; St++) {
                        var $t = this.thresholds[St];
                        if ($t == Et || $t == wt || $t < Et != $t < wt) return !0
                    }
            }, at.prototype._rootIsInDom = function() {
                return !this.root || bt(_e, this.root)
            }, at.prototype._rootContainsTarget = function(xt) {
                var yt = this.root && (this.root.ownerDocument || this.root) || _e;
                return bt(yt, xt) && (!this.root || yt == xt.ownerDocument)
            }, at.prototype._registerInstance = function() {
                et.indexOf(this) < 0 && et.push(this)
            }, at.prototype._unregisterInstance = function() {
                var xt = et.indexOf(this);
                xt != -1 && et.splice(xt, 1)
            };

            function st() {
                return window.performance && performance.now && performance.now()
            }

            function lt(xt, yt) {
                var Et = null;
                return function() {
                    Et || (Et = setTimeout(function() {
                        xt(), Et = null
                    }, yt))
                }
            }

            function ut(xt, yt, Et, wt) {
                typeof xt.addEventListener == "function" ? xt.addEventListener(yt, Et, wt || !1) : typeof xt.attachEvent == "function" && xt.attachEvent("on" + yt, Et)
            }

            function dt(xt, yt, Et, wt) {
                typeof xt.removeEventListener == "function" ? xt.removeEventListener(yt, Et, wt || !1) : typeof xt.detachEvent == "function" && xt.detachEvent("on" + yt, Et)
            }

            function ct(xt, yt) {
                var Et = Math.max(xt.top, yt.top),
                    wt = Math.min(xt.bottom, yt.bottom),
                    St = Math.max(xt.left, yt.left),
                    $t = Math.min(xt.right, yt.right),
                    Ct = $t - St,
                    Rt = wt - Et;
                return Ct >= 0 && Rt >= 0 && {
                    top: Et,
                    bottom: wt,
                    left: St,
                    right: $t,
                    width: Ct,
                    height: Rt
                } || null
            }

            function pt(xt) {
                var yt;
                try {
                    yt = xt.getBoundingClientRect()
                } catch (Et) {}
                return yt ? (yt.width && yt.height || (yt = {
                    top: yt.top,
                    right: yt.right,
                    bottom: yt.bottom,
                    left: yt.left,
                    width: yt.right - yt.left,
                    height: yt.bottom - yt.top
                }), yt) : ft()
            }

            function ft() {
                return {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0
                }
            }

            function ht(xt) {
                return !xt || "x" in xt ? xt : {
                    top: xt.top,
                    y: xt.top,
                    bottom: xt.bottom,
                    left: xt.left,
                    x: xt.left,
                    right: xt.right,
                    width: xt.width,
                    height: xt.height
                }
            }

            function mt(xt, yt) {
                var Et = yt.top - xt.top,
                    wt = yt.left - xt.left;
                return {
                    top: Et,
                    left: wt,
                    height: yt.height,
                    width: yt.width,
                    bottom: Et + yt.height,
                    right: wt + yt.width
                }
            }

            function bt(xt, yt) {
                for (var Et = yt; Et;) {
                    if (Et == xt) return !0;
                    Et = gt(Et)
                }
                return !1
            }

            function gt(xt) {
                var yt = xt.parentNode;
                return xt.nodeType == 9 && xt != _e ? _(xt) : (yt && yt.assignedSlot && (yt = yt.assignedSlot.parentNode), yt && yt.nodeType == 11 && yt.host ? yt.host : yt)
            }

            function vt(xt) {
                return xt && xt.nodeType === 9
            }
            window.IntersectionObserver = at, window.IntersectionObserverEntry = ot
        }();
    var MAX_DIGITS = 1e9,
        defaults = {
            precision: 20,
            rounding: 4,
            toExpNeg: -7,
            toExpPos: 21,
            LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
        },
        Decimal, external = !0,
        decimalError = "[DecimalError] ",
        invalidArgument = decimalError + "Invalid argument: ",
        exponentOutOfRange = decimalError + "Exponent out of range: ",
        mathfloor = Math.floor,
        mathpow = Math.pow,
        isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        ONE$1, BASE = 1e7,
        LOG_BASE = 7,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),
        P$1 = {};
    P$1.absoluteValue = P$1.abs = function() {
        var _ = new this.constructor(this);
        return _.s && (_.s = 1), _
    }, P$1.comparedTo = P$1.cmp = function(_) {
        var _e, et, tt, nt, ot = this;
        if (_ = new ot.constructor(_), ot.s !== _.s) return ot.s || -_.s;
        if (ot.e !== _.e) return ot.e > _.e ^ ot.s < 0 ? 1 : -1;
        for (tt = ot.d.length, nt = _.d.length, _e = 0, et = tt < nt ? tt : nt; _e < et; ++_e)
            if (ot.d[_e] !== _.d[_e]) return ot.d[_e] > _.d[_e] ^ ot.s < 0 ? 1 : -1;
        return tt === nt ? 0 : tt > nt ^ ot.s < 0 ? 1 : -1
    }, P$1.decimalPlaces = P$1.dp = function() {
        var _ = this,
            _e = _.d.length - 1,
            et = (_e - _.e) * LOG_BASE;
        if (_e = _.d[_e], _e)
            for (; _e % 10 == 0; _e /= 10) et--;
        return et < 0 ? 0 : et
    }, P$1.dividedBy = P$1.div = function(_) {
        return divide(this, new this.constructor(_))
    }, P$1.dividedToIntegerBy = P$1.idiv = function(_) {
        var _e = this,
            et = _e.constructor;
        return round(divide(_e, new et(_), 0, 1), et.precision)
    }, P$1.equals = P$1.eq = function(_) {
        return !this.cmp(_)
    }, P$1.exponent = function() {
        return getBase10Exponent(this)
    }, P$1.greaterThan = P$1.gt = function(_) {
        return this.cmp(_) > 0
    }, P$1.greaterThanOrEqualTo = P$1.gte = function(_) {
        return this.cmp(_) >= 0
    }, P$1.isInteger = P$1.isint = function() {
        return this.e > this.d.length - 2
    }, P$1.isNegative = P$1.isneg = function() {
        return this.s < 0
    }, P$1.isPositive = P$1.ispos = function() {
        return this.s > 0
    }, P$1.isZero = function() {
        return this.s === 0
    }, P$1.lessThan = P$1.lt = function(_) {
        return this.cmp(_) < 0
    }, P$1.lessThanOrEqualTo = P$1.lte = function(_) {
        return this.cmp(_) < 1
    }, P$1.logarithm = P$1.log = function(_) {
        var _e, et = this,
            tt = et.constructor,
            nt = tt.precision,
            ot = nt + 5;
        if (_ === void 0) _ = new tt(10);
        else if (_ = new tt(_), _.s < 1 || _.eq(ONE$1)) throw Error(decimalError + "NaN");
        if (et.s < 1) throw Error(decimalError + (et.s ? "NaN" : "-Infinity"));
        return et.eq(ONE$1) ? new tt(0) : (external = !1, _e = divide(ln(et, ot), ln(_, ot), ot), external = !0, round(_e, nt))
    }, P$1.minus = P$1.sub = function(_) {
        var _e = this;
        return _ = new _e.constructor(_), _e.s == _.s ? subtract(_e, _) : add(_e, (_.s = -_.s, _))
    }, P$1.modulo = P$1.mod = function(_) {
        var _e, et = this,
            tt = et.constructor,
            nt = tt.precision;
        if (_ = new tt(_), !_.s) throw Error(decimalError + "NaN");
        return et.s ? (external = !1, _e = divide(et, _, 0, 1).times(_), external = !0, et.minus(_e)) : round(new tt(et), nt)
    }, P$1.naturalExponential = P$1.exp = function() {
        return exp(this)
    }, P$1.naturalLogarithm = P$1.ln = function() {
        return ln(this)
    }, P$1.negated = P$1.neg = function() {
        var _ = new this.constructor(this);
        return _.s = -_.s || 0, _
    }, P$1.plus = P$1.add = function(_) {
        var _e = this;
        return _ = new _e.constructor(_), _e.s == _.s ? add(_e, _) : subtract(_e, (_.s = -_.s, _))
    }, P$1.precision = P$1.sd = function(_) {
        var _e, et, tt, nt = this;
        if (_ !== void 0 && _ !== !!_ && _ !== 1 && _ !== 0) throw Error(invalidArgument + _);
        if (_e = getBase10Exponent(nt) + 1, tt = nt.d.length - 1, et = tt * LOG_BASE + 1, tt = nt.d[tt], tt) {
            for (; tt % 10 == 0; tt /= 10) et--;
            for (tt = nt.d[0]; tt >= 10; tt /= 10) et++
        }
        return _ && _e > et ? _e : et
    }, P$1.squareRoot = P$1.sqrt = function() {
        var _, _e, et, tt, nt, ot, at, st = this,
            lt = st.constructor;
        if (st.s < 1) {
            if (!st.s) return new lt(0);
            throw Error(decimalError + "NaN")
        }
        for (_ = getBase10Exponent(st), external = !1, nt = Math.sqrt(+st), nt == 0 || nt == 1 / 0 ? (_e = digitsToString(st.d), (_e.length + _) % 2 == 0 && (_e += "0"), nt = Math.sqrt(_e), _ = mathfloor((_ + 1) / 2) - (_ < 0 || _ % 2), nt == 1 / 0 ? _e = "5e" + _ : (_e = nt.toExponential(), _e = _e.slice(0, _e.indexOf("e") + 1) + _), tt = new lt(_e)) : tt = new lt(nt.toString()), et = lt.precision, nt = at = et + 3;;)
            if (ot = tt, tt = ot.plus(divide(st, ot, at + 2)).times(.5), digitsToString(ot.d).slice(0, at) === (_e = digitsToString(tt.d)).slice(0, at)) {
                if (_e = _e.slice(at - 3, at + 1), nt == at && _e == "4999") {
                    if (round(ot, et + 1, 0), ot.times(ot).eq(st)) {
                        tt = ot;
                        break
                    }
                } else if (_e != "9999") break;
                at += 4
            }
        return external = !0, round(tt, et)
    }, P$1.times = P$1.mul = function(_) {
        var _e, et, tt, nt, ot, at, st, lt, ut, dt = this,
            ct = dt.constructor,
            pt = dt.d,
            ft = (_ = new ct(_)).d;
        if (!dt.s || !_.s) return new ct(0);
        for (_.s *= dt.s, et = dt.e + _.e, lt = pt.length, ut = ft.length, lt < ut && (ot = pt, pt = ft, ft = ot, at = lt, lt = ut, ut = at), ot = [], at = lt + ut, tt = at; tt--;) ot.push(0);
        for (tt = ut; --tt >= 0;) {
            for (_e = 0, nt = lt + tt; nt > tt;) st = ot[nt] + ft[tt] * pt[nt - tt - 1] + _e, ot[nt--] = st % BASE | 0, _e = st / BASE | 0;
            ot[nt] = (ot[nt] + _e) % BASE | 0
        }
        for (; !ot[--at];) ot.pop();
        return _e ? ++et : ot.shift(), _.d = ot, _.e = et, external ? round(_, ct.precision) : _
    }, P$1.toDecimalPlaces = P$1.todp = function(_, _e) {
        var et = this,
            tt = et.constructor;
        return et = new tt(et), _ === void 0 ? et : (checkInt32(_, 0, MAX_DIGITS), _e === void 0 ? _e = tt.rounding : checkInt32(_e, 0, 8), round(et, _ + getBase10Exponent(et) + 1, _e))
    }, P$1.toExponential = function(_, _e) {
        var et, tt = this,
            nt = tt.constructor;
        return _ === void 0 ? et = toString$3(tt, !0) : (checkInt32(_, 0, MAX_DIGITS), _e === void 0 ? _e = nt.rounding : checkInt32(_e, 0, 8), tt = round(new nt(tt), _ + 1, _e), et = toString$3(tt, !0, _ + 1)), et
    }, P$1.toFixed = function(_, _e) {
        var et, tt, nt = this,
            ot = nt.constructor;
        return _ === void 0 ? toString$3(nt) : (checkInt32(_, 0, MAX_DIGITS), _e === void 0 ? _e = ot.rounding : checkInt32(_e, 0, 8), tt = round(new ot(nt), _ + getBase10Exponent(nt) + 1, _e), et = toString$3(tt.abs(), !1, _ + getBase10Exponent(tt) + 1), nt.isneg() && !nt.isZero() ? "-" + et : et)
    }, P$1.toInteger = P$1.toint = function() {
        var _ = this,
            _e = _.constructor;
        return round(new _e(_), getBase10Exponent(_) + 1, _e.rounding)
    }, P$1.toNumber = function() {
        return +this
    }, P$1.toPower = P$1.pow = function(_) {
        var _e, et, tt, nt, ot, at, st = this,
            lt = st.constructor,
            ut = 12,
            dt = +(_ = new lt(_));
        if (!_.s) return new lt(ONE$1);
        if (st = new lt(st), !st.s) {
            if (_.s < 1) throw Error(decimalError + "Infinity");
            return st
        }
        if (st.eq(ONE$1)) return st;
        if (tt = lt.precision, _.eq(ONE$1)) return round(st, tt);
        if (_e = _.e, et = _.d.length - 1, at = _e >= et, ot = st.s, at) {
            if ((et = dt < 0 ? -dt : dt) <= MAX_SAFE_INTEGER) {
                for (nt = new lt(ONE$1), _e = Math.ceil(tt / LOG_BASE + 4), external = !1; et % 2 && (nt = nt.times(st), truncate(nt.d, _e)), et = mathfloor(et / 2), et !== 0;) st = st.times(st), truncate(st.d, _e);
                return external = !0, _.s < 0 ? new lt(ONE$1).div(nt) : round(nt, tt)
            }
        } else if (ot < 0) throw Error(decimalError + "NaN");
        return ot = ot < 0 && _.d[Math.max(_e, et)] & 1 ? -1 : 1, st.s = 1, external = !1, nt = _.times(ln(st, tt + ut)), external = !0, nt = exp(nt), nt.s = ot, nt
    }, P$1.toPrecision = function(_, _e) {
        var et, tt, nt = this,
            ot = nt.constructor;
        return _ === void 0 ? (et = getBase10Exponent(nt), tt = toString$3(nt, et <= ot.toExpNeg || et >= ot.toExpPos)) : (checkInt32(_, 1, MAX_DIGITS), _e === void 0 ? _e = ot.rounding : checkInt32(_e, 0, 8), nt = round(new ot(nt), _, _e), et = getBase10Exponent(nt), tt = toString$3(nt, _ <= et || et <= ot.toExpNeg, _)), tt
    }, P$1.toSignificantDigits = P$1.tosd = function(_, _e) {
        var et = this,
            tt = et.constructor;
        return _ === void 0 ? (_ = tt.precision, _e = tt.rounding) : (checkInt32(_, 1, MAX_DIGITS), _e === void 0 ? _e = tt.rounding : checkInt32(_e, 0, 8)), round(new tt(et), _, _e)
    }, P$1.toString = P$1.valueOf = P$1.val = P$1.toJSON = P$1[Symbol.for("nodejs.util.inspect.custom")] = function() {
        var _ = this,
            _e = getBase10Exponent(_),
            et = _.constructor;
        return toString$3(_, _e <= et.toExpNeg || _e >= et.toExpPos)
    };

    function add(_, _e) {
        var et, tt, nt, ot, at, st, lt, ut, dt = _.constructor,
            ct = dt.precision;
        if (!_.s || !_e.s) return _e.s || (_e = new dt(_)), external ? round(_e, ct) : _e;
        if (lt = _.d, ut = _e.d, at = _.e, nt = _e.e, lt = lt.slice(), ot = at - nt, ot) {
            for (ot < 0 ? (tt = lt, ot = -ot, st = ut.length) : (tt = ut, nt = at, st = lt.length), at = Math.ceil(ct / LOG_BASE), st = at > st ? at + 1 : st + 1, ot > st && (ot = st, tt.length = 1), tt.reverse(); ot--;) tt.push(0);
            tt.reverse()
        }
        for (st = lt.length, ot = ut.length, st - ot < 0 && (ot = st, tt = ut, ut = lt, lt = tt), et = 0; ot;) et = (lt[--ot] = lt[ot] + ut[ot] + et) / BASE | 0, lt[ot] %= BASE;
        for (et && (lt.unshift(et), ++nt), st = lt.length; lt[--st] == 0;) lt.pop();
        return _e.d = lt, _e.e = nt, external ? round(_e, ct) : _e
    }

    function checkInt32(_, _e, et) {
        if (_ !== ~~_ || _ < _e || _ > et) throw Error(invalidArgument + _)
    }

    function digitsToString(_) {
        var _e, et, tt, nt = _.length - 1,
            ot = "",
            at = _[0];
        if (nt > 0) {
            for (ot += at, _e = 1; _e < nt; _e++) tt = _[_e] + "", et = LOG_BASE - tt.length, et && (ot += getZeroString(et)), ot += tt;
            at = _[_e], tt = at + "", et = LOG_BASE - tt.length, et && (ot += getZeroString(et))
        } else if (at === 0) return "0";
        for (; at % 10 === 0;) at /= 10;
        return ot + at
    }
    var divide = function() {
        function _(tt, nt) {
            var ot, at = 0,
                st = tt.length;
            for (tt = tt.slice(); st--;) ot = tt[st] * nt + at, tt[st] = ot % BASE | 0, at = ot / BASE | 0;
            return at && tt.unshift(at), tt
        }

        function _e(tt, nt, ot, at) {
            var st, lt;
            if (ot != at) lt = ot > at ? 1 : -1;
            else
                for (st = lt = 0; st < ot; st++)
                    if (tt[st] != nt[st]) {
                        lt = tt[st] > nt[st] ? 1 : -1;
                        break
                    } return lt
        }

        function et(tt, nt, ot) {
            for (var at = 0; ot--;) tt[ot] -= at, at = tt[ot] < nt[ot] ? 1 : 0, tt[ot] = at * BASE + tt[ot] - nt[ot];
            for (; !tt[0] && tt.length > 1;) tt.shift()
        }
        return function(tt, nt, ot, at) {
            var st, lt, ut, dt, ct, pt, ft, ht, mt, bt, gt, vt, xt, yt, Et, wt, St, $t, Ct = tt.constructor,
                Rt = tt.s == nt.s ? 1 : -1,
                Pt = tt.d,
                Tt = nt.d;
            if (!tt.s) return new Ct(tt);
            if (!nt.s) throw Error(decimalError + "Division by zero");
            for (lt = tt.e - nt.e, St = Tt.length, Et = Pt.length, ft = new Ct(Rt), ht = ft.d = [], ut = 0; Tt[ut] == (Pt[ut] || 0);) ++ut;
            if (Tt[ut] > (Pt[ut] || 0) && --lt, ot == null ? vt = ot = Ct.precision : at ? vt = ot + (getBase10Exponent(tt) - getBase10Exponent(nt)) + 1 : vt = ot, vt < 0) return new Ct(0);
            if (vt = vt / LOG_BASE + 2 | 0, ut = 0, St == 1)
                for (dt = 0, Tt = Tt[0], vt++;
                    (ut < Et || dt) && vt--; ut++) xt = dt * BASE + (Pt[ut] || 0), ht[ut] = xt / Tt | 0, dt = xt % Tt | 0;
            else {
                for (dt = BASE / (Tt[0] + 1) | 0, dt > 1 && (Tt = _(Tt, dt), Pt = _(Pt, dt), St = Tt.length, Et = Pt.length), yt = St, mt = Pt.slice(0, St), bt = mt.length; bt < St;) mt[bt++] = 0;
                $t = Tt.slice(), $t.unshift(0), wt = Tt[0], Tt[1] >= BASE / 2 && ++wt;
                do dt = 0, st = _e(Tt, mt, St, bt), st < 0 ? (gt = mt[0], St != bt && (gt = gt * BASE + (mt[1] || 0)), dt = gt / wt | 0, dt > 1 ? (dt >= BASE && (dt = BASE - 1), ct = _(Tt, dt), pt = ct.length, bt = mt.length, st = _e(ct, mt, pt, bt), st == 1 && (dt--, et(ct, St < pt ? $t : Tt, pt))) : (dt == 0 && (st = dt = 1), ct = Tt.slice()), pt = ct.length, pt < bt && ct.unshift(0), et(mt, ct, bt), st == -1 && (bt = mt.length, st = _e(Tt, mt, St, bt), st < 1 && (dt++, et(mt, St < bt ? $t : Tt, bt))), bt = mt.length) : st === 0 && (dt++, mt = [0]), ht[ut++] = dt, st && mt[0] ? mt[bt++] = Pt[yt] || 0 : (mt = [Pt[yt]], bt = 1); while ((yt++ < Et || mt[0] !== void 0) && vt--)
            }
            return ht[0] || ht.shift(), ft.e = lt, round(ft, at ? ot + getBase10Exponent(ft) + 1 : ot)
        }
    }();

    function exp(_, _e) {
        var et, tt, nt, ot, at, st, lt = 0,
            ut = 0,
            dt = _.constructor,
            ct = dt.precision;
        if (getBase10Exponent(_) > 16) throw Error(exponentOutOfRange + getBase10Exponent(_));
        if (!_.s) return new dt(ONE$1);
        for (_e == null ? (external = !1, st = ct) : st = _e, at = new dt(.03125); _.abs().gte(.1);) _ = _.times(at), ut += 5;
        for (tt = Math.log(mathpow(2, ut)) / Math.LN10 * 2 + 5 | 0, st += tt, et = nt = ot = new dt(ONE$1), dt.precision = st;;) {
            if (nt = round(nt.times(_), st), et = et.times(++lt), at = ot.plus(divide(nt, et, st)), digitsToString(at.d).slice(0, st) === digitsToString(ot.d).slice(0, st)) {
                for (; ut--;) ot = round(ot.times(ot), st);
                return dt.precision = ct, _e == null ? (external = !0, round(ot, ct)) : ot
            }
            ot = at
        }
    }

    function getBase10Exponent(_) {
        for (var _e = _.e * LOG_BASE, et = _.d[0]; et >= 10; et /= 10) _e++;
        return _e
    }

    function getLn10(_, _e, et) {
        if (_e > _.LN10.sd()) throw external = !0, et && (_.precision = et), Error(decimalError + "LN10 precision limit exceeded");
        return round(new _(_.LN10), _e)
    }

    function getZeroString(_) {
        for (var _e = ""; _--;) _e += "0";
        return _e
    }

    function ln(_, _e) {
        var et, tt, nt, ot, at, st, lt, ut, dt, ct = 1,
            pt = 10,
            ft = _,
            ht = ft.d,
            mt = ft.constructor,
            bt = mt.precision;
        if (ft.s < 1) throw Error(decimalError + (ft.s ? "NaN" : "-Infinity"));
        if (ft.eq(ONE$1)) return new mt(0);
        if (_e == null ? (external = !1, ut = bt) : ut = _e, ft.eq(10)) return _e == null && (external = !0), getLn10(mt, ut);
        if (ut += pt, mt.precision = ut, et = digitsToString(ht), tt = et.charAt(0), ot = getBase10Exponent(ft), Math.abs(ot) < 15e14) {
            for (; tt < 7 && tt != 1 || tt == 1 && et.charAt(1) > 3;) ft = ft.times(_), et = digitsToString(ft.d), tt = et.charAt(0), ct++;
            ot = getBase10Exponent(ft), tt > 1 ? (ft = new mt("0." + et), ot++) : ft = new mt(tt + "." + et.slice(1))
        } else return lt = getLn10(mt, ut + 2, bt).times(ot + ""), ft = ln(new mt(tt + "." + et.slice(1)), ut - pt).plus(lt), mt.precision = bt, _e == null ? (external = !0, round(ft, bt)) : ft;
        for (st = at = ft = divide(ft.minus(ONE$1), ft.plus(ONE$1), ut), dt = round(ft.times(ft), ut), nt = 3;;) {
            if (at = round(at.times(dt), ut), lt = st.plus(divide(at, new mt(nt), ut)), digitsToString(lt.d).slice(0, ut) === digitsToString(st.d).slice(0, ut)) return st = st.times(2), ot !== 0 && (st = st.plus(getLn10(mt, ut + 2, bt).times(ot + ""))), st = divide(st, new mt(ct), ut), mt.precision = bt, _e == null ? (external = !0, round(st, bt)) : st;
            st = lt, nt += 2
        }
    }

    function parseDecimal(_, _e) {
        var et, tt, nt;
        for ((et = _e.indexOf(".")) > -1 && (_e = _e.replace(".", "")), (tt = _e.search(/e/i)) > 0 ? (et < 0 && (et = tt), et += +_e.slice(tt + 1), _e = _e.substring(0, tt)) : et < 0 && (et = _e.length), tt = 0; _e.charCodeAt(tt) === 48;) ++tt;
        for (nt = _e.length; _e.charCodeAt(nt - 1) === 48;) --nt;
        if (_e = _e.slice(tt, nt), _e) {
            if (nt -= tt, et = et - tt - 1, _.e = mathfloor(et / LOG_BASE), _.d = [], tt = (et + 1) % LOG_BASE, et < 0 && (tt += LOG_BASE), tt < nt) {
                for (tt && _.d.push(+_e.slice(0, tt)), nt -= LOG_BASE; tt < nt;) _.d.push(+_e.slice(tt, tt += LOG_BASE));
                _e = _e.slice(tt), tt = LOG_BASE - _e.length
            } else tt -= nt;
            for (; tt--;) _e += "0";
            if (_.d.push(+_e), external && (_.e > MAX_E || _.e < -MAX_E)) throw Error(exponentOutOfRange + et)
        } else _.s = 0, _.e = 0, _.d = [0];
        return _
    }

    function round(_, _e, et) {
        var tt, nt, ot, at, st, lt, ut, dt, ct = _.d;
        for (at = 1, ot = ct[0]; ot >= 10; ot /= 10) at++;
        if (tt = _e - at, tt < 0) tt += LOG_BASE, nt = _e, ut = ct[dt = 0];
        else {
            if (dt = Math.ceil((tt + 1) / LOG_BASE), ot = ct.length, dt >= ot) return _;
            for (ut = ot = ct[dt], at = 1; ot >= 10; ot /= 10) at++;
            tt %= LOG_BASE, nt = tt - LOG_BASE + at
        }
        if (et !== void 0 && (ot = mathpow(10, at - nt - 1), st = ut / ot % 10 | 0, lt = _e < 0 || ct[dt + 1] !== void 0 || ut % ot, lt = et < 4 ? (st || lt) && (et == 0 || et == (_.s < 0 ? 3 : 2)) : st > 5 || st == 5 && (et == 4 || lt || et == 6 && (tt > 0 ? nt > 0 ? ut / mathpow(10, at - nt) : 0 : ct[dt - 1]) % 10 & 1 || et == (_.s < 0 ? 8 : 7))), _e < 1 || !ct[0]) return lt ? (ot = getBase10Exponent(_), ct.length = 1, _e = _e - ot - 1, ct[0] = mathpow(10, (LOG_BASE - _e % LOG_BASE) % LOG_BASE), _.e = mathfloor(-_e / LOG_BASE) || 0) : (ct.length = 1, ct[0] = _.e = _.s = 0), _;
        if (tt == 0 ? (ct.length = dt, ot = 1, dt--) : (ct.length = dt + 1, ot = mathpow(10, LOG_BASE - tt), ct[dt] = nt > 0 ? (ut / mathpow(10, at - nt) % mathpow(10, nt) | 0) * ot : 0), lt)
            for (;;)
                if (dt == 0) {
                    (ct[0] += ot) == BASE && (ct[0] = 1, ++_.e);
                    break
                } else {
                    if (ct[dt] += ot, ct[dt] != BASE) break;
                    ct[dt--] = 0, ot = 1
                }
        for (tt = ct.length; ct[--tt] === 0;) ct.pop();
        if (external && (_.e > MAX_E || _.e < -MAX_E)) throw Error(exponentOutOfRange + getBase10Exponent(_));
        return _
    }

    function subtract(_, _e) {
        var et, tt, nt, ot, at, st, lt, ut, dt, ct, pt = _.constructor,
            ft = pt.precision;
        if (!_.s || !_e.s) return _e.s ? _e.s = -_e.s : _e = new pt(_), external ? round(_e, ft) : _e;
        if (lt = _.d, ct = _e.d, tt = _e.e, ut = _.e, lt = lt.slice(), at = ut - tt, at) {
            for (dt = at < 0, dt ? (et = lt, at = -at, st = ct.length) : (et = ct, tt = ut, st = lt.length), nt = Math.max(Math.ceil(ft / LOG_BASE), st) + 2, at > nt && (at = nt, et.length = 1), et.reverse(), nt = at; nt--;) et.push(0);
            et.reverse()
        } else {
            for (nt = lt.length, st = ct.length, dt = nt < st, dt && (st = nt), nt = 0; nt < st; nt++)
                if (lt[nt] != ct[nt]) {
                    dt = lt[nt] < ct[nt];
                    break
                }
            at = 0
        }
        for (dt && (et = lt, lt = ct, ct = et, _e.s = -_e.s), st = lt.length, nt = ct.length - st; nt > 0; --nt) lt[st++] = 0;
        for (nt = ct.length; nt > at;) {
            if (lt[--nt] < ct[nt]) {
                for (ot = nt; ot && lt[--ot] === 0;) lt[ot] = BASE - 1;
                --lt[ot], lt[nt] += BASE
            }
            lt[nt] -= ct[nt]
        }
        for (; lt[--st] === 0;) lt.pop();
        for (; lt[0] === 0; lt.shift()) --tt;
        return lt[0] ? (_e.d = lt, _e.e = tt, external ? round(_e, ft) : _e) : new pt(0)
    }

    function toString$3(_, _e, et) {
        var tt, nt = getBase10Exponent(_),
            ot = digitsToString(_.d),
            at = ot.length;
        return _e ? (et && (tt = et - at) > 0 ? ot = ot.charAt(0) + "." + ot.slice(1) + getZeroString(tt) : at > 1 && (ot = ot.charAt(0) + "." + ot.slice(1)), ot = ot + (nt < 0 ? "e" : "e+") + nt) : nt < 0 ? (ot = "0." + getZeroString(-nt - 1) + ot, et && (tt = et - at) > 0 && (ot += getZeroString(tt))) : nt >= at ? (ot += getZeroString(nt + 1 - at), et && (tt = et - nt - 1) > 0 && (ot = ot + "." + getZeroString(tt))) : ((tt = nt + 1) < at && (ot = ot.slice(0, tt) + "." + ot.slice(tt)), et && (tt = et - at) > 0 && (nt + 1 === at && (ot += "."), ot += getZeroString(tt))), _.s < 0 ? "-" + ot : ot
    }

    function truncate(_, _e) {
        if (_.length > _e) return _.length = _e, !0
    }

    function clone$1(_) {
        var _e, et, tt;

        function nt(ot) {
            var at = this;
            if (!(at instanceof nt)) return new nt(ot);
            if (at.constructor = nt, ot instanceof nt) {
                at.s = ot.s, at.e = ot.e, at.d = (ot = ot.d) ? ot.slice() : ot;
                return
            }
            if (typeof ot == "number") {
                if (ot * 0 !== 0) throw Error(invalidArgument + ot);
                if (ot > 0) at.s = 1;
                else if (ot < 0) ot = -ot, at.s = -1;
                else {
                    at.s = 0, at.e = 0, at.d = [0];
                    return
                }
                if (ot === ~~ot && ot < 1e7) {
                    at.e = 0, at.d = [ot];
                    return
                }
                return parseDecimal(at, ot.toString())
            } else if (typeof ot != "string") throw Error(invalidArgument + ot);
            if (ot.charCodeAt(0) === 45 ? (ot = ot.slice(1), at.s = -1) : at.s = 1, isDecimal.test(ot)) parseDecimal(at, ot);
            else throw Error(invalidArgument + ot)
        }
        if (nt.prototype = P$1, nt.ROUND_UP = 0, nt.ROUND_DOWN = 1, nt.ROUND_CEIL = 2, nt.ROUND_FLOOR = 3, nt.ROUND_HALF_UP = 4, nt.ROUND_HALF_DOWN = 5, nt.ROUND_HALF_EVEN = 6, nt.ROUND_HALF_CEIL = 7, nt.ROUND_HALF_FLOOR = 8, nt.clone = clone$1, nt.config = nt.set = config, _ === void 0 && (_ = {}), _)
            for (tt = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], _e = 0; _e < tt.length;) _.hasOwnProperty(et = tt[_e++]) || (_[et] = this[et]);
        return nt.config(_), nt
    }

    function config(_) {
        if (!_ || typeof _ != "object") throw Error(decimalError + "Object expected");
        var _e, et, tt, nt = ["precision", 1, MAX_DIGITS, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0];
        for (_e = 0; _e < nt.length; _e += 3)
            if ((tt = _[et = nt[_e]]) !== void 0)
                if (mathfloor(tt) === tt && tt >= nt[_e + 1] && tt <= nt[_e + 2]) this[et] = tt;
                else throw Error(invalidArgument + et + ": " + tt);
        if ((tt = _[et = "LN10"]) !== void 0)
            if (tt == Math.LN10) this[et] = new this(tt);
            else throw Error(invalidArgument + et + ": " + tt);
        return this
    }
    var Decimal = clone$1(defaults);
    ONE$1 = new Decimal(1), Decimal$1 = Decimal;

    function indianFormat(_) {
        var _e = parseFloat(String(_));
        return isFinite(_e) ? _formatAfterCleanup(_e) : _
    }

    function _formatAfterCleanup(_) {
        var _e, et;
        _ < 0 ? (_e = -1 * _, et = !0) : (_e = _, et = !1);
        var tt = String(_e).split("").reverse(),
            nt = tt.indexOf(".") + 1,
            ot, at = [];
        for (ot = 0; ot < nt; ot++) at.push(tt[ot]);
        var st = 0;
        for (ot = nt; ot < tt.length; ot++) at.push(tt[ot]), st++, (st === 3 || st === 5 || st === 7) && ot < tt.length - 1 && at.push(","), st === 7 && (st = 0);
        return et && at.push("-"), at.reverse().join("")
    }
    const isWechat = () => window.navigator.userAgent.search(/MicroMessenger/i) !== -1;

    function formateAmount(_ = 0, _e = 8, et = !1) {
        const tt = new Decimal$1(_),
            nt = et ? Decimal$1.ROUND_UP : Decimal$1.ROUND_DOWN,
            ot = tt.abs().toFixed(0, Decimal$1.ROUND_DOWN).length,
            at = tt.toNumber();
        if (_e = _e > 8 ? 9 : _e + 1, ot >= _e) {
            const st = tt.abs().toFixed(0, nt);
            return at > 0 ? st : "-" + st
        } else return tt.toFixed(_e - ot, nt)
    }
    const linearScale = (_, _e, et = !1) => tt => (et && (tt < _[0] ? tt = _[0] : tt > _[1] && (tt = _[1])), _e[0] + (tt - _[0]) * (_e[0] - _e[1]) / (_[0] - _[1])),
        toUnderline = _ => _.replace(/[A-Z]/g, _e => `_${_e.toLowerCase()}`),
        toHump = _ => _.replace(/_(\w)/g, (_e, et) => et.toUpperCase()),
        ellipsis = (_, _e) => (_ = String(_), _.length > _e ? _.slice(0, _e) + "..." : _),
        requestFullscreen = async (_ = document.documentElement) => {
            try {
                _.requestFullscreen ? await _.requestFullscreen() : _.mozRequestFullScreen ? await _.mozRequestFullScreen() : _.msRequestFullscreen ? await _.msRequestFullscreen() : _.webkitRequestFullscreen && await _.webkitRequestFullScreen()
            } catch (_e) {}
        },
        exitFullscreen = async () => {
            try {
                document.exitFullscreen ? await document.exitFullscreen() : document.msExitFullscreen ? await document.msExitFullscreen() : document.mozCancelFullScreen ? await document.mozCancelFullScreen() : document.webkitExitFullscreen && await document.webkitExitFullscreen()
            } catch (_) {}
        },
        random = (_ = 10, _e = 0) => _e + Math.random() * (_ - _e),
        rotateVector = (_, _e) => {
            const et = Math.cos(_e),
                tt = Math.sin(_e);
            return [_[0] * et + _[1] * tt, _[1] * et + _[0] * tt]
        },
        hexToRgb = _ => {
            _ = _.replace(/#/, "");
            var _e = parseInt(_, 16),
                et = _e >> 16 & 255,
                tt = _e >> 8 & 255,
                nt = _e & 255;
            return [et, tt, nt]
        },
        rgbToHex = (_, _e, et) => (_ << 16) + (_e << 8) + et,
        loadScript = memoize$1((_, _e, et) => new Promise((tt, nt) => {
            var ot = document.head || document.getElementsByTagName("head")[0];
            const at = document.createElement("script");
            at.async = !0, at.src = _, et && (at.id = et), at.charset = "utf8", ot.appendChild(at), at.onload = () => {
                let st = _e ? window[_e] : null;
                ot.removeChild(at), tt(st)
            }, at.onerror = st => {
                ot.removeChild(at), loadScript.cache.delete(`${_}:${_e}`), nt(new Error(`Load Script Error: ${_}`))
            }
        }), (_, _e) => `${_}:${_e}`);

    function bolb2Image(_) {
        return new Promise(_e => {
            const et = new Image;
            et.onload = () => {
                URL.revokeObjectURL(et.src), _e(et)
            }, et.src = URL.createObjectURL(_)
        })
    }
    const concatenate = (_, ..._e) => {
            let et = 0;
            for (let ot of _e) et += ot.length;
            let tt = new _(et),
                nt = 0;
            for (let ot of _e) tt.set(ot, nt), nt += ot.length;
            return tt
        },
        delay = (_ = 0) => new Promise(_e => setTimeout(_e, _)),
        delayFrame = (_ = 0) => new Promise(_e => gsapWithCSS.delayedCall(_ / 1e3, _e)),
        stringSplice = (_, _e, et, tt) => _.slice(0, _e) + tt + _.slice(_e + et);

    function precision(_) {
        if (!isFinite(_)) return 0;
        for (var _e = 1, et = 0; Math.round(_ * _e) / _e !== _;) _e *= 10, et++;
        return et
    }

    function numberWithCommas(_, _e, et) {
        const tt = (typeof et == "number" ? new Decimal$1(_e).toFixed(et, Decimal$1.ROUND_DOWN) : _e.toString()).toString().split(".");
        return _ === "INRFIAT" ? (tt[0] = indianFormat(tt[0]).toString(), tt.join(".")) : (tt[0] = tt[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","), tt.join("."))
    }
    const numberZeroize = _ => _ < 10 && _ >= 0 ? `0${_}` : _.toString(),
        numberOrdinal = _ => {
            let _e;
            switch (_) {
                case 1:
                    _e = "st";
                    break;
                case 2:
                    _e = "nd";
                    break;
                case 3:
                    _e = "rd";
                    break;
                default:
                    _e = "th";
                    break
            }
            return `${_}${_e}`
        };

    function numPercent(_) {
        return `${Math.round(_*1e6)/1e4}%`
    }

    function amountValid(_) {
        return _.toFixed(10).slice(0, 10).replace(/\.$/, "")
    }

    function intervalQueue(_, _e, et = 20) {
        let tt = !1;
        const nt = [];
        let ot;
        const at = () => {
                tt || (tt = !0, ot = window.setTimeout(() => {
                    nt.length != 0 && (_.apply(window, nt.shift()), tt = !1, nt.length > 0 && at())
                }, _e))
            },
            st = (...lt) => {
                nt.length >= et || (nt.push(lt), at())
            };
        return st.clear = () => {
            clearTimeout(ot), nt.splice(0, nt.length)
        }, st
    }

    function debounceQueue(_, _e = 0) {
        let et = [];
        const tt = debounce(() => {
            _(et), et = []
        }, _e);
        return nt => {
            et.push(nt), tt()
        }
    }
    const isSSR = typeof window > "u";

    function noSSR(_) {
        return isSSR ? (..._e) => {} : _
    }

    function switchSSR(_, _e) {
        return isSSR ? _e : _
    }
    const pendingWithSSR = new Promise(_ => !isSSR && _()),
        isSupportTouch = isSSR ? !1 : window.hasOwnProperty("ontouchstart");
    let hidden, visibilityChange;
    isSSR || typeof document.hidden < "u" ? (hidden = "hidden", visibilityChange = "visibilitychange") : typeof document.msHidden < "u" ? (hidden = "msHidden", visibilityChange = "msvisibilitychange") : typeof document.webkitHidden < "u" && (hidden = "webkitHidden", visibilityChange = "webkitvisibilitychange");

    function onVisibilityChange(_, _e = !1) {
        const et = () => _(!document[hidden]);
        return document.addEventListener(visibilityChange, et, !1), _e && et(), () => document.removeEventListener(visibilityChange, et, !1)
    }

    function Uint8Array2Hex(_) {
        let _e = "";
        for (let et = 0; et < _.length; et++) {
            let tt = _[et].toString(16);
            _e += tt.length === 1 ? "0" + tt : tt
        }
        return `0x${_e}`
    }
    const loadImage = memoize$1(function(_) {
        const _e = new Promise((et, tt) => {
            const nt = new Image;
            nt.onload = () => et(_), nt.src = _, nt.onerror = () => tt(new Error("Image load error!"))
        });
        return _e.catch(et => {
            loadImage.cache.delete(_)
        }), _e
    });

    function i18nReplace(_, ..._e) {
        let et = 0;
        return _e.length == 0 ? _ : _.replace(/{\d+}/g, () => {
            const tt = _e[et];
            return et++, tt
        })
    }

    function isIos() {
        return isSSR ? !1 : ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document
    }
    const emptyPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";

    function mergeRefs(_) {
        return reactExports.useCallback(_e => {
            _.forEach(et => {
                typeof et == "function" ? et(_e) : et != null && (et.current = _e)
            })
        }, _)
    }

    function classList(..._) {
        return _.filter(Boolean).join(" ")
    }

    function copyToClipboard(_) {
        const _e = document.createElement("input");
        document.body.appendChild(_e);
        try {
            _e.setAttribute("readonly", "readonly"), _e.setAttribute("value", _), _e.setSelectionRange(0, 99999), _e.select(), document.execCommand("copy")
        } catch (et) {
            throw et
        } finally {
            document.body.removeChild(_e)
        }
    }
    const springConfigs = {
        fast: {
            stiffness: 640,
            damping: 60
        }
    };

    function singlePromise(_) {
        let _e;
        return (...et) => (_e === void 0 && (_e = _(...et), _e.then(() => _e = void 0)), _e)
    }

    function dataBind(_, _e) {
        return {
            value: _[_e],
            onChange(et) {
                _[_e] = et
            }
        }
    }

    function detectAuto() {
        const _ = [];
        return window.atob("d2ViZHJpdmVyLF9fZHJpdmVyX2V2YWx1YXRlLF9fd2ViZHJpdmVyX2V2YWx1YXRlLCBfX3NlbGVuaXVtX2V2YWx1YXRlLF9fZnhkcml2ZXJfZXZhbHVhdGUsX19kcml2ZXJfdW53cmFwcGVkLF9fd2ViZHJpdmVyX3Vud3JhcHBlZCxfX3NlbGVuaXVtX3Vud3JhcHBlZCxfX2Z4ZHJpdmVyX3Vud3JhcHBlZCxfU2VsZW5pdW1fSURFX1JlY29yZGVyLF9zZWxlbml1bSxjYWxsZWRTZWxlbml1bSxfV0VCRFJJVkVSX0VMRU1fQ0FDSEUsQ2hyb21lRHJpdmVydyxkcml2ZXItZXZhbHVhdGUsd2ViZHJpdmVyLWV2YWx1YXRlLHNlbGVuaXVtLWV2YWx1YXRlLHdlYmRyaXZlckNvbW1hbmQsd2ViZHJpdmVyLWV2YWx1YXRlLXJlc3BvbnNlLF9fd2ViZHJpdmVyRnVuYyxfX3dlYmRyaXZlcl9zY3JpcHRfZm4sX18kd2ViZHJpdmVyQXN5bmNFeGVjdXRvcixfX2xhc3RXYXRpckFsZXJ0LF9fbGFzdFdhdGlyQ29uZmlybSxfX2xhc3RXYXRpclByb21wdCwkY2hyb21lX2FzeW5jU2NyaXB0SW5mbywkY2RjX2FzZGpmbGFzdXRvcGZodmNaTG1jZmxfLF9waGFudG9tLF9waGFudG9tYXM=").split(",").forEach(_e => {
            (window[_e] || window.document.documentElement.getAttribute(_e) || navigator[_e]) && _.push(_e)
        }), _.length > 0
    }

    function getUrlParms(_, _e = 5) {
        return (_["*"] || "").split("/").concat(Array(_e).fill(""))
    }

    function formatWrapString(_) {
        return _.replace(/\n/g, "<br />")
    }

    function collapseElement(_, _e = _.clientHeight === 0, et = .2) {
        const tt = et > 0 ? `height ${et}s ease-out` : "";
        if (_e) {
            var nt = _.scrollHeight;
            if (_.style.transition = tt, _.style.height = nt + "px", tt !== "") {
                let ot = function() {
                    _.removeEventListener("transitionend", ot), _.style.height = ""
                };
                _.addEventListener("transitionend", ot)
            }
        } else _.style.transition = "", _.style.height = _.clientHeight + "px", requestAnimationFrame(() => {
            _.style.transition = tt, _.style.height = "0px"
        })
    }

    function intersectionObserver(_, _e, et) {
        const tt = new IntersectionObserver(([nt]) => {
            _e(nt.isIntersecting)
        }, {
            rootMargin: et
        });
        return tt.observe(_), tt
    }
    class SharedResizeObserver {
        constructor() {
            de(this, "observerMap", new Map), de(this, "observer"), this.observer = new ResizeObserver(_e => {
                for (var et of _e) {
                    var tt = this.observerMap.get(et.target);
                    tt && tt(et.contentRect)
                }
            })
        }
        add(_e, et) {
            this.observerMap.set(_e, et), this.observer.observe(_e)
        }
        remove(_e) {
            this.observerMap.has(_e) && (this.observerMap.delete(_e), this.observer.unobserve(_e))
        }
    }
    const SRObserver = isSSR ? null : new SharedResizeObserver;
    class SharedIntersectionObserver {
        constructor() {
            de(this, "observerMap", new Map), de(this, "observer"), this.observer = new IntersectionObserver(_e => {
                for (var et of _e) {
                    var tt = this.observerMap.get(et.target);
                    tt && tt(et.isIntersecting)
                }
            })
        }
        add(_e, et) {
            this.observerMap.set(_e, et), this.observer.observe(_e)
        }
        remove(_e) {
            this.observerMap.has(_e) && (this.observerMap.delete(_e), this.observer.unobserve(_e))
        }
    }
    const SIObserver = isSSR ? null : new SharedIntersectionObserver;

    function timeMemoize(_, {
        timeout: _e = 6e4,
        getKey: et
    } = {}) {
        const tt = new TimeCache(_e),
            nt = memoize$1((...ot) => {
                const at = _(...ot);
                return at.catch(() => tt.delete(et ? et(...ot) : ot[0])), at
            }, et);
        return nt.cache = tt, nt
    }
    class TimeCache extends Map {
        constructor(_e = 6e4) {
            super(), de(this, "timeout"), de(this, "lastTimeout", 0), this.timeout = _e
        }
        has(_e) {
            const et = Math.round(Date.now() / this.timeout);
            return et !== this.lastTimeout && (this.lastTimeout = et, this.clear()), super.has(_e)
        }
    }

    function splitFillList(_, _e) {
        if (!_ || _.length === 0) return [];
        const et = Math.ceil(_.length / _e),
            tt = _.concat(_);
        return chunk(tt, _e).splice(0, et)
    }
    let timeDiff = 0;

    function serverTime(_) {
        if (typeof _ > "u") return new Date(Date.now() - timeDiff);
        timeDiff = Date.now() - _
    }

    function pick(_, ..._e) {
        return _e.length == 0 ? _ : _e.reduce((et, tt) => (et[tt] = _[tt], et), {})
    }

    function shallow(_, _e) {
        for (let et in _)
            if (_[et] !== _e[et]) return !1;
        return !0
    }

    function currencyFormat(_, _e) {
        return _.toFixed() + _e
    }

    function toValidAmount(_, _e) {
        return _.gte(1e7) || _.lte(-1e7) ? _.toFixed() : _.toFixed(_e).substring(0, _.gt(0) ? 10 : 11).replace(/\.0+$/, "")
    }
    let e$1, t$1, r$2, n$1;
    index$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        SIObserver,
        SRObserver,
        Uint8Array2Hex,
        amountValid,
        bolb2Image,
        classList,
        collapseElement,
        concatenate,
        copyToClipboard,
        currencyFormat,
        dataBind,
        debounceQueue,
        delay,
        delayFrame,
        detectAuto,
        ellipsis,
        emptyPng,
        exitFullscreen,
        formatWrapString,
        formateAmount,
        getUrlParms,
        hexToRgb,
        i18nReplace,
        intersectionObserver,
        intervalQueue,
        isIos,
        isSSR,
        isSupportTouch,
        isWechat,
        linearScale,
        loadImage,
        loadScript,
        mergeRefs,
        noSSR,
        numPercent,
        numberOrdinal,
        numberWithCommas,
        numberZeroize,
        onVisibilityChange,
        pendingWithSSR,
        pick,
        precision,
        random,
        requestFullscreen,
        rgbToHex,
        rotateVector,
        serverTime,
        shallow,
        singlePromise,
        splitFillList,
        springConfigs,
        stringSplice,
        switchSSR,
        timeMemoize,
        toHump,
        toUnderline,
        toValidAmount
    }, Symbol.toStringTag, {
        value: "Module"
    })), useIsomorphicEffect = isSSR ? reactExports.useEffect : reactExports.useLayoutEffect, e$1 = Symbol(), t$1 = Symbol(), r$2 = "a", n$1 = "w";
    let o$1 = (_, _e) => new Proxy(_, _e);
    const s$5 = Object.getPrototypeOf,
        c$2 = new WeakMap,
        l$1 = _ => _ && (c$2.has(_) ? c$2.get(_) : s$5(_) === Object.prototype || s$5(_) === Array.prototype),
        f$2 = _ => typeof _ == "object" && _ !== null,
        i$2 = _ => {
            if (Array.isArray(_)) return Array.from(_);
            const _e = Object.getOwnPropertyDescriptors(_);
            return Object.values(_e).forEach(et => {
                et.configurable = !0
            }), Object.create(s$5(_), _e)
        },
        u$1 = _ => _[t$1] || _,
        a$3 = (_, _e, et, tt) => {
            if (!l$1(_)) return _;
            let nt = tt && tt.get(_);
            if (!nt) {
                const lt = u$1(_);
                nt = (ut => Object.values(Object.getOwnPropertyDescriptors(ut)).some(dt => !dt.configurable && !dt.writable))(lt) ? [lt, i$2(lt)] : [lt], tt == null || tt.set(_, nt)
            }
            const [ot, at] = nt;
            let st = et && et.get(ot);
            return st && st[1].f === !!at || (st = ((lt, ut) => {
                const dt = {
                    f: ut
                };
                let ct = !1;
                const pt = (ht, mt) => {
                        if (!ct) {
                            let bt = dt[r$2].get(lt);
                            if (bt || (bt = {}, dt[r$2].set(lt, bt)), ht === n$1) bt[n$1] = !0;
                            else {
                                let gt = bt[ht];
                                gt || (gt = new Set, bt[ht] = gt), gt.add(mt)
                            }
                        }
                    },
                    ft = {
                        get: (ht, mt) => mt === t$1 ? lt : (pt("k", mt), a$3(Reflect.get(ht, mt), dt[r$2], dt.c, dt.t)),
                        has: (ht, mt) => mt === e$1 ? (ct = !0, dt[r$2].delete(lt), !0) : (pt("h", mt), Reflect.has(ht, mt)),
                        getOwnPropertyDescriptor: (ht, mt) => (pt("o", mt), Reflect.getOwnPropertyDescriptor(ht, mt)),
                        ownKeys: ht => (pt(n$1), Reflect.ownKeys(ht))
                    };
                return ut && (ft.set = ft.deleteProperty = () => !1), [ft, dt]
            })(ot, !!at), st[1].p = o$1(at || ot, st[0]), et && et.set(ot, st)), st[1][r$2] = _e, st[1].c = et, st[1].t = tt, st[1].p
        },
        p$1 = (_, _e, et, tt) => {
            if (Object.is(_, _e)) return !1;
            if (!f$2(_) || !f$2(_e)) return !0;
            const nt = et.get(u$1(_));
            if (!nt) return !0;
            if (tt) {
                const at = tt.get(_);
                if (at && at.n === _e) return at.g;
                tt.set(_, {
                    n: _e,
                    g: !1
                })
            }
            let ot = null;
            try {
                for (const at of nt.h || [])
                    if (ot = Reflect.has(_, at) !== Reflect.has(_e, at), ot) return ot;
                if (nt[n$1] === !0) {
                    if (ot = ((at, st) => {
                            const lt = Reflect.ownKeys(at),
                                ut = Reflect.ownKeys(st);
                            return lt.length !== ut.length || lt.some((dt, ct) => dt !== ut[ct])
                        })(_, _e), ot) return ot
                } else
                    for (const at of nt.o || [])
                        if (ot = !!Reflect.getOwnPropertyDescriptor(_, at) != !!Reflect.getOwnPropertyDescriptor(_e, at), ot) return ot;
                for (const at of nt.k || [])
                    if (ot = p$1(_[at], _e[at], et, tt), ot) return ot;
                return ot === null && (ot = !0), ot
            } finally {
                tt && tt.set(_, {
                    n: _e,
                    g: ot
                })
            }
        },
        y$4 = _ => l$1(_) && _[t$1] || null,
        h$3 = (_, _e = !0) => {
            c$2.set(_, _e)
        },
        isObject = _ => typeof _ == "object" && _ !== null,
        proxyStateMap = new WeakMap,
        refSet = new WeakSet,
        buildProxyFunction = (_ = Object.is, _e = (ut, dt) => new Proxy(ut, dt), et = ut => isObject(ut) && !refSet.has(ut) && (Array.isArray(ut) || !(Symbol.iterator in ut)) && !(ut instanceof WeakMap) && !(ut instanceof WeakSet) && !(ut instanceof Error) && !(ut instanceof Number) && !(ut instanceof Date) && !(ut instanceof String) && !(ut instanceof RegExp) && !(ut instanceof ArrayBuffer), tt = ut => {
            switch (ut.status) {
                case "fulfilled":
                    return ut.value;
                case "rejected":
                    throw ut.reason;
                default:
                    throw ut
            }
        }, nt = new WeakMap, ot = (ut, dt, ct = tt) => {
            const pt = nt.get(ut);
            if ((pt == null ? void 0 : pt[0]) === dt) return pt[1];
            const ft = Array.isArray(ut) ? [] : Object.create(Object.getPrototypeOf(ut));
            return h$3(ft, !0), nt.set(ut, [dt, ft]), Reflect.ownKeys(ut).forEach(ht => {
                if (Object.getOwnPropertyDescriptor(ft, ht)) return;
                const mt = Reflect.get(ut, ht),
                    {
                        enumerable: bt
                    } = Reflect.getOwnPropertyDescriptor(ut, ht),
                    gt = {
                        value: mt,
                        enumerable: bt,
                        configurable: !0
                    };
                if (refSet.has(mt)) h$3(mt, !1);
                else if (mt instanceof Promise) delete gt.value, gt.get = () => ct(mt);
                else if (proxyStateMap.has(mt)) {
                    const [vt, xt] = proxyStateMap.get(mt);
                    gt.value = ot(vt, xt(), ct)
                }
                Object.defineProperty(ft, ht, gt)
            }), Object.preventExtensions(ft)
        }, at = new WeakMap, st = [1, 1], lt = ut => {
            if (!isObject(ut)) throw new Error("object required");
            const dt = at.get(ut);
            if (dt) return dt;
            let ct = st[0];
            const pt = new Set,
                ft = ($t, Ct = ++st[0]) => {
                    ct !== Ct && (ct = Ct, pt.forEach(Rt => Rt($t, Ct)))
                };
            let ht = st[1];
            const mt = ($t = ++st[1]) => (ht !== $t && !pt.size && (ht = $t, gt.forEach(([Ct]) => {
                    const Rt = Ct[1]($t);
                    Rt > ct && (ct = Rt)
                })), ct),
                bt = $t => (Ct, Rt) => {
                    const Pt = [...Ct];
                    Pt[1] = [$t, ...Pt[1]], ft(Pt, Rt)
                },
                gt = new Map,
                vt = ($t, Ct) => {
                    if (pt.size) {
                        const Rt = Ct[3](bt($t));
                        gt.set($t, [Ct, Rt])
                    } else gt.set($t, [Ct])
                },
                xt = $t => {
                    var Ct;
                    const Rt = gt.get($t);
                    Rt && (gt.delete($t), (Ct = Rt[1]) == null || Ct.call(Rt))
                },
                yt = $t => (pt.add($t), pt.size === 1 && gt.forEach(([Ct, Rt], Pt) => {
                    const Tt = Ct[3](bt(Pt));
                    gt.set(Pt, [Ct, Tt])
                }), () => {
                    pt.delete($t), pt.size === 0 && gt.forEach(([Ct, Rt], Pt) => {
                        Rt && (Rt(), gt.set(Pt, [Ct]))
                    })
                }),
                Et = Array.isArray(ut) ? [] : Object.create(Object.getPrototypeOf(ut)),
                wt = _e(Et, {
                    deleteProperty($t, Ct) {
                        const Rt = Reflect.get($t, Ct);
                        xt(Ct);
                        const Pt = Reflect.deleteProperty($t, Ct);
                        return Pt && ft(["delete", [Ct], Rt]), Pt
                    },
                    set($t, Ct, Rt, Pt) {
                        const Tt = Reflect.has($t, Ct),
                            It = Reflect.get($t, Ct, Pt);
                        if (Tt && (_(It, Rt) || at.has(Rt) && _(It, at.get(Rt)))) return !0;
                        xt(Ct), isObject(Rt) && (Rt = y$4(Rt) || Rt);
                        let Ot = Rt;
                        if (Rt instanceof Promise) Rt.then(Dt => {
                            Rt.status = "fulfilled", Rt.value = Dt, ft(["resolve", [Ct], Dt])
                        }).catch(Dt => {
                            Rt.status = "rejected", Rt.reason = Dt, ft(["reject", [Ct], Dt])
                        });
                        else {
                            !proxyStateMap.has(Rt) && et(Rt) && (Ot = lt(Rt));
                            const Dt = !refSet.has(Ot) && proxyStateMap.get(Ot);
                            Dt && vt(Ct, Dt)
                        }
                        return Reflect.set($t, Ct, Ot, Pt), ft(["set", [Ct], Rt, It]), !0
                    }
                });
            at.set(ut, wt);
            const St = [Et, mt, ot, yt];
            return proxyStateMap.set(wt, St), Reflect.ownKeys(ut).forEach($t => {
                const Ct = Object.getOwnPropertyDescriptor(ut, $t);
                "value" in Ct && (wt[$t] = ut[$t], delete Ct.value, delete Ct.writable), Object.defineProperty(Et, $t, Ct)
            }), wt
        }) => [lt, proxyStateMap, refSet, _, _e, et, tt, nt, ot, at, st],
        [defaultProxyFunction] = buildProxyFunction();

    function proxy$9(_ = {}) {
        return defaultProxyFunction(_)
    }

    function getVersion(_) {
        const _e = proxyStateMap.get(_);
        return _e == null ? void 0 : _e[1]()
    }

    function subscribe$2(_, _e, et) {
        const tt = proxyStateMap.get(_);
        let nt;
        const ot = [],
            at = tt[3];
        let st = !1;
        const lt = at(ut => {
            if (ot.push(ut), et) {
                _e(ot.splice(0));
                return
            }
            nt || (nt = Promise.resolve().then(() => {
                nt = void 0, st && _e(ot.splice(0))
            }))
        });
        return st = !0, () => {
            st = !1, lt()
        }
    }

    function snapshot(_, _e) {
        const et = proxyStateMap.get(_),
            [tt, nt, ot] = et;
        return ot(tt, nt(), _e)
    }

    function ref$4(_) {
        return refSet.add(_), _
    }
    var shim = {
            exports: {}
        },
        useSyncExternalStoreShim_production_min = {},
        hasRequiredUseSyncExternalStoreShim_production_min;

    function requireUseSyncExternalStoreShim_production_min() {
        if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;
        hasRequiredUseSyncExternalStoreShim_production_min = 1;
        var _ = React;

        function _e(ct, pt) {
            return ct === pt && (ct !== 0 || 1 / ct === 1 / pt) || ct !== ct && pt !== pt
        }
        var et = typeof Object.is == "function" ? Object.is : _e,
            tt = _.useState,
            nt = _.useEffect,
            ot = _.useLayoutEffect,
            at = _.useDebugValue;

        function st(ct, pt) {
            var ft = pt(),
                ht = tt({
                    inst: {
                        value: ft,
                        getSnapshot: pt
                    }
                }),
                mt = ht[0].inst,
                bt = ht[1];
            return ot(function() {
                mt.value = ft, mt.getSnapshot = pt, lt(mt) && bt({
                    inst: mt
                })
            }, [ct, ft, pt]), nt(function() {
                return lt(mt) && bt({
                    inst: mt
                }), ct(function() {
                    lt(mt) && bt({
                        inst: mt
                    })
                })
            }, [ct]), at(ft), ft
        }

        function lt(ct) {
            var pt = ct.getSnapshot;
            ct = ct.value;
            try {
                var ft = pt();
                return !et(ct, ft)
            } catch (ht) {
                return !0
            }
        }

        function ut(ct, pt) {
            return pt()
        }
        var dt = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? ut : st;
        return useSyncExternalStoreShim_production_min.useSyncExternalStore = _.useSyncExternalStore !== void 0 ? _.useSyncExternalStore : dt, useSyncExternalStoreShim_production_min
    }
    shim.exports = requireUseSyncExternalStoreShim_production_min();
    var shimExports = shim.exports;
    const useSyncExternalStoreExports = getDefaultExportFromCjs(shimExports),
        {
            use
        } = React,
        {
            useSyncExternalStore
        } = useSyncExternalStoreExports,
        targetCache = new WeakMap;

    function useSnapshot(_, _e) {
        const et = _e == null ? void 0 : _e.sync,
            tt = reactExports.useRef(),
            nt = reactExports.useRef();
        let ot = !0;
        const at = useSyncExternalStore(reactExports.useCallback(ut => {
            const dt = subscribe$2(_, ut, et);
            return ut(), dt
        }, [_, et]), () => {
            const ut = snapshot(_, use);
            try {
                if (!ot && tt.current && nt.current && !p$1(tt.current, ut, nt.current, new WeakMap)) return tt.current
            } catch (dt) {}
            return ut
        }, () => snapshot(_, use));
        ot = !1;
        const st = new WeakMap;
        reactExports.useEffect(() => {
            tt.current = at, nt.current = st
        });
        const lt = reactExports.useMemo(() => new WeakMap, []);
        return a$3(at, st, lt, targetCache)
    }
    const o = new WeakMap,
        r$1 = new WeakMap,
        s$4 = (_, _e) => {
            const et = o.get(_);
            et && (et[0].forEach(tt => {
                const {
                    d: nt
                } = tt;
                _ !== nt && s$4(nt)
            }), ++et[2], _e && et[3].add(_e))
        },
        l = _ => {
            const _e = o.get(_);
            _e && (--_e[2], _e[2] || (_e[3].forEach(et => et()), _e[3].clear()), _e[0].forEach(et => {
                const {
                    d: tt
                } = et;
                _ !== tt && l(tt)
            }))
        },
        c$1 = _ => {
            const {
                s: _e,
                d: et
            } = _;
            let tt = r$1.get(et);
            tt || (tt = [new Set], r$1.set(_.d, tt)), tt[0].add(_);
            let nt = o.get(_e);
            if (!nt) {
                const ot = new Set,
                    at = subscribe$2(_e, st => {
                        ot.forEach(lt => {
                            const {
                                d: ut,
                                c: dt,
                                n: ct,
                                i: pt
                            } = lt;
                            _e === ut && st.every(ft => ft[1].length === 1 && pt.includes(ft[1][0])) || lt.p || (s$4(_e, dt), ct ? l(_e) : lt.p = Promise.resolve().then(() => {
                                delete lt.p, l(_e)
                            }))
                        })
                    }, !0);
                nt = [ot, at, 0, new Set], o.set(_e, nt)
            }
            nt[0].add(_)
        },
        a$2 = _ => {
            const {
                s: _e,
                d: et
            } = _, tt = r$1.get(et);
            tt == null || tt[0].delete(_), (tt == null ? void 0 : tt[0].size) === 0 && r$1.delete(et);
            const nt = o.get(_e);
            if (nt) {
                const [ot, at] = nt;
                ot.delete(_), ot.size || (at(), o.delete(_e))
            }
        },
        d$4 = _ => {
            const _e = r$1.get(_);
            return _e ? Array.from(_e[0]) : []
        };

    function f$1(_, _e) {
        const et = (_e == null ? void 0 : _e.proxy) || proxy$9({}),
            tt = !(_e == null || !_e.sync),
            nt = Object.keys(_);
        return nt.forEach(ot => {
            if (Object.getOwnPropertyDescriptor(et, ot)) throw new Error("object property already defined");
            const at = _[ot];
            let st = null;
            const lt = () => {
                if (st && (Array.from(st).map(([pt]) => ((ft, ht) => {
                        const mt = o.get(ft);
                        return !(mt == null || !mt[2] || (mt[3].add(ht), 0))
                    })(pt, lt)).some(pt => pt) || Array.from(st).every(([pt, ft]) => getVersion(pt) === ft.v))) return;
                const ut = new Map,
                    dt = at(pt => (ut.set(pt, {
                        v: getVersion(pt)
                    }), pt)),
                    ct = () => {
                        var pt;
                        ut.forEach((ft, ht) => {
                            var mt;
                            const bt = (mt = st) == null || (mt = mt.get(ht)) == null ? void 0 : mt.s;
                            if (bt) ft.s = bt;
                            else {
                                const gt = {
                                    s: ht,
                                    d: et,
                                    k: ot,
                                    c: lt,
                                    n: tt,
                                    i: nt
                                };
                                c$1(gt), ft.s = gt
                            }
                        }), (pt = st) == null || pt.forEach((ft, ht) => {
                            !ut.has(ht) && ft.s && a$2(ft.s)
                        }), st = ut
                    };
                dt instanceof Promise ? dt.finally(ct) : ct(), et[ot] = dt
            };
            lt()
        }), et
    }

    function u(_, _e) {
        const et = _e != null && _e.delete ? new Set : null;
        d$4(_).forEach(tt => {
            const {
                k: nt
            } = tt;
            _e != null && _e.keys && !_e.keys.includes(nt) || (a$2(tt), et && et.add(nt))
        }), et && et.forEach(tt => {
            delete _[tt]
        })
    }

    function subscribeKey$2(_, _e, et, tt) {
        let nt = _[_e];
        return subscribe$2(_, () => {
            const ot = _[_e];
            Object.is(nt, ot) || et(nt = ot)
        }, tt)
    }
    let currentCleanups;

    function watch(_, _e) {
        let et = !0;
        const tt = new Set,
            nt = new Map,
            ot = () => {
                et && (et = !1, tt.forEach(st => st()), tt.clear(), nt.forEach(st => st()), nt.clear())
            },
            at = () => {
                if (!et) return;
                tt.forEach(ut => ut()), tt.clear();
                const st = new Set,
                    lt = currentCleanups;
                currentCleanups = tt;
                try {
                    const ut = _(dt => (st.add(dt), dt));
                    ut && tt.add(ut)
                } finally {
                    currentCleanups = lt
                }
                nt.forEach((ut, dt) => {
                    st.has(dt) ? st.delete(dt) : (nt.delete(dt), ut())
                }), st.forEach(ut => {
                    const dt = subscribe$2(ut, at, _e == null ? void 0 : _e.sync);
                    nt.set(ut, dt)
                })
            };
        return currentCleanups && currentCleanups.add(ot), at(), ot
    }

    function useProxy$9(_, _e) {
        const et = useSnapshot(_, _e);
        let tt = !0;
        return useIsomorphicEffect(() => {
            tt = !1
        }), new Proxy(_, {
            get(nt, ot) {
                return tt ? et[ot] : nt[ot]
            }
        })
    }
    let DecimalUtils;
    valtio = {
        getVersion,
        proxy: proxy$9,
        ref: ref$4,
        snapshot,
        subscribe: subscribe$2,
        useSnapshot,
        derive: f$1,
        subscribeKey: subscribeKey$2,
        underive: u,
        watch,
        useProxy: useProxy$9
    }, DecimalUtils = {
        floor: _ => _.toDecimalPlaces(0, Decimal$1.ROUND_DOWN),
        round: _ => _.toDecimalPlaces(0),
        max: (..._) => {
            let _e = _[0];
            for (let et = 1; et < _.length; et++) _[et].greaterThan(_e) && (_e = _[et]);
            return _e
        },
        min: (..._) => {
            let _e = _[0];
            for (let et = 1; et < _.length; et++) _[et].lessThan(_e) && (_e = _[et]);
            return _e
        }
    }, useForceUpdate = function() {
        return reactExports.useReducer(_ => _ + 1, 0)[1]
    };
    class AsyncQueue {
        constructor() {
            de(this, "list", [])
        }
        enqueue(_e, et) {
            const {
                weights: tt = 0
            } = et || {}, nt = {
                weights: tt,
                run: _e
            }, ot = sortedIndexBy(this.list, nt, at => at.weights);
            this.list.splice(ot, 0, nt)
        }
        dequeue() {
            var _e;
            return (_e = this.list.shift()) == null ? void 0 : _e.run
        }
        get size() {
            return this.list.length
        }
        filter(_e) {
            return this.list.map(et => et.run)
        }
    }
    class ModalQueue extends PQueue {
        constructor() {
            super({
                queueClass: AsyncQueue,
                concurrency: 1
            })
        }
        useIdle(_e = 0) {
            const et = useForceUpdate(),
                tt = this.pending === 0 && this.size === 0;
            return reactExports.useEffect(() => {
                const nt = () => setTimeout(() => et(), _e);
                return this.on("idle", nt), () => {
                    this.off("idle", nt)
                }
            }, []), tt
        }
    }
    const AsyncQueue$1 = new ModalQueue;
    var wasm = null;
    try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports
    } catch (_) {}

    function Long(_, _e, et) {
        this.low = _ | 0, this.high = _e | 0, this.unsigned = !!et
    }
    Long.prototype.__isLong__, Object.defineProperty(Long.prototype, "__isLong__", {
        value: !0
    });

    function isLong(_) {
        return (_ && _.__isLong__) === !0
    }

    function ctz32(_) {
        var _e = Math.clz32(_ & -_);
        return _ ? 31 - _e : _e
    }
    Long.isLong = isLong;
    var INT_CACHE = {},
        UINT_CACHE = {};

    function fromInt(_, _e) {
        var et, tt, nt;
        return _e ? (_ >>>= 0, (nt = 0 <= _ && _ < 256) && (tt = UINT_CACHE[_], tt) ? tt : (et = fromBits(_, 0, !0), nt && (UINT_CACHE[_] = et), et)) : (_ |= 0, (nt = -128 <= _ && _ < 128) && (tt = INT_CACHE[_], tt) ? tt : (et = fromBits(_, _ < 0 ? -1 : 0, !1), nt && (INT_CACHE[_] = et), et))
    }
    Long.fromInt = fromInt;

    function fromNumber(_, _e) {
        if (isNaN(_)) return _e ? UZERO : ZERO;
        if (_e) {
            if (_ < 0) return UZERO;
            if (_ >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE
        } else {
            if (_ <= -TWO_PWR_63_DBL) return MIN_VALUE;
            if (_ + 1 >= TWO_PWR_63_DBL) return MAX_VALUE
        }
        return _ < 0 ? fromNumber(-_, _e).neg() : fromBits(_ % TWO_PWR_32_DBL | 0, _ / TWO_PWR_32_DBL | 0, _e)
    }
    Long.fromNumber = fromNumber;

    function fromBits(_, _e, et) {
        return new Long(_, _e, et)
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;

    function fromString(_, _e, et) {
        if (_.length === 0) throw Error("empty string");
        if (typeof _e == "number" ? (et = _e, _e = !1) : _e = !!_e, _ === "NaN" || _ === "Infinity" || _ === "+Infinity" || _ === "-Infinity") return _e ? UZERO : ZERO;
        if (et = et || 10, et < 2 || 36 < et) throw RangeError("radix");
        var tt;
        if ((tt = _.indexOf("-")) > 0) throw Error("interior hyphen");
        if (tt === 0) return fromString(_.substring(1), _e, et).neg();
        for (var nt = fromNumber(pow_dbl(et, 8)), ot = ZERO, at = 0; at < _.length; at += 8) {
            var st = Math.min(8, _.length - at),
                lt = parseInt(_.substring(at, at + st), et);
            if (st < 8) {
                var ut = fromNumber(pow_dbl(et, st));
                ot = ot.mul(ut).add(fromNumber(lt))
            } else ot = ot.mul(nt), ot = ot.add(fromNumber(lt))
        }
        return ot.unsigned = _e, ot
    }
    Long.fromString = fromString;

    function fromValue(_, _e) {
        return typeof _ == "number" ? fromNumber(_, _e) : typeof _ == "string" ? fromString(_, _e) : fromBits(_.low, _.high, typeof _e == "boolean" ? _e : _.unsigned)
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 65536,
        TWO_PWR_24_DBL = 1 << 24,
        TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL,
        TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL,
        TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2,
        TWO_PWR_24 = fromInt(TWO_PWR_24_DBL),
        ZERO = fromInt(0);
    Long.ZERO = ZERO;
    var UZERO = fromInt(0, !0);
    Long.UZERO = UZERO;
    var ONE = fromInt(1);
    Long.ONE = ONE;
    var UONE = fromInt(1, !0);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(-1, 2147483647, !1);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, -2147483648, !1);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function _() {
        return this.unsigned ? this.low >>> 0 : this.low
    }, LongPrototype.toNumber = function _() {
        return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0)
    }, LongPrototype.toString = function _(_e) {
        if (_e = _e || 10, _e < 2 || 36 < _e) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative())
            if (this.eq(MIN_VALUE)) {
                var et = fromNumber(_e),
                    tt = this.div(et),
                    nt = tt.mul(et).sub(this);
                return tt.toString(_e) + nt.toInt().toString(_e)
            } else return "-" + this.neg().toString(_e);
        for (var ot = fromNumber(pow_dbl(_e, 6), this.unsigned), at = this, st = "";;) {
            var lt = at.div(ot),
                ut = at.sub(lt.mul(ot)).toInt() >>> 0,
                dt = ut.toString(_e);
            if (at = lt, at.isZero()) return dt + st;
            for (; dt.length < 6;) dt = "0" + dt;
            st = "" + dt + st
        }
    }, LongPrototype.getHighBits = function _() {
        return this.high
    }, LongPrototype.getHighBitsUnsigned = function _() {
        return this.high >>> 0
    }, LongPrototype.getLowBits = function _() {
        return this.low
    }, LongPrototype.getLowBitsUnsigned = function _() {
        return this.low >>> 0
    }, LongPrototype.getNumBitsAbs = function _() {
        if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        for (var _e = this.high != 0 ? this.high : this.low, et = 31; et > 0 && !(_e & 1 << et); et--);
        return this.high != 0 ? et + 33 : et + 1
    }, LongPrototype.isZero = function _() {
        return this.high === 0 && this.low === 0
    }, LongPrototype.eqz = LongPrototype.isZero, LongPrototype.isNegative = function _() {
        return !this.unsigned && this.high < 0
    }, LongPrototype.isPositive = function _() {
        return this.unsigned || this.high >= 0
    }, LongPrototype.isOdd = function _() {
        return (this.low & 1) === 1
    }, LongPrototype.isEven = function _() {
        return (this.low & 1) === 0
    }, LongPrototype.equals = function _(_e) {
        return isLong(_e) || (_e = fromValue(_e)), this.unsigned !== _e.unsigned && this.high >>> 31 === 1 && _e.high >>> 31 === 1 ? !1 : this.high === _e.high && this.low === _e.low
    }, LongPrototype.eq = LongPrototype.equals, LongPrototype.notEquals = function _(_e) {
        return !this.eq(_e)
    }, LongPrototype.neq = LongPrototype.notEquals, LongPrototype.ne = LongPrototype.notEquals, LongPrototype.lessThan = function _(_e) {
        return this.comp(_e) < 0
    }, LongPrototype.lt = LongPrototype.lessThan, LongPrototype.lessThanOrEqual = function _(_e) {
        return this.comp(_e) <= 0
    }, LongPrototype.lte = LongPrototype.lessThanOrEqual, LongPrototype.le = LongPrototype.lessThanOrEqual, LongPrototype.greaterThan = function _(_e) {
        return this.comp(_e) > 0
    }, LongPrototype.gt = LongPrototype.greaterThan, LongPrototype.greaterThanOrEqual = function _(_e) {
        return this.comp(_e) >= 0
    }, LongPrototype.gte = LongPrototype.greaterThanOrEqual, LongPrototype.ge = LongPrototype.greaterThanOrEqual, LongPrototype.compare = function _(_e) {
        if (isLong(_e) || (_e = fromValue(_e)), this.eq(_e)) return 0;
        var et = this.isNegative(),
            tt = _e.isNegative();
        return et && !tt ? -1 : !et && tt ? 1 : this.unsigned ? _e.high >>> 0 > this.high >>> 0 || _e.high === this.high && _e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(_e).isNegative() ? -1 : 1
    }, LongPrototype.comp = LongPrototype.compare, LongPrototype.negate = function _() {
        return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE)
    }, LongPrototype.neg = LongPrototype.negate, LongPrototype.add = function _(_e) {
        isLong(_e) || (_e = fromValue(_e));
        var et = this.high >>> 16,
            tt = this.high & 65535,
            nt = this.low >>> 16,
            ot = this.low & 65535,
            at = _e.high >>> 16,
            st = _e.high & 65535,
            lt = _e.low >>> 16,
            ut = _e.low & 65535,
            dt = 0,
            ct = 0,
            pt = 0,
            ft = 0;
        return ft += ot + ut, pt += ft >>> 16, ft &= 65535, pt += nt + lt, ct += pt >>> 16, pt &= 65535, ct += tt + st, dt += ct >>> 16, ct &= 65535, dt += et + at, dt &= 65535, fromBits(pt << 16 | ft, dt << 16 | ct, this.unsigned)
    }, LongPrototype.subtract = function _(_e) {
        return isLong(_e) || (_e = fromValue(_e)), this.add(_e.neg())
    }, LongPrototype.sub = LongPrototype.subtract, LongPrototype.multiply = function _(_e) {
        if (this.isZero()) return this;
        if (isLong(_e) || (_e = fromValue(_e)), wasm) {
            var et = wasm.mul(this.low, this.high, _e.low, _e.high);
            return fromBits(et, wasm.get_high(), this.unsigned)
        }
        if (_e.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return _e.isOdd() ? MIN_VALUE : ZERO;
        if (_e.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) return _e.isNegative() ? this.neg().mul(_e.neg()) : this.neg().mul(_e).neg();
        if (_e.isNegative()) return this.mul(_e.neg()).neg();
        if (this.lt(TWO_PWR_24) && _e.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * _e.toNumber(), this.unsigned);
        var tt = this.high >>> 16,
            nt = this.high & 65535,
            ot = this.low >>> 16,
            at = this.low & 65535,
            st = _e.high >>> 16,
            lt = _e.high & 65535,
            ut = _e.low >>> 16,
            dt = _e.low & 65535,
            ct = 0,
            pt = 0,
            ft = 0,
            ht = 0;
        return ht += at * dt, ft += ht >>> 16, ht &= 65535, ft += ot * dt, pt += ft >>> 16, ft &= 65535, ft += at * ut, pt += ft >>> 16, ft &= 65535, pt += nt * dt, ct += pt >>> 16, pt &= 65535, pt += ot * ut, ct += pt >>> 16, pt &= 65535, pt += at * lt, ct += pt >>> 16, pt &= 65535, ct += tt * dt + nt * ut + ot * lt + at * st, ct &= 65535, fromBits(ft << 16 | ht, ct << 16 | pt, this.unsigned)
    }, LongPrototype.mul = LongPrototype.multiply, LongPrototype.divide = function _(_e) {
        if (isLong(_e) || (_e = fromValue(_e)), _e.isZero()) throw Error("division by zero");
        if (wasm) {
            if (!this.unsigned && this.high === -2147483648 && _e.low === -1 && _e.high === -1) return this;
            var et = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, _e.low, _e.high);
            return fromBits(et, wasm.get_high(), this.unsigned)
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var tt, nt, ot;
        if (this.unsigned) {
            if (_e.unsigned || (_e = _e.toUnsigned()), _e.gt(this)) return UZERO;
            if (_e.gt(this.shru(1))) return UONE;
            ot = UZERO
        } else {
            if (this.eq(MIN_VALUE)) {
                if (_e.eq(ONE) || _e.eq(NEG_ONE)) return MIN_VALUE;
                if (_e.eq(MIN_VALUE)) return ONE;
                var at = this.shr(1);
                return tt = at.div(_e).shl(1), tt.eq(ZERO) ? _e.isNegative() ? ONE : NEG_ONE : (nt = this.sub(_e.mul(tt)), ot = tt.add(nt.div(_e)), ot)
            } else if (_e.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) return _e.isNegative() ? this.neg().div(_e.neg()) : this.neg().div(_e).neg();
            if (_e.isNegative()) return this.div(_e.neg()).neg();
            ot = ZERO
        }
        for (nt = this; nt.gte(_e);) {
            tt = Math.max(1, Math.floor(nt.toNumber() / _e.toNumber()));
            for (var st = Math.ceil(Math.log(tt) / Math.LN2), lt = st <= 48 ? 1 : pow_dbl(2, st - 48), ut = fromNumber(tt), dt = ut.mul(_e); dt.isNegative() || dt.gt(nt);) tt -= lt, ut = fromNumber(tt, this.unsigned), dt = ut.mul(_e);
            ut.isZero() && (ut = ONE), ot = ot.add(ut), nt = nt.sub(dt)
        }
        return ot
    }, LongPrototype.div = LongPrototype.divide, LongPrototype.modulo = function _(_e) {
        if (isLong(_e) || (_e = fromValue(_e)), wasm) {
            var et = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, _e.low, _e.high);
            return fromBits(et, wasm.get_high(), this.unsigned)
        }
        return this.sub(this.div(_e).mul(_e))
    }, LongPrototype.mod = LongPrototype.modulo, LongPrototype.rem = LongPrototype.modulo, LongPrototype.not = function _() {
        return fromBits(~this.low, ~this.high, this.unsigned)
    }, LongPrototype.countLeadingZeros = function _() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32
    }, LongPrototype.clz = LongPrototype.countLeadingZeros, LongPrototype.countTrailingZeros = function _() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32
    }, LongPrototype.ctz = LongPrototype.countTrailingZeros, LongPrototype.and = function _(_e) {
        return isLong(_e) || (_e = fromValue(_e)), fromBits(this.low & _e.low, this.high & _e.high, this.unsigned)
    }, LongPrototype.or = function _(_e) {
        return isLong(_e) || (_e = fromValue(_e)), fromBits(this.low | _e.low, this.high | _e.high, this.unsigned)
    }, LongPrototype.xor = function _(_e) {
        return isLong(_e) || (_e = fromValue(_e)), fromBits(this.low ^ _e.low, this.high ^ _e.high, this.unsigned)
    }, LongPrototype.shiftLeft = function _(_e) {
        return isLong(_e) && (_e = _e.toInt()), (_e &= 63) === 0 ? this : _e < 32 ? fromBits(this.low << _e, this.high << _e | this.low >>> 32 - _e, this.unsigned) : fromBits(0, this.low << _e - 32, this.unsigned)
    }, LongPrototype.shl = LongPrototype.shiftLeft, LongPrototype.shiftRight = function _(_e) {
        return isLong(_e) && (_e = _e.toInt()), (_e &= 63) === 0 ? this : _e < 32 ? fromBits(this.low >>> _e | this.high << 32 - _e, this.high >> _e, this.unsigned) : fromBits(this.high >> _e - 32, this.high >= 0 ? 0 : -1, this.unsigned)
    }, LongPrototype.shr = LongPrototype.shiftRight, LongPrototype.shiftRightUnsigned = function _(_e) {
        return isLong(_e) && (_e = _e.toInt()), (_e &= 63) === 0 ? this : _e < 32 ? fromBits(this.low >>> _e | this.high << 32 - _e, this.high >>> _e, this.unsigned) : _e === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(this.high >>> _e - 32, 0, this.unsigned)
    }, LongPrototype.shru = LongPrototype.shiftRightUnsigned, LongPrototype.shr_u = LongPrototype.shiftRightUnsigned, LongPrototype.rotateLeft = function _(_e) {
        var et;
        return isLong(_e) && (_e = _e.toInt()), (_e &= 63) === 0 ? this : _e === 32 ? fromBits(this.high, this.low, this.unsigned) : _e < 32 ? (et = 32 - _e, fromBits(this.low << _e | this.high >>> et, this.high << _e | this.low >>> et, this.unsigned)) : (_e -= 32, et = 32 - _e, fromBits(this.high << _e | this.low >>> et, this.low << _e | this.high >>> et, this.unsigned))
    }, LongPrototype.rotl = LongPrototype.rotateLeft, LongPrototype.rotateRight = function _(_e) {
        var et;
        return isLong(_e) && (_e = _e.toInt()), (_e &= 63) === 0 ? this : _e === 32 ? fromBits(this.high, this.low, this.unsigned) : _e < 32 ? (et = 32 - _e, fromBits(this.high << et | this.low >>> _e, this.low << et | this.high >>> _e, this.unsigned)) : (_e -= 32, et = 32 - _e, fromBits(this.low << et | this.high >>> _e, this.high << et | this.low >>> _e, this.unsigned))
    }, LongPrototype.rotr = LongPrototype.rotateRight, LongPrototype.toSigned = function _() {
        return this.unsigned ? fromBits(this.low, this.high, !1) : this
    }, LongPrototype.toUnsigned = function _() {
        return this.unsigned ? this : fromBits(this.low, this.high, !0)
    }, LongPrototype.toBytes = function _(_e) {
        return _e ? this.toBytesLE() : this.toBytesBE()
    }, LongPrototype.toBytesLE = function _() {
        var _e = this.high,
            et = this.low;
        return [et & 255, et >>> 8 & 255, et >>> 16 & 255, et >>> 24, _e & 255, _e >>> 8 & 255, _e >>> 16 & 255, _e >>> 24]
    }, LongPrototype.toBytesBE = function _() {
        var _e = this.high,
            et = this.low;
        return [_e >>> 24, _e >>> 16 & 255, _e >>> 8 & 255, _e & 255, et >>> 24, et >>> 16 & 255, et >>> 8 & 255, et & 255]
    }, Long.fromBytes = function _(_e, et, tt) {
        return tt ? Long.fromBytesLE(_e, et) : Long.fromBytesBE(_e, et)
    }, Long.fromBytesLE = function _(_e, et) {
        return new Long(_e[0] | _e[1] << 8 | _e[2] << 16 | _e[3] << 24, _e[4] | _e[5] << 8 | _e[6] << 16 | _e[7] << 24, et)
    }, Long.fromBytesBE = function _(_e, et) {
        return new Long(_e[4] << 24 | _e[5] << 16 | _e[6] << 8 | _e[7], _e[0] << 24 | _e[1] << 16 | _e[2] << 8 | _e[3], et)
    };
    const ErrorCode$1 = {
        TWOFA_ERROR: 4002,
        INSUFFICIENT_BALANCE: 5002,
        SAME_EMAIL: 5801,
        IS_MUTE: 6001,
        NEED_LOGIN: 6002,
        SESSION_ERROR: 6003,
        NEED_VERIFY: 6004,
        IS_BLOCKED: 6005,
        LOCKED_BY_KYC: 6008,
        NEED_EMAIL_AND_BASIC_KYC: 6101,
        NEED_EMAIL_AND_ADVANCED_KYC: 6102,
        NEED_PHONE_AND_BASIC_KYC: 6103,
        NEED_PHONE_AND_ADVANCED_KYC: 6104,
        NEED_EMAIL_OR_PHONE_AND_BASIC_KYC: 6105,
        NEED_EMAIL_OR_PHONE_AND_ADVANCED_KYC: 6106,
        NEED_EMAIL_AND_PHONE_AND_BASIC_KYC: 6107,
        NEED_EMAIL_AND_PHONE_AND_ADVANCED_KYC: 6108,
        NEED_BASIC_KYC: 6109,
        NEED_ADVANCED_KYC: 6110,
        FINAL_REJECT_KYC: 6111,
        IS_UPDATING: 1999
    };
    var lib$1 = {
            exports: {}
        },
        re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        parts = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
        parseuri$2 = function _(_e) {
            var et = _e,
                tt = _e.indexOf("["),
                nt = _e.indexOf("]");
            tt != -1 && nt != -1 && (_e = _e.substring(0, tt) + _e.substring(tt, nt).replace(/:/g, ";") + _e.substring(nt, _e.length));
            for (var ot = re.exec(_e || ""), at = {}, st = 14; st--;) at[parts[st]] = ot[st] || "";
            return tt != -1 && nt != -1 && (at.source = et, at.host = at.host.substring(1, at.host.length - 1).replace(/;/g, ":"), at.authority = at.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), at.ipv6uri = !0), at.pathNames = pathNames(at, at.path), at.queryKey = queryKey(at, at.query), at
        };

    function pathNames(_, _e) {
        var et = /\/{2,9}/g,
            tt = _e.replace(et, "/").split("/");
        return (_e.substr(0, 1) == "/" || _e.length === 0) && tt.splice(0, 1), _e.substr(_e.length - 1, 1) == "/" && tt.splice(tt.length - 1, 1), tt
    }

    function queryKey(_, _e) {
        var et = {};
        return _e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(tt, nt, ot) {
            nt && (et[nt] = ot)
        }), et
    }
    var browser$3 = {
            exports: {}
        },
        debug$8 = {
            exports: {}
        },
        s$3 = 1e3,
        m$3 = s$3 * 60,
        h$2 = m$3 * 60,
        d$3 = h$2 * 24,
        y$3 = d$3 * 365.25,
        ms$2 = function(_, _e) {
            _e = _e || {};
            var et = typeof _;
            if (et === "string" && _.length > 0) return parse$2(_);
            if (et === "number" && isNaN(_) === !1) return _e.long ? fmtLong$2(_) : fmtShort$2(_);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(_))
        };

    function parse$2(_) {
        if (_ = String(_), !(_.length > 100)) {
            var _e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(_);
            if (_e) {
                var et = parseFloat(_e[1]),
                    tt = (_e[2] || "ms").toLowerCase();
                switch (tt) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return et * y$3;
                    case "days":
                    case "day":
                    case "d":
                        return et * d$3;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return et * h$2;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return et * m$3;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return et * s$3;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return et;
                    default:
                        return
                }
            }
        }
    }

    function fmtShort$2(_) {
        return _ >= d$3 ? Math.round(_ / d$3) + "d" : _ >= h$2 ? Math.round(_ / h$2) + "h" : _ >= m$3 ? Math.round(_ / m$3) + "m" : _ >= s$3 ? Math.round(_ / s$3) + "s" : _ + "ms"
    }

    function fmtLong$2(_) {
        return plural$2(_, d$3, "day") || plural$2(_, h$2, "hour") || plural$2(_, m$3, "minute") || plural$2(_, s$3, "second") || _ + " ms"
    }

    function plural$2(_, _e, et) {
        if (!(_ < _e)) return _ < _e * 1.5 ? Math.floor(_ / _e) + " " + et : Math.ceil(_ / _e) + " " + et + "s"
    }(function(_, _e) {
        _e = _.exports = tt.debug = tt.default = tt, _e.coerce = lt, _e.disable = at, _e.enable = ot, _e.enabled = st, _e.humanize = ms$2, _e.instances = [], _e.names = [], _e.skips = [], _e.formatters = {};

        function et(ut) {
            var dt = 0,
                ct;
            for (ct in ut) dt = (dt << 5) - dt + ut.charCodeAt(ct), dt |= 0;
            return _e.colors[Math.abs(dt) % _e.colors.length]
        }

        function tt(ut) {
            var dt;

            function ct() {
                if (ct.enabled) {
                    var pt = ct,
                        ft = +new Date,
                        ht = ft - (dt || ft);
                    pt.diff = ht, pt.prev = dt, pt.curr = ft, dt = ft;
                    for (var mt = new Array(arguments.length), bt = 0; bt < mt.length; bt++) mt[bt] = arguments[bt];
                    mt[0] = _e.coerce(mt[0]), typeof mt[0] != "string" && mt.unshift("%O");
                    var gt = 0;
                    mt[0] = mt[0].replace(/%([a-zA-Z%])/g, function(xt, yt) {
                        if (xt === "%%") return xt;
                        gt++;
                        var Et = _e.formatters[yt];
                        if (typeof Et == "function") {
                            var wt = mt[gt];
                            xt = Et.call(pt, wt), mt.splice(gt, 1), gt--
                        }
                        return xt
                    }), _e.formatArgs.call(pt, mt);
                    var vt = ct.log || _e.log || console.log.bind(console);
                    vt.apply(pt, mt)
                }
            }
            return ct.namespace = ut, ct.enabled = _e.enabled(ut), ct.useColors = _e.useColors(), ct.color = et(ut), ct.destroy = nt, typeof _e.init == "function" && _e.init(ct), _e.instances.push(ct), ct
        }

        function nt() {
            var ut = _e.instances.indexOf(this);
            return ut !== -1 ? (_e.instances.splice(ut, 1), !0) : !1
        }

        function ot(ut) {
            _e.save(ut), _e.names = [], _e.skips = [];
            var dt, ct = (typeof ut == "string" ? ut : "").split(/[\s,]+/),
                pt = ct.length;
            for (dt = 0; dt < pt; dt++) ct[dt] && (ut = ct[dt].replace(/\*/g, ".*?"), ut[0] === "-" ? _e.skips.push(new RegExp("^" + ut.substr(1) + "$")) : _e.names.push(new RegExp("^" + ut + "$")));
            for (dt = 0; dt < _e.instances.length; dt++) {
                var ft = _e.instances[dt];
                ft.enabled = _e.enabled(ft.namespace)
            }
        }

        function at() {
            _e.enable("")
        }

        function st(ut) {
            if (ut[ut.length - 1] === "*") return !0;
            var dt, ct;
            for (dt = 0, ct = _e.skips.length; dt < ct; dt++)
                if (_e.skips[dt].test(ut)) return !1;
            for (dt = 0, ct = _e.names.length; dt < ct; dt++)
                if (_e.names[dt].test(ut)) return !0;
            return !1
        }

        function lt(ut) {
            return ut instanceof Error ? ut.stack || ut.message : ut
        }
    })(debug$8, debug$8.exports);
    var debugExports$2 = debug$8.exports;
    (function(_, _e) {
        _e = _.exports = debugExports$2, _e.log = nt, _e.formatArgs = tt, _e.save = ot, _e.load = at, _e.useColors = et, _e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : st(), _e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

        function et() {
            return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        _e.formatters.j = function(lt) {
            try {
                return JSON.stringify(lt)
            } catch (ut) {
                return "[UnexpectedJSONParseError]: " + ut.message
            }
        };

        function tt(lt) {
            var ut = this.useColors;
            if (lt[0] = (ut ? "%c" : "") + this.namespace + (ut ? " %c" : " ") + lt[0] + (ut ? "%c " : " ") + "+" + _e.humanize(this.diff), !!ut) {
                var dt = "color: " + this.color;
                lt.splice(1, 0, dt, "color: inherit");
                var ct = 0,
                    pt = 0;
                lt[0].replace(/%[a-zA-Z%]/g, function(ft) {
                    ft !== "%%" && (ct++, ft === "%c" && (pt = ct))
                }), lt.splice(pt, 0, dt)
            }
        }

        function nt() {
            return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
        }

        function ot(lt) {
            try {
                lt == null ? _e.storage.removeItem("debug") : _e.storage.debug = lt
            } catch (ut) {}
        }

        function at() {
            var lt;
            try {
                lt = _e.storage.debug
            } catch (ut) {}
            return !lt && typeof process < "u" && "env" in process && (lt = {}.DEBUG), lt
        }
        _e.enable(at());

        function st() {
            try {
                return window.localStorage
            } catch (lt) {}
        }
    })(browser$3, browser$3.exports);
    var browserExports$2 = browser$3.exports,
        parseuri$1 = parseuri$2,
        debug$7 = browserExports$2("socket.io-client:url"),
        url_1 = url;

    function url(_, _e) {
        var et = _;
        _e = _e || typeof location < "u" && location, _ == null && (_ = _e.protocol + "//" + _e.host), typeof _ == "string" && (_.charAt(0) === "/" && (_.charAt(1) === "/" ? _ = _e.protocol + _ : _ = _e.host + _), /^(https?|wss?):\/\//.test(_) || (debug$7("protocol-less url %s", _), typeof _e < "u" ? _ = _e.protocol + "//" + _ : _ = "https://" + _), debug$7("parse %s", _), et = parseuri$1(_)), et.port || (/^(http|ws)$/.test(et.protocol) ? et.port = "80" : /^(http|ws)s$/.test(et.protocol) && (et.port = "443")), et.path = et.path || "/";
        var tt = et.host.indexOf(":") !== -1,
            nt = tt ? "[" + et.host + "]" : et.host;
        return et.id = et.protocol + "://" + nt + ":" + et.port, et.href = et.protocol + "://" + nt + (_e && _e.port === et.port ? "" : ":" + et.port), et
    }
    var socket_ioParser = {},
        browser$2 = {
            exports: {}
        },
        debug$6 = {
            exports: {}
        },
        s$2 = 1e3,
        m$2 = s$2 * 60,
        h$1 = m$2 * 60,
        d$2 = h$1 * 24,
        y$2 = d$2 * 365.25,
        ms$1 = function(_, _e) {
            _e = _e || {};
            var et = typeof _;
            if (et === "string" && _.length > 0) return parse$1(_);
            if (et === "number" && isNaN(_) === !1) return _e.long ? fmtLong$1(_) : fmtShort$1(_);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(_))
        };

    function parse$1(_) {
        if (_ = String(_), !(_.length > 100)) {
            var _e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(_);
            if (_e) {
                var et = parseFloat(_e[1]),
                    tt = (_e[2] || "ms").toLowerCase();
                switch (tt) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return et * y$2;
                    case "days":
                    case "day":
                    case "d":
                        return et * d$2;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return et * h$1;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return et * m$2;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return et * s$2;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return et;
                    default:
                        return
                }
            }
        }
    }

    function fmtShort$1(_) {
        return _ >= d$2 ? Math.round(_ / d$2) + "d" : _ >= h$1 ? Math.round(_ / h$1) + "h" : _ >= m$2 ? Math.round(_ / m$2) + "m" : _ >= s$2 ? Math.round(_ / s$2) + "s" : _ + "ms"
    }

    function fmtLong$1(_) {
        return plural$1(_, d$2, "day") || plural$1(_, h$1, "hour") || plural$1(_, m$2, "minute") || plural$1(_, s$2, "second") || _ + " ms"
    }

    function plural$1(_, _e, et) {
        if (!(_ < _e)) return _ < _e * 1.5 ? Math.floor(_ / _e) + " " + et : Math.ceil(_ / _e) + " " + et + "s"
    }(function(_, _e) {
        _e = _.exports = tt.debug = tt.default = tt, _e.coerce = lt, _e.disable = at, _e.enable = ot, _e.enabled = st, _e.humanize = ms$1, _e.instances = [], _e.names = [], _e.skips = [], _e.formatters = {};

        function et(ut) {
            var dt = 0,
                ct;
            for (ct in ut) dt = (dt << 5) - dt + ut.charCodeAt(ct), dt |= 0;
            return _e.colors[Math.abs(dt) % _e.colors.length]
        }

        function tt(ut) {
            var dt;

            function ct() {
                if (ct.enabled) {
                    var pt = ct,
                        ft = +new Date,
                        ht = ft - (dt || ft);
                    pt.diff = ht, pt.prev = dt, pt.curr = ft, dt = ft;
                    for (var mt = new Array(arguments.length), bt = 0; bt < mt.length; bt++) mt[bt] = arguments[bt];
                    mt[0] = _e.coerce(mt[0]), typeof mt[0] != "string" && mt.unshift("%O");
                    var gt = 0;
                    mt[0] = mt[0].replace(/%([a-zA-Z%])/g, function(xt, yt) {
                        if (xt === "%%") return xt;
                        gt++;
                        var Et = _e.formatters[yt];
                        if (typeof Et == "function") {
                            var wt = mt[gt];
                            xt = Et.call(pt, wt), mt.splice(gt, 1), gt--
                        }
                        return xt
                    }), _e.formatArgs.call(pt, mt);
                    var vt = ct.log || _e.log || console.log.bind(console);
                    vt.apply(pt, mt)
                }
            }
            return ct.namespace = ut, ct.enabled = _e.enabled(ut), ct.useColors = _e.useColors(), ct.color = et(ut), ct.destroy = nt, typeof _e.init == "function" && _e.init(ct), _e.instances.push(ct), ct
        }

        function nt() {
            var ut = _e.instances.indexOf(this);
            return ut !== -1 ? (_e.instances.splice(ut, 1), !0) : !1
        }

        function ot(ut) {
            _e.save(ut), _e.names = [], _e.skips = [];
            var dt, ct = (typeof ut == "string" ? ut : "").split(/[\s,]+/),
                pt = ct.length;
            for (dt = 0; dt < pt; dt++) ct[dt] && (ut = ct[dt].replace(/\*/g, ".*?"), ut[0] === "-" ? _e.skips.push(new RegExp("^" + ut.substr(1) + "$")) : _e.names.push(new RegExp("^" + ut + "$")));
            for (dt = 0; dt < _e.instances.length; dt++) {
                var ft = _e.instances[dt];
                ft.enabled = _e.enabled(ft.namespace)
            }
        }

        function at() {
            _e.enable("")
        }

        function st(ut) {
            if (ut[ut.length - 1] === "*") return !0;
            var dt, ct;
            for (dt = 0, ct = _e.skips.length; dt < ct; dt++)
                if (_e.skips[dt].test(ut)) return !1;
            for (dt = 0, ct = _e.names.length; dt < ct; dt++)
                if (_e.names[dt].test(ut)) return !0;
            return !1
        }

        function lt(ut) {
            return ut instanceof Error ? ut.stack || ut.message : ut
        }
    })(debug$6, debug$6.exports);
    var debugExports$1 = debug$6.exports;
    (function(_, _e) {
        _e = _.exports = debugExports$1, _e.log = nt, _e.formatArgs = tt, _e.save = ot, _e.load = at, _e.useColors = et, _e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : st(), _e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

        function et() {
            return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        _e.formatters.j = function(lt) {
            try {
                return JSON.stringify(lt)
            } catch (ut) {
                return "[UnexpectedJSONParseError]: " + ut.message
            }
        };

        function tt(lt) {
            var ut = this.useColors;
            if (lt[0] = (ut ? "%c" : "") + this.namespace + (ut ? " %c" : " ") + lt[0] + (ut ? "%c " : " ") + "+" + _e.humanize(this.diff), !!ut) {
                var dt = "color: " + this.color;
                lt.splice(1, 0, dt, "color: inherit");
                var ct = 0,
                    pt = 0;
                lt[0].replace(/%[a-zA-Z%]/g, function(ft) {
                    ft !== "%%" && (ct++, ft === "%c" && (pt = ct))
                }), lt.splice(pt, 0, dt)
            }
        }

        function nt() {
            return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
        }

        function ot(lt) {
            try {
                lt == null ? _e.storage.removeItem("debug") : _e.storage.debug = lt
            } catch (ut) {}
        }

        function at() {
            var lt;
            try {
                lt = _e.storage.debug
            } catch (ut) {}
            return !lt && typeof process < "u" && "env" in process && (lt = {}.DEBUG), lt
        }
        _e.enable(at());

        function st() {
            try {
                return window.localStorage
            } catch (lt) {}
        }
    })(browser$2, browser$2.exports);
    var browserExports$1 = browser$2.exports,
        componentEmitter = {
            exports: {}
        };
    (function(_) {
        _.exports = _e;

        function _e(tt) {
            if (tt) return et(tt)
        }

        function et(tt) {
            for (var nt in _e.prototype) tt[nt] = _e.prototype[nt];
            return tt
        }
        _e.prototype.on = _e.prototype.addEventListener = function(tt, nt) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + tt] = this._callbacks["$" + tt] || []).push(nt), this
        }, _e.prototype.once = function(tt, nt) {
            function ot() {
                this.off(tt, ot), nt.apply(this, arguments)
            }
            return ot.fn = nt, this.on(tt, ot), this
        }, _e.prototype.off = _e.prototype.removeListener = _e.prototype.removeAllListeners = _e.prototype.removeEventListener = function(tt, nt) {
            if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this;
            var ot = this._callbacks["$" + tt];
            if (!ot) return this;
            if (arguments.length == 1) return delete this._callbacks["$" + tt], this;
            for (var at, st = 0; st < ot.length; st++)
                if (at = ot[st], at === nt || at.fn === nt) {
                    ot.splice(st, 1);
                    break
                }
            return ot.length === 0 && delete this._callbacks["$" + tt], this
        }, _e.prototype.emit = function(tt) {
            this._callbacks = this._callbacks || {};
            for (var nt = new Array(arguments.length - 1), ot = this._callbacks["$" + tt], at = 1; at < arguments.length; at++) nt[at - 1] = arguments[at];
            if (ot) {
                ot = ot.slice(0);
                for (var at = 0, st = ot.length; at < st; ++at) ot[at].apply(this, nt)
            }
            return this
        }, _e.prototype.listeners = function(tt) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + tt] || []
        }, _e.prototype.hasListeners = function(tt) {
            return !!this.listeners(tt).length
        }
    })(componentEmitter);
    var componentEmitterExports = componentEmitter.exports,
        binary = {},
        toString$2 = {}.toString,
        isarray = Array.isArray || function(_) {
            return toString$2.call(_) == "[object Array]"
        },
        isBuffer = isBuf$1,
        withNativeBuffer = typeof Buffer == "function" && typeof Buffer.isBuffer == "function",
        withNativeArrayBuffer = typeof ArrayBuffer == "function",
        isView = function(_) {
            return typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(_) : _.buffer instanceof ArrayBuffer
        };

    function isBuf$1(_) {
        return withNativeBuffer && Buffer.isBuffer(_) || withNativeArrayBuffer && (_ instanceof ArrayBuffer || isView(_))
    }
    var isArray$1 = isarray,
        isBuf = isBuffer,
        toString$1 = Object.prototype.toString,
        withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && toString$1.call(Blob) === "[object BlobConstructor]",
        withNativeFile$1 = typeof File == "function" || typeof File < "u" && toString$1.call(File) === "[object FileConstructor]";
    binary.deconstructPacket = function(_) {
        var _e = [],
            et = _.data,
            tt = _;
        return tt.data = _deconstructPacket(et, _e), tt.attachments = _e.length, {
            packet: tt,
            buffers: _e
        }
    };

    function _deconstructPacket(_, _e) {
        if (!_) return _;
        if (isBuf(_)) {
            var et = {
                _placeholder: !0,
                num: _e.length
            };
            return _e.push(_), et
        } else if (isArray$1(_)) {
            for (var tt = new Array(_.length), nt = 0; nt < _.length; nt++) tt[nt] = _deconstructPacket(_[nt], _e);
            return tt
        } else if (typeof _ == "object" && !(_ instanceof Date)) {
            var tt = {};
            for (var ot in _) tt[ot] = _deconstructPacket(_[ot], _e);
            return tt
        }
        return _
    }
    binary.reconstructPacket = function(_, _e) {
        return _.data = _reconstructPacket(_.data, _e), _.attachments = void 0, _
    };

    function _reconstructPacket(_, _e) {
        if (!_) return _;
        if (_ && _._placeholder === !0) {
            var et = typeof _.num == "number" && _.num >= 0 && _.num < _e.length;
            if (et) return _e[_.num];
            throw new Error("illegal attachments")
        } else if (isArray$1(_))
            for (var tt = 0; tt < _.length; tt++) _[tt] = _reconstructPacket(_[tt], _e);
        else if (typeof _ == "object")
            for (var nt in _) _[nt] = _reconstructPacket(_[nt], _e);
        return _
    }
    binary.removeBlobs = function(_, _e) {
            function et(ot, at, st) {
                if (!ot) return ot;
                if (withNativeBlob$1 && ot instanceof Blob || withNativeFile$1 && ot instanceof File) {
                    tt++;
                    var lt = new FileReader;
                    lt.onload = function() {
                        st ? st[at] = this.result : nt = this.result, --tt || _e(nt)
                    }, lt.readAsArrayBuffer(ot)
                } else if (isArray$1(ot))
                    for (var ut = 0; ut < ot.length; ut++) et(ot[ut], ut, ot);
                else if (typeof ot == "object" && !isBuf(ot))
                    for (var dt in ot) et(ot[dt], dt, ot)
            }
            var tt = 0,
                nt = _;
            et(nt), tt || _e(nt)
        },
        function(_) {
            var _e = browserExports$1("socket.io-parser"),
                et = componentEmitterExports,
                tt = binary,
                nt = isarray,
                ot = isBuffer;
            _.protocol = 4, _.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], _.CONNECT = 0, _.DISCONNECT = 1, _.EVENT = 2, _.ACK = 3, _.ERROR = 4, _.BINARY_EVENT = 5, _.BINARY_ACK = 6, _.Encoder = at, _.Decoder = ct;

            function at() {}
            var st = _.ERROR + '"encode error"';
            at.prototype.encode = function(bt, gt) {
                if (_e("encoding packet %j", bt), _.BINARY_EVENT === bt.type || _.BINARY_ACK === bt.type) dt(bt, gt);
                else {
                    var vt = lt(bt);
                    gt([vt])
                }
            };

            function lt(bt) {
                var gt = "" + bt.type;
                if ((_.BINARY_EVENT === bt.type || _.BINARY_ACK === bt.type) && (gt += bt.attachments + "-"), bt.nsp && bt.nsp !== "/" && (gt += bt.nsp + ","), bt.id != null && (gt += bt.id), bt.data != null) {
                    var vt = ut(bt.data);
                    if (vt !== !1) gt += vt;
                    else return st
                }
                return _e("encoded %j as %s", bt, gt), gt
            }

            function ut(bt) {
                try {
                    return JSON.stringify(bt)
                } catch (gt) {
                    return !1
                }
            }

            function dt(bt, gt) {
                function vt(xt) {
                    var yt = tt.deconstructPacket(xt),
                        Et = lt(yt.packet),
                        wt = yt.buffers;
                    wt.unshift(Et), gt(wt)
                }
                tt.removeBlobs(bt, vt)
            }

            function ct() {
                this.reconstructor = null
            }
            et(ct.prototype), ct.prototype.add = function(bt) {
                var gt;
                if (typeof bt == "string") {
                    if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
                    gt = pt(bt), _.BINARY_EVENT === gt.type || _.BINARY_ACK === gt.type ? (this.reconstructor = new ht(gt), this.reconstructor.reconPack.attachments === 0 && this.emit("decoded", gt)) : this.emit("decoded", gt)
                } else if (ot(bt) || bt.base64)
                    if (this.reconstructor) gt = this.reconstructor.takeBinaryData(bt), gt && (this.reconstructor = null, this.emit("decoded", gt));
                    else throw new Error("got binary data when not reconstructing a packet");
                else throw new Error("Unknown type: " + bt)
            };

            function pt(bt) {
                var gt = 0,
                    vt = {
                        type: Number(bt.charAt(0))
                    };
                if (_.types[vt.type] == null) return mt("unknown packet type " + vt.type);
                if (_.BINARY_EVENT === vt.type || _.BINARY_ACK === vt.type) {
                    for (var xt = gt + 1; bt.charAt(++gt) !== "-" && gt != bt.length;);
                    var yt = bt.substring(xt, gt);
                    if (yt != Number(yt) || bt.charAt(gt) !== "-") throw new Error("Illegal attachments");
                    vt.attachments = Number(yt)
                }
                if (bt.charAt(gt + 1) === "/") {
                    for (var xt = gt + 1; ++gt;) {
                        var Et = bt.charAt(gt);
                        if (Et === "," || gt === bt.length) break
                    }
                    vt.nsp = bt.substring(xt, gt)
                } else vt.nsp = "/";
                var wt = bt.charAt(gt + 1);
                if (wt !== "" && Number(wt) == wt) {
                    for (var xt = gt + 1; ++gt;) {
                        var Et = bt.charAt(gt);
                        if (Et == null || Number(Et) != Et) {
                            --gt;
                            break
                        }
                        if (gt === bt.length) break
                    }
                    vt.id = Number(bt.substring(xt, gt + 1))
                }
                if (bt.charAt(++gt)) {
                    var St = ft(bt.substr(gt)),
                        $t = St !== !1 && (vt.type === _.ERROR || nt(St));
                    if ($t) vt.data = St;
                    else return mt("invalid payload")
                }
                return _e("decoded %s as %j", bt, vt), vt
            }

            function ft(bt) {
                try {
                    return JSON.parse(bt)
                } catch (gt) {
                    return !1
                }
            }
            ct.prototype.destroy = function() {
                this.reconstructor && this.reconstructor.finishedReconstruction()
            };

            function ht(bt) {
                this.reconPack = bt, this.buffers = []
            }
            ht.prototype.takeBinaryData = function(bt) {
                if (this.buffers.push(bt), this.buffers.length === this.reconPack.attachments) {
                    var gt = tt.reconstructPacket(this.reconPack, this.buffers);
                    return this.finishedReconstruction(), gt
                }
                return null
            }, ht.prototype.finishedReconstruction = function() {
                this.reconPack = null, this.buffers = []
            };

            function mt(bt) {
                return {
                    type: _.ERROR,
                    data: "parser error: " + bt
                }
            }
        }(socket_ioParser);
    var lib = {
            exports: {}
        },
        transports$1 = {},
        hasCors = {
            exports: {}
        };
    try {
        hasCors.exports = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest
    } catch (_) {
        hasCors.exports = !1
    }
    var hasCorsExports = hasCors.exports,
        globalThis_browser = function() {
            return typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")()
        }(),
        hasCORS = hasCorsExports,
        globalThis$3 = globalThis_browser,
        xmlhttprequest_browser = function(_) {
            var _e = _.xdomain,
                et = _.xscheme,
                tt = _.enablesXDR;
            try {
                if (typeof XMLHttpRequest < "u" && (!_e || hasCORS)) return new XMLHttpRequest
            } catch (nt) {}
            try {
                if (typeof XDomainRequest < "u" && !et && tt) return new XDomainRequest
            } catch (nt) {}
            if (!_e) try {
                return new globalThis$3[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
            } catch (nt) {}
        },
        pollingXhr = {
            exports: {}
        },
        browser$1 = {},
        keys = Object.keys || function _(_e) {
            var et = [],
                tt = Object.prototype.hasOwnProperty;
            for (var nt in _e) tt.call(_e, nt) && et.push(nt);
            return et
        },
        isArray = isarray,
        toString = Object.prototype.toString,
        withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]",
        withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]",
        hasBinary2 = hasBinary;

    function hasBinary(_) {
        if (!_ || typeof _ != "object") return !1;
        if (isArray(_)) {
            for (var _e = 0, et = _.length; _e < et; _e++)
                if (hasBinary(_[_e])) return !0;
            return !1
        }
        if (typeof Buffer == "function" && Buffer.isBuffer && Buffer.isBuffer(_) || typeof ArrayBuffer == "function" && _ instanceof ArrayBuffer || withNativeBlob && _ instanceof Blob || withNativeFile && _ instanceof File) return !0;
        if (_.toJSON && typeof _.toJSON == "function" && arguments.length === 1) return hasBinary(_.toJSON(), !0);
        for (var tt in _)
            if (Object.prototype.hasOwnProperty.call(_, tt) && hasBinary(_[tt])) return !0;
        return !1
    }
    var arraybuffer_slice = function(_, _e, et) {
            var tt = _.byteLength;
            if (_e = _e || 0, et = et || tt, _.slice) return _.slice(_e, et);
            if (_e < 0 && (_e += tt), et < 0 && (et += tt), et > tt && (et = tt), _e >= tt || _e >= et || tt === 0) return new ArrayBuffer(0);
            for (var nt = new Uint8Array(_), ot = new Uint8Array(et - _e), at = _e, st = 0; at < et; at++, st++) ot[st] = nt[at];
            return ot.buffer
        },
        after_1 = after;

    function after(_, _e, et) {
        var tt = !1;
        return et = et || noop$2, nt.count = _, _ === 0 ? _e() : nt;

        function nt(ot, at) {
            if (nt.count <= 0) throw new Error("after called too many times");
            --nt.count, ot ? (tt = !0, _e(ot), _e = et) : nt.count === 0 && !tt && _e(null, at)
        }
    }

    function noop$2() {}
    var stringFromCharCode = String.fromCharCode;

    function ucs2decode(_) {
        for (var _e = [], et = 0, tt = _.length, nt, ot; et < tt;) nt = _.charCodeAt(et++), nt >= 55296 && nt <= 56319 && et < tt ? (ot = _.charCodeAt(et++), (ot & 64512) == 56320 ? _e.push(((nt & 1023) << 10) + (ot & 1023) + 65536) : (_e.push(nt), et--)) : _e.push(nt);
        return _e
    }

    function ucs2encode(_) {
        for (var _e = _.length, et = -1, tt, nt = ""; ++et < _e;) tt = _[et], tt > 65535 && (tt -= 65536, nt += stringFromCharCode(tt >>> 10 & 1023 | 55296), tt = 56320 | tt & 1023), nt += stringFromCharCode(tt);
        return nt
    }

    function checkScalarValue(_, _e) {
        if (_ >= 55296 && _ <= 57343) {
            if (_e) throw Error("Lone surrogate U+" + _.toString(16).toUpperCase() + " is not a scalar value");
            return !1
        }
        return !0
    }

    function createByte(_, _e) {
        return stringFromCharCode(_ >> _e & 63 | 128)
    }

    function encodeCodePoint(_, _e) {
        if (!(_ & 4294967168)) return stringFromCharCode(_);
        var et = "";
        return _ & 4294965248 ? _ & 4294901760 ? _ & 4292870144 || (et = stringFromCharCode(_ >> 18 & 7 | 240), et += createByte(_, 12), et += createByte(_, 6)) : (checkScalarValue(_, _e) || (_ = 65533), et = stringFromCharCode(_ >> 12 & 15 | 224), et += createByte(_, 6)) : et = stringFromCharCode(_ >> 6 & 31 | 192), et += stringFromCharCode(_ & 63 | 128), et
    }

    function utf8encode(_, _e) {
        _e = _e || {};
        for (var et = _e.strict !== !1, tt = ucs2decode(_), nt = tt.length, ot = -1, at, st = ""; ++ot < nt;) at = tt[ot], st += encodeCodePoint(at, et);
        return st
    }

    function readContinuationByte() {
        if (byteIndex >= byteCount) throw Error("Invalid byte index");
        var _ = byteArray[byteIndex] & 255;
        if (byteIndex++, (_ & 192) == 128) return _ & 63;
        throw Error("Invalid continuation byte")
    }

    function decodeSymbol(_) {
        var _e, et, tt, nt, ot;
        if (byteIndex > byteCount) throw Error("Invalid byte index");
        if (byteIndex == byteCount) return !1;
        if (_e = byteArray[byteIndex] & 255, byteIndex++, !(_e & 128)) return _e;
        if ((_e & 224) == 192) {
            if (et = readContinuationByte(), ot = (_e & 31) << 6 | et, ot >= 128) return ot;
            throw Error("Invalid continuation byte")
        }
        if ((_e & 240) == 224) {
            if (et = readContinuationByte(), tt = readContinuationByte(), ot = (_e & 15) << 12 | et << 6 | tt, ot >= 2048) return checkScalarValue(ot, _) ? ot : 65533;
            throw Error("Invalid continuation byte")
        }
        if ((_e & 248) == 240 && (et = readContinuationByte(), tt = readContinuationByte(), nt = readContinuationByte(), ot = (_e & 7) << 18 | et << 12 | tt << 6 | nt, ot >= 65536 && ot <= 1114111)) return ot;
        throw Error("Invalid UTF-8 detected")
    }
    var byteArray, byteCount, byteIndex;

    function utf8decode(_, _e) {
        _e = _e || {};
        var et = _e.strict !== !1;
        byteArray = ucs2decode(_), byteCount = byteArray.length, byteIndex = 0;
        for (var tt = [], nt;
            (nt = decodeSymbol(et)) !== !1;) tt.push(nt);
        return ucs2encode(tt)
    }
    var utf8$2 = {
            version: "2.1.2",
            encode: utf8encode,
            decode: utf8decode
        },
        base64Arraybuffer = {},
        hasRequiredBase64Arraybuffer;

    function requireBase64Arraybuffer() {
        return hasRequiredBase64Arraybuffer || (hasRequiredBase64Arraybuffer = 1, function(_) {
            base64Arraybuffer.encode = function(_e) {
                var et = new Uint8Array(_e),
                    tt, nt = et.length,
                    ot = "";
                for (tt = 0; tt < nt; tt += 3) ot += _[et[tt] >> 2], ot += _[(et[tt] & 3) << 4 | et[tt + 1] >> 4], ot += _[(et[tt + 1] & 15) << 2 | et[tt + 2] >> 6], ot += _[et[tt + 2] & 63];
                return nt % 3 === 2 ? ot = ot.substring(0, ot.length - 1) + "=" : nt % 3 === 1 && (ot = ot.substring(0, ot.length - 2) + "=="), ot
            }, base64Arraybuffer.decode = function(_e) {
                var et = _e.length * .75,
                    tt = _e.length,
                    nt, ot = 0,
                    at, st, lt, ut;
                _e[_e.length - 1] === "=" && (et--, _e[_e.length - 2] === "=" && et--);
                var dt = new ArrayBuffer(et),
                    ct = new Uint8Array(dt);
                for (nt = 0; nt < tt; nt += 4) at = _.indexOf(_e[nt]), st = _.indexOf(_e[nt + 1]), lt = _.indexOf(_e[nt + 2]), ut = _.indexOf(_e[nt + 3]), ct[ot++] = at << 2 | st >> 4, ct[ot++] = (st & 15) << 4 | lt >> 2, ct[ot++] = (lt & 3) << 6 | ut & 63;
                return dt
            }
        }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")), base64Arraybuffer
    }
    var blob, hasRequiredBlob;

    function requireBlob() {
        if (hasRequiredBlob) return blob;
        hasRequiredBlob = 1;
        var _ = typeof _ < "u" ? _ : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : !1,
            _e = function() {
                try {
                    var st = new Blob(["hi"]);
                    return st.size === 2
                } catch (lt) {
                    return !1
                }
            }(),
            et = _e && function() {
                try {
                    var st = new Blob([new Uint8Array([1, 2])]);
                    return st.size === 2
                } catch (lt) {
                    return !1
                }
            }(),
            tt = _ && _.prototype.append && _.prototype.getBlob;

        function nt(st) {
            return st.map(function(lt) {
                if (lt.buffer instanceof ArrayBuffer) {
                    var ut = lt.buffer;
                    if (lt.byteLength !== ut.byteLength) {
                        var dt = new Uint8Array(lt.byteLength);
                        dt.set(new Uint8Array(ut, lt.byteOffset, lt.byteLength)), ut = dt.buffer
                    }
                    return ut
                }
                return lt
            })
        }

        function ot(st, lt) {
            lt = lt || {};
            var ut = new _;
            return nt(st).forEach(function(dt) {
                ut.append(dt)
            }), lt.type ? ut.getBlob(lt.type) : ut.getBlob()
        }

        function at(st, lt) {
            return new Blob(nt(st), lt || {})
        }
        return typeof Blob < "u" && (ot.prototype = Blob.prototype, at.prototype = Blob.prototype), blob = function() {
            return _e ? et ? Blob : at : tt ? ot : void 0
        }(), blob
    }(function(_) {
        var _e = keys,
            et = hasBinary2,
            tt = arraybuffer_slice,
            nt = after_1,
            ot = utf8$2,
            at;
        typeof ArrayBuffer < "u" && (at = requireBase64Arraybuffer());
        var st = typeof navigator < "u" && /Android/i.test(navigator.userAgent),
            lt = typeof navigator < "u" && /PhantomJS/i.test(navigator.userAgent),
            ut = st || lt;
        _.protocol = 3;
        var dt = _.packets = {
                open: 0,
                close: 1,
                ping: 2,
                pong: 3,
                message: 4,
                upgrade: 5,
                noop: 6
            },
            ct = _e(dt),
            pt = {
                type: "error",
                data: "parser error"
            },
            ft = requireBlob();
        _.encodePacket = function(yt, Et, wt, St) {
            typeof Et == "function" && (St = Et, Et = !1), typeof wt == "function" && (St = wt, wt = null);
            var $t = yt.data === void 0 ? void 0 : yt.data.buffer || yt.data;
            if (typeof ArrayBuffer < "u" && $t instanceof ArrayBuffer) return mt(yt, Et, St);
            if (typeof ft < "u" && $t instanceof ft) return gt(yt, Et, St);
            if ($t && $t.base64) return ht(yt, St);
            var Ct = dt[yt.type];
            return yt.data !== void 0 && (Ct += wt ? ot.encode(String(yt.data), {
                strict: !1
            }) : String(yt.data)), St("" + Ct)
        };

        function ht(yt, Et) {
            var wt = "b" + _.packets[yt.type] + yt.data.data;
            return Et(wt)
        }

        function mt(yt, Et, wt) {
            if (!Et) return _.encodeBase64Packet(yt, wt);
            var St = yt.data,
                $t = new Uint8Array(St),
                Ct = new Uint8Array(1 + St.byteLength);
            Ct[0] = dt[yt.type];
            for (var Rt = 0; Rt < $t.length; Rt++) Ct[Rt + 1] = $t[Rt];
            return wt(Ct.buffer)
        }

        function bt(yt, Et, wt) {
            if (!Et) return _.encodeBase64Packet(yt, wt);
            var St = new FileReader;
            return St.onload = function() {
                _.encodePacket({
                    type: yt.type,
                    data: St.result
                }, Et, !0, wt)
            }, St.readAsArrayBuffer(yt.data)
        }

        function gt(yt, Et, wt) {
            if (!Et) return _.encodeBase64Packet(yt, wt);
            if (ut) return bt(yt, Et, wt);
            var St = new Uint8Array(1);
            St[0] = dt[yt.type];
            var $t = new ft([St.buffer, yt.data]);
            return wt($t)
        }
        _.encodeBase64Packet = function(yt, Et) {
            var wt = "b" + _.packets[yt.type];
            if (typeof ft < "u" && yt.data instanceof ft) {
                var St = new FileReader;
                return St.onload = function() {
                    var Tt = St.result.split(",")[1];
                    Et(wt + Tt)
                }, St.readAsDataURL(yt.data)
            }
            var $t;
            try {
                $t = String.fromCharCode.apply(null, new Uint8Array(yt.data))
            } catch (Tt) {
                for (var Ct = new Uint8Array(yt.data), Rt = new Array(Ct.length), Pt = 0; Pt < Ct.length; Pt++) Rt[Pt] = Ct[Pt];
                $t = String.fromCharCode.apply(null, Rt)
            }
            return wt += btoa($t), Et(wt)
        }, _.decodePacket = function(yt, Et, wt) {
            if (yt === void 0) return pt;
            if (typeof yt == "string") {
                if (yt.charAt(0) === "b") return _.decodeBase64Packet(yt.substr(1), Et);
                if (wt && (yt = vt(yt), yt === !1)) return pt;
                var $t = yt.charAt(0);
                return Number($t) != $t || !ct[$t] ? pt : yt.length > 1 ? {
                    type: ct[$t],
                    data: yt.substring(1)
                } : {
                    type: ct[$t]
                }
            }
            var St = new Uint8Array(yt),
                $t = St[0],
                Ct = tt(yt, 1);
            return ft && Et === "blob" && (Ct = new ft([Ct])), {
                type: ct[$t],
                data: Ct
            }
        };

        function vt(yt) {
            try {
                yt = ot.decode(yt, {
                    strict: !1
                })
            } catch (Et) {
                return !1
            }
            return yt
        }
        _.decodeBase64Packet = function(yt, Et) {
            var wt = ct[yt.charAt(0)];
            if (!at) return {
                type: wt,
                data: {
                    base64: !0,
                    data: yt.substr(1)
                }
            };
            var St = at.decode(yt.substr(1));
            return Et === "blob" && ft && (St = new ft([St])), {
                type: wt,
                data: St
            }
        }, _.encodePayload = function(yt, Et, wt) {
            typeof Et == "function" && (wt = Et, Et = null);
            var St = et(yt);
            if (Et && St) return ft && !ut ? _.encodePayloadAsBlob(yt, wt) : _.encodePayloadAsArrayBuffer(yt, wt);
            if (!yt.length) return wt("0:");

            function $t(Rt) {
                return Rt.length + ":" + Rt
            }

            function Ct(Rt, Pt) {
                _.encodePacket(Rt, St ? Et : !1, !1, function(Tt) {
                    Pt(null, $t(Tt))
                })
            }
            xt(yt, Ct, function(Rt, Pt) {
                return wt(Pt.join(""))
            })
        };

        function xt(yt, Et, wt) {
            for (var St = new Array(yt.length), $t = nt(yt.length, wt), Ct = function(Pt, Tt, It) {
                    Et(Tt, function(Ot, Dt) {
                        St[Pt] = Dt, It(Ot, St)
                    })
                }, Rt = 0; Rt < yt.length; Rt++) Ct(Rt, yt[Rt], $t)
        }
        _.decodePayload = function(yt, Et, wt) {
            if (typeof yt != "string") return _.decodePayloadAsBinary(yt, Et, wt);
            typeof Et == "function" && (wt = Et, Et = null);
            var St;
            if (yt === "") return wt(pt, 0, 1);
            for (var $t = "", Ct, Rt, Pt = 0, Tt = yt.length; Pt < Tt; Pt++) {
                var It = yt.charAt(Pt);
                if (It !== ":") {
                    $t += It;
                    continue
                }
                if ($t === "" || $t != (Ct = Number($t)) || (Rt = yt.substr(Pt + 1, Ct), $t != Rt.length)) return wt(pt, 0, 1);
                if (Rt.length) {
                    if (St = _.decodePacket(Rt, Et, !1), pt.type === St.type && pt.data === St.data) return wt(pt, 0, 1);
                    var Ot = wt(St, Pt + Ct, Tt);
                    if (Ot === !1) return
                }
                Pt += Ct, $t = ""
            }
            if ($t !== "") return wt(pt, 0, 1)
        }, _.encodePayloadAsArrayBuffer = function(yt, Et) {
            if (!yt.length) return Et(new ArrayBuffer(0));

            function wt(St, $t) {
                _.encodePacket(St, !0, !0, function(Ct) {
                    return $t(null, Ct)
                })
            }
            xt(yt, wt, function(St, $t) {
                var Ct = $t.reduce(function(Tt, It) {
                        var Ot;
                        return typeof It == "string" ? Ot = It.length : Ot = It.byteLength, Tt + Ot.toString().length + Ot + 2
                    }, 0),
                    Rt = new Uint8Array(Ct),
                    Pt = 0;
                return $t.forEach(function(Tt) {
                    var It = typeof Tt == "string",
                        Ot = Tt;
                    if (It) {
                        for (var Dt = new Uint8Array(Tt.length), jt = 0; jt < Tt.length; jt++) Dt[jt] = Tt.charCodeAt(jt);
                        Ot = Dt.buffer
                    }
                    It ? Rt[Pt++] = 0 : Rt[Pt++] = 1;
                    for (var Ht = Ot.byteLength.toString(), jt = 0; jt < Ht.length; jt++) Rt[Pt++] = parseInt(Ht[jt]);
                    Rt[Pt++] = 255;
                    for (var Dt = new Uint8Array(Ot), jt = 0; jt < Dt.length; jt++) Rt[Pt++] = Dt[jt]
                }), Et(Rt.buffer)
            })
        }, _.encodePayloadAsBlob = function(yt, Et) {
            function wt(St, $t) {
                _.encodePacket(St, !0, !0, function(Ct) {
                    var Rt = new Uint8Array(1);
                    if (Rt[0] = 1, typeof Ct == "string") {
                        for (var Pt = new Uint8Array(Ct.length), Tt = 0; Tt < Ct.length; Tt++) Pt[Tt] = Ct.charCodeAt(Tt);
                        Ct = Pt.buffer, Rt[0] = 0
                    }
                    for (var It = Ct instanceof ArrayBuffer ? Ct.byteLength : Ct.size, Ot = It.toString(), Dt = new Uint8Array(Ot.length + 1), Tt = 0; Tt < Ot.length; Tt++) Dt[Tt] = parseInt(Ot[Tt]);
                    if (Dt[Ot.length] = 255, ft) {
                        var jt = new ft([Rt.buffer, Dt.buffer, Ct]);
                        $t(null, jt)
                    }
                })
            }
            xt(yt, wt, function(St, $t) {
                return Et(new ft($t))
            })
        }, _.decodePayloadAsBinary = function(yt, Et, wt) {
            typeof Et == "function" && (wt = Et, Et = null);
            for (var St = yt, $t = []; St.byteLength > 0;) {
                for (var Ct = new Uint8Array(St), Rt = Ct[0] === 0, Pt = "", Tt = 1; Ct[Tt] !== 255; Tt++) {
                    if (Pt.length > 310) return wt(pt, 0, 1);
                    Pt += Ct[Tt]
                }
                St = tt(St, 2 + Pt.length), Pt = parseInt(Pt);
                var It = tt(St, 0, Pt);
                if (Rt) try {
                    It = String.fromCharCode.apply(null, new Uint8Array(It))
                } catch (jt) {
                    var Ot = new Uint8Array(It);
                    It = "";
                    for (var Tt = 0; Tt < Ot.length; Tt++) It += String.fromCharCode(Ot[Tt])
                }
                $t.push(It), St = tt(St, Pt)
            }
            var Dt = $t.length;
            $t.forEach(function(jt, Ht) {
                wt(_.decodePacket(jt, Et, !0), Ht, Dt)
            })
        }
    })(browser$1);
    var transport, hasRequiredTransport;

    function requireTransport() {
        if (hasRequiredTransport) return transport;
        hasRequiredTransport = 1;
        var _ = browser$1,
            _e = componentEmitterExports;
        transport = et;

        function et(tt) {
            this.path = tt.path, this.hostname = tt.hostname, this.port = tt.port, this.secure = tt.secure, this.query = tt.query, this.timestampParam = tt.timestampParam, this.timestampRequests = tt.timestampRequests, this.readyState = "", this.agent = tt.agent || !1, this.socket = tt.socket, this.enablesXDR = tt.enablesXDR, this.withCredentials = tt.withCredentials, this.pfx = tt.pfx, this.key = tt.key, this.passphrase = tt.passphrase, this.cert = tt.cert, this.ca = tt.ca, this.ciphers = tt.ciphers, this.rejectUnauthorized = tt.rejectUnauthorized, this.forceNode = tt.forceNode, this.isReactNative = tt.isReactNative, this.extraHeaders = tt.extraHeaders, this.localAddress = tt.localAddress
        }
        return _e(et.prototype), et.prototype.onError = function(tt, nt) {
            var ot = new Error(tt);
            return ot.type = "TransportError", ot.description = nt, this.emit("error", ot), this
        }, et.prototype.open = function() {
            return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this
        }, et.prototype.close = function() {
            return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this
        }, et.prototype.send = function(tt) {
            if (this.readyState === "open") this.write(tt);
            else throw new Error("Transport not open")
        }, et.prototype.onOpen = function() {
            this.readyState = "open", this.writable = !0, this.emit("open")
        }, et.prototype.onData = function(tt) {
            var nt = _.decodePacket(tt, this.socket.binaryType);
            this.onPacket(nt)
        }, et.prototype.onPacket = function(tt) {
            this.emit("packet", tt)
        }, et.prototype.onClose = function() {
            this.readyState = "closed", this.emit("close")
        }, transport
    }
    var parseqs$3 = {};
    parseqs$3.encode = function(_) {
        var _e = "";
        for (var et in _) _.hasOwnProperty(et) && (_e.length && (_e += "&"), _e += encodeURIComponent(et) + "=" + encodeURIComponent(_[et]));
        return _e
    }, parseqs$3.decode = function(_) {
        for (var _e = {}, et = _.split("&"), tt = 0, nt = et.length; tt < nt; tt++) {
            var ot = et[tt].split("=");
            _e[decodeURIComponent(ot[0])] = decodeURIComponent(ot[1])
        }
        return _e
    };
    var componentInherit = function(_, _e) {
            var et = function() {};
            et.prototype = _e.prototype, _.prototype = new et, _.prototype.constructor = _
        },
        alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
        length = 64,
        map = {},
        seed = 0,
        i$1 = 0,
        prev;

    function encode(_) {
        var _e = "";
        do _e = alphabet[_ % length] + _e, _ = Math.floor(_ / length); while (_ > 0);
        return _e
    }

    function decode(_) {
        var _e = 0;
        for (i$1 = 0; i$1 < _.length; i$1++) _e = _e * length + map[_.charAt(i$1)];
        return _e
    }

    function yeast$2() {
        var _ = encode(+new Date);
        return _ !== prev ? (seed = 0, prev = _) : _ + "." + encode(seed++)
    }
    for (; i$1 < length; i$1++) map[alphabet[i$1]] = i$1;
    yeast$2.encode = encode, yeast$2.decode = decode;
    var yeast_1 = yeast$2,
        browser = {
            exports: {}
        },
        debug$5 = {
            exports: {}
        },
        s$1 = 1e3,
        m$1 = s$1 * 60,
        h = m$1 * 60,
        d$1 = h * 24,
        y$1 = d$1 * 365.25,
        ms = function(_, _e) {
            _e = _e || {};
            var et = typeof _;
            if (et === "string" && _.length > 0) return parse(_);
            if (et === "number" && isNaN(_) === !1) return _e.long ? fmtLong(_) : fmtShort(_);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(_))
        };

    function parse(_) {
        if (_ = String(_), !(_.length > 100)) {
            var _e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(_);
            if (_e) {
                var et = parseFloat(_e[1]),
                    tt = (_e[2] || "ms").toLowerCase();
                switch (tt) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return et * y$1;
                    case "days":
                    case "day":
                    case "d":
                        return et * d$1;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return et * h;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return et * m$1;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return et * s$1;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return et;
                    default:
                        return
                }
            }
        }
    }

    function fmtShort(_) {
        return _ >= d$1 ? Math.round(_ / d$1) + "d" : _ >= h ? Math.round(_ / h) + "h" : _ >= m$1 ? Math.round(_ / m$1) + "m" : _ >= s$1 ? Math.round(_ / s$1) + "s" : _ + "ms"
    }

    function fmtLong(_) {
        return plural(_, d$1, "day") || plural(_, h, "hour") || plural(_, m$1, "minute") || plural(_, s$1, "second") || _ + " ms"
    }

    function plural(_, _e, et) {
        if (!(_ < _e)) return _ < _e * 1.5 ? Math.floor(_ / _e) + " " + et : Math.ceil(_ / _e) + " " + et + "s"
    }(function(_, _e) {
        _e = _.exports = tt.debug = tt.default = tt, _e.coerce = lt, _e.disable = at, _e.enable = ot, _e.enabled = st, _e.humanize = ms, _e.instances = [], _e.names = [], _e.skips = [], _e.formatters = {};

        function et(ut) {
            var dt = 0,
                ct;
            for (ct in ut) dt = (dt << 5) - dt + ut.charCodeAt(ct), dt |= 0;
            return _e.colors[Math.abs(dt) % _e.colors.length]
        }

        function tt(ut) {
            var dt;

            function ct() {
                if (ct.enabled) {
                    var pt = ct,
                        ft = +new Date,
                        ht = ft - (dt || ft);
                    pt.diff = ht, pt.prev = dt, pt.curr = ft, dt = ft;
                    for (var mt = new Array(arguments.length), bt = 0; bt < mt.length; bt++) mt[bt] = arguments[bt];
                    mt[0] = _e.coerce(mt[0]), typeof mt[0] != "string" && mt.unshift("%O");
                    var gt = 0;
                    mt[0] = mt[0].replace(/%([a-zA-Z%])/g, function(xt, yt) {
                        if (xt === "%%") return xt;
                        gt++;
                        var Et = _e.formatters[yt];
                        if (typeof Et == "function") {
                            var wt = mt[gt];
                            xt = Et.call(pt, wt), mt.splice(gt, 1), gt--
                        }
                        return xt
                    }), _e.formatArgs.call(pt, mt);
                    var vt = ct.log || _e.log || console.log.bind(console);
                    vt.apply(pt, mt)
                }
            }
            return ct.namespace = ut, ct.enabled = _e.enabled(ut), ct.useColors = _e.useColors(), ct.color = et(ut), ct.destroy = nt, typeof _e.init == "function" && _e.init(ct), _e.instances.push(ct), ct
        }

        function nt() {
            var ut = _e.instances.indexOf(this);
            return ut !== -1 ? (_e.instances.splice(ut, 1), !0) : !1
        }

        function ot(ut) {
            _e.save(ut), _e.names = [], _e.skips = [];
            var dt, ct = (typeof ut == "string" ? ut : "").split(/[\s,]+/),
                pt = ct.length;
            for (dt = 0; dt < pt; dt++) ct[dt] && (ut = ct[dt].replace(/\*/g, ".*?"), ut[0] === "-" ? _e.skips.push(new RegExp("^" + ut.substr(1) + "$")) : _e.names.push(new RegExp("^" + ut + "$")));
            for (dt = 0; dt < _e.instances.length; dt++) {
                var ft = _e.instances[dt];
                ft.enabled = _e.enabled(ft.namespace)
            }
        }

        function at() {
            _e.enable("")
        }

        function st(ut) {
            if (ut[ut.length - 1] === "*") return !0;
            var dt, ct;
            for (dt = 0, ct = _e.skips.length; dt < ct; dt++)
                if (_e.skips[dt].test(ut)) return !1;
            for (dt = 0, ct = _e.names.length; dt < ct; dt++)
                if (_e.names[dt].test(ut)) return !0;
            return !1
        }

        function lt(ut) {
            return ut instanceof Error ? ut.stack || ut.message : ut
        }
    })(debug$5, debug$5.exports);
    var debugExports = debug$5.exports;
    (function(_, _e) {
        _e = _.exports = debugExports, _e.log = nt, _e.formatArgs = tt, _e.save = ot, _e.load = at, _e.useColors = et, _e.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : st(), _e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

        function et() {
            return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        _e.formatters.j = function(lt) {
            try {
                return JSON.stringify(lt)
            } catch (ut) {
                return "[UnexpectedJSONParseError]: " + ut.message
            }
        };

        function tt(lt) {
            var ut = this.useColors;
            if (lt[0] = (ut ? "%c" : "") + this.namespace + (ut ? " %c" : " ") + lt[0] + (ut ? "%c " : " ") + "+" + _e.humanize(this.diff), !!ut) {
                var dt = "color: " + this.color;
                lt.splice(1, 0, dt, "color: inherit");
                var ct = 0,
                    pt = 0;
                lt[0].replace(/%[a-zA-Z%]/g, function(ft) {
                    ft !== "%%" && (ct++, ft === "%c" && (pt = ct))
                }), lt.splice(pt, 0, dt)
            }
        }

        function nt() {
            return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
        }

        function ot(lt) {
            try {
                lt == null ? _e.storage.removeItem("debug") : _e.storage.debug = lt
            } catch (ut) {}
        }

        function at() {
            var lt;
            try {
                lt = _e.storage.debug
            } catch (ut) {}
            return !lt && typeof process < "u" && "env" in process && (lt = {}.DEBUG), lt
        }
        _e.enable(at());

        function st() {
            try {
                return window.localStorage
            } catch (lt) {}
        }
    })(browser, browser.exports);
    var browserExports = browser.exports,
        Transport$1 = requireTransport(),
        parseqs$2 = parseqs$3,
        parser$3 = browser$1,
        inherit$3 = componentInherit,
        yeast$1 = yeast_1,
        debug$4 = browserExports("engine.io-client:polling"),
        polling$1 = Polling$2,
        hasXHR2 = function() {
            var _ = xmlhttprequest_browser,
                _e = new _({
                    xdomain: !1
                });
            return _e.responseType != null
        }();

    function Polling$2(_) {
        var _e = _ && _.forceBase64;
        (!hasXHR2 || _e) && (this.supportsBinary = !1), Transport$1.call(this, _)
    }
    inherit$3(Polling$2, Transport$1), Polling$2.prototype.name = "polling", Polling$2.prototype.doOpen = function() {
        this.poll()
    }, Polling$2.prototype.pause = function(_) {
        var _e = this;
        this.readyState = "pausing";

        function et() {
            debug$4("paused"), _e.readyState = "paused", _()
        }
        if (this.polling || !this.writable) {
            var tt = 0;
            this.polling && (debug$4("we are currently polling - waiting to pause"), tt++, this.once("pollComplete", function() {
                debug$4("pre-pause polling complete"), --tt || et()
            })), this.writable || (debug$4("we are currently writing - waiting to pause"), tt++, this.once("drain", function() {
                debug$4("pre-pause writing complete"), --tt || et()
            }))
        } else et()
    }, Polling$2.prototype.poll = function() {
        debug$4("polling"), this.polling = !0, this.doPoll(), this.emit("poll")
    }, Polling$2.prototype.onData = function(_) {
        var _e = this;
        debug$4("polling got data %s", _);
        var et = function(tt, nt, ot) {
            if (_e.readyState === "opening" && tt.type === "open" && _e.onOpen(), tt.type === "close") return _e.onClose(), !1;
            _e.onPacket(tt)
        };
        parser$3.decodePayload(_, this.socket.binaryType, et), this.readyState !== "closed" && (this.polling = !1, this.emit("pollComplete"), this.readyState === "open" ? this.poll() : debug$4('ignoring poll - transport state "%s"', this.readyState))
    }, Polling$2.prototype.doClose = function() {
        var _ = this;

        function _e() {
            debug$4("writing close packet"), _.write([{
                type: "close"
            }])
        }
        this.readyState === "open" ? (debug$4("transport open - closing"), _e()) : (debug$4("transport not open - deferring close"), this.once("open", _e))
    }, Polling$2.prototype.write = function(_) {
        var _e = this;
        this.writable = !1;
        var et = function() {
            _e.writable = !0, _e.emit("drain")
        };
        parser$3.encodePayload(_, this.supportsBinary, function(tt) {
            _e.doWrite(tt, et)
        })
    }, Polling$2.prototype.uri = function() {
        var _ = this.query || {},
            _e = this.secure ? "https" : "http",
            et = "";
        this.timestampRequests !== !1 && (_[this.timestampParam] = yeast$1()), !this.supportsBinary && !_.sid && (_.b64 = 1), _ = parseqs$2.encode(_), this.port && (_e === "https" && Number(this.port) !== 443 || _e === "http" && Number(this.port) !== 80) && (et = ":" + this.port), _.length && (_ = "?" + _);
        var tt = this.hostname.indexOf(":") !== -1;
        return _e + "://" + (tt ? "[" + this.hostname + "]" : this.hostname) + et + this.path + _
    };
    var XMLHttpRequest$2 = xmlhttprequest_browser,
        Polling$1 = polling$1,
        Emitter$2 = componentEmitterExports,
        inherit$2 = componentInherit,
        debug$3 = browserExports("engine.io-client:polling-xhr"),
        globalThis$2 = globalThis_browser;
    pollingXhr.exports = XHR$1, pollingXhr.exports.Request = Request$1;

    function empty$1() {}

    function XHR$1(_) {
        if (Polling$1.call(this, _), this.requestTimeout = _.requestTimeout, this.extraHeaders = _.extraHeaders, typeof location < "u") {
            var _e = location.protocol === "https:",
                et = location.port;
            et || (et = _e ? 443 : 80), this.xd = typeof location < "u" && _.hostname !== location.hostname || et !== _.port, this.xs = _.secure !== _e
        }
    }
    inherit$2(XHR$1, Polling$1), XHR$1.prototype.supportsBinary = !0, XHR$1.prototype.request = function(_) {
        return _ = _ || {}, _.uri = this.uri(), _.xd = this.xd, _.xs = this.xs, _.agent = this.agent || !1, _.supportsBinary = this.supportsBinary, _.enablesXDR = this.enablesXDR, _.withCredentials = this.withCredentials, _.pfx = this.pfx, _.key = this.key, _.passphrase = this.passphrase, _.cert = this.cert, _.ca = this.ca, _.ciphers = this.ciphers, _.rejectUnauthorized = this.rejectUnauthorized, _.requestTimeout = this.requestTimeout, _.extraHeaders = this.extraHeaders, new Request$1(_)
    }, XHR$1.prototype.doWrite = function(_, _e) {
        var et = typeof _ != "string" && _ !== void 0,
            tt = this.request({
                method: "POST",
                data: _,
                isBinary: et
            }),
            nt = this;
        tt.on("success", _e), tt.on("error", function(ot) {
            nt.onError("xhr post error", ot)
        }), this.sendXhr = tt
    }, XHR$1.prototype.doPoll = function() {
        debug$3("xhr poll");
        var _ = this.request(),
            _e = this;
        _.on("data", function(et) {
            _e.onData(et)
        }), _.on("error", function(et) {
            _e.onError("xhr poll error", et)
        }), this.pollXhr = _
    };

    function Request$1(_) {
        this.method = _.method || "GET", this.uri = _.uri, this.xd = !!_.xd, this.xs = !!_.xs, this.async = _.async !== !1, this.data = _.data !== void 0 ? _.data : null, this.agent = _.agent, this.isBinary = _.isBinary, this.supportsBinary = _.supportsBinary, this.enablesXDR = _.enablesXDR, this.withCredentials = _.withCredentials, this.requestTimeout = _.requestTimeout, this.pfx = _.pfx, this.key = _.key, this.passphrase = _.passphrase, this.cert = _.cert, this.ca = _.ca, this.ciphers = _.ciphers, this.rejectUnauthorized = _.rejectUnauthorized, this.extraHeaders = _.extraHeaders, this.create()
    }
    if (Emitter$2(Request$1.prototype), Request$1.prototype.create = function() {
            var _ = {
                agent: this.agent,
                xdomain: this.xd,
                xscheme: this.xs,
                enablesXDR: this.enablesXDR
            };
            _.pfx = this.pfx, _.key = this.key, _.passphrase = this.passphrase, _.cert = this.cert, _.ca = this.ca, _.ciphers = this.ciphers, _.rejectUnauthorized = this.rejectUnauthorized;
            var _e = this.xhr = new XMLHttpRequest$2(_),
                et = this;
            try {
                debug$3("xhr open %s: %s", this.method, this.uri), _e.open(this.method, this.uri, this.async);
                try {
                    if (this.extraHeaders) {
                        _e.setDisableHeaderCheck && _e.setDisableHeaderCheck(!0);
                        for (var tt in this.extraHeaders) this.extraHeaders.hasOwnProperty(tt) && _e.setRequestHeader(tt, this.extraHeaders[tt])
                    }
                } catch (nt) {}
                if (this.method === "POST") try {
                    this.isBinary ? _e.setRequestHeader("Content-type", "application/octet-stream") : _e.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch (nt) {}
                try {
                    _e.setRequestHeader("Accept", "*/*")
                } catch (nt) {}
                "withCredentials" in _e && (_e.withCredentials = this.withCredentials), this.requestTimeout && (_e.timeout = this.requestTimeout), this.hasXDR() ? (_e.onload = function() {
                    et.onLoad()
                }, _e.onerror = function() {
                    et.onError(_e.responseText)
                }) : _e.onreadystatechange = function() {
                    if (_e.readyState === 2) try {
                        var nt = _e.getResponseHeader("Content-Type");
                        (et.supportsBinary && nt === "application/octet-stream" || nt === "application/octet-stream; charset=UTF-8") && (_e.responseType = "arraybuffer")
                    } catch (ot) {}
                    _e.readyState === 4 && (_e.status === 200 || _e.status === 1223 ? et.onLoad() : setTimeout(function() {
                        et.onError(typeof _e.status == "number" ? _e.status : 0)
                    }, 0))
                }, debug$3("xhr data %s", this.data), _e.send(this.data)
            } catch (nt) {
                setTimeout(function() {
                    et.onError(nt)
                }, 0);
                return
            }
            typeof document < "u" && (this.index = Request$1.requestsCount++, Request$1.requests[this.index] = this)
        }, Request$1.prototype.onSuccess = function() {
            this.emit("success"), this.cleanup()
        }, Request$1.prototype.onData = function(_) {
            this.emit("data", _), this.onSuccess()
        }, Request$1.prototype.onError = function(_) {
            this.emit("error", _), this.cleanup(!0)
        }, Request$1.prototype.cleanup = function(_) {
            if (!(typeof this.xhr > "u" || this.xhr === null)) {
                if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = empty$1 : this.xhr.onreadystatechange = empty$1, _) try {
                    this.xhr.abort()
                } catch (_e) {}
                typeof document < "u" && delete Request$1.requests[this.index], this.xhr = null
            }
        }, Request$1.prototype.onLoad = function() {
            var _;
            try {
                var _e;
                try {
                    _e = this.xhr.getResponseHeader("Content-Type")
                } catch (et) {}
                _e === "application/octet-stream" || _e === "application/octet-stream; charset=UTF-8" ? _ = this.xhr.response || this.xhr.responseText : _ = this.xhr.responseText
            } catch (et) {
                this.onError(et)
            }
            _ != null && this.onData(_)
        }, Request$1.prototype.hasXDR = function() {
            return typeof XDomainRequest < "u" && !this.xs && this.enablesXDR
        }, Request$1.prototype.abort = function() {
            this.cleanup()
        }, Request$1.requestsCount = 0, Request$1.requests = {}, typeof document < "u") {
        if (typeof attachEvent == "function") attachEvent("onunload", unloadHandler);
        else if (typeof addEventListener == "function") {
            var terminationEvent = "onpagehide" in globalThis$2 ? "pagehide" : "unload";
            addEventListener(terminationEvent, unloadHandler, !1)
        }
    }

    function unloadHandler() {
        for (var _ in Request$1.requests) Request$1.requests.hasOwnProperty(_) && Request$1.requests[_].abort()
    }
    var pollingXhrExports = pollingXhr.exports,
        Polling = polling$1,
        inherit$1 = componentInherit,
        globalThis$1 = globalThis_browser,
        pollingJsonp = JSONPPolling,
        rNewline = /\n/g,
        rEscapedNewline = /\\n/g,
        callbacks;

    function empty() {}

    function JSONPPolling(_) {
        Polling.call(this, _), this.query = this.query || {}, callbacks || (callbacks = globalThis$1.___eio = globalThis$1.___eio || []), this.index = callbacks.length;
        var _e = this;
        callbacks.push(function(et) {
            _e.onData(et)
        }), this.query.j = this.index, typeof addEventListener == "function" && addEventListener("beforeunload", function() {
            _e.script && (_e.script.onerror = empty)
        }, !1)
    }
    inherit$1(JSONPPolling, Polling), JSONPPolling.prototype.supportsBinary = !1, JSONPPolling.prototype.doClose = function() {
        this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), Polling.prototype.doClose.call(this)
    }, JSONPPolling.prototype.doPoll = function() {
        var _ = this,
            _e = document.createElement("script");
        this.script && (this.script.parentNode.removeChild(this.script), this.script = null), _e.async = !0, _e.src = this.uri(), _e.onerror = function(nt) {
            _.onError("jsonp poll error", nt)
        };
        var et = document.getElementsByTagName("script")[0];
        et ? et.parentNode.insertBefore(_e, et) : (document.head || document.body).appendChild(_e), this.script = _e;
        var tt = typeof navigator < "u" && /gecko/i.test(navigator.userAgent);
        tt && setTimeout(function() {
            var nt = document.createElement("iframe");
            document.body.appendChild(nt), document.body.removeChild(nt)
        }, 100)
    }, JSONPPolling.prototype.doWrite = function(_, _e) {
        var et = this;
        if (!this.form) {
            var tt = document.createElement("form"),
                nt = document.createElement("textarea"),
                ot = this.iframeId = "eio_iframe_" + this.index,
                at;
            tt.className = "socketio", tt.style.position = "absolute", tt.style.top = "-1000px", tt.style.left = "-1000px", tt.target = ot, tt.method = "POST", tt.setAttribute("accept-charset", "utf-8"), nt.name = "d", tt.appendChild(nt), document.body.appendChild(tt), this.form = tt, this.area = nt
        }
        this.form.action = this.uri();

        function st() {
            lt(), _e()
        }

        function lt() {
            if (et.iframe) try {
                et.form.removeChild(et.iframe)
            } catch (dt) {
                et.onError("jsonp polling iframe removal error", dt)
            }
            try {
                var ut = '<iframe src="javascript:0" name="' + et.iframeId + '">';
                at = document.createElement(ut)
            } catch (dt) {
                at = document.createElement("iframe"), at.name = et.iframeId, at.src = "javascript:0"
            }
            at.id = et.iframeId, et.form.appendChild(at), et.iframe = at
        }
        lt(), _ = _.replace(rEscapedNewline, `\\
`), this.area.value = _.replace(rNewline, "\\n");
        try {
            this.form.submit()
        } catch (ut) {}
        this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
            et.iframe.readyState === "complete" && st()
        } : this.iframe.onload = st
    };
    const __viteBrowserExternal = {},
        __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
            __proto__: null,
            default: __viteBrowserExternal
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        require$$6 = getAugmentedNamespace(__viteBrowserExternal$1);
    var Transport = requireTransport(),
        parser$2 = browser$1,
        parseqs$1 = parseqs$3,
        inherit = componentInherit,
        yeast = yeast_1,
        debug$2 = browserExports("engine.io-client:websocket"),
        BrowserWebSocket, NodeWebSocket;
    if (typeof WebSocket < "u" ? BrowserWebSocket = WebSocket : typeof self < "u" && (BrowserWebSocket = self.WebSocket || self.MozWebSocket), typeof window > "u") try {
        NodeWebSocket = require$$6
    } catch (_) {}
    var WebSocketImpl = BrowserWebSocket || NodeWebSocket,
        websocket$1 = WS;

    function WS(_) {
        var _e = _ && _.forceBase64;
        _e && (this.supportsBinary = !1), this.perMessageDeflate = _.perMessageDeflate, this.usingBrowserWebSocket = BrowserWebSocket && !_.forceNode, this.protocols = _.protocols, this.usingBrowserWebSocket || (WebSocketImpl = NodeWebSocket), Transport.call(this, _)
    }
    inherit(WS, Transport), WS.prototype.name = "websocket", WS.prototype.supportsBinary = !0, WS.prototype.doOpen = function() {
        if (this.check()) {
            var _ = this.uri(),
                _e = this.protocols,
                et = {};
            this.isReactNative || (et.agent = this.agent, et.perMessageDeflate = this.perMessageDeflate, et.pfx = this.pfx, et.key = this.key, et.passphrase = this.passphrase, et.cert = this.cert, et.ca = this.ca, et.ciphers = this.ciphers, et.rejectUnauthorized = this.rejectUnauthorized), this.extraHeaders && (et.headers = this.extraHeaders), this.localAddress && (et.localAddress = this.localAddress);
            try {
                this.ws = this.usingBrowserWebSocket && !this.isReactNative ? _e ? new WebSocketImpl(_, _e) : new WebSocketImpl(_) : new WebSocketImpl(_, _e, et)
            } catch (tt) {
                return this.emit("error", tt)
            }
            this.ws.binaryType === void 0 && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners()
        }
    }, WS.prototype.addEventListeners = function() {
        var _ = this;
        this.ws.onopen = function() {
            _.onOpen()
        }, this.ws.onclose = function() {
            _.onClose()
        }, this.ws.onmessage = function(_e) {
            _.onData(_e.data)
        }, this.ws.onerror = function(_e) {
            _.onError("websocket error", _e)
        }
    }, WS.prototype.write = function(_) {
        var _e = this;
        this.writable = !1;
        for (var et = _.length, tt = 0, nt = et; tt < nt; tt++)(function(at) {
            parser$2.encodePacket(at, _e.supportsBinary, function(st) {
                if (!_e.usingBrowserWebSocket) {
                    var lt = {};
                    if (at.options && (lt.compress = at.options.compress), _e.perMessageDeflate) {
                        var ut = typeof st == "string" ? Buffer.byteLength(st) : st.length;
                        ut < _e.perMessageDeflate.threshold && (lt.compress = !1)
                    }
                }
                try {
                    _e.usingBrowserWebSocket ? _e.ws.send(st) : _e.ws.send(st, lt)
                } catch (dt) {
                    debug$2("websocket closed before onclose event")
                }--et || ot()
            })
        })(_[tt]);

        function ot() {
            _e.emit("flush"), setTimeout(function() {
                _e.writable = !0, _e.emit("drain")
            }, 0)
        }
    }, WS.prototype.onClose = function() {
        Transport.prototype.onClose.call(this)
    }, WS.prototype.doClose = function() {
        typeof this.ws < "u" && this.ws.close()
    }, WS.prototype.uri = function() {
        var _ = this.query || {},
            _e = this.secure ? "wss" : "ws",
            et = "";
        this.port && (_e === "wss" && Number(this.port) !== 443 || _e === "ws" && Number(this.port) !== 80) && (et = ":" + this.port), this.timestampRequests && (_[this.timestampParam] = yeast()), this.supportsBinary || (_.b64 = 1), _ = parseqs$1.encode(_), _.length && (_ = "?" + _);
        var tt = this.hostname.indexOf(":") !== -1;
        return _e + "://" + (tt ? "[" + this.hostname + "]" : this.hostname) + et + this.path + _
    }, WS.prototype.check = function() {
        return !!WebSocketImpl && !("__initialize" in WebSocketImpl && this.name === WS.prototype.name)
    };
    var XMLHttpRequest$1 = xmlhttprequest_browser,
        XHR = pollingXhrExports,
        JSONP = pollingJsonp,
        websocket = websocket$1;
    transports$1.polling = polling, transports$1.websocket = websocket;

    function polling(_) {
        var _e, et = !1,
            tt = !1,
            nt = _.jsonp !== !1;
        if (typeof location < "u") {
            var ot = location.protocol === "https:",
                at = location.port;
            at || (at = ot ? 443 : 80), et = _.hostname !== location.hostname || at !== _.port, tt = _.secure !== ot
        }
        if (_.xdomain = et, _.xscheme = tt, _e = new XMLHttpRequest$1(_), "open" in _e && !_.forceJSONP) return new XHR(_);
        if (!nt) throw new Error("JSONP disabled");
        return new JSONP(_)
    }
    var indexOf$1 = [].indexOf,
        indexof = function(_, _e) {
            if (indexOf$1) return _.indexOf(_e);
            for (var et = 0; et < _.length; ++et)
                if (_[et] === _e) return et;
            return -1
        },
        transports = transports$1,
        Emitter$1 = componentEmitterExports,
        debug$1 = browserExports("engine.io-client:socket"),
        index = indexof,
        parser$1 = browser$1,
        parseuri = parseuri$2,
        parseqs = parseqs$3,
        socket$2 = Socket$1;

    function Socket$1(_, _e) {
        if (!(this instanceof Socket$1)) return new Socket$1(_, _e);
        _e = _e || {}, _ && typeof _ == "object" && (_e = _, _ = null), _ ? (_ = parseuri(_), _e.hostname = _.host, _e.secure = _.protocol === "https" || _.protocol === "wss", _e.port = _.port, _.query && (_e.query = _.query)) : _e.host && (_e.hostname = parseuri(_e.host).host), this.secure = _e.secure != null ? _e.secure : typeof location < "u" && location.protocol === "https:", _e.hostname && !_e.port && (_e.port = this.secure ? "443" : "80"), this.agent = _e.agent || !1, this.hostname = _e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = _e.port || (typeof location < "u" && location.port ? location.port : this.secure ? 443 : 80), this.query = _e.query || {}, typeof this.query == "string" && (this.query = parseqs.decode(this.query)), this.upgrade = _e.upgrade !== !1, this.path = (_e.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!_e.forceJSONP, this.jsonp = _e.jsonp !== !1, this.forceBase64 = !!_e.forceBase64, this.enablesXDR = !!_e.enablesXDR, this.withCredentials = _e.withCredentials !== !1, this.timestampParam = _e.timestampParam || "t", this.timestampRequests = _e.timestampRequests, this.transports = _e.transports || ["polling", "websocket"], this.transportOptions = _e.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = _e.policyPort || 843, this.rememberUpgrade = _e.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = _e.onlyBinaryUpgrades, this.perMessageDeflate = _e.perMessageDeflate !== !1 ? _e.perMessageDeflate || {} : !1, this.perMessageDeflate === !0 && (this.perMessageDeflate = {}), this.perMessageDeflate && this.perMessageDeflate.threshold == null && (this.perMessageDeflate.threshold = 1024), this.pfx = _e.pfx || void 0, this.key = _e.key || void 0, this.passphrase = _e.passphrase || void 0, this.cert = _e.cert || void 0, this.ca = _e.ca || void 0, this.ciphers = _e.ciphers || void 0, this.rejectUnauthorized = _e.rejectUnauthorized === void 0 ? !0 : _e.rejectUnauthorized, this.forceNode = !!_e.forceNode, this.isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative", (typeof self > "u" || this.isReactNative) && (_e.extraHeaders && Object.keys(_e.extraHeaders).length > 0 && (this.extraHeaders = _e.extraHeaders), _e.localAddress && (this.localAddress = _e.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open()
    }
    Socket$1.priorWebsocketSuccess = !1, Emitter$1(Socket$1.prototype), Socket$1.protocol = parser$1.protocol, Socket$1.Socket = Socket$1, Socket$1.Transport = requireTransport(), Socket$1.transports = transports$1, Socket$1.parser = browser$1, Socket$1.prototype.createTransport = function(_) {
        debug$1('creating transport "%s"', _);
        var _e = clone(this.query);
        _e.EIO = parser$1.protocol, _e.transport = _;
        var et = this.transportOptions[_] || {};
        this.id && (_e.sid = this.id);
        var tt = new transports[_]({
            query: _e,
            socket: this,
            agent: et.agent || this.agent,
            hostname: et.hostname || this.hostname,
            port: et.port || this.port,
            secure: et.secure || this.secure,
            path: et.path || this.path,
            forceJSONP: et.forceJSONP || this.forceJSONP,
            jsonp: et.jsonp || this.jsonp,
            forceBase64: et.forceBase64 || this.forceBase64,
            enablesXDR: et.enablesXDR || this.enablesXDR,
            withCredentials: et.withCredentials || this.withCredentials,
            timestampRequests: et.timestampRequests || this.timestampRequests,
            timestampParam: et.timestampParam || this.timestampParam,
            policyPort: et.policyPort || this.policyPort,
            pfx: et.pfx || this.pfx,
            key: et.key || this.key,
            passphrase: et.passphrase || this.passphrase,
            cert: et.cert || this.cert,
            ca: et.ca || this.ca,
            ciphers: et.ciphers || this.ciphers,
            rejectUnauthorized: et.rejectUnauthorized || this.rejectUnauthorized,
            perMessageDeflate: et.perMessageDeflate || this.perMessageDeflate,
            extraHeaders: et.extraHeaders || this.extraHeaders,
            forceNode: et.forceNode || this.forceNode,
            localAddress: et.localAddress || this.localAddress,
            requestTimeout: et.requestTimeout || this.requestTimeout,
            protocols: et.protocols || void 0,
            isReactNative: this.isReactNative
        });
        return tt
    };

    function clone(_) {
        var _e = {};
        for (var et in _) _.hasOwnProperty(et) && (_e[et] = _[et]);
        return _e
    }
    Socket$1.prototype.open = function() {
        var _;
        if (this.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) _ = "websocket";
        else if (this.transports.length === 0) {
            var _e = this;
            setTimeout(function() {
                _e.emit("error", "No transports available")
            }, 0);
            return
        } else _ = this.transports[0];
        this.readyState = "opening";
        try {
            _ = this.createTransport(_)
        } catch (et) {
            this.transports.shift(), this.open();
            return
        }
        _.open(), this.setTransport(_)
    }, Socket$1.prototype.setTransport = function(_) {
        debug$1("setting transport %s", _.name);
        var _e = this;
        this.transport && (debug$1("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = _, _.on("drain", function() {
            _e.onDrain()
        }).on("packet", function(et) {
            _e.onPacket(et)
        }).on("error", function(et) {
            _e.onError(et)
        }).on("close", function() {
            _e.onClose("transport close")
        })
    }, Socket$1.prototype.probe = function(_) {
        debug$1('probing transport "%s"', _);
        var _e = this.createTransport(_, {
                probe: 1
            }),
            et = !1,
            tt = this;
        Socket$1.priorWebsocketSuccess = !1;

        function nt() {
            if (tt.onlyBinaryUpgrades) {
                var ct = !this.supportsBinary && tt.transport.supportsBinary;
                et = et || ct
            }
            et || (debug$1('probe transport "%s" opened', _), _e.send([{
                type: "ping",
                data: "probe"
            }]), _e.once("packet", function(pt) {
                if (!et)
                    if (pt.type === "pong" && pt.data === "probe") {
                        if (debug$1('probe transport "%s" pong', _), tt.upgrading = !0, tt.emit("upgrading", _e), !_e) return;
                        Socket$1.priorWebsocketSuccess = _e.name === "websocket", debug$1('pausing current transport "%s"', tt.transport.name), tt.transport.pause(function() {
                            et || tt.readyState !== "closed" && (debug$1("changing transport and sending upgrade packet"), dt(), tt.setTransport(_e), _e.send([{
                                type: "upgrade"
                            }]), tt.emit("upgrade", _e), _e = null, tt.upgrading = !1, tt.flush())
                        })
                    } else {
                        debug$1('probe transport "%s" failed', _);
                        var ft = new Error("probe error");
                        ft.transport = _e.name, tt.emit("upgradeError", ft)
                    }
            }))
        }

        function ot() {
            et || (et = !0, dt(), _e.close(), _e = null)
        }

        function at(ct) {
            var pt = new Error("probe error: " + ct);
            pt.transport = _e.name, ot(), debug$1('probe transport "%s" failed because of error: %s', _, ct), tt.emit("upgradeError", pt)
        }

        function st() {
            at("transport closed")
        }

        function lt() {
            at("socket closed")
        }

        function ut(ct) {
            _e && ct.name !== _e.name && (debug$1('"%s" works - aborting "%s"', ct.name, _e.name), ot())
        }

        function dt() {
            _e.removeListener("open", nt), _e.removeListener("error", at), _e.removeListener("close", st), tt.removeListener("close", lt), tt.removeListener("upgrading", ut)
        }
        _e.once("open", nt), _e.once("error", at), _e.once("close", st), this.once("close", lt), this.once("upgrading", ut), _e.open()
    }, Socket$1.prototype.onOpen = function() {
        if (debug$1("socket open"), this.readyState = "open", Socket$1.priorWebsocketSuccess = this.transport.name === "websocket", this.emit("open"), this.flush(), this.readyState === "open" && this.upgrade && this.transport.pause) {
            debug$1("starting upgrade probes");
            for (var _ = 0, _e = this.upgrades.length; _ < _e; _++) this.probe(this.upgrades[_])
        }
    }, Socket$1.prototype.onPacket = function(_) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (debug$1('socket receive: type "%s", data "%s"', _.type, _.data), this.emit("packet", _), this.emit("heartbeat"), _.type) {
            case "open":
                this.onHandshake(JSON.parse(_.data));
                break;
            case "pong":
                this.setPing(), this.emit("pong");
                break;
            case "error":
                var _e = new Error("server error");
                _e.code = _.data, this.onError(_e);
                break;
            case "message":
                this.emit("data", _.data), this.emit("message", _.data);
                break
        } else debug$1('packet received with socket readyState "%s"', this.readyState)
    }, Socket$1.prototype.onHandshake = function(_) {
        this.emit("handshake", _), this.id = _.sid, this.transport.query.sid = _.sid, this.upgrades = this.filterUpgrades(_.upgrades), this.pingInterval = _.pingInterval, this.pingTimeout = _.pingTimeout, this.onOpen(), this.readyState !== "closed" && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat))
    }, Socket$1.prototype.onHeartbeat = function(_) {
        clearTimeout(this.pingTimeoutTimer);
        var _e = this;
        _e.pingTimeoutTimer = setTimeout(function() {
            _e.readyState !== "closed" && _e.onClose("ping timeout")
        }, _ || _e.pingInterval + _e.pingTimeout)
    }, Socket$1.prototype.setPing = function() {
        var _ = this;
        clearTimeout(_.pingIntervalTimer), _.pingIntervalTimer = setTimeout(function() {
            debug$1("writing ping packet - expecting pong within %sms", _.pingTimeout), _.ping(), _.onHeartbeat(_.pingTimeout)
        }, _.pingInterval)
    }, Socket$1.prototype.ping = function() {
        var _ = this;
        this.sendPacket("ping", function() {
            _.emit("ping")
        })
    }, Socket$1.prototype.onDrain = function() {
        this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emit("drain") : this.flush()
    }, Socket$1.prototype.flush = function() {
        this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length && (debug$1("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
    }, Socket$1.prototype.write = Socket$1.prototype.send = function(_, _e, et) {
        return this.sendPacket("message", _, _e, et), this
    }, Socket$1.prototype.sendPacket = function(_, _e, et, tt) {
        if (typeof _e == "function" && (tt = _e, _e = void 0), typeof et == "function" && (tt = et, et = null), !(this.readyState === "closing" || this.readyState === "closed")) {
            et = et || {}, et.compress = et.compress !== !1;
            var nt = {
                type: _,
                data: _e,
                options: et
            };
            this.emit("packetCreate", nt), this.writeBuffer.push(nt), tt && this.once("flush", tt), this.flush()
        }
    }, Socket$1.prototype.close = function() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.readyState = "closing";
            var _ = this;
            this.writeBuffer.length ? this.once("drain", function() {
                this.upgrading ? tt() : _e()
            }) : this.upgrading ? tt() : _e()
        }

        function _e() {
            _.onClose("forced close"), debug$1("socket closing - telling transport to close"), _.transport.close()
        }

        function et() {
            _.removeListener("upgrade", et), _.removeListener("upgradeError", et), _e()
        }

        function tt() {
            _.once("upgrade", et), _.once("upgradeError", et)
        }
        return this
    }, Socket$1.prototype.onError = function(_) {
        debug$1("socket error %j", _), Socket$1.priorWebsocketSuccess = !1, this.emit("error", _), this.onClose("transport error", _)
    }, Socket$1.prototype.onClose = function(_, _e) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            debug$1('socket close with reason: "%s"', _);
            var et = this;
            clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", _, _e), et.writeBuffer = [], et.prevBufferLen = 0
        }
    }, Socket$1.prototype.filterUpgrades = function(_) {
        for (var _e = [], et = 0, tt = _.length; et < tt; et++) ~index(this.transports, _[et]) && _e.push(_[et]);
        return _e
    }, lib.exports = socket$2, lib.exports.parser = browser$1;
    var libExports$1 = lib.exports,
        socket$1 = {
            exports: {}
        },
        toArray_1 = toArray;

    function toArray(_, _e) {
        var et = [];
        _e = _e || 0;
        for (var tt = _e || 0; tt < _.length; tt++) et[tt - _e] = _[tt];
        return et
    }
    var on_1 = on$1;

    function on$1(_, _e, et) {
        return _.on(_e, et), {
            destroy: function() {
                _.removeListener(_e, et)
            }
        }
    }
    var slice = [].slice,
        componentBind = function(_, _e) {
            if (typeof _e == "string" && (_e = _[_e]), typeof _e != "function") throw new Error("bind() requires a function");
            var et = slice.call(arguments, 2);
            return function() {
                return _e.apply(_, et.concat(slice.call(arguments)))
            }
        };
    (function(_, _e) {
        var et = socket_ioParser,
            tt = componentEmitterExports,
            nt = toArray_1,
            ot = on_1,
            at = componentBind,
            st = browserExports$2("socket.io-client:socket"),
            lt = parseqs$3,
            ut = hasBinary2;
        _.exports = pt;
        var dt = {
                connect: 1,
                connect_error: 1,
                connect_timeout: 1,
                connecting: 1,
                disconnect: 1,
                error: 1,
                reconnect: 1,
                reconnect_attempt: 1,
                reconnect_failed: 1,
                reconnect_error: 1,
                reconnecting: 1,
                ping: 1,
                pong: 1
            },
            ct = tt.prototype.emit;

        function pt(ft, ht, mt) {
            this.io = ft, this.nsp = ht, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, mt && mt.query && (this.query = mt.query), this.io.autoConnect && this.open()
        }
        tt(pt.prototype), pt.prototype.subEvents = function() {
            if (!this.subs) {
                var ft = this.io;
                this.subs = [ot(ft, "open", at(this, "onopen")), ot(ft, "packet", at(this, "onpacket")), ot(ft, "close", at(this, "onclose"))]
            }
        }, pt.prototype.open = pt.prototype.connect = function() {
            return this.connected ? this : (this.subEvents(), this.io.reconnecting || this.io.open(), this.io.readyState === "open" && this.onopen(), this.emit("connecting"), this)
        }, pt.prototype.send = function() {
            var ft = nt(arguments);
            return ft.unshift("message"), this.emit.apply(this, ft), this
        }, pt.prototype.emit = function(ft) {
            if (dt.hasOwnProperty(ft)) return ct.apply(this, arguments), this;
            var ht = nt(arguments),
                mt = {
                    type: (this.flags.binary !== void 0 ? this.flags.binary : ut(ht)) ? et.BINARY_EVENT : et.EVENT,
                    data: ht
                };
            return mt.options = {}, mt.options.compress = !this.flags || this.flags.compress !== !1, typeof ht[ht.length - 1] == "function" && (st("emitting packet with ack id %d", this.ids), this.acks[this.ids] = ht.pop(), mt.id = this.ids++), this.connected ? this.packet(mt) : this.sendBuffer.push(mt), this.flags = {}, this
        }, pt.prototype.packet = function(ft) {
            ft.nsp = this.nsp, this.io.packet(ft)
        }, pt.prototype.onopen = function() {
            if (st("transport is open - connecting"), this.nsp !== "/")
                if (this.query) {
                    var ft = typeof this.query == "object" ? lt.encode(this.query) : this.query;
                    st("sending connect packet with query %s", ft), this.packet({
                        type: et.CONNECT,
                        query: ft
                    })
                } else this.packet({
                    type: et.CONNECT
                })
        }, pt.prototype.onclose = function(ft) {
            st("close (%s)", ft), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", ft)
        }, pt.prototype.onpacket = function(ft) {
            var ht = ft.nsp === this.nsp,
                mt = ft.type === et.ERROR && ft.nsp === "/";
            if (!(!ht && !mt)) switch (ft.type) {
                case et.CONNECT:
                    this.onconnect();
                    break;
                case et.EVENT:
                    this.onevent(ft);
                    break;
                case et.BINARY_EVENT:
                    this.onevent(ft);
                    break;
                case et.ACK:
                    this.onack(ft);
                    break;
                case et.BINARY_ACK:
                    this.onack(ft);
                    break;
                case et.DISCONNECT:
                    this.ondisconnect();
                    break;
                case et.ERROR:
                    this.emit("error", ft.data);
                    break
            }
        }, pt.prototype.onevent = function(ft) {
            var ht = ft.data || [];
            st("emitting event %j", ht), ft.id != null && (st("attaching ack callback to event"), ht.push(this.ack(ft.id))), this.connected ? ct.apply(this, ht) : this.receiveBuffer.push(ht)
        }, pt.prototype.ack = function(ft) {
            var ht = this,
                mt = !1;
            return function() {
                if (!mt) {
                    mt = !0;
                    var bt = nt(arguments);
                    st("sending ack %j", bt), ht.packet({
                        type: ut(bt) ? et.BINARY_ACK : et.ACK,
                        id: ft,
                        data: bt
                    })
                }
            }
        }, pt.prototype.onack = function(ft) {
            var ht = this.acks[ft.id];
            typeof ht == "function" ? (st("calling ack %s with %j", ft.id, ft.data), ht.apply(this, ft.data), delete this.acks[ft.id]) : st("bad ack %s", ft.id)
        }, pt.prototype.onconnect = function() {
            this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered()
        }, pt.prototype.emitBuffered = function() {
            var ft;
            for (ft = 0; ft < this.receiveBuffer.length; ft++) ct.apply(this, this.receiveBuffer[ft]);
            for (this.receiveBuffer = [], ft = 0; ft < this.sendBuffer.length; ft++) this.packet(this.sendBuffer[ft]);
            this.sendBuffer = []
        }, pt.prototype.ondisconnect = function() {
            st("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect")
        }, pt.prototype.destroy = function() {
            if (this.subs) {
                for (var ft = 0; ft < this.subs.length; ft++) this.subs[ft].destroy();
                this.subs = null
            }
            this.io.destroy(this)
        }, pt.prototype.close = pt.prototype.disconnect = function() {
            return this.connected && (st("performing disconnect (%s)", this.nsp), this.packet({
                type: et.DISCONNECT
            })), this.destroy(), this.connected && this.onclose("io client disconnect"), this
        }, pt.prototype.compress = function(ft) {
            return this.flags.compress = ft, this
        }, pt.prototype.binary = function(ft) {
            return this.flags.binary = ft, this
        }
    })(socket$1);
    var socketExports = socket$1.exports,
        backo2 = Backoff$1;

    function Backoff$1(_) {
        _ = _ || {}, this.ms = _.min || 100, this.max = _.max || 1e4, this.factor = _.factor || 2, this.jitter = _.jitter > 0 && _.jitter <= 1 ? _.jitter : 0, this.attempts = 0
    }
    Backoff$1.prototype.duration = function() {
        var _ = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
            var _e = Math.random(),
                et = Math.floor(_e * this.jitter * _);
            _ = Math.floor(_e * 10) & 1 ? _ + et : _ - et
        }
        return Math.min(_, this.max) | 0
    }, Backoff$1.prototype.reset = function() {
        this.attempts = 0
    }, Backoff$1.prototype.setMin = function(_) {
        this.ms = _
    }, Backoff$1.prototype.setMax = function(_) {
        this.max = _
    }, Backoff$1.prototype.setJitter = function(_) {
        this.jitter = _
    };
    var eio = libExports$1,
        Socket = socketExports,
        Emitter = componentEmitterExports,
        parser = socket_ioParser,
        on = on_1,
        bind = componentBind,
        debug = browserExports$2("socket.io-client:manager"),
        indexOf = indexof,
        Backoff = backo2,
        has = Object.prototype.hasOwnProperty,
        manager = Manager;

    function Manager(_, _e) {
        if (!(this instanceof Manager)) return new Manager(_, _e);
        _ && typeof _ == "object" && (_e = _, _ = void 0), _e = _e || {}, _e.path = _e.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = _e, this.reconnection(_e.reconnection !== !1), this.reconnectionAttempts(_e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(_e.reconnectionDelay || 1e3), this.reconnectionDelayMax(_e.reconnectionDelayMax || 5e3), this.randomizationFactor(_e.randomizationFactor || .5), this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        }), this.timeout(_e.timeout == null ? 2e4 : _e.timeout), this.readyState = "closed", this.uri = _, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = [];
        var et = _e.parser || parser;
        this.encoder = new et.Encoder, this.decoder = new et.Decoder, this.autoConnect = _e.autoConnect !== !1, this.autoConnect && this.open()
    }
    Manager.prototype.emitAll = function() {
            this.emit.apply(this, arguments);
            for (var _ in this.nsps) has.call(this.nsps, _) && this.nsps[_].emit.apply(this.nsps[_], arguments)
        }, Manager.prototype.updateSocketIds = function() {
            for (var _ in this.nsps) has.call(this.nsps, _) && (this.nsps[_].id = this.generateId(_))
        }, Manager.prototype.generateId = function(_) {
            return (_ === "/" ? "" : _ + "#") + this.engine.id
        }, Emitter(Manager.prototype), Manager.prototype.reconnection = function(_) {
            return arguments.length ? (this._reconnection = !!_, this) : this._reconnection
        }, Manager.prototype.reconnectionAttempts = function(_) {
            return arguments.length ? (this._reconnectionAttempts = _, this) : this._reconnectionAttempts
        }, Manager.prototype.reconnectionDelay = function(_) {
            return arguments.length ? (this._reconnectionDelay = _, this.backoff && this.backoff.setMin(_), this) : this._reconnectionDelay
        }, Manager.prototype.randomizationFactor = function(_) {
            return arguments.length ? (this._randomizationFactor = _, this.backoff && this.backoff.setJitter(_), this) : this._randomizationFactor
        }, Manager.prototype.reconnectionDelayMax = function(_) {
            return arguments.length ? (this._reconnectionDelayMax = _, this.backoff && this.backoff.setMax(_), this) : this._reconnectionDelayMax
        }, Manager.prototype.timeout = function(_) {
            return arguments.length ? (this._timeout = _, this) : this._timeout
        }, Manager.prototype.maybeReconnectOnOpen = function() {
            !this.reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
        }, Manager.prototype.open = Manager.prototype.connect = function(_, _e) {
            if (debug("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this;
            debug("opening %s", this.uri), this.engine = eio(this.uri, this.opts);
            var et = this.engine,
                tt = this;
            this.readyState = "opening", this.skipReconnect = !1;
            var nt = on(et, "open", function() {
                    tt.onopen(), _ && _()
                }),
                ot = on(et, "error", function(lt) {
                    if (debug("connect_error"), tt.cleanup(), tt.readyState = "closed", tt.emitAll("connect_error", lt), _) {
                        var ut = new Error("Connection error");
                        ut.data = lt, _(ut)
                    } else tt.maybeReconnectOnOpen()
                });
            if (this._timeout !== !1) {
                var at = this._timeout;
                debug("connect attempt will timeout after %d", at), at === 0 && nt.destroy();
                var st = setTimeout(function() {
                    debug("connect attempt timed out after %d", at), nt.destroy(), et.close(), et.emit("error", "timeout"), tt.emitAll("connect_timeout", at)
                }, at);
                this.subs.push({
                    destroy: function() {
                        clearTimeout(st)
                    }
                })
            }
            return this.subs.push(nt), this.subs.push(ot), this
        }, Manager.prototype.onopen = function() {
            debug("open"), this.cleanup(), this.readyState = "open", this.emit("open");
            var _ = this.engine;
            this.subs.push(on(_, "data", bind(this, "ondata"))), this.subs.push(on(_, "ping", bind(this, "onping"))), this.subs.push(on(_, "pong", bind(this, "onpong"))), this.subs.push(on(_, "error", bind(this, "onerror"))), this.subs.push(on(_, "close", bind(this, "onclose"))), this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")))
        }, Manager.prototype.onping = function() {
            this.lastPing = new Date, this.emitAll("ping")
        }, Manager.prototype.onpong = function() {
            this.emitAll("pong", new Date - this.lastPing)
        }, Manager.prototype.ondata = function(_) {
            this.decoder.add(_)
        }, Manager.prototype.ondecoded = function(_) {
            this.emit("packet", _)
        }, Manager.prototype.onerror = function(_) {
            debug("error", _), this.emitAll("error", _)
        }, Manager.prototype.socket = function(_, _e) {
            var et = this.nsps[_];
            if (!et) {
                et = new Socket(this, _, _e), this.nsps[_] = et;
                var tt = this;
                et.on("connecting", nt), et.on("connect", function() {
                    et.id = tt.generateId(_)
                }), this.autoConnect && nt()
            }

            function nt() {
                ~indexOf(tt.connecting, et) || tt.connecting.push(et)
            }
            return et
        }, Manager.prototype.destroy = function(_) {
            var _e = indexOf(this.connecting, _);
            ~_e && this.connecting.splice(_e, 1), !this.connecting.length && this.close()
        }, Manager.prototype.packet = function(_) {
            debug("writing packet %j", _);
            var _e = this;
            _.query && _.type === 0 && (_.nsp += "?" + _.query), _e.encoding ? _e.packetBuffer.push(_) : (_e.encoding = !0, this.encoder.encode(_, function(et) {
                for (var tt = 0; tt < et.length; tt++) _e.engine.write(et[tt], _.options);
                _e.encoding = !1, _e.processPacketQueue()
            }))
        }, Manager.prototype.processPacketQueue = function() {
            if (this.packetBuffer.length > 0 && !this.encoding) {
                var _ = this.packetBuffer.shift();
                this.packet(_)
            }
        }, Manager.prototype.cleanup = function() {
            debug("cleanup");
            for (var _ = this.subs.length, _e = 0; _e < _; _e++) {
                var et = this.subs.shift();
                et.destroy()
            }
            this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy()
        }, Manager.prototype.close = Manager.prototype.disconnect = function() {
            debug("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, this.readyState === "opening" && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close()
        }, Manager.prototype.onclose = function(_) {
            debug("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", _), this._reconnection && !this.skipReconnect && this.reconnect()
        }, Manager.prototype.reconnect = function() {
            if (this.reconnecting || this.skipReconnect) return this;
            var _ = this;
            if (this.backoff.attempts >= this._reconnectionAttempts) debug("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;
            else {
                var _e = this.backoff.duration();
                debug("will wait %dms before reconnect attempt", _e), this.reconnecting = !0;
                var et = setTimeout(function() {
                    _.skipReconnect || (debug("attempting reconnect"), _.emitAll("reconnect_attempt", _.backoff.attempts), _.emitAll("reconnecting", _.backoff.attempts), !_.skipReconnect && _.open(function(tt) {
                        tt ? (debug("reconnect attempt error"), _.reconnecting = !1, _.reconnect(), _.emitAll("reconnect_error", tt.data)) : (debug("reconnect success"), _.onreconnect())
                    }))
                }, _e);
                this.subs.push({
                    destroy: function() {
                        clearTimeout(et)
                    }
                })
            }
        }, Manager.prototype.onreconnect = function() {
            var _ = this.backoff.attempts;
            this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", _)
        },
        function(_, _e) {
            var et = url_1,
                tt = socket_ioParser,
                nt = manager,
                ot = browserExports$2("socket.io-client");
            _.exports = _e = st;
            var at = _e.managers = {};

            function st(lt, ut) {
                typeof lt == "object" && (ut = lt, lt = void 0), ut = ut || {};
                var dt = et(lt),
                    ct = dt.source,
                    pt = dt.id,
                    ft = dt.path,
                    ht = at[pt] && ft in at[pt].nsps,
                    mt = ut.forceNew || ut["force new connection"] || ut.multiplex === !1 || ht,
                    bt;
                return mt ? (ot("ignoring socket cache for %s", ct), bt = nt(ct, ut)) : (at[pt] || (ot("new io instance for %s", ct), at[pt] = nt(ct, ut)), bt = at[pt]), dt.query && !ut.query && (ut.query = dt.query), bt.socket(dt.path, ut)
            }
            _e.protocol = tt.protocol, _e.connect = st, _e.Manager = manager, _e.Socket = socketExports
        }(lib$1, lib$1.exports);
    var libExports = lib$1.exports,
        events = {
            exports: {}
        },
        R = typeof Reflect == "object" ? Reflect : null,
        ReflectApply = R && typeof R.apply == "function" ? R.apply : function _(_e, et, tt) {
            return Function.prototype.apply.call(_e, et, tt)
        },
        ReflectOwnKeys;
    R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(_) {
        return Object.getOwnPropertyNames(_).concat(Object.getOwnPropertySymbols(_))
    } : ReflectOwnKeys = function(_) {
        return Object.getOwnPropertyNames(_)
    };

    function ProcessEmitWarning(_) {
        console && console.warn && console.warn(_)
    }
    var NumberIsNaN = Number.isNaN || function _(_e) {
        return _e !== _e
    };

    function EventEmitter$1() {
        EventEmitter$1.init.call(this)
    }
    events.exports = EventEmitter$1, events.exports.once = once, EventEmitter$1.EventEmitter = EventEmitter$1, EventEmitter$1.prototype._events = void 0, EventEmitter$1.prototype._eventsCount = 0, EventEmitter$1.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;

    function checkListener(_) {
        if (typeof _ != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof _)
    }
    Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return defaultMaxListeners
        },
        set: function(_) {
            if (typeof _ != "number" || _ < 0 || NumberIsNaN(_)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + _ + ".");
            defaultMaxListeners = _
        }
    }), EventEmitter$1.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    }, EventEmitter$1.prototype.setMaxListeners = function _(_e) {
        if (typeof _e != "number" || _e < 0 || NumberIsNaN(_e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + _e + ".");
        return this._maxListeners = _e, this
    };

    function _getMaxListeners(_) {
        return _._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : _._maxListeners
    }
    EventEmitter$1.prototype.getMaxListeners = function _() {
        return _getMaxListeners(this)
    }, EventEmitter$1.prototype.emit = function _(_e) {
        for (var et = [], tt = 1; tt < arguments.length; tt++) et.push(arguments[tt]);
        var nt = _e === "error",
            ot = this._events;
        if (ot !== void 0) nt = nt && ot.error === void 0;
        else if (!nt) return !1;
        if (nt) {
            var at;
            if (et.length > 0 && (at = et[0]), at instanceof Error) throw at;
            var st = new Error("Unhandled error." + (at ? " (" + at.message + ")" : ""));
            throw st.context = at, st
        }
        var lt = ot[_e];
        if (lt === void 0) return !1;
        if (typeof lt == "function") ReflectApply(lt, this, et);
        else
            for (var ut = lt.length, dt = arrayClone(lt, ut), tt = 0; tt < ut; ++tt) ReflectApply(dt[tt], this, et);
        return !0
    };

    function _addListener(_, _e, et, tt) {
        var nt, ot, at;
        if (checkListener(et), ot = _._events, ot === void 0 ? (ot = _._events = Object.create(null), _._eventsCount = 0) : (ot.newListener !== void 0 && (_.emit("newListener", _e, et.listener ? et.listener : et), ot = _._events), at = ot[_e]), at === void 0) at = ot[_e] = et, ++_._eventsCount;
        else if (typeof at == "function" ? at = ot[_e] = tt ? [et, at] : [at, et] : tt ? at.unshift(et) : at.push(et), nt = _getMaxListeners(_), nt > 0 && at.length > nt && !at.warned) {
            at.warned = !0;
            var st = new Error("Possible EventEmitter memory leak detected. " + at.length + " " + String(_e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            st.name = "MaxListenersExceededWarning", st.emitter = _, st.type = _e, st.count = at.length, ProcessEmitWarning(st)
        }
        return _
    }
    EventEmitter$1.prototype.addListener = function _(_e, et) {
        return _addListener(this, _e, et, !1)
    }, EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener, EventEmitter$1.prototype.prependListener = function _(_e, et) {
        return _addListener(this, _e, et, !0)
    };

    function onceWrapper() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function _onceWrap(_, _e, et) {
        var tt = {
                fired: !1,
                wrapFn: void 0,
                target: _,
                type: _e,
                listener: et
            },
            nt = onceWrapper.bind(tt);
        return nt.listener = et, tt.wrapFn = nt, nt
    }
    EventEmitter$1.prototype.once = function _(_e, et) {
        return checkListener(et), this.on(_e, _onceWrap(this, _e, et)), this
    }, EventEmitter$1.prototype.prependOnceListener = function _(_e, et) {
        return checkListener(et), this.prependListener(_e, _onceWrap(this, _e, et)), this
    }, EventEmitter$1.prototype.removeListener = function _(_e, et) {
        var tt, nt, ot, at, st;
        if (checkListener(et), nt = this._events, nt === void 0) return this;
        if (tt = nt[_e], tt === void 0) return this;
        if (tt === et || tt.listener === et) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete nt[_e], nt.removeListener && this.emit("removeListener", _e, tt.listener || et));
        else if (typeof tt != "function") {
            for (ot = -1, at = tt.length - 1; at >= 0; at--)
                if (tt[at] === et || tt[at].listener === et) {
                    st = tt[at].listener, ot = at;
                    break
                }
            if (ot < 0) return this;
            ot === 0 ? tt.shift() : spliceOne(tt, ot), tt.length === 1 && (nt[_e] = tt[0]), nt.removeListener !== void 0 && this.emit("removeListener", _e, st || et)
        }
        return this
    }, EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener, EventEmitter$1.prototype.removeAllListeners = function _(_e) {
        var et, tt, nt;
        if (tt = this._events, tt === void 0) return this;
        if (tt.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : tt[_e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete tt[_e]), this;
        if (arguments.length === 0) {
            var ot = Object.keys(tt),
                at;
            for (nt = 0; nt < ot.length; ++nt) at = ot[nt], at !== "removeListener" && this.removeAllListeners(at);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if (et = tt[_e], typeof et == "function") this.removeListener(_e, et);
        else if (et !== void 0)
            for (nt = et.length - 1; nt >= 0; nt--) this.removeListener(_e, et[nt]);
        return this
    };

    function _listeners(_, _e, et) {
        var tt = _._events;
        if (tt === void 0) return [];
        var nt = tt[_e];
        return nt === void 0 ? [] : typeof nt == "function" ? et ? [nt.listener || nt] : [nt] : et ? unwrapListeners(nt) : arrayClone(nt, nt.length)
    }
    EventEmitter$1.prototype.listeners = function _(_e) {
        return _listeners(this, _e, !0)
    }, EventEmitter$1.prototype.rawListeners = function _(_e) {
        return _listeners(this, _e, !1)
    }, EventEmitter$1.listenerCount = function(_, _e) {
        return typeof _.listenerCount == "function" ? _.listenerCount(_e) : listenerCount.call(_, _e)
    }, EventEmitter$1.prototype.listenerCount = listenerCount;

    function listenerCount(_) {
        var _e = this._events;
        if (_e !== void 0) {
            var et = _e[_];
            if (typeof et == "function") return 1;
            if (et !== void 0) return et.length
        }
        return 0
    }
    EventEmitter$1.prototype.eventNames = function _() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
    };

    function arrayClone(_, _e) {
        for (var et = new Array(_e), tt = 0; tt < _e; ++tt) et[tt] = _[tt];
        return et
    }

    function spliceOne(_, _e) {
        for (; _e + 1 < _.length; _e++) _[_e] = _[_e + 1];
        _.pop()
    }

    function unwrapListeners(_) {
        for (var _e = new Array(_.length), et = 0; et < _e.length; ++et) _e[et] = _[et].listener || _[et];
        return _e
    }

    function once(_, _e) {
        return new Promise(function(et, tt) {
            function nt(at) {
                _.removeListener(_e, ot), tt(at)
            }

            function ot() {
                typeof _.removeListener == "function" && _.removeListener("error", nt), et([].slice.call(arguments))
            }
            eventTargetAgnosticAddListener(_, _e, ot, {
                once: !0
            }), _e !== "error" && addErrorHandlerIfEventEmitter(_, nt, {
                once: !0
            })
        })
    }

    function addErrorHandlerIfEventEmitter(_, _e, et) {
        typeof _.on == "function" && eventTargetAgnosticAddListener(_, "error", _e, et)
    }

    function eventTargetAgnosticAddListener(_, _e, et, tt) {
        if (typeof _.on == "function") tt.once ? _.once(_e, et) : _.on(_e, et);
        else if (typeof _.addEventListener == "function") _.addEventListener(_e, function nt(ot) {
            tt.once && _.removeEventListener(_e, nt), et(ot)
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof _)
    }
    var eventsExports = events.exports,
        indexMinimal = {},
        minimal$1 = {},
        longbits, hasRequiredLongbits;

    function requireLongbits() {
        if (hasRequiredLongbits) return longbits;
        hasRequiredLongbits = 1, longbits = _e;
        var _ = requireMinimal();

        function _e(ot, at) {
            this.lo = ot >>> 0, this.hi = at >>> 0
        }
        var et = _e.zero = new _e(0, 0);
        et.toNumber = function() {
            return 0
        }, et.zzEncode = et.zzDecode = function() {
            return this
        }, et.length = function() {
            return 1
        };
        var tt = _e.zeroHash = "\0\0\0\0\0\0\0\0";
        _e.fromNumber = function(ot) {
            if (ot === 0) return et;
            var at = ot < 0;
            at && (ot = -ot);
            var st = ot >>> 0,
                lt = (ot - st) / 4294967296 >>> 0;
            return at && (lt = ~lt >>> 0, st = ~st >>> 0, ++st > 4294967295 && (st = 0, ++lt > 4294967295 && (lt = 0))), new _e(st, lt)
        }, _e.from = function(ot) {
            if (typeof ot == "number") return _e.fromNumber(ot);
            if (_.isString(ot))
                if (_.Long) ot = _.Long.fromString(ot);
                else return _e.fromNumber(parseInt(ot, 10));
            return ot.low || ot.high ? new _e(ot.low >>> 0, ot.high >>> 0) : et
        }, _e.prototype.toNumber = function(ot) {
            if (!ot && this.hi >>> 31) {
                var at = ~this.lo + 1 >>> 0,
                    st = ~this.hi >>> 0;
                return at || (st = st + 1 >>> 0), -(at + st * 4294967296)
            }
            return this.lo + this.hi * 4294967296
        }, _e.prototype.toLong = function(ot) {
            return _.Long ? new _.Long(this.lo | 0, this.hi | 0, !!ot) : {
                low: this.lo | 0,
                high: this.hi | 0,
                unsigned: !!ot
            }
        };
        var nt = String.prototype.charCodeAt;
        return _e.fromHash = function(ot) {
            return ot === tt ? et : new _e((nt.call(ot, 0) | nt.call(ot, 1) << 8 | nt.call(ot, 2) << 16 | nt.call(ot, 3) << 24) >>> 0, (nt.call(ot, 4) | nt.call(ot, 5) << 8 | nt.call(ot, 6) << 16 | nt.call(ot, 7) << 24) >>> 0)
        }, _e.prototype.toHash = function() {
            return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
        }, _e.prototype.zzEncode = function() {
            var ot = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ ot) >>> 0, this.lo = (this.lo << 1 ^ ot) >>> 0, this
        }, _e.prototype.zzDecode = function() {
            var ot = -(this.lo & 1);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ ot) >>> 0, this.hi = (this.hi >>> 1 ^ ot) >>> 0, this
        }, _e.prototype.length = function() {
            var ot = this.lo,
                at = (this.lo >>> 28 | this.hi << 4) >>> 0,
                st = this.hi >>> 24;
            return st === 0 ? at === 0 ? ot < 16384 ? ot < 128 ? 1 : 2 : ot < 2097152 ? 3 : 4 : at < 16384 ? at < 128 ? 5 : 6 : at < 2097152 ? 7 : 8 : st < 128 ? 9 : 10
        }, longbits
    }
    var hasRequiredMinimal;

    function requireMinimal() {
        return hasRequiredMinimal || (hasRequiredMinimal = 1, function(_) {
            var _e = _;
            _e.asPromise = aspromise, _e.base64 = base64$2, _e.EventEmitter = eventemitter, _e.float = float, _e.inquire = inquire_1, _e.utf8 = utf8$5, _e.pool = pool_1, _e.LongBits = requireLongbits(), _e.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), _e.global = _e.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, _e.emptyArray = Object.freeze ? Object.freeze([]) : [], _e.emptyObject = Object.freeze ? Object.freeze({}) : {}, _e.isInteger = Number.isInteger || function(nt) {
                return typeof nt == "number" && isFinite(nt) && Math.floor(nt) === nt
            }, _e.isString = function(nt) {
                return typeof nt == "string" || nt instanceof String
            }, _e.isObject = function(nt) {
                return nt && typeof nt == "object"
            }, _e.isset = _e.isSet = function(nt, ot) {
                var at = nt[ot];
                return at != null && nt.hasOwnProperty(ot) ? typeof at != "object" || (Array.isArray(at) ? at.length : Object.keys(at).length) > 0 : !1
            }, _e.Buffer = function() {
                try {
                    var nt = _e.inquire("buffer").Buffer;
                    return nt.prototype.utf8Write ? nt : null
                } catch (ot) {
                    return null
                }
            }(), _e._Buffer_from = null, _e._Buffer_allocUnsafe = null, _e.newBuffer = function(nt) {
                return typeof nt == "number" ? _e.Buffer ? _e._Buffer_allocUnsafe(nt) : new _e.Array(nt) : _e.Buffer ? _e._Buffer_from(nt) : typeof Uint8Array > "u" ? nt : new Uint8Array(nt)
            }, _e.Array = typeof Uint8Array < "u" ? Uint8Array : Array, _e.Long = _e.global.dcodeIO && _e.global.dcodeIO.Long || _e.global.Long || _e.inquire("long"), _e.key2Re = /^true|false|0|1$/, _e.key32Re = /^-?(?:0|[1-9][0-9]*)$/, _e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, _e.longToHash = function(nt) {
                return nt ? _e.LongBits.from(nt).toHash() : _e.LongBits.zeroHash
            }, _e.longFromHash = function(nt, ot) {
                var at = _e.LongBits.fromHash(nt);
                return _e.Long ? _e.Long.fromBits(at.lo, at.hi, ot) : at.toNumber(!!ot)
            };

            function et(nt, ot, at) {
                for (var st = Object.keys(ot), lt = 0; lt < st.length; ++lt)(nt[st[lt]] === void 0 || !at) && (nt[st[lt]] = ot[st[lt]]);
                return nt
            }
            _e.merge = et, _e.lcFirst = function(nt) {
                return nt.charAt(0).toLowerCase() + nt.substring(1)
            };

            function tt(nt) {
                function ot(at, st) {
                    if (!(this instanceof ot)) return new ot(at, st);
                    Object.defineProperty(this, "message", {
                        get: function() {
                            return at
                        }
                    }), Error.captureStackTrace ? Error.captureStackTrace(this, ot) : Object.defineProperty(this, "stack", {
                        value: new Error().stack || ""
                    }), st && et(this, st)
                }
                return (ot.prototype = Object.create(Error.prototype)).constructor = ot, Object.defineProperty(ot.prototype, "name", {
                    get: function() {
                        return nt
                    }
                }), ot.prototype.toString = function() {
                    return this.name + ": " + this.message
                }, ot
            }
            _e.newError = tt, _e.ProtocolError = tt("ProtocolError"), _e.oneOfGetter = function(nt) {
                for (var ot = {}, at = 0; at < nt.length; ++at) ot[nt[at]] = 1;
                return function() {
                    for (var st = Object.keys(this), lt = st.length - 1; lt > -1; --lt)
                        if (ot[st[lt]] === 1 && this[st[lt]] !== void 0 && this[st[lt]] !== null) return st[lt]
                }
            }, _e.oneOfSetter = function(nt) {
                return function(ot) {
                    for (var at = 0; at < nt.length; ++at) nt[at] !== ot && delete this[nt[at]]
                }
            }, _e.toJSONOptions = {
                longs: String,
                enums: String,
                bytes: String,
                json: !0
            }, _e._configure = function() {
                var nt = _e.Buffer;
                if (!nt) {
                    _e._Buffer_from = _e._Buffer_allocUnsafe = null;
                    return
                }
                _e._Buffer_from = nt.from !== Uint8Array.from && nt.from || function(ot, at) {
                    return new nt(ot, at)
                }, _e._Buffer_allocUnsafe = nt.allocUnsafe || function(ot) {
                    return new nt(ot)
                }
            }
        }(minimal$1)), minimal$1
    }
    var writer = Writer$1,
        util$4 = requireMinimal(),
        BufferWriter$1, LongBits$1 = util$4.LongBits,
        base64 = util$4.base64,
        utf8$1 = util$4.utf8;

    function Op(_, _e, et) {
        this.fn = _, this.len = _e, this.next = void 0, this.val = et
    }

    function noop$1() {}

    function State$1(_) {
        this.head = _.head, this.tail = _.tail, this.len = _.len, this.next = _.states
    }

    function Writer$1() {
        this.len = 0, this.head = new Op(noop$1, 0, 0), this.tail = this.head, this.states = null
    }
    var create$1 = function _() {
        return util$4.Buffer ? function() {
            return (Writer$1.create = function() {
                return new BufferWriter$1
            })()
        } : function() {
            return new Writer$1
        }
    };
    Writer$1.create = create$1(), Writer$1.alloc = function _(_e) {
        return new util$4.Array(_e)
    }, util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray)), Writer$1.prototype._push = function _(_e, et, tt) {
        return this.tail = this.tail.next = new Op(_e, et, tt), this.len += et, this
    };

    function writeByte(_, _e, et) {
        _e[et] = _ & 255
    }

    function writeVarint32(_, _e, et) {
        for (; _ > 127;) _e[et++] = _ & 127 | 128, _ >>>= 7;
        _e[et] = _
    }

    function VarintOp(_, _e) {
        this.len = _, this.next = void 0, this.val = _e
    }
    VarintOp.prototype = Object.create(Op.prototype), VarintOp.prototype.fn = writeVarint32, Writer$1.prototype.uint32 = function _(_e) {
        return this.len += (this.tail = this.tail.next = new VarintOp((_e = _e >>> 0) < 128 ? 1 : _e < 16384 ? 2 : _e < 2097152 ? 3 : _e < 268435456 ? 4 : 5, _e)).len, this
    }, Writer$1.prototype.int32 = function _(_e) {
        return _e < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(_e)) : this.uint32(_e)
    }, Writer$1.prototype.sint32 = function _(_e) {
        return this.uint32((_e << 1 ^ _e >> 31) >>> 0)
    };

    function writeVarint64(_, _e, et) {
        for (; _.hi;) _e[et++] = _.lo & 127 | 128, _.lo = (_.lo >>> 7 | _.hi << 25) >>> 0, _.hi >>>= 7;
        for (; _.lo > 127;) _e[et++] = _.lo & 127 | 128, _.lo = _.lo >>> 7;
        _e[et++] = _.lo
    }
    Writer$1.prototype.uint64 = function _(_e) {
        var et = LongBits$1.from(_e);
        return this._push(writeVarint64, et.length(), et)
    }, Writer$1.prototype.int64 = Writer$1.prototype.uint64, Writer$1.prototype.sint64 = function _(_e) {
        var et = LongBits$1.from(_e).zzEncode();
        return this._push(writeVarint64, et.length(), et)
    }, Writer$1.prototype.bool = function _(_e) {
        return this._push(writeByte, 1, _e ? 1 : 0)
    };

    function writeFixed32(_, _e, et) {
        _e[et] = _ & 255, _e[et + 1] = _ >>> 8 & 255, _e[et + 2] = _ >>> 16 & 255, _e[et + 3] = _ >>> 24
    }
    Writer$1.prototype.fixed32 = function _(_e) {
        return this._push(writeFixed32, 4, _e >>> 0)
    }, Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32, Writer$1.prototype.fixed64 = function _(_e) {
        var et = LongBits$1.from(_e);
        return this._push(writeFixed32, 4, et.lo)._push(writeFixed32, 4, et.hi)
    }, Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64, Writer$1.prototype.float = function _(_e) {
        return this._push(util$4.float.writeFloatLE, 4, _e)
    }, Writer$1.prototype.double = function _(_e) {
        return this._push(util$4.float.writeDoubleLE, 8, _e)
    };
    var writeBytes = util$4.Array.prototype.set ? function _(_e, et, tt) {
        et.set(_e, tt)
    } : function _(_e, et, tt) {
        for (var nt = 0; nt < _e.length; ++nt) et[tt + nt] = _e[nt]
    };
    Writer$1.prototype.bytes = function _(_e) {
        var et = _e.length >>> 0;
        if (!et) return this._push(writeByte, 1, 0);
        if (util$4.isString(_e)) {
            var tt = Writer$1.alloc(et = base64.length(_e));
            base64.decode(_e, tt, 0), _e = tt
        }
        return this.uint32(et)._push(writeBytes, et, _e)
    }, Writer$1.prototype.string = function _(_e) {
        var et = utf8$1.length(_e);
        return et ? this.uint32(et)._push(utf8$1.write, et, _e) : this._push(writeByte, 1, 0)
    }, Writer$1.prototype.fork = function _() {
        return this.states = new State$1(this), this.head = this.tail = new Op(noop$1, 0, 0), this.len = 0, this
    }, Writer$1.prototype.reset = function _() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$1, 0, 0), this.len = 0), this
    }, Writer$1.prototype.ldelim = function _() {
        var _e = this.head,
            et = this.tail,
            tt = this.len;
        return this.reset().uint32(tt), tt && (this.tail.next = _e.next, this.tail = et, this.len += tt), this
    }, Writer$1.prototype.finish = function _() {
        for (var _e = this.head.next, et = this.constructor.alloc(this.len), tt = 0; _e;) _e.fn(_e.val, et, tt), tt += _e.len, _e = _e.next;
        return et
    }, Writer$1._configure = function(_) {
        BufferWriter$1 = _, Writer$1.create = create$1(), BufferWriter$1._configure()
    };
    var writer_buffer = BufferWriter,
        Writer = writer;
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util$3 = requireMinimal();

    function BufferWriter() {
        Writer.call(this)
    }
    BufferWriter._configure = function() {
        BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function(_, _e, et) {
            _e.set(_, et)
        } : function(_, _e, et) {
            if (_.copy) _.copy(_e, et, 0, _.length);
            else
                for (var tt = 0; tt < _.length;) _e[et++] = _[tt++]
        }
    }, BufferWriter.prototype.bytes = function _(_e) {
        util$3.isString(_e) && (_e = util$3._Buffer_from(_e, "base64"));
        var et = _e.length >>> 0;
        return this.uint32(et), et && this._push(BufferWriter.writeBytesBuffer, et, _e), this
    };

    function writeStringBuffer(_, _e, et) {
        _.length < 40 ? util$3.utf8.write(_, _e, et) : _e.utf8Write ? _e.utf8Write(_, et) : _e.write(_, et)
    }
    BufferWriter.prototype.string = function _(_e) {
        var et = util$3.Buffer.byteLength(_e);
        return this.uint32(et), et && this._push(writeStringBuffer, et, _e), this
    }, BufferWriter._configure();
    var reader = Reader$1,
        util$2 = requireMinimal(),
        BufferReader$1, LongBits = util$2.LongBits,
        utf8 = util$2.utf8;

    function indexOutOfRange(_, _e) {
        return RangeError("index out of range: " + _.pos + " + " + (_e || 1) + " > " + _.len)
    }

    function Reader$1(_) {
        this.buf = _, this.pos = 0, this.len = _.length
    }
    var create_array = typeof Uint8Array < "u" ? function _(_e) {
            if (_e instanceof Uint8Array || Array.isArray(_e)) return new Reader$1(_e);
            throw Error("illegal buffer")
        } : function _(_e) {
            if (Array.isArray(_e)) return new Reader$1(_e);
            throw Error("illegal buffer")
        },
        create = function _() {
            return util$2.Buffer ? function(_e) {
                return (Reader$1.create = function(et) {
                    return util$2.Buffer.isBuffer(et) ? new BufferReader$1(et) : create_array(et)
                })(_e)
            } : create_array
        };
    Reader$1.create = create(), Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice, Reader$1.prototype.uint32 = function _() {
        var _e = 4294967295;
        return function() {
            if (_e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (_e = (_e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (_e = (_e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (_e = (_e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (_e = (_e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return _e;
            if ((this.pos += 5) > this.len) throw this.pos = this.len, indexOutOfRange(this, 10);
            return _e
        }
    }(), Reader$1.prototype.int32 = function _() {
        return this.uint32() | 0
    }, Reader$1.prototype.sint32 = function _() {
        var _e = this.uint32();
        return _e >>> 1 ^ -(_e & 1) | 0
    };

    function readLongVarint() {
        var _ = new LongBits(0, 0),
            _e = 0;
        if (this.len - this.pos > 4) {
            for (; _e < 4; ++_e)
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << _e * 7) >>> 0, this.buf[this.pos++] < 128) return _;
            if (_.lo = (_.lo | (this.buf[this.pos] & 127) << 28) >>> 0, _.hi = (_.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128) return _;
            _e = 0
        } else {
            for (; _e < 3; ++_e) {
                if (this.pos >= this.len) throw indexOutOfRange(this);
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << _e * 7) >>> 0, this.buf[this.pos++] < 128) return _
            }
            return _.lo = (_.lo | (this.buf[this.pos++] & 127) << _e * 7) >>> 0, _
        }
        if (this.len - this.pos > 4) {
            for (; _e < 5; ++_e)
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << _e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return _
        } else
            for (; _e < 5; ++_e) {
                if (this.pos >= this.len) throw indexOutOfRange(this);
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << _e * 7 + 3) >>> 0, this.buf[this.pos++] < 128) return _
            }
        throw Error("invalid varint encoding")
    }
    Reader$1.prototype.bool = function _() {
        return this.uint32() !== 0
    };

    function readFixed32_end(_, _e) {
        return (_[_e - 4] | _[_e - 3] << 8 | _[_e - 2] << 16 | _[_e - 1] << 24) >>> 0
    }
    Reader$1.prototype.fixed32 = function _() {
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4)
    }, Reader$1.prototype.sfixed32 = function _() {
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0
    };

    function readFixed64() {
        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4))
    }
    Reader$1.prototype.float = function _() {
        if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
        var _e = util$2.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, _e
    }, Reader$1.prototype.double = function _() {
        if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
        var _e = util$2.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, _e
    }, Reader$1.prototype.bytes = function _() {
        var _e = this.uint32(),
            et = this.pos,
            tt = this.pos + _e;
        if (tt > this.len) throw indexOutOfRange(this, _e);
        return this.pos += _e, Array.isArray(this.buf) ? this.buf.slice(et, tt) : et === tt ? new this.buf.constructor(0) : this._slice.call(this.buf, et, tt)
    }, Reader$1.prototype.string = function _() {
        var _e = this.bytes();
        return utf8.read(_e, 0, _e.length)
    }, Reader$1.prototype.skip = function _(_e) {
        if (typeof _e == "number") {
            if (this.pos + _e > this.len) throw indexOutOfRange(this, _e);
            this.pos += _e
        } else
            do
                if (this.pos >= this.len) throw indexOutOfRange(this); while (this.buf[this.pos++] & 128);
        return this
    }, Reader$1.prototype.skipType = function(_) {
        switch (_) {
            case 0:
                this.skip();
                break;
            case 1:
                this.skip(8);
                break;
            case 2:
                this.skip(this.uint32());
                break;
            case 3:
                for (;
                    (_ = this.uint32() & 7) !== 4;) this.skipType(_);
                break;
            case 5:
                this.skip(4);
                break;
            default:
                throw Error("invalid wire type " + _ + " at offset " + this.pos)
        }
        return this
    }, Reader$1._configure = function(_) {
        BufferReader$1 = _, Reader$1.create = create(), BufferReader$1._configure();
        var _e = util$2.Long ? "toLong" : "toNumber";
        util$2.merge(Reader$1.prototype, {
            int64: function() {
                return readLongVarint.call(this)[_e](!1)
            },
            uint64: function() {
                return readLongVarint.call(this)[_e](!0)
            },
            sint64: function() {
                return readLongVarint.call(this).zzDecode()[_e](!1)
            },
            fixed64: function() {
                return readFixed64.call(this)[_e](!0)
            },
            sfixed64: function() {
                return readFixed64.call(this)[_e](!1)
            }
        })
    };
    var reader_buffer = BufferReader,
        Reader = reader;
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util$1 = requireMinimal();

    function BufferReader(_) {
        Reader.call(this, _)
    }
    BufferReader._configure = function() {
        util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice)
    }, BufferReader.prototype.string = function _() {
        var _e = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + _e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + _e, this.len))
    }, BufferReader._configure();
    var rpc = {},
        service = Service,
        util = requireMinimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

    function Service(_, _e, et) {
        if (typeof _ != "function") throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this), this.rpcImpl = _, this.requestDelimited = !!_e, this.responseDelimited = !!et
    }
    Service.prototype.rpcCall = function _(_e, et, tt, nt, ot) {
            if (!nt) throw TypeError("request must be specified");
            var at = this;
            if (!ot) return util.asPromise(_, at, _e, et, tt, nt);
            if (!at.rpcImpl) {
                setTimeout(function() {
                    ot(Error("already ended"))
                }, 0);
                return
            }
            try {
                return at.rpcImpl(_e, et[at.requestDelimited ? "encodeDelimited" : "encode"](nt).finish(), function(st, lt) {
                    if (st) return at.emit("error", st, _e), ot(st);
                    if (lt === null) {
                        at.end(!0);
                        return
                    }
                    if (!(lt instanceof tt)) try {
                        lt = tt[at.responseDelimited ? "decodeDelimited" : "decode"](lt)
                    } catch (ut) {
                        return at.emit("error", ut, _e), ot(ut)
                    }
                    return at.emit("data", lt, _e), ot(null, lt)
                })
            } catch (st) {
                at.emit("error", st, _e), setTimeout(function() {
                    ot(st)
                }, 0);
                return
            }
        }, Service.prototype.end = function _(_e) {
            return this.rpcImpl && (_e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this
        },
        function(_) {
            var _e = _;
            _e.Service = service
        }(rpc);
    var roots = {};
    (function(_) {
        var _e = _;
        _e.build = "minimal", _e.Writer = writer, _e.BufferWriter = writer_buffer, _e.Reader = reader, _e.BufferReader = reader_buffer, _e.util = requireMinimal(), _e.rpc = rpc, _e.roots = roots, _e.configure = et;

        function et() {
            _e.util._configure(), _e.Writer._configure(_e.BufferWriter), _e.Reader._configure(_e.BufferReader)
        }
        et()
    })(indexMinimal);
    var minimal = indexMinimal;
    const d = getDefaultExportFromCjs(minimal);
    var D = Object.defineProperty,
        S = (_, _e, et) => _e in _ ? D(_, _e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: et
        }) : _[_e] = et,
        a$1 = (_, _e, et) => (S(_, typeof _e != "symbol" ? _e + "" : _e, et), et);
    const w = new TextEncoder,
        p = new TextDecoder;
    class $ {
        encode(_e, et) {
            let tt, nt, ot;
            _e.type === 2 ? (tt = _e.data[0], nt = _e.data[1]) : (tt = "", nt = new ArrayBuffer(0)), ot = _e.id === void 0 ? -1 : _e.id;
            let at = {
                type: _e.type,
                namespace: _e.nsp,
                event: tt,
                data: nt,
                ackId: ot
            };
            return et([E(at)])
        }
    }
    class x extends eventsExports.EventEmitter {
        add(_e) {
            let et = j(_e);
            et.type === 5 && (et.type = 2), et.type === 6 && (et.type = 3);
            let tt = {
                type: et.type,
                data: et.type === 3 ? [et.data] : [et.event, et.data],
                nsp: et.namespace,
                id: et.ackId
            };
            this.emit("decoded", tt)
        }
        destroy() {}
    }

    function E(_) {
        let _e, et, tt = _.type,
            nt = [];
        if (_.ackId !== -1) {
            tt += 128, nt.push(Uint8Array.of(tt));
            let ot = new Uint8Array(4);
            new DataView(ot.buffer).setUint32(0, _.ackId), nt.push(ot)
        } else nt.push(Uint8Array.of(tt));
        return et = w.encode(_.namespace), nt.push(Uint8Array.of(et.length)), nt.push(et), _e = w.encode(_.event), nt.push(Uint8Array.of(_e.length)), nt.push(_e), nt.push(new Uint8Array(_.data)), O(Uint8Array, ...nt).buffer
    }

    function j(_) {
        let _e = 0,
            et, tt = -1,
            nt, ot, at, st;
        const lt = new DataView(_, 0);
        return et = lt.getUint8(_e), _e++, et >= 128 && (et %= 128, tt = lt.getUint32(_e), _e += 4), st = lt.getUint8(_e), _e++, nt = new Uint8Array(_, _e, st), _e += st, st = lt.getUint8(_e), _e++, ot = new Uint8Array(_, _e, st), _e += st, at = _.slice(_e), {
            type: et,
            data: at,
            namespace: p.decode(nt),
            event: p.decode(ot),
            ackId: tt
        }
    }
    const O = (_, ..._e) => {
            let et = 0;
            for (let ot of _e) et += ot.length;
            let tt = new _(et),
                nt = 0;
            for (let ot of _e) tt.set(ot, nt), nt += ot.length;
            return tt
        },
        v = Object.freeze(Object.defineProperty({
            __proto__: null,
            Decoder: x,
            Encoder: $,
            concatenate: O
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        y = d.Reader,
        C = d.Writer,
        q = d.util,
        g = d.roots.default || (d.roots.default = {}),
        B = g.ResultObj = (() => {
            function _(_e) {
                if (_e)
                    for (let et = Object.keys(_e), tt = 0; tt < et.length; ++tt) _e[et[tt]] != null && (this[et[tt]] = _e[et[tt]])
            }
            return _.prototype.code = 0, _.prototype.msg = "", _.prototype.data = q.newBuffer([]), _.encode = function(_e, et) {
                return et || (et = C.create()), _e.code != null && Object.hasOwnProperty.call(_e, "code") && et.uint32(8).sint32(_e.code), _e.msg != null && Object.hasOwnProperty.call(_e, "msg") && et.uint32(18).string(_e.msg), _e.data != null && Object.hasOwnProperty.call(_e, "data") && et.uint32(26).bytes(_e.data), et
            }, _.decode = function(_e, et) {
                _e instanceof y || (_e = y.create(_e));
                let tt = et === void 0 ? _e.len : _e.pos + et,
                    nt = new g.ResultObj;
                for (; _e.pos < tt;) {
                    let ot = _e.uint32();
                    switch (ot >>> 3) {
                        case 1:
                            nt.code = _e.sint32();
                            break;
                        case 2:
                            nt.msg = _e.string();
                            break;
                        case 3:
                            nt.data = _e.bytes();
                            break;
                        default:
                            _e.skipType(ot & 7);
                            break
                    }
                }
                return nt
            }, _
        })(),
        T = () => __vitePreload(() =>
            import ("./chunk-b3c3490f.js"), []).then(_ => _.default),
        V = typeof window > "u",
        f = class tn extends libExports.Manager {
            constructor({
                uris: _e
            }, et = tn.socketOptions) {
                super(_e[0].socket, et), a$1(this, "afterRequest", []), a$1(this, "uris"), a$1(this, "isConnecting", !1), a$1(this, "enableSocketConnect", () => {}), a$1(this, "waitSocketConnect", new Promise(tt => this.enableSocketConnect = tt)), a$1(this, "socketRequestBind", tt => (nt, ot) => new Promise((at, st) => {
                    const lt = setTimeout(() => st(new Error(`${tt.nsp}/${nt}:Socket time out`)), 2e4);
                    tt.emit(nt, ot, this.decodeBind(ut => {
                        clearTimeout(lt);
                        try {
                            for (let dt = 0, ct = this.afterRequest.length; dt < ct; dt++) this.afterRequest[dt](ut);
                            ut.code === 0 ? at(ut.data) : (console.log(`Socket Error: ${tt.nsp}:${nt}
${JSON.stringify(ot)}`), st(new P(ut.msg, ut.code)))
                        } catch (dt) {
                            st(dt)
                        }
                    }, B))
                })), this.uris = _e
            }
            open(_e) {
                V || this.isConnecting || ~this.readyState.indexOf("open") || (this.isConnecting = !0, this.openWithSign().finally(() => {
                    super.open(_e), this.isConnecting = !1
                }))
            }
            async openWithSign() {
                const {
                    sign: _e,
                    uri: et,
                    source: tt
                } = await this.getSignData();
                await this.waitSocketConnect, this.opts.query = {
                    p: _e,
                    t: tt
                }, this.uri = et.socket
            }
            async testSocketRoute(_e, et = "") {
                const {
                    socket: tt,
                    test: nt = tt
                } = _e, ot = `${nt}/test/${et?"?p="+et:""}`, at = await fetch(ot, {
                    credentials: "include"
                }).then(st => st.text());
                return {
                    uri: _e,
                    sign: at
                }
            }
            async getSignData() {
                const {
                    t1: _e,
                    t2: et
                } = await T(), tt = window.navigator.userAgent.trim(), nt = _e(tt);
                let {
                    uri: ot,
                    sign: at
                } = await Promise.race(this.uris.map(st => this.testSocketRoute(st, nt)));
                return {
                    sign: et(at, tt),
                    uri: ot,
                    source: at
                }
            }
            addAfterRequest(_e) {
                this.afterRequest.push(_e)
            }
            decode(_e = "utf8") {
                return et => {
                    let tt;
                    if (_e === "utf8") tt = b.decode(et);
                    else if (_e === "json") tt = JSON.parse(b.decode(et));
                    else if (_e === "int8") tt = new DataView(et).getUint8(0);
                    else if (_e === "int32") tt = new DataView(et).getUint32(0);
                    else if (_e === "int64") {
                        let nt = new DataView(et);
                        tt = new Long(nt.getUint32(4), nt.getUint32(0)).toNumber()
                    } else tt = _e.decode(new Uint8Array(et));
                    return tt
                }
            }
            encode(_e = "utf8") {
                return et => {
                    if (_e === "utf8") return U.encode(et);
                    if (_e === "json") return U.encode(JSON.stringify(et));
                    if (_e === "int8") return Uint8Array.of(et);
                    if (_e === "int32") {
                        let tt = new Uint8Array(4);
                        return new DataView(tt.buffer).setUint32(0, et), tt
                    } else if (_e === "int64") {
                        let tt = Long.fromNumber(et),
                            nt = new Uint8Array(8),
                            ot = new DataView(nt.buffer);
                        return ot.setUint32(0, tt.high), ot.setUint32(4, tt.low), nt
                    } else return _e.encode(new _e(et)).finish()
                }
            }
            decodeBind(_e, et = "utf8") {
                const tt = this.decode(et);
                return nt => _e(tt(nt))
            }
        };
    a$1(f, "socketOptions", {
        timeout: 2e4,
        reconnectionDelayMax: 1e4,
        transports: ["websocket"],
        autoConnect: !1,
        parser: v,
        query: {}
    });
    let m = f;
    const U = new TextEncoder,
        b = new TextDecoder;
    class P extends Error {
        constructor(_e, et = 0) {
            super(_e), a$1(this, "code"), this.code = et
        }
    }
    let useProxy$8, proxy$8, Context;
    F = () => __vitePreload(() =>
        import ("./chunk-b3c3490f.js"), []).then(_ => _.default), {
        useProxy: useProxy$8,
        proxy: proxy$8
    } = valtio, Context = React.createContext(void 0), usePageContext = function() {
        return reactExports.useContext(Context)
    }, usePageProps = function() {
        return reactExports.useContext(Context).pageProps.suspensed
    };

    function useSetSearch() {
        const {
            urlParsed: _
        } = usePageContext();
        return reactExports.useCallback(_e => {
            const et = kt(kt({}, _.search), _e),
                tt = new URLSearchParams(et);
            tt.forEach((ot, at) => !ot && tt.delete(at));
            const nt = tt.toString();
            return `${_.pathname}${nt?"?"+nt:""}`
        }, [_])
    }
    useNavigate = function() {
        return app.unsafeNavigate
    };
    const baseUrl = "/".replace(/\/$/, "");

    function getI18nPath(_, _e) {
        if (_.startsWith("/") && !_.startsWith("//")) {
            const et = _e === "en" ? "" : `/${_e}`;
            return `${baseUrl}${et}${_}`
        }
        return _
    }

    function useLocation() {
        const {
            urlParsed: {
                pathname: _,
                hash: _e,
                searchOriginal: et
            }
        } = usePageContext();
        return reactExports.useMemo(() => ({
            pathname: _,
            search: et || "",
            hash: _e
        }), [_, _e, et])
    }
    const globalState = proxy$8({
        mobile: !1,
        darken: !localStorage.getItem("isBrighten")
    });

    function useGlobalState() {
        return useProxy$8(globalState)
    }
    useIsDarken = function() {
        return useGlobalState().darken
    }, useToggleDarken = function() {
        return _ => {
            globalState.darken = _
        }
    }, useIsMobile = function() {
        return useGlobalState().mobile
    };
    const consoleLogger = {
        type: "logger",
        log(_) {
            this.output("log", _)
        },
        warn(_) {
            this.output("warn", _)
        },
        error(_) {
            this.output("error", _)
        },
        output(_, _e) {
            console && console[_] && console[_].apply(console, _e)
        }
    };
    class Logger {
        constructor(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.init(_e, et)
        }
        init(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.prefix = et.prefix || "i18next:", this.logger = _e || consoleLogger, this.options = et, this.debug = et.debug
        }
        log() {
            for (var _e = arguments.length, et = new Array(_e), tt = 0; tt < _e; tt++) et[tt] = arguments[tt];
            return this.forward(et, "log", "", !0)
        }
        warn() {
            for (var _e = arguments.length, et = new Array(_e), tt = 0; tt < _e; tt++) et[tt] = arguments[tt];
            return this.forward(et, "warn", "", !0)
        }
        error() {
            for (var _e = arguments.length, et = new Array(_e), tt = 0; tt < _e; tt++) et[tt] = arguments[tt];
            return this.forward(et, "error", "")
        }
        deprecate() {
            for (var _e = arguments.length, et = new Array(_e), tt = 0; tt < _e; tt++) et[tt] = arguments[tt];
            return this.forward(et, "warn", "WARNING DEPRECATED: ", !0)
        }
        forward(_e, et, tt, nt) {
            return nt && !this.debug ? null : (typeof _e[0] == "string" && (_e[0] = `${tt}${this.prefix} ${_e[0]}`), this.logger[et](_e))
        }
        create(_e) {
            return new Logger(this.logger, kt({
                prefix: `${this.prefix}:${_e}:`
            }, this.options))
        }
        clone(_e) {
            return _e = _e || this.options, _e.prefix = _e.prefix || this.prefix, new Logger(this.logger, _e)
        }
    }
    var baseLogger = new Logger;
    class EventEmitter {
        constructor() {
            this.observers = {}
        }
        on(_e, et) {
            return _e.split(" ").forEach(tt => {
                this.observers[tt] = this.observers[tt] || [], this.observers[tt].push(et)
            }), this
        }
        off(_e, et) {
            if (this.observers[_e]) {
                if (!et) {
                    delete this.observers[_e];
                    return
                }
                this.observers[_e] = this.observers[_e].filter(tt => tt !== et)
            }
        }
        emit(_e) {
            for (var et = arguments.length, tt = new Array(et > 1 ? et - 1 : 0), nt = 1; nt < et; nt++) tt[nt - 1] = arguments[nt];
            this.observers[_e] && [].concat(this.observers[_e]).forEach(ot => {
                ot(...tt)
            }), this.observers["*"] && [].concat(this.observers["*"]).forEach(ot => {
                ot.apply(ot, [_e, ...tt])
            })
        }
    }

    function defer() {
        let _, _e;
        const et = new Promise((tt, nt) => {
            _ = tt, _e = nt
        });
        return et.resolve = _, et.reject = _e, et
    }

    function makeString(_) {
        return _ == null ? "" : "" + _
    }

    function copy(_, _e, et) {
        _.forEach(tt => {
            _e[tt] && (et[tt] = _e[tt])
        })
    }

    function getLastOfPath(_, _e, et) {
        function tt(at) {
            return at && at.indexOf("###") > -1 ? at.replace(/###/g, ".") : at
        }

        function nt() {
            return !_ || typeof _ == "string"
        }
        const ot = typeof _e != "string" ? [].concat(_e) : _e.split(".");
        for (; ot.length > 1;) {
            if (nt()) return {};
            const at = tt(ot.shift());
            !_[at] && et && (_[at] = new et), Object.prototype.hasOwnProperty.call(_, at) ? _ = _[at] : _ = {}
        }
        return nt() ? {} : {
            obj: _,
            k: tt(ot.shift())
        }
    }

    function setPath(_, _e, et) {
        const {
            obj: tt,
            k: nt
        } = getLastOfPath(_, _e, Object);
        tt[nt] = et
    }

    function pushPath(_, _e, et, tt) {
        const {
            obj: nt,
            k: ot
        } = getLastOfPath(_, _e, Object);
        nt[ot] = nt[ot] || [], tt && (nt[ot] = nt[ot].concat(et)), tt || nt[ot].push(et)
    }

    function getPath(_, _e) {
        const {
            obj: et,
            k: tt
        } = getLastOfPath(_, _e);
        if (et) return et[tt]
    }

    function getPathWithDefaults(_, _e, et) {
        const tt = getPath(_, et);
        return tt !== void 0 ? tt : getPath(_e, et)
    }

    function deepExtend(_, _e, et) {
        for (const tt in _e) tt !== "__proto__" && tt !== "constructor" && (tt in _ ? typeof _[tt] == "string" || _[tt] instanceof String || typeof _e[tt] == "string" || _e[tt] instanceof String ? et && (_[tt] = _e[tt]) : deepExtend(_[tt], _e[tt], et) : _[tt] = _e[tt]);
        return _
    }

    function regexEscape(_) {
        return _.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
    }
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    };

    function escape(_) {
        return typeof _ == "string" ? _.replace(/[&<>"'\/]/g, _e => _entityMap[_e]) : _
    }
    const chars = [" ", ",", "?", "!", ";"];

    function looksLikeObjectPath(_, _e, et) {
        _e = _e || "", et = et || "";
        const tt = chars.filter(at => _e.indexOf(at) < 0 && et.indexOf(at) < 0);
        if (tt.length === 0) return !0;
        const nt = new RegExp(`(${tt.map(at=>at==="?"?"\\?":at).join("|")})`);
        let ot = !nt.test(_);
        if (!ot) {
            const at = _.indexOf(et);
            at > 0 && !nt.test(_.substring(0, at)) && (ot = !0)
        }
        return ot
    }

    function deepFind(_, _e) {
        let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
        if (!_) return;
        if (_[_e]) return _[_e];
        const tt = _e.split(et);
        let nt = _;
        for (let ot = 0; ot < tt.length; ++ot) {
            if (!nt || typeof nt[tt[ot]] == "string" && ot + 1 < tt.length) return;
            if (nt[tt[ot]] === void 0) {
                let at = 2,
                    st = tt.slice(ot, ot + at).join(et),
                    lt = nt[st];
                for (; lt === void 0 && tt.length > ot + at;) at++, st = tt.slice(ot, ot + at).join(et), lt = nt[st];
                if (lt === void 0) return;
                if (lt === null) return null;
                if (_e.endsWith(st)) {
                    if (typeof lt == "string") return lt;
                    if (st && typeof lt[st] == "string") return lt[st]
                }
                const ut = tt.slice(ot + at).join(et);
                return ut ? deepFind(lt, ut, et) : void 0
            }
            nt = nt[tt[ot]]
        }
        return nt
    }

    function getCleanedCode(_) {
        return _ && _.indexOf("_") > 0 ? _.replace("_", "-") : _
    }
    class ResourceStore extends EventEmitter {
        constructor(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                ns: ["translation"],
                defaultNS: "translation"
            };
            super(), this.data = _e || {}, this.options = et, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
        }
        addNamespaces(_e) {
            this.options.ns.indexOf(_e) < 0 && this.options.ns.push(_e)
        }
        removeNamespaces(_e) {
            const et = this.options.ns.indexOf(_e);
            et > -1 && this.options.ns.splice(et, 1)
        }
        getResource(_e, et, tt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            const ot = nt.keySeparator !== void 0 ? nt.keySeparator : this.options.keySeparator,
                at = nt.ignoreJSONStructure !== void 0 ? nt.ignoreJSONStructure : this.options.ignoreJSONStructure;
            let st = [_e, et];
            tt && typeof tt != "string" && (st = st.concat(tt)), tt && typeof tt == "string" && (st = st.concat(ot ? tt.split(ot) : tt)), _e.indexOf(".") > -1 && (st = _e.split("."));
            const lt = getPath(this.data, st);
            return lt || !at || typeof tt != "string" ? lt : deepFind(this.data && this.data[_e] && this.data[_e][et], tt, ot)
        }
        addResource(_e, et, tt, nt) {
            let ot = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                silent: !1
            };
            const at = ot.keySeparator !== void 0 ? ot.keySeparator : this.options.keySeparator;
            let st = [_e, et];
            tt && (st = st.concat(at ? tt.split(at) : tt)), _e.indexOf(".") > -1 && (st = _e.split("."), nt = et, et = st[1]), this.addNamespaces(et), setPath(this.data, st, nt), ot.silent || this.emit("added", _e, et, tt, nt)
        }
        addResources(_e, et, tt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
                silent: !1
            };
            for (const ot in tt)(typeof tt[ot] == "string" || Object.prototype.toString.apply(tt[ot]) === "[object Array]") && this.addResource(_e, et, ot, tt[ot], {
                silent: !0
            });
            nt.silent || this.emit("added", _e, et, tt)
        }
        addResourceBundle(_e, et, tt, nt, ot) {
            let at = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
                    silent: !1
                },
                st = [_e, et];
            _e.indexOf(".") > -1 && (st = _e.split("."), nt = tt, tt = et, et = st[1]), this.addNamespaces(et);
            let lt = getPath(this.data, st) || {};
            nt ? deepExtend(lt, tt, ot) : lt = kt(kt({}, lt), tt), setPath(this.data, st, lt), at.silent || this.emit("added", _e, et, tt)
        }
        removeResourceBundle(_e, et) {
            this.hasResourceBundle(_e, et) && delete this.data[_e][et], this.removeNamespaces(et), this.emit("removed", _e, et)
        }
        hasResourceBundle(_e, et) {
            return this.getResource(_e, et) !== void 0
        }
        getResourceBundle(_e, et) {
            return et || (et = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? kt({}, this.getResource(_e, et)) : this.getResource(_e, et)
        }
        getDataByLanguage(_e) {
            return this.data[_e]
        }
        hasLanguageSomeTranslations(_e) {
            const et = this.getDataByLanguage(_e);
            return !!(et && Object.keys(et) || []).find(tt => et[tt] && Object.keys(et[tt]).length > 0)
        }
        toJSON() {
            return this.data
        }
    }
    var postProcessor = {
        processors: {},
        addPostProcessor(_) {
            this.processors[_.name] = _
        },
        handle(_, _e, et, tt, nt) {
            return _.forEach(ot => {
                this.processors[ot] && (_e = this.processors[ot].process(_e, et, tt, nt))
            }), _e
        }
    };
    const checkedLoadedFor = {};
    class Translator extends EventEmitter {
        constructor(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            super(), copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], _e, this), this.options = et, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = baseLogger.create("translator")
        }
        changeLanguage(_e) {
            _e && (this.language = _e)
        }
        exists(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                interpolation: {}
            };
            if (_e == null) return !1;
            const tt = this.resolve(_e, et);
            return tt && tt.res !== void 0
        }
        extractFromKey(_e, et) {
            let tt = et.nsSeparator !== void 0 ? et.nsSeparator : this.options.nsSeparator;
            tt === void 0 && (tt = ":");
            const nt = et.keySeparator !== void 0 ? et.keySeparator : this.options.keySeparator;
            let ot = et.ns || this.options.defaultNS || [];
            const at = tt && _e.indexOf(tt) > -1,
                st = !this.options.userDefinedKeySeparator && !et.keySeparator && !this.options.userDefinedNsSeparator && !et.nsSeparator && !looksLikeObjectPath(_e, tt, nt);
            if (at && !st) {
                const lt = _e.match(this.interpolator.nestingRegexp);
                if (lt && lt.length > 0) return {
                    key: _e,
                    namespaces: ot
                };
                const ut = _e.split(tt);
                (tt !== nt || tt === nt && this.options.ns.indexOf(ut[0]) > -1) && (ot = ut.shift()), _e = ut.join(nt)
            }
            return typeof ot == "string" && (ot = [ot]), {
                key: _e,
                namespaces: ot
            }
        }
        translate(_e, et, tt) {
            if (typeof et != "object" && this.options.overloadTranslationOptionHandler && (et = this.options.overloadTranslationOptionHandler(arguments)), typeof et == "object" && (et = kt({}, et)), et || (et = {}), _e == null) return "";
            Array.isArray(_e) || (_e = [String(_e)]);
            const nt = et.returnDetails !== void 0 ? et.returnDetails : this.options.returnDetails,
                ot = et.keySeparator !== void 0 ? et.keySeparator : this.options.keySeparator,
                {
                    key: at,
                    namespaces: st
                } = this.extractFromKey(_e[_e.length - 1], et),
                lt = st[st.length - 1],
                ut = et.lng || this.language,
                dt = et.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
            if (ut && ut.toLowerCase() === "cimode") {
                if (dt) {
                    const xt = et.nsSeparator || this.options.nsSeparator;
                    return nt ? {
                        res: `${lt}${xt}${at}`,
                        usedKey: at,
                        exactUsedKey: at,
                        usedLng: ut,
                        usedNS: lt,
                        usedParams: this.getUsedParamsDetails(et)
                    } : `${lt}${xt}${at}`
                }
                return nt ? {
                    res: at,
                    usedKey: at,
                    exactUsedKey: at,
                    usedLng: ut,
                    usedNS: lt,
                    usedParams: this.getUsedParamsDetails(et)
                } : at
            }
            const ct = this.resolve(_e, et);
            let pt = ct && ct.res;
            const ft = ct && ct.usedKey || at,
                ht = ct && ct.exactUsedKey || at,
                mt = Object.prototype.toString.apply(pt),
                bt = ["[object Number]", "[object Function]", "[object RegExp]"],
                gt = et.joinArrays !== void 0 ? et.joinArrays : this.options.joinArrays,
                vt = !this.i18nFormat || this.i18nFormat.handleAsObject;
            if (vt && pt && typeof pt != "string" && typeof pt != "boolean" && typeof pt != "number" && bt.indexOf(mt) < 0 && !(typeof gt == "string" && mt === "[object Array]")) {
                if (!et.returnObjects && !this.options.returnObjects) {
                    this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                    const xt = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(ft, pt, Bt(kt({}, et), {
                        ns: st
                    })) : `key '${at} (${this.language})' returned an object instead of string.`;
                    return nt ? (ct.res = xt, ct.usedParams = this.getUsedParamsDetails(et), ct) : xt
                }
                if (ot) {
                    const xt = mt === "[object Array]",
                        yt = xt ? [] : {},
                        Et = xt ? ht : ft;
                    for (const wt in pt)
                        if (Object.prototype.hasOwnProperty.call(pt, wt)) {
                            const St = `${Et}${ot}${wt}`;
                            yt[wt] = this.translate(St, Bt(kt({}, et), {
                                joinArrays: !1,
                                ns: st
                            })), yt[wt] === St && (yt[wt] = pt[wt])
                        }
                    pt = yt
                }
            } else if (vt && typeof gt == "string" && mt === "[object Array]") pt = pt.join(gt), pt && (pt = this.extendTranslation(pt, _e, et, tt));
            else {
                let xt = !1,
                    yt = !1;
                const Et = et.count !== void 0 && typeof et.count != "string",
                    wt = Translator.hasDefaultValue(et),
                    St = Et ? this.pluralResolver.getSuffix(ut, et.count, et) : "",
                    $t = et.ordinal && Et ? this.pluralResolver.getSuffix(ut, et.count, {
                        ordinal: !1
                    }) : "",
                    Ct = et[`defaultValue${St}`] || et[`defaultValue${$t}`] || et.defaultValue;
                !this.isValidLookup(pt) && wt && (xt = !0, pt = Ct), this.isValidLookup(pt) || (yt = !0, pt = at);
                const Rt = (et.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && yt ? void 0 : pt,
                    Pt = wt && Ct !== pt && this.options.updateMissing;
                if (yt || xt || Pt) {
                    if (this.logger.log(Pt ? "updateKey" : "missingKey", ut, lt, at, Pt ? Ct : pt), ot) {
                        const Dt = this.resolve(at, Bt(kt({}, et), {
                            keySeparator: !1
                        }));
                        Dt && Dt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                    }
                    let Tt = [];
                    const It = this.languageUtils.getFallbackCodes(this.options.fallbackLng, et.lng || this.language);
                    if (this.options.saveMissingTo === "fallback" && It && It[0])
                        for (let Dt = 0; Dt < It.length; Dt++) Tt.push(It[Dt]);
                    else this.options.saveMissingTo === "all" ? Tt = this.languageUtils.toResolveHierarchy(et.lng || this.language) : Tt.push(et.lng || this.language);
                    const Ot = (Dt, jt, Ht) => {
                        const Mt = wt && Ht !== pt ? Ht : Rt;
                        this.options.missingKeyHandler ? this.options.missingKeyHandler(Dt, lt, jt, Mt, Pt, et) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(Dt, lt, jt, Mt, Pt, et), this.emit("missingKey", Dt, lt, jt, pt)
                    };
                    this.options.saveMissing && (this.options.saveMissingPlurals && Et ? Tt.forEach(Dt => {
                        this.pluralResolver.getSuffixes(Dt, et).forEach(jt => {
                            Ot([Dt], at + jt, et[`defaultValue${jt}`] || Ct)
                        })
                    }) : Ot(Tt, at, Ct))
                }
                pt = this.extendTranslation(pt, _e, et, ct, tt), yt && pt === at && this.options.appendNamespaceToMissingKey && (pt = `${lt}:${at}`), (yt || xt) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? pt = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${lt}:${at}` : at, xt ? pt : void 0) : pt = this.options.parseMissingKeyHandler(pt))
            }
            return nt ? (ct.res = pt, ct.usedParams = this.getUsedParamsDetails(et), ct) : pt
        }
        extendTranslation(_e, et, tt, nt, ot) {
            var at = this;
            if (this.i18nFormat && this.i18nFormat.parse) _e = this.i18nFormat.parse(_e, kt(kt({}, this.options.interpolation.defaultVariables), tt), tt.lng || this.language || nt.usedLng, nt.usedNS, nt.usedKey, {
                resolved: nt
            });
            else if (!tt.skipInterpolation) {
                tt.interpolation && this.interpolator.init(Bt(kt({}, tt), {
                    interpolation: kt(kt({}, this.options.interpolation), tt.interpolation)
                }));
                const ut = typeof _e == "string" && (tt && tt.interpolation && tt.interpolation.skipOnVariables !== void 0 ? tt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
                let dt;
                if (ut) {
                    const pt = _e.match(this.interpolator.nestingRegexp);
                    dt = pt && pt.length
                }
                let ct = tt.replace && typeof tt.replace != "string" ? tt.replace : tt;
                if (this.options.interpolation.defaultVariables && (ct = kt(kt({}, this.options.interpolation.defaultVariables), ct)), _e = this.interpolator.interpolate(_e, ct, tt.lng || this.language, tt), ut) {
                    const pt = _e.match(this.interpolator.nestingRegexp),
                        ft = pt && pt.length;
                    dt < ft && (tt.nest = !1)
                }!tt.lng && this.options.compatibilityAPI !== "v1" && nt && nt.res && (tt.lng = nt.usedLng), tt.nest !== !1 && (_e = this.interpolator.nest(_e, function() {
                    for (var pt = arguments.length, ft = new Array(pt), ht = 0; ht < pt; ht++) ft[ht] = arguments[ht];
                    return ot && ot[0] === ft[0] && !tt.context ? (at.logger.warn(`It seems you are nesting recursively key: ${ft[0]} in key: ${et[0]}`), null) : at.translate(...ft, et)
                }, tt)), tt.interpolation && this.interpolator.reset()
            }
            const st = tt.postProcess || this.options.postProcess,
                lt = typeof st == "string" ? [st] : st;
            return _e != null && lt && lt.length && tt.applyPostProcessor !== !1 && (_e = postProcessor.handle(lt, _e, et, this.options && this.options.postProcessPassResolved ? kt({
                i18nResolved: nt
            }, tt) : tt, this)), _e
        }
        resolve(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                tt, nt, ot, at, st;
            return typeof _e == "string" && (_e = [_e]), _e.forEach(lt => {
                if (this.isValidLookup(tt)) return;
                const ut = this.extractFromKey(lt, et),
                    dt = ut.key;
                nt = dt;
                let ct = ut.namespaces;
                this.options.fallbackNS && (ct = ct.concat(this.options.fallbackNS));
                const pt = et.count !== void 0 && typeof et.count != "string",
                    ft = pt && !et.ordinal && et.count === 0 && this.pluralResolver.shouldUseIntlApi(),
                    ht = et.context !== void 0 && (typeof et.context == "string" || typeof et.context == "number") && et.context !== "",
                    mt = et.lngs ? et.lngs : this.languageUtils.toResolveHierarchy(et.lng || this.language, et.fallbackLng);
                ct.forEach(bt => {
                    this.isValidLookup(tt) || (st = bt, !checkedLoadedFor[`${mt[0]}-${bt}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(st) && (checkedLoadedFor[`${mt[0]}-${bt}`] = !0, this.logger.warn(`key "${nt}" for languages "${mt.join(", ")}" won't get resolved as namespace "${st}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), mt.forEach(gt => {
                        if (this.isValidLookup(tt)) return;
                        at = gt;
                        const vt = [dt];
                        if (this.i18nFormat && this.i18nFormat.addLookupKeys) this.i18nFormat.addLookupKeys(vt, dt, gt, bt, et);
                        else {
                            let yt;
                            pt && (yt = this.pluralResolver.getSuffix(gt, et.count, et));
                            const Et = `${this.options.pluralSeparator}zero`,
                                wt = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                            if (pt && (vt.push(dt + yt), et.ordinal && yt.indexOf(wt) === 0 && vt.push(dt + yt.replace(wt, this.options.pluralSeparator)), ft && vt.push(dt + Et)), ht) {
                                const St = `${dt}${this.options.contextSeparator}${et.context}`;
                                vt.push(St), pt && (vt.push(St + yt), et.ordinal && yt.indexOf(wt) === 0 && vt.push(St + yt.replace(wt, this.options.pluralSeparator)), ft && vt.push(St + Et))
                            }
                        }
                        let xt;
                        for (; xt = vt.pop();) this.isValidLookup(tt) || (ot = xt, tt = this.getResource(gt, bt, xt, et))
                    }))
                })
            }), {
                res: tt,
                usedKey: nt,
                exactUsedKey: ot,
                usedLng: at,
                usedNS: st
            }
        }
        isValidLookup(_e) {
            return _e !== void 0 && !(!this.options.returnNull && _e === null) && !(!this.options.returnEmptyString && _e === "")
        }
        getResource(_e, et, tt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(_e, et, tt, nt) : this.resourceStore.getResource(_e, et, tt, nt)
        }
        getUsedParamsDetails() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            const et = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"],
                tt = _e.replace && typeof _e.replace != "string";
            let nt = tt ? _e.replace : _e;
            if (tt && typeof _e.count < "u" && (nt.count = _e.count), this.options.interpolation.defaultVariables && (nt = kt(kt({}, this.options.interpolation.defaultVariables), nt)), !tt) {
                nt = kt({}, nt);
                for (const ot of et) delete nt[ot]
            }
            return nt
        }
        static hasDefaultValue(_e) {
            const et = "defaultValue";
            for (const tt in _e)
                if (Object.prototype.hasOwnProperty.call(_e, tt) && et === tt.substring(0, et.length) && _e[tt] !== void 0) return !0;
            return !1
        }
    }

    function capitalize(_) {
        return _.charAt(0).toUpperCase() + _.slice(1)
    }
    class LanguageUtil {
        constructor(_e) {
            this.options = _e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils")
        }
        getScriptPartFromCode(_e) {
            if (_e = getCleanedCode(_e), !_e || _e.indexOf("-") < 0) return null;
            const et = _e.split("-");
            return et.length === 2 || (et.pop(), et[et.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(et.join("-"))
        }
        getLanguagePartFromCode(_e) {
            if (_e = getCleanedCode(_e), !_e || _e.indexOf("-") < 0) return _e;
            const et = _e.split("-");
            return this.formatLanguageCode(et[0])
        }
        formatLanguageCode(_e) {
            if (typeof _e == "string" && _e.indexOf("-") > -1) {
                const et = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
                let tt = _e.split("-");
                return this.options.lowerCaseLng ? tt = tt.map(nt => nt.toLowerCase()) : tt.length === 2 ? (tt[0] = tt[0].toLowerCase(), tt[1] = tt[1].toUpperCase(), et.indexOf(tt[1].toLowerCase()) > -1 && (tt[1] = capitalize(tt[1].toLowerCase()))) : tt.length === 3 && (tt[0] = tt[0].toLowerCase(), tt[1].length === 2 && (tt[1] = tt[1].toUpperCase()), tt[0] !== "sgn" && tt[2].length === 2 && (tt[2] = tt[2].toUpperCase()), et.indexOf(tt[1].toLowerCase()) > -1 && (tt[1] = capitalize(tt[1].toLowerCase())), et.indexOf(tt[2].toLowerCase()) > -1 && (tt[2] = capitalize(tt[2].toLowerCase()))), tt.join("-")
            }
            return this.options.cleanCode || this.options.lowerCaseLng ? _e.toLowerCase() : _e
        }
        isSupportedCode(_e) {
            return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (_e = this.getLanguagePartFromCode(_e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(_e) > -1
        }
        getBestMatchFromCodes(_e) {
            if (!_e) return null;
            let et;
            return _e.forEach(tt => {
                if (et) return;
                const nt = this.formatLanguageCode(tt);
                (!this.options.supportedLngs || this.isSupportedCode(nt)) && (et = nt)
            }), !et && this.options.supportedLngs && _e.forEach(tt => {
                if (et) return;
                const nt = this.getLanguagePartFromCode(tt);
                if (this.isSupportedCode(nt)) return et = nt;
                et = this.options.supportedLngs.find(ot => {
                    if (ot === nt || !(ot.indexOf("-") < 0 && nt.indexOf("-") < 0) && ot.indexOf(nt) === 0) return ot
                })
            }), et || (et = this.getFallbackCodes(this.options.fallbackLng)[0]), et
        }
        getFallbackCodes(_e, et) {
            if (!_e) return [];
            if (typeof _e == "function" && (_e = _e(et)), typeof _e == "string" && (_e = [_e]), Object.prototype.toString.apply(_e) === "[object Array]") return _e;
            if (!et) return _e.default || [];
            let tt = _e[et];
            return tt || (tt = _e[this.getScriptPartFromCode(et)]), tt || (tt = _e[this.formatLanguageCode(et)]), tt || (tt = _e[this.getLanguagePartFromCode(et)]), tt || (tt = _e.default), tt || []
        }
        toResolveHierarchy(_e, et) {
            const tt = this.getFallbackCodes(et || this.options.fallbackLng || [], _e),
                nt = [],
                ot = at => {
                    at && (this.isSupportedCode(at) ? nt.push(at) : this.logger.warn(`rejecting language code not found in supportedLngs: ${at}`))
                };
            return typeof _e == "string" && (_e.indexOf("-") > -1 || _e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && ot(this.formatLanguageCode(_e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && ot(this.getScriptPartFromCode(_e)), this.options.load !== "currentOnly" && ot(this.getLanguagePartFromCode(_e))) : typeof _e == "string" && ot(this.formatLanguageCode(_e)), tt.forEach(at => {
                nt.indexOf(at) < 0 && ot(this.formatLanguageCode(at))
            }), nt
        }
    }
    let sets = [{
            lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
            nr: [1, 2],
            fc: 1
        }, {
            lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
            nr: [1, 2],
            fc: 2
        }, {
            lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
            nr: [1],
            fc: 3
        }, {
            lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
            nr: [1, 2, 5],
            fc: 4
        }, {
            lngs: ["ar"],
            nr: [0, 1, 2, 3, 11, 100],
            fc: 5
        }, {
            lngs: ["cs", "sk"],
            nr: [1, 2, 5],
            fc: 6
        }, {
            lngs: ["csb", "pl"],
            nr: [1, 2, 5],
            fc: 7
        }, {
            lngs: ["cy"],
            nr: [1, 2, 3, 8],
            fc: 8
        }, {
            lngs: ["fr"],
            nr: [1, 2],
            fc: 9
        }, {
            lngs: ["ga"],
            nr: [1, 2, 3, 7, 11],
            fc: 10
        }, {
            lngs: ["gd"],
            nr: [1, 2, 3, 20],
            fc: 11
        }, {
            lngs: ["is"],
            nr: [1, 2],
            fc: 12
        }, {
            lngs: ["jv"],
            nr: [0, 1],
            fc: 13
        }, {
            lngs: ["kw"],
            nr: [1, 2, 3, 4],
            fc: 14
        }, {
            lngs: ["lt"],
            nr: [1, 2, 10],
            fc: 15
        }, {
            lngs: ["lv"],
            nr: [1, 2, 0],
            fc: 16
        }, {
            lngs: ["mk"],
            nr: [1, 2],
            fc: 17
        }, {
            lngs: ["mnk"],
            nr: [0, 1, 2],
            fc: 18
        }, {
            lngs: ["mt"],
            nr: [1, 2, 11, 20],
            fc: 19
        }, {
            lngs: ["or"],
            nr: [2, 1],
            fc: 2
        }, {
            lngs: ["ro"],
            nr: [1, 2, 20],
            fc: 20
        }, {
            lngs: ["sl"],
            nr: [5, 1, 2, 3],
            fc: 21
        }, {
            lngs: ["he", "iw"],
            nr: [1, 2, 20, 21],
            fc: 22
        }],
        _rulesPluralsTypes = {
            1: function(_) {
                return +(_ > 1)
            },
            2: function(_) {
                return +(_ != 1)
            },
            3: function(_) {
                return 0
            },
            4: function(_) {
                return _ % 10 == 1 && _ % 100 != 11 ? 0 : _ % 10 >= 2 && _ % 10 <= 4 && (_ % 100 < 10 || _ % 100 >= 20) ? 1 : 2
            },
            5: function(_) {
                return _ == 0 ? 0 : _ == 1 ? 1 : _ == 2 ? 2 : _ % 100 >= 3 && _ % 100 <= 10 ? 3 : _ % 100 >= 11 ? 4 : 5
            },
            6: function(_) {
                return _ == 1 ? 0 : _ >= 2 && _ <= 4 ? 1 : 2
            },
            7: function(_) {
                return _ == 1 ? 0 : _ % 10 >= 2 && _ % 10 <= 4 && (_ % 100 < 10 || _ % 100 >= 20) ? 1 : 2
            },
            8: function(_) {
                return _ == 1 ? 0 : _ == 2 ? 1 : _ != 8 && _ != 11 ? 2 : 3
            },
            9: function(_) {
                return +(_ >= 2)
            },
            10: function(_) {
                return _ == 1 ? 0 : _ == 2 ? 1 : _ < 7 ? 2 : _ < 11 ? 3 : 4
            },
            11: function(_) {
                return _ == 1 || _ == 11 ? 0 : _ == 2 || _ == 12 ? 1 : _ > 2 && _ < 20 ? 2 : 3
            },
            12: function(_) {
                return +(_ % 10 != 1 || _ % 100 == 11)
            },
            13: function(_) {
                return +(_ !== 0)
            },
            14: function(_) {
                return _ == 1 ? 0 : _ == 2 ? 1 : _ == 3 ? 2 : 3
            },
            15: function(_) {
                return _ % 10 == 1 && _ % 100 != 11 ? 0 : _ % 10 >= 2 && (_ % 100 < 10 || _ % 100 >= 20) ? 1 : 2
            },
            16: function(_) {
                return _ % 10 == 1 && _ % 100 != 11 ? 0 : _ !== 0 ? 1 : 2
            },
            17: function(_) {
                return _ == 1 || _ % 10 == 1 && _ % 100 != 11 ? 0 : 1
            },
            18: function(_) {
                return _ == 0 ? 0 : _ == 1 ? 1 : 2
            },
            19: function(_) {
                return _ == 1 ? 0 : _ == 0 || _ % 100 > 1 && _ % 100 < 11 ? 1 : _ % 100 > 10 && _ % 100 < 20 ? 2 : 3
            },
            20: function(_) {
                return _ == 1 ? 0 : _ == 0 || _ % 100 > 0 && _ % 100 < 20 ? 1 : 2
            },
            21: function(_) {
                return _ % 100 == 1 ? 1 : _ % 100 == 2 ? 2 : _ % 100 == 3 || _ % 100 == 4 ? 3 : 0
            },
            22: function(_) {
                return _ == 1 ? 0 : _ == 2 ? 1 : (_ < 0 || _ > 10) && _ % 10 == 0 ? 2 : 3
            }
        };
    const nonIntlVersions = ["v1", "v2", "v3"],
        intlVersions = ["v4"],
        suffixesOrder = {
            zero: 0,
            one: 1,
            two: 2,
            few: 3,
            many: 4,
            other: 5
        };

    function createRules() {
        const _ = {};
        return sets.forEach(_e => {
            _e.lngs.forEach(et => {
                _[et] = {
                    numbers: _e.nr,
                    plurals: _rulesPluralsTypes[_e.fc]
                }
            })
        }), _
    }
    class PluralResolver {
        constructor(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.languageUtils = _e, this.options = et, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules()
        }
        addRule(_e, et) {
            this.rules[_e] = et
        }
        getRule(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (this.shouldUseIntlApi()) try {
                return new Intl.PluralRules(getCleanedCode(_e), {
                    type: et.ordinal ? "ordinal" : "cardinal"
                })
            } catch (tt) {
                return
            }
            return this.rules[_e] || this.rules[this.languageUtils.getLanguagePartFromCode(_e)]
        }
        needsPlural(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const tt = this.getRule(_e, et);
            return this.shouldUseIntlApi() ? tt && tt.resolvedOptions().pluralCategories.length > 1 : tt && tt.numbers.length > 1
        }
        getPluralFormsOfKey(_e, et) {
            let tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this.getSuffixes(_e, tt).map(nt => `${et}${nt}`)
        }
        getSuffixes(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const tt = this.getRule(_e, et);
            return tt ? this.shouldUseIntlApi() ? tt.resolvedOptions().pluralCategories.sort((nt, ot) => suffixesOrder[nt] - suffixesOrder[ot]).map(nt => `${this.options.prepend}${et.ordinal?`ordinal${this.options.prepend}`:""}${nt}`) : tt.numbers.map(nt => this.getSuffix(_e, nt, et)) : []
        }
        getSuffix(_e, et) {
            let tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            const nt = this.getRule(_e, tt);
            return nt ? this.shouldUseIntlApi() ? `${this.options.prepend}${tt.ordinal?`ordinal${this.options.prepend}`:""}${nt.select(et)}` : this.getSuffixRetroCompatible(nt, et) : (this.logger.warn(`no plural rule found for: ${_e}`), "")
        }
        getSuffixRetroCompatible(_e, et) {
            const tt = _e.noAbs ? _e.plurals(et) : _e.plurals(Math.abs(et));
            let nt = _e.numbers[tt];
            this.options.simplifyPluralSuffix && _e.numbers.length === 2 && _e.numbers[0] === 1 && (nt === 2 ? nt = "plural" : nt === 1 && (nt = ""));
            const ot = () => this.options.prepend && nt.toString() ? this.options.prepend + nt.toString() : nt.toString();
            return this.options.compatibilityJSON === "v1" ? nt === 1 ? "" : typeof nt == "number" ? `_plural_${nt.toString()}` : ot() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && _e.numbers.length === 2 && _e.numbers[0] === 1 ? ot() : this.options.prepend && tt.toString() ? this.options.prepend + tt.toString() : tt.toString()
        }
        shouldUseIntlApi() {
            return !nonIntlVersions.includes(this.options.compatibilityJSON)
        }
    }

    function deepFindWithDefaults(_, _e, et) {
        let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".",
            nt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0,
            ot = getPathWithDefaults(_, _e, et);
        return !ot && nt && typeof et == "string" && (ot = deepFind(_, et, tt), ot === void 0 && (ot = deepFind(_e, et, tt))), ot
    }
    class Interpolator {
        constructor() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.logger = baseLogger.create("interpolator"), this.options = _e, this.format = _e.interpolation && _e.interpolation.format || (et => et), this.init(_e)
        }
        init() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            _e.interpolation || (_e.interpolation = {
                escapeValue: !0
            });
            const et = _e.interpolation;
            this.escape = et.escape !== void 0 ? et.escape : escape, this.escapeValue = et.escapeValue !== void 0 ? et.escapeValue : !0, this.useRawValueToEscape = et.useRawValueToEscape !== void 0 ? et.useRawValueToEscape : !1, this.prefix = et.prefix ? regexEscape(et.prefix) : et.prefixEscaped || "{{", this.suffix = et.suffix ? regexEscape(et.suffix) : et.suffixEscaped || "}}", this.formatSeparator = et.formatSeparator ? et.formatSeparator : et.formatSeparator || ",", this.unescapePrefix = et.unescapeSuffix ? "" : et.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : et.unescapeSuffix || "", this.nestingPrefix = et.nestingPrefix ? regexEscape(et.nestingPrefix) : et.nestingPrefixEscaped || regexEscape("$t("), this.nestingSuffix = et.nestingSuffix ? regexEscape(et.nestingSuffix) : et.nestingSuffixEscaped || regexEscape(")"), this.nestingOptionsSeparator = et.nestingOptionsSeparator ? et.nestingOptionsSeparator : et.nestingOptionsSeparator || ",", this.maxReplaces = et.maxReplaces ? et.maxReplaces : 1e3, this.alwaysFormat = et.alwaysFormat !== void 0 ? et.alwaysFormat : !1, this.resetRegExp()
        }
        reset() {
            this.options && this.init(this.options)
        }
        resetRegExp() {
            const _e = `${this.prefix}(.+?)${this.suffix}`;
            this.regexp = new RegExp(_e, "g");
            const et = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
            this.regexpUnescape = new RegExp(et, "g");
            const tt = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
            this.nestingRegexp = new RegExp(tt, "g")
        }
        interpolate(_e, et, tt, nt) {
            let ot, at, st;
            const lt = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

            function ut(ft) {
                return ft.replace(/\$/g, "$$$$")
            }
            const dt = ft => {
                if (ft.indexOf(this.formatSeparator) < 0) {
                    const gt = deepFindWithDefaults(et, lt, ft, this.options.keySeparator, this.options.ignoreJSONStructure);
                    return this.alwaysFormat ? this.format(gt, void 0, tt, Bt(kt(kt({}, nt), et), {
                        interpolationkey: ft
                    })) : gt
                }
                const ht = ft.split(this.formatSeparator),
                    mt = ht.shift().trim(),
                    bt = ht.join(this.formatSeparator).trim();
                return this.format(deepFindWithDefaults(et, lt, mt, this.options.keySeparator, this.options.ignoreJSONStructure), bt, tt, Bt(kt(kt({}, nt), et), {
                    interpolationkey: mt
                }))
            };
            this.resetRegExp();
            const ct = nt && nt.missingInterpolationHandler || this.options.missingInterpolationHandler,
                pt = nt && nt.interpolation && nt.interpolation.skipOnVariables !== void 0 ? nt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
            return [{
                regex: this.regexpUnescape,
                safeValue: ft => ut(ft)
            }, {
                regex: this.regexp,
                safeValue: ft => this.escapeValue ? ut(this.escape(ft)) : ut(ft)
            }].forEach(ft => {
                for (st = 0; ot = ft.regex.exec(_e);) {
                    const ht = ot[1].trim();
                    if (at = dt(ht), at === void 0)
                        if (typeof ct == "function") {
                            const bt = ct(_e, ot, nt);
                            at = typeof bt == "string" ? bt : ""
                        } else if (nt && Object.prototype.hasOwnProperty.call(nt, ht)) at = "";
                    else if (pt) {
                        at = ot[0];
                        continue
                    } else this.logger.warn(`missed to pass in variable ${ht} for interpolating ${_e}`), at = "";
                    else typeof at != "string" && !this.useRawValueToEscape && (at = makeString(at));
                    const mt = ft.safeValue(at);
                    if (_e = _e.replace(ot[0], mt), pt ? (ft.regex.lastIndex += at.length, ft.regex.lastIndex -= ot[0].length) : ft.regex.lastIndex = 0, st++, st >= this.maxReplaces) break
                }
            }), _e
        }
        nest(_e, et) {
            let tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                nt, ot, at;

            function st(lt, ut) {
                const dt = this.nestingOptionsSeparator;
                if (lt.indexOf(dt) < 0) return lt;
                const ct = lt.split(new RegExp(`${dt}[ ]*{`));
                let pt = `{${ct[1]}`;
                lt = ct[0], pt = this.interpolate(pt, at);
                const ft = pt.match(/'/g),
                    ht = pt.match(/"/g);
                (ft && ft.length % 2 === 0 && !ht || ht.length % 2 !== 0) && (pt = pt.replace(/'/g, '"'));
                try {
                    at = JSON.parse(pt), ut && (at = kt(kt({}, ut), at))
                } catch (mt) {
                    return this.logger.warn(`failed parsing options string in nesting for key ${lt}`, mt), `${lt}${dt}${pt}`
                }
                return delete at.defaultValue, lt
            }
            for (; nt = this.nestingRegexp.exec(_e);) {
                let lt = [];
                at = kt({}, tt), at = at.replace && typeof at.replace != "string" ? at.replace : at, at.applyPostProcessor = !1, delete at.defaultValue;
                let ut = !1;
                if (nt[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(nt[1])) {
                    const dt = nt[1].split(this.formatSeparator).map(ct => ct.trim());
                    nt[1] = dt.shift(), lt = dt, ut = !0
                }
                if (ot = et(st.call(this, nt[1].trim(), at), at), ot && nt[0] === _e && typeof ot != "string") return ot;
                typeof ot != "string" && (ot = makeString(ot)), ot || (this.logger.warn(`missed to resolve ${nt[1]} for nesting ${_e}`), ot = ""), ut && (ot = lt.reduce((dt, ct) => this.format(dt, ct, tt.lng, Bt(kt({}, tt), {
                    interpolationkey: nt[1].trim()
                })), ot.trim())), _e = _e.replace(nt[0], ot), this.regexp.lastIndex = 0
            }
            return _e
        }
    }

    function parseFormatStr(_) {
        let _e = _.toLowerCase().trim();
        const et = {};
        if (_.indexOf("(") > -1) {
            const tt = _.split("(");
            _e = tt[0].toLowerCase().trim();
            const nt = tt[1].substring(0, tt[1].length - 1);
            _e === "currency" && nt.indexOf(":") < 0 ? et.currency || (et.currency = nt.trim()) : _e === "relativetime" && nt.indexOf(":") < 0 ? et.range || (et.range = nt.trim()) : nt.split(";").forEach(ot => {
                if (!ot) return;
                const [at, ...st] = ot.split(":"), lt = st.join(":").trim().replace(/^'+|'+$/g, "");
                et[at.trim()] || (et[at.trim()] = lt), lt === "false" && (et[at.trim()] = !1), lt === "true" && (et[at.trim()] = !0), isNaN(lt) || (et[at.trim()] = parseInt(lt, 10))
            })
        }
        return {
            formatName: _e,
            formatOptions: et
        }
    }

    function createCachedFormatter(_) {
        const _e = {};
        return function(et, tt, nt) {
            const ot = tt + JSON.stringify(nt);
            let at = _e[ot];
            return at || (at = _(getCleanedCode(tt), nt), _e[ot] = at), at(et)
        }
    }
    class Formatter {
        constructor() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.logger = baseLogger.create("formatter"), this.options = _e, this.formats = {
                number: createCachedFormatter((et, tt) => {
                    const nt = new Intl.NumberFormat(et, kt({}, tt));
                    return ot => nt.format(ot)
                }),
                currency: createCachedFormatter((et, tt) => {
                    const nt = new Intl.NumberFormat(et, Bt(kt({}, tt), {
                        style: "currency"
                    }));
                    return ot => nt.format(ot)
                }),
                datetime: createCachedFormatter((et, tt) => {
                    const nt = new Intl.DateTimeFormat(et, kt({}, tt));
                    return ot => nt.format(ot)
                }),
                relativetime: createCachedFormatter((et, tt) => {
                    const nt = new Intl.RelativeTimeFormat(et, kt({}, tt));
                    return ot => nt.format(ot, tt.range || "day")
                }),
                list: createCachedFormatter((et, tt) => {
                    const nt = new Intl.ListFormat(et, kt({}, tt));
                    return ot => nt.format(ot)
                })
            }, this.init(_e)
        }
        init(_e) {
            const et = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                interpolation: {}
            }).interpolation;
            this.formatSeparator = et.formatSeparator ? et.formatSeparator : et.formatSeparator || ","
        }
        add(_e, et) {
            this.formats[_e.toLowerCase().trim()] = et
        }
        addCached(_e, et) {
            this.formats[_e.toLowerCase().trim()] = createCachedFormatter(et)
        }
        format(_e, et, tt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return et.split(this.formatSeparator).reduce((ot, at) => {
                const {
                    formatName: st,
                    formatOptions: lt
                } = parseFormatStr(at);
                if (this.formats[st]) {
                    let ut = ot;
                    try {
                        const dt = nt && nt.formatParams && nt.formatParams[nt.interpolationkey] || {},
                            ct = dt.locale || dt.lng || nt.locale || nt.lng || tt;
                        ut = this.formats[st](ot, ct, kt(kt(kt({}, lt), nt), dt))
                    } catch (dt) {
                        this.logger.warn(dt)
                    }
                    return ut
                } else this.logger.warn(`there was no format function for ${st}`);
                return ot
            }, _e)
        }
    }

    function removePending(_, _e) {
        _.pending[_e] !== void 0 && (delete _.pending[_e], _.pendingCount--)
    }
    class Connector extends EventEmitter {
        constructor(_e, et, tt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            super(), this.backend = _e, this.store = et, this.services = tt, this.languageUtils = tt.languageUtils, this.options = nt, this.logger = baseLogger.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = nt.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = nt.maxRetries >= 0 ? nt.maxRetries : 5, this.retryTimeout = nt.retryTimeout >= 1 ? nt.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(tt, nt.backend, nt)
        }
        queueLoad(_e, et, tt, nt) {
            const ot = {},
                at = {},
                st = {},
                lt = {};
            return _e.forEach(ut => {
                let dt = !0;
                et.forEach(ct => {
                    const pt = `${ut}|${ct}`;
                    !tt.reload && this.store.hasResourceBundle(ut, ct) ? this.state[pt] = 2 : this.state[pt] < 0 || (this.state[pt] === 1 ? at[pt] === void 0 && (at[pt] = !0) : (this.state[pt] = 1, dt = !1, at[pt] === void 0 && (at[pt] = !0), ot[pt] === void 0 && (ot[pt] = !0), lt[ct] === void 0 && (lt[ct] = !0)))
                }), dt || (st[ut] = !0)
            }), (Object.keys(ot).length || Object.keys(at).length) && this.queue.push({
                pending: at,
                pendingCount: Object.keys(at).length,
                loaded: {},
                errors: [],
                callback: nt
            }), {
                toLoad: Object.keys(ot),
                pending: Object.keys(at),
                toLoadLanguages: Object.keys(st),
                toLoadNamespaces: Object.keys(lt)
            }
        }
        loaded(_e, et, tt) {
            const nt = _e.split("|"),
                ot = nt[0],
                at = nt[1];
            et && this.emit("failedLoading", ot, at, et), tt && this.store.addResourceBundle(ot, at, tt), this.state[_e] = et ? -1 : 2;
            const st = {};
            this.queue.forEach(lt => {
                pushPath(lt.loaded, [ot], at), removePending(lt, _e), et && lt.errors.push(et), lt.pendingCount === 0 && !lt.done && (Object.keys(lt.loaded).forEach(ut => {
                    st[ut] || (st[ut] = {});
                    const dt = lt.loaded[ut];
                    dt.length && dt.forEach(ct => {
                        st[ut][ct] === void 0 && (st[ut][ct] = !0)
                    })
                }), lt.done = !0, lt.errors.length ? lt.callback(lt.errors) : lt.callback())
            }), this.emit("loaded", st), this.queue = this.queue.filter(lt => !lt.done)
        }
        read(_e, et, tt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
                ot = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout,
                at = arguments.length > 5 ? arguments[5] : void 0;
            if (!_e.length) return at(null, {});
            if (this.readingCalls >= this.maxParallelReads) {
                this.waitingReads.push({
                    lng: _e,
                    ns: et,
                    fcName: tt,
                    tried: nt,
                    wait: ot,
                    callback: at
                });
                return
            }
            this.readingCalls++;
            const st = (ut, dt) => {
                    if (this.readingCalls--, this.waitingReads.length > 0) {
                        const ct = this.waitingReads.shift();
                        this.read(ct.lng, ct.ns, ct.fcName, ct.tried, ct.wait, ct.callback)
                    }
                    if (ut && dt && nt < this.maxRetries) {
                        setTimeout(() => {
                            this.read.call(this, _e, et, tt, nt + 1, ot * 2, at)
                        }, ot);
                        return
                    }
                    at(ut, dt)
                },
                lt = this.backend[tt].bind(this.backend);
            if (lt.length === 2) {
                try {
                    const ut = lt(_e, et);
                    ut && typeof ut.then == "function" ? ut.then(dt => st(null, dt)).catch(st) : st(null, ut)
                } catch (ut) {
                    st(ut)
                }
                return
            }
            return lt(_e, et, st)
        }
        prepareLoading(_e, et) {
            let tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                nt = arguments.length > 3 ? arguments[3] : void 0;
            if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), nt && nt();
            typeof _e == "string" && (_e = this.languageUtils.toResolveHierarchy(_e)), typeof et == "string" && (et = [et]);
            const ot = this.queueLoad(_e, et, tt, nt);
            if (!ot.toLoad.length) return ot.pending.length || nt(), null;
            ot.toLoad.forEach(at => {
                this.loadOne(at)
            })
        }
        load(_e, et, tt) {
            this.prepareLoading(_e, et, {}, tt)
        }
        reload(_e, et, tt) {
            this.prepareLoading(_e, et, {
                reload: !0
            }, tt)
        }
        loadOne(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            const tt = _e.split("|"),
                nt = tt[0],
                ot = tt[1];
            this.read(nt, ot, "read", void 0, void 0, (at, st) => {
                at && this.logger.warn(`${et}loading namespace ${ot} for language ${nt} failed`, at), !at && st && this.logger.log(`${et}loaded namespace ${ot} for language ${nt}`, st), this.loaded(_e, at, st)
            })
        }
        saveMissing(_e, et, tt, nt, ot) {
            let at = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {},
                st = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {};
            if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(et)) {
                this.logger.warn(`did not save key "${tt}" as the namespace "${et}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
                return
            }
            if (!(tt == null || tt === "")) {
                if (this.backend && this.backend.create) {
                    const lt = Bt(kt({}, at), {
                            isUpdate: ot
                        }),
                        ut = this.backend.create.bind(this.backend);
                    if (ut.length < 6) try {
                        let dt;
                        ut.length === 5 ? dt = ut(_e, et, tt, nt, lt) : dt = ut(_e, et, tt, nt), dt && typeof dt.then == "function" ? dt.then(ct => st(null, ct)).catch(st) : st(null, dt)
                    } catch (dt) {
                        st(dt)
                    } else ut(_e, et, tt, nt, st, lt)
                }!_e || !_e[0] || this.store.addResource(_e[0], et, tt, nt)
            }
        }
    }

    function get() {
        return {
            debug: !1,
            initImmediate: !0,
            ns: ["translation"],
            defaultNS: ["translation"],
            fallbackLng: ["dev"],
            fallbackNS: !1,
            supportedLngs: !1,
            nonExplicitSupportedLngs: !1,
            load: "all",
            preload: !1,
            simplifyPluralSuffix: !0,
            keySeparator: ".",
            nsSeparator: ":",
            pluralSeparator: "_",
            contextSeparator: "_",
            partialBundledLanguages: !1,
            saveMissing: !1,
            updateMissing: !1,
            saveMissingTo: "fallback",
            saveMissingPlurals: !0,
            missingKeyHandler: !1,
            missingInterpolationHandler: !1,
            postProcess: !1,
            postProcessPassResolved: !1,
            returnNull: !1,
            returnEmptyString: !0,
            returnObjects: !1,
            joinArrays: !1,
            returnedObjectHandler: !1,
            parseMissingKeyHandler: !1,
            appendNamespaceToMissingKey: !1,
            appendNamespaceToCIMode: !1,
            overloadTranslationOptionHandler: function(_) {
                let _e = {};
                if (typeof _[1] == "object" && (_e = _[1]), typeof _[1] == "string" && (_e.defaultValue = _[1]), typeof _[2] == "string" && (_e.tDescription = _[2]), typeof _[2] == "object" || typeof _[3] == "object") {
                    const et = _[3] || _[2];
                    Object.keys(et).forEach(tt => {
                        _e[tt] = et[tt]
                    })
                }
                return _e
            },
            interpolation: {
                escapeValue: !0,
                format: (_, _e, et, tt) => _,
                prefix: "{{",
                suffix: "}}",
                formatSeparator: ",",
                unescapePrefix: "-",
                nestingPrefix: "$t(",
                nestingSuffix: ")",
                nestingOptionsSeparator: ",",
                maxReplaces: 1e3,
                skipOnVariables: !0
            }
        }
    }

    function transformOptions(_) {
        return typeof _.ns == "string" && (_.ns = [_.ns]), typeof _.fallbackLng == "string" && (_.fallbackLng = [_.fallbackLng]), typeof _.fallbackNS == "string" && (_.fallbackNS = [_.fallbackNS]), _.supportedLngs && _.supportedLngs.indexOf("cimode") < 0 && (_.supportedLngs = _.supportedLngs.concat(["cimode"])), _
    }

    function noop() {}

    function bindMemberFunctions(_) {
        Object.getOwnPropertyNames(Object.getPrototypeOf(_)).forEach(_e => {
            typeof _[_e] == "function" && (_[_e] = _[_e].bind(_))
        })
    }
    let I18n$1 = class Xr extends EventEmitter {
        constructor() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                et = arguments.length > 1 ? arguments[1] : void 0;
            if (super(), this.options = transformOptions(_e), this.services = {}, this.logger = baseLogger, this.modules = {
                    external: []
                }, bindMemberFunctions(this), et && !this.isInitialized && !_e.isClone) {
                if (!this.options.initImmediate) return this.init(_e, et), this;
                setTimeout(() => {
                    this.init(_e, et)
                }, 0)
            }
        }
        init() {
            var _e = this;
            let et = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                tt = arguments.length > 1 ? arguments[1] : void 0;
            typeof et == "function" && (tt = et, et = {}), !et.defaultNS && et.defaultNS !== !1 && et.ns && (typeof et.ns == "string" ? et.defaultNS = et.ns : et.ns.indexOf("translation") < 0 && (et.defaultNS = et.ns[0]));
            const nt = get();
            this.options = kt(kt(kt({}, nt), this.options), transformOptions(et)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = kt(kt({}, nt.interpolation), this.options.interpolation)), et.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = et.keySeparator), et.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = et.nsSeparator);

            function ot(lt) {
                return lt ? typeof lt == "function" ? new lt : lt : null
            }
            if (!this.options.isClone) {
                this.modules.logger ? baseLogger.init(ot(this.modules.logger), this.options) : baseLogger.init(null, this.options);
                let lt;
                this.modules.formatter ? lt = this.modules.formatter : typeof Intl < "u" && (lt = Formatter);
                const ut = new LanguageUtil(this.options);
                this.store = new ResourceStore(this.options.resources, this.options);
                const dt = this.services;
                dt.logger = baseLogger, dt.resourceStore = this.store, dt.languageUtils = ut, dt.pluralResolver = new PluralResolver(ut, {
                    prepend: this.options.pluralSeparator,
                    compatibilityJSON: this.options.compatibilityJSON,
                    simplifyPluralSuffix: this.options.simplifyPluralSuffix
                }), lt && (!this.options.interpolation.format || this.options.interpolation.format === nt.interpolation.format) && (dt.formatter = ot(lt), dt.formatter.init(dt, this.options), this.options.interpolation.format = dt.formatter.format.bind(dt.formatter)), dt.interpolator = new Interpolator(this.options), dt.utils = {
                    hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                }, dt.backendConnector = new Connector(ot(this.modules.backend), dt.resourceStore, dt, this.options), dt.backendConnector.on("*", function(ct) {
                    for (var pt = arguments.length, ft = new Array(pt > 1 ? pt - 1 : 0), ht = 1; ht < pt; ht++) ft[ht - 1] = arguments[ht];
                    _e.emit(ct, ...ft)
                }), this.modules.languageDetector && (dt.languageDetector = ot(this.modules.languageDetector), dt.languageDetector.init && dt.languageDetector.init(dt, this.options.detection, this.options)), this.modules.i18nFormat && (dt.i18nFormat = ot(this.modules.i18nFormat), dt.i18nFormat.init && dt.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function(ct) {
                    for (var pt = arguments.length, ft = new Array(pt > 1 ? pt - 1 : 0), ht = 1; ht < pt; ht++) ft[ht - 1] = arguments[ht];
                    _e.emit(ct, ...ft)
                }), this.modules.external.forEach(ct => {
                    ct.init && ct.init(this)
                })
            }
            if (this.format = this.options.interpolation.format, tt || (tt = noop), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                const lt = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                lt.length > 0 && lt[0] !== "dev" && (this.options.lng = lt[0])
            }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(lt => {
                this[lt] = function() {
                    return _e.store[lt](...arguments)
                }
            }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(lt => {
                this[lt] = function() {
                    return _e.store[lt](...arguments), _e
                }
            });
            const at = defer(),
                st = () => {
                    const lt = (ut, dt) => {
                        this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), at.resolve(dt), tt(ut, dt)
                    };
                    if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return lt(null, this.t.bind(this));
                    this.changeLanguage(this.options.lng, lt)
                };
            return this.options.resources || !this.options.initImmediate ? st() : setTimeout(st, 0), at
        }
        loadResources(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
            const tt = typeof _e == "string" ? _e : this.language;
            if (typeof _e == "function" && (et = _e), !this.options.resources || this.options.partialBundledLanguages) {
                if (tt && tt.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return et();
                const nt = [],
                    ot = at => {
                        !at || at === "cimode" || this.services.languageUtils.toResolveHierarchy(at).forEach(st => {
                            st !== "cimode" && nt.indexOf(st) < 0 && nt.push(st)
                        })
                    };
                tt ? ot(tt) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(at => ot(at)), this.options.preload && this.options.preload.forEach(at => ot(at)), this.services.backendConnector.load(nt, this.options.ns, at => {
                    !at && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), et(at)
                })
            } else et(null)
        }
        reloadResources(_e, et, tt) {
            const nt = defer();
            return _e || (_e = this.languages), et || (et = this.options.ns), tt || (tt = noop), this.services.backendConnector.reload(_e, et, ot => {
                nt.resolve(), tt(ot)
            }), nt
        }
        use(_e) {
            if (!_e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
            if (!_e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
            return _e.type === "backend" && (this.modules.backend = _e), (_e.type === "logger" || _e.log && _e.warn && _e.error) && (this.modules.logger = _e), _e.type === "languageDetector" && (this.modules.languageDetector = _e), _e.type === "i18nFormat" && (this.modules.i18nFormat = _e), _e.type === "postProcessor" && postProcessor.addPostProcessor(_e), _e.type === "formatter" && (this.modules.formatter = _e), _e.type === "3rdParty" && this.modules.external.push(_e), this
        }
        setResolvedLanguage(_e) {
            if (!(!_e || !this.languages) && !(["cimode", "dev"].indexOf(_e) > -1))
                for (let et = 0; et < this.languages.length; et++) {
                    const tt = this.languages[et];
                    if (!(["cimode", "dev"].indexOf(tt) > -1) && this.store.hasLanguageSomeTranslations(tt)) {
                        this.resolvedLanguage = tt;
                        break
                    }
                }
        }
        changeLanguage(_e, et) {
            var tt = this;
            this.isLanguageChangingTo = _e;
            const nt = defer();
            this.emit("languageChanging", _e);
            const ot = lt => {
                    this.language = lt, this.languages = this.services.languageUtils.toResolveHierarchy(lt), this.resolvedLanguage = void 0, this.setResolvedLanguage(lt)
                },
                at = (lt, ut) => {
                    ut ? (ot(ut), this.translator.changeLanguage(ut), this.isLanguageChangingTo = void 0, this.emit("languageChanged", ut), this.logger.log("languageChanged", ut)) : this.isLanguageChangingTo = void 0, nt.resolve(function() {
                        return tt.t(...arguments)
                    }), et && et(lt, function() {
                        return tt.t(...arguments)
                    })
                },
                st = lt => {
                    !_e && !lt && this.services.languageDetector && (lt = []);
                    const ut = typeof lt == "string" ? lt : this.services.languageUtils.getBestMatchFromCodes(lt);
                    ut && (this.language || ot(ut), this.translator.language || this.translator.changeLanguage(ut), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(ut)), this.loadResources(ut, dt => {
                        at(dt, ut)
                    })
                };
            return !_e && this.services.languageDetector && !this.services.languageDetector.async ? st(this.services.languageDetector.detect()) : !_e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(st) : this.services.languageDetector.detect(st) : st(_e), nt
        }
        getFixedT(_e, et, tt) {
            var nt = this;
            const ot = function(at, st) {
                let lt;
                if (typeof st != "object") {
                    for (var ut = arguments.length, dt = new Array(ut > 2 ? ut - 2 : 0), ct = 2; ct < ut; ct++) dt[ct - 2] = arguments[ct];
                    lt = nt.options.overloadTranslationOptionHandler([at, st].concat(dt))
                } else lt = kt({}, st);
                lt.lng = lt.lng || ot.lng, lt.lngs = lt.lngs || ot.lngs, lt.ns = lt.ns || ot.ns, lt.keyPrefix = lt.keyPrefix || tt || ot.keyPrefix;
                const pt = nt.options.keySeparator || ".";
                let ft;
                return lt.keyPrefix && Array.isArray(at) ? ft = at.map(ht => `${lt.keyPrefix}${pt}${ht}`) : ft = lt.keyPrefix ? `${lt.keyPrefix}${pt}${at}` : at, nt.t(ft, lt)
            };
            return typeof _e == "string" ? ot.lng = _e : ot.lngs = _e, ot.ns = et, ot.keyPrefix = tt, ot
        }
        t() {
            return this.translator && this.translator.translate(...arguments)
        }
        exists() {
            return this.translator && this.translator.exists(...arguments)
        }
        setDefaultNamespace(_e) {
            this.options.defaultNS = _e
        }
        hasLoadedNamespace(_e) {
            let et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
            if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
            const tt = et.lng || this.resolvedLanguage || this.languages[0],
                nt = this.options ? this.options.fallbackLng : !1,
                ot = this.languages[this.languages.length - 1];
            if (tt.toLowerCase() === "cimode") return !0;
            const at = (st, lt) => {
                const ut = this.services.backendConnector.state[`${st}|${lt}`];
                return ut === -1 || ut === 2
            };
            if (et.precheck) {
                const st = et.precheck(this, at);
                if (st !== void 0) return st
            }
            return !!(this.hasResourceBundle(tt, _e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || at(tt, _e) && (!nt || at(ot, _e)))
        }
        loadNamespaces(_e, et) {
            const tt = defer();
            return this.options.ns ? (typeof _e == "string" && (_e = [_e]), _e.forEach(nt => {
                this.options.ns.indexOf(nt) < 0 && this.options.ns.push(nt)
            }), this.loadResources(nt => {
                tt.resolve(), et && et(nt)
            }), tt) : (et && et(), Promise.resolve())
        }
        loadLanguages(_e, et) {
            const tt = defer();
            typeof _e == "string" && (_e = [_e]);
            const nt = this.options.preload || [],
                ot = _e.filter(at => nt.indexOf(at) < 0);
            return ot.length ? (this.options.preload = nt.concat(ot), this.loadResources(at => {
                tt.resolve(), et && et(at)
            }), tt) : (et && et(), Promise.resolve())
        }
        dir(_e) {
            if (_e || (_e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !_e) return "rtl";
            const et = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
                tt = this.services && this.services.languageUtils || new LanguageUtil(get());
            return et.indexOf(tt.getLanguagePartFromCode(_e)) > -1 || _e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
        }
        static createInstance() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                et = arguments.length > 1 ? arguments[1] : void 0;
            return new Xr(_e, et)
        }
        cloneInstance() {
            let _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
            const tt = _e.forkResourceStore;
            tt && delete _e.forkResourceStore;
            const nt = Bt(kt(kt({}, this.options), _e), {
                    isClone: !0
                }),
                ot = new Xr(nt);
            return (_e.debug !== void 0 || _e.prefix !== void 0) && (ot.logger = ot.logger.clone(_e)), ["store", "services", "language"].forEach(at => {
                ot[at] = this[at]
            }), ot.services = kt({}, this.services), ot.services.utils = {
                hasLoadedNamespace: ot.hasLoadedNamespace.bind(ot)
            }, tt && (ot.store = new ResourceStore(this.store.data, nt), ot.services.resourceStore = ot.store), ot.translator = new Translator(ot.services, nt), ot.translator.on("*", function(at) {
                for (var st = arguments.length, lt = new Array(st > 1 ? st - 1 : 0), ut = 1; ut < st; ut++) lt[ut - 1] = arguments[ut];
                ot.emit(at, ...lt)
            }), ot.init(nt, et), ot.translator.options = nt, ot.translator.backendConnector.services.utils = {
                hasLoadedNamespace: ot.hasLoadedNamespace.bind(ot)
            }, ot
        }
        toJSON() {
            return {
                options: this.options,
                store: this.store,
                language: this.language,
                languages: this.languages,
                resolvedLanguage: this.resolvedLanguage
            }
        }
    };
    const instance = I18n$1.createInstance();
    instance.createInstance = I18n$1.createInstance, instance.createInstance, instance.dir, instance.init, instance.loadResources, instance.reloadResources, instance.use, instance.changeLanguage, instance.getFixedT, instance.t, instance.exists, instance.setDefaultNamespace, instance.hasLoadedNamespace, instance.loadNamespaces, instance.loadLanguages;
    class App extends EventEmitter$3 {
        constructor() {
            super(), de(this, "rootEm", 16), de(this, "rootNodes", []), de(this, "dialogNodes", []), de(this, "hashRouter", null), de(this, "socket", null), de(this, "i18n", null), de(this, "history_navigate", () => {}), de(this, "unsafeNavigate", (..._e) => {
                this.history_navigate(..._e)
            }), de(this, "unsafeTranslate", (..._e) => this.i18n.t(..._e)), this.on("inject_dialog", _e => this.dialogNodes.push(..._e)), this.on("inject_rootNode", _e => this.rootNodes.push(_e))
        }
        assets(_e) {
            let et = `/modules/assets/${_e}`;
            return _e.startsWith("/logo/") && (env.buildHost === "55k.com" && (et = et.replace("/logo/", "/logo55k/")), env.buildHost === "87.com" && (et = et.replace("/logo/", "/logo87/"))), et
        }
        createPath(_e, et = "") {
            return et = et && et + ".", `${window.location.protocol}//${et}${env.host}${_e}`
        }
        isMobile() {
            return globalThis.innerWidth <= env.MAX_DESIGN_WIDTH
        }
        enableRem(_e, et) {
            const tt = throttle(() => {
                const nt = globalThis.innerWidth;
                let ot;
                nt <= et ? ot = nt / _e : ot = 1, this.rootEm = 16 * ot;
                const at = document.documentElement.style;
                at.fontSize = this.rootEm + "px"
            }, 500, {
                leading: !0
            });
            globalThis.addEventListener("resize", tt), tt()
        }
        relativePx(_e) {
            return this.remScale(_e) * this.rootEm
        }
        remScale(_e) {
            return _e / 16
        }
        promisify(_e) {
            return (...et) => new Promise(tt => {
                this.emit(_e, ...et, nt => tt(nt))
            })
        }
    }
    app = new App, env = {
        isSSR,
        localCurrencys: []
    }, I18nItem = class {
        constructor(_, _e, et, tt) {
            de(this, "name"), de(this, "code"), de(this, "match"), de(this, "file"), de(this, "sortCode"), this.name = _, this.code = _e, this.sortCode = et, this.file = tt, this.match = new RegExp(`${et}($|-.+)`)
        }
    }, I18nManager = class {
        constructor({
            lng: _ = "en",
            langs: _e
        }) {
            de(this, "langs"), de(this, "lng", ""), de(this, "fallback", ""), de(this, "messages", {}), de(this, "events", new EventEmitter$3), de(this, "t", (et, ...tt) => {
                const nt = (this.messages[this.lng] || this.messages[this.fallback])[et] || this.messages[this.fallback][et] || et;
                if (tt.length > 0) {
                    let ot = 0;
                    return nt.split(i18nVarReg).map(at => i18nVarReg.test(at) ? tt[ot++] || "" : at).join("")
                }
                return nt
            }), this.langs = _e, this.fallback = _, this.t = this.t.bind(this), this.setLang = this.setLang.bind(this)
        }
        matchLang(_) {
            const _e = Object.values(this.langs);
            return _e.find(et => et.match.test(_)) || _e.find(et => et.match.test(this.fallback)) || _e[0]
        }
        async setLang(_) {
            return this.messages[this.fallback] || await this.setLangPrivate(this.fallback), await this.setLangPrivate(_)
        }
        async setLangPrivate(_) {
            const _e = this.matchLang(_);
            let et;
            typeof _e.file == "function" ? et = (await _e.file()).default : et = _e.file, this.messages[_e.sortCode] = et, this.lng = _e.sortCode, this.events.emit("change")
        }
    };
    const i18nVarReg = /({\d+})/;

    function SyncI18n() {
        const {
            urlOriginal: _,
            lang: _e
        } = usePageContext(), et = useNavigate();
        return reactExports.useEffect(() => {
            const tt = localStorage.getItem("lang");
            if (tt) {
                if (tt !== _e) {
                    const nt = app.i18n.matchLang(tt);
                    localStorage.setItem("lang", nt.sortCode), nt && et(_, {
                        lang: nt.sortCode
                    })
                }
            } else if (navigator.language) {
                let nt = _e !== "en" ? _e : navigator.language;
                nt = nt.replace("fil", "tl");
                const ot = app.i18n.matchLang(nt);
                localStorage.setItem("lang", ot.sortCode), et(_, {
                    lang: ot.sortCode
                })
            } else localStorage.setItem("navigatornolang", "lang")
        }, [_e]), useIsomorphicEffect(() => {
            instance.changeLanguage(_e)
        }, [_e]), null
    }
    useI18n = function() {
        return useI18nChange().t
    };

    function useI18nChange() {
        const _ = useForceUpdate();
        return reactExports.useEffect(() => {
            const _e = app.i18n.events;
            return _e.addListener("change", _), () => {
                _e.removeListener("change", _)
            }
        }, []), app.i18n
    }
    useChangeLang = function() {
        const {
            urlOriginal: _,
            lang: _e
        } = usePageContext(), et = useNavigate();
        return tt => {
            _e !== tt && (localStorage.setItem("lang", tt), et(_, {
                lang: tt
            }))
        }
    }, I18n = reactExports.memo(function _({
        k: _e,
        children: et
    }) {
        const tt = useI18n()(_e),
            nt = reactExports.Children.toArray(et);
        if (nt.length == 0) return reactExports.createElement(reactExports.Fragment, {
            children: tt
        }); {
            let ot = 0,
                at = tt.split(i18nVarReg).map(st => i18nVarReg.test(st) ? nt[ot++] || null : jsxRuntimeExports.jsx("span", {
                    children: st
                }));
            return reactExports.createElement(reactExports.Fragment, {}, ...at)
        }
    });

    function getHttp() {
        const _ = axios$1.create({
            baseURL: "/api"
        });
        return _.interceptors.request.use(_e => (_e.cache && (_e.params = Bt(kt({}, _e.params), {
            v: env.version
        }), _e.baseURL = "/cache", delete _e.cache), _e.headers = _e.headers || {}, _e), _e => Promise.reject(String(_e) + ":REQ!")), _.interceptors.response.use(_e => {
            let et = _e.data;
            return et.code === 0 ? et.data : Promise.reject(new HttpResponseError(et.msg, et.code, et))
        }, _e => _e && _e.response ? Promise.reject(new ErrorWithTip("Oops\uFF01We lost your network, Please have a check\uFF01", _e.response.status + _e.config.url)) : Promise.reject(new ErrorWithTip("Network error!"))), _
    }
    http = globalThis.__http || getHttp();
    class ErrorWithTip extends Error {
        constructor(_e, et) {
            super(_e), de(this, "tip"), this.tip = et
        }
    }
    HttpResponseError = class extends Error {
        constructor(_, _e, et) {
            super(_), this.code = _e, this.response = et
        }
    };
    let supportSocket;
    socket = new m({
        uris: getSocketUri()
    }), userSocket = socket.socket("/user"), supportSocket = socket.socket("/game-support");

    function getSocketUri() {
        if (isSSR) return [{
            socket: ""
        }];
        if (location.hostname === "localhost") return [{
            socket: `${location.origin}`,
            test: `${location.origin}/socketapi`
        }]; {
            const _ = location.hostname.match(/\w+\.\w+$/);
            return [{
                socket: `${location.protocol}//socketv2.${_}`
            }, {
                socket: `${location.protocol}//socket2v2.${_}`
            }]
        }
    }

    function addUserReceiptEvent(_, _e) {
        const et = socket.decodeBind(tt => {
            msgReceipt(tt) || _e(tt)
        }, "json");
        return userSocket.on(_, et), () => userSocket.off(_, et)
    }
    const msgDict = new Set;

    function msgReceipt({
        msgId: _
    }) {
        return _ ? msgDict.has(_) ? !0 : (http.post("/account/userNotification/received/", {
            msgId: _
        }), msgDict.add(_), !1) : !1
    }
    useMountedState = function() {
        const _ = reactExports.useRef(!1),
            _e = reactExports.useCallback(() => _.current, []);
        return useIsomorphicEffect(() => (_.current = !0, () => {
            _.current = !1
        }), []), _e
    }, useSetState = function(_) {
        const [_e, et] = reactExports.useState(_), tt = useMountedState(), nt = reactExports.useCallback(ot => {
            tt() && et(at => {
                const st = ot instanceof Function ? ot(at) : ot;
                return Object.keys(st).findIndex(lt => at[lt] !== st[lt]) != -1 ? Object.assign({}, at, st) : at
            })
        }, [et]);
        return [_e, nt]
    };

    function cx$1(..._) {
        return _.filter(Boolean).join(" ")
    }

    function Loading({
        className: _,
        size: _e = 0,
        stroke: et = "#3BC117"
    }) {
        const tt = _e > 0 ? {
            height: _e,
            maxHeight: _e
        } : void 0;
        return jsxRuntimeExports.jsx("div", {
            className: cx$1(ellipsisStyle, "loading", _),
            children: jsxRuntimeExports.jsxs("svg", {
                viewBox: "0 0 84 24",
                fill: et,
                style: tt,
                children: [jsxRuntimeExports.jsx("circle", {
                    cx: "18",
                    cy: "12",
                    r: "6"
                }), jsxRuntimeExports.jsx("circle", {
                    cx: "18",
                    cy: "12",
                    r: "6"
                }), jsxRuntimeExports.jsx("circle", {
                    cx: "42",
                    cy: "12",
                    r: "6"
                }), jsxRuntimeExports.jsx("circle", {
                    cx: "66",
                    cy: "12",
                    r: "6"
                })]
            })
        })
    }
    let ellipsisStyle, assetsDict;
    Loading$1 = React.memo(Loading), ellipsisStyle = "e9sva", assetsDict = {
        empty: ["common/empty.png", "common/empty_w.png"],
        notfound: ["common/notfound.png", "common/notfound_w.png"],
        offline: ["common/offline.png", "common/offline_w.png"],
        privacy: ["common/privacy.png", "common/privacy_w.png"],
        ban: ["common/ban.png", "common/ban_w.png"]
    };

    function getAssets$1(_, _e) {
        return app.assets(assetsDict[_][_e ? 0 : 1])
    }
    let style$3, initState;
    Empty = React.memo(function({
        className: _ = "",
        type: _e = "empty",
        children: et,
        hideMsg: tt = !1
    }) {
        const nt = useIsDarken();
        usePageContext();
        const ot = {
                empty: app.unsafeTranslate("common.messages.no_data"),
                notfound: app.unsafeTranslate("common.messages.not_found"),
                offline: app.unsafeTranslate("common.messages.offline"),
                privacy: app.unsafeTranslate("common.messages.privacy_enable"),
                ban: ""
            },
            at = et || !tt && ot[_e];
        return jsxRuntimeExports.jsxs("div", {
            className: `empty ${style$3} ${_}`,
            children: [jsxRuntimeExports.jsx("img", {
                src: getAssets$1(_e, nt)
            }), at && jsxRuntimeExports.jsx("div", {
                className: "msg",
                children: at
            })]
        })
    }), style$3 = "sowd61n", initState = {
        error: null,
        data: null
    }, useAsyncFn = function(_, _e = [], et = initState) {
        const tt = reactExports.useRef(0),
            [nt, ot] = useSetState(et),
            at = useMountedState(),
            st = reactExports.useCallback((...lt) => {
                const ut = ++tt.current;
                return ot(initState), _(...lt).then(dt => {
                    at() && tt.current == ut && ot({
                        data: dt
                    })
                }).catch(dt => {
                    if (at() && tt.current == ut && ot({
                            error: dt
                        }), dt instanceof Error) throw dt
                })
            }, _e);
        return {
            state: nt,
            fetch: st
        }
    }, useAsync = function(_, _e = []) {
        const {
            state: et,
            fetch: tt
        } = useAsyncFn(_, _e, initState);
        return reactExports.useEffect(() => {
            tt()
        }, [tt]), et
    }, useAsyncNode = function(_, _e = [], {
        loadingNode: et = jsxRuntimeExports.jsx(Loading$1, {}),
        errorNode: tt = jsxRuntimeExports.jsx(Empty, {})
    } = {}) {
        const {
            data: nt,
            error: ot
        } = useAsync(_, _e);
        return ot ? tt : nt || et
    }, useIsFirstRender = function() {
        const _ = reactExports.useRef(!0);
        return reactExports.useEffect(() => {
            _.current = !1
        }, []), _.current
    };

    function useIntersection(_, _e) {
        const [et, tt] = reactExports.useState(!1);
        return reactExports.useEffect(() => {
            if (_.current) {
                const nt = _.current,
                    ot = intersectionObserver(nt, tt, _e);
                return () => {
                    ot.unobserve(nt)
                }
            }
        }, [_.current]), et
    }
    useInView = function(_) {
        const _e = reactExports.useRef(null),
            et = useIntersection(_e, _);
        return {
            ref: _e,
            inView: et
        }
    }, useOnClickOutside = function(_, _e = [], et = [], tt = !1) {
        const nt = reactExports.useRef(null);
        return reactExports.useEffect(() => {
            const ot = _e.concat(nt),
                at = st => {
                    ot.find(lt => !lt.current || lt.current.contains(st.target)) || _(st)
                };
            return tt ? (document.addEventListener("mousedown", at), document.addEventListener("touchstart", at), () => {
                document.removeEventListener("mousedown", at), document.removeEventListener("touchstart", at)
            }) : (document.addEventListener("click", at, !0), () => {
                document.removeEventListener("click", at, !0)
            })
        }, et), nt
    };

    function usePrevious$1(_) {
        const _e = reactExports.useRef();
        return reactExports.useEffect(() => {
            _e.current = _
        }), _e.current
    }
    useWindowSize = function() {
        const [_, _e] = reactExports.useState({
            width: globalThis.innerWidth,
            height: globalThis.innerHeight
        }), et = reactExports.useMemo(() => throttle(() => _e({
            width: globalThis.innerWidth,
            height: globalThis.innerHeight
        }), 200), []);
        return reactExports.useEffect(() => (globalThis.addEventListener("resize", et), () => globalThis.removeEventListener("resize", et)), []), _
    }, useResize = function(_, _e = 0) {
        const et = useMountedState(),
            tt = reactExports.useRef({
                width: 0,
                height: 0,
                el: null,
                fn: _
            });
        tt.current.fn = reactExports.useMemo(() => _e > 0 ? throttle(at => et() && _(at), _e) : _, [_, _e]);
        const nt = reactExports.useCallback(({
                width: at,
                height: st
            }) => {
                const lt = tt.current;
                (st != lt.height || at != lt.width) && (Object.assign(lt, {
                    width: at,
                    height: st
                }), et() && lt.fn({
                    width: at,
                    height: st
                }))
            }, []),
            ot = reactExports.useRef(null);
        return useIsomorphicEffect(() => {
            const at = tt.current,
                st = ot.current;
            st && at.el !== st && (at.el && SRObserver.remove(at.el), at.el = st, nt({
                width: st.clientWidth,
                height: st.clientHeight
            }), SRObserver.add(st, nt))
        }), reactExports.useEffect(() => () => {
            const at = tt.current.el;
            at && SRObserver.remove(at)
        }, []), ot
    };

    function useHover(_ = !1) {
        const _e = reactExports.useRef(null),
            [et, tt] = reactExports.useState(!1);
        return useIsomorphicEffect(() => {
            if (_e.current) {
                const nt = () => tt(!0),
                    ot = () => tt(!1),
                    at = _e.current;
                if (isSupportTouch) {
                    if (!_) return at.addEventListener("touchstart", nt), at.addEventListener("touchend", ot), at.addEventListener("touchcancel", ot), () => {
                        at.removeEventListener("touchstart", nt), at.removeEventListener("touchend", ot), at.removeEventListener("touchcancel", ot)
                    }
                } else return at.addEventListener("mouseenter", nt), at.addEventListener("mouseleave", ot), () => {
                    at.removeEventListener("mouseenter", nt), at.removeEventListener("mouseleave", ot)
                }
            }
        }, []), {
            isHover: et,
            ref: _e
        }
    }

    function useAutoRemove(_ = 2e3) {
        const [_e, et] = reactExports.useState(null);
        return reactExports.useEffect(() => {
            if (_e) {
                const tt = setTimeout(() => et(null), _);
                return () => {
                    clearTimeout(tt)
                }
            }
        }, [_e, _]), [_e, et]
    }
    useAnimatedFrames = function({
        config: _,
        image: _e,
        fps: et = 60,
        options: tt = {}
    }) {
        const nt = reactExports.useRef(null),
            ot = _.frames[0].sourceSize,
            at = {
                width: ot.w,
                height: ot.h
            },
            st = reactExports.useMemo(() => _.frames.map(ut => {
                const {
                    frame: dt,
                    spriteSourceSize: ct
                } = ut;
                return {
                    width: `${dt.w}px`,
                    height: `${dt.h}px`,
                    left: `${ct.x}px`,
                    top: `${ct.y}px`,
                    backgroundPosition: `${-dt.x}px ${-dt.y}px`
                }
            }), [_]),
            lt = reactExports.useMemo(() => {
                const ut = {
                    idx: 0,
                    frames: st
                };
                return gsapWithCSS.to(ut, Object.assign(tt, {
                    idx: ut.frames.length - 1,
                    duration: ut.frames.length / et,
                    ease: Linear.easeNone,
                    onUpdate() {
                        nt.current && Object.assign(nt.current.style, ut.frames[Math.round(ut.idx)])
                    }
                }))
            }, [_, et]);
        return useIsomorphicEffect(() => (lt.progress(0), () => {
            gsapWithCSS.killTweensOf(lt)
        }), [lt]), [reactExports.useMemo(() => jsxRuntimeExports.jsx("div", {
            className: `${wrapStyle$3} animatedframes`,
            style: at,
            children: jsxRuntimeExports.jsx("div", {
                className: "frame",
                ref: nt,
                style: kt({
                    backgroundImage: `url(${_e})`
                }, st[0])
            })
        }), []), lt]
    };
    const wrapStyle$3 = "w183p1ml";

    function _toConsumableArray(_) {
        if (Array.isArray(_)) {
            for (var _e = 0, et = Array(_.length); _e < _.length; _e++) et[_e] = _[_e];
            return et
        } else return Array.from(_)
    }
    var hasPassiveEvents = !1;
    if (typeof window < "u") {
        var passiveTestOptions = {
            get passive() {
                hasPassiveEvents = !0
            }
        };
        window.addEventListener("testPassive", null, passiveTestOptions), window.removeEventListener("testPassive", null, passiveTestOptions)
    }
    var isIosDevice = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1),
        locks = [],
        documentListenerAdded = !1,
        initialClientY = -1,
        previousBodyOverflowSetting = void 0,
        previousBodyPaddingRight = void 0,
        allowTouchMove = function _(_e) {
            return locks.some(function(et) {
                return !!(et.options.allowTouchMove && et.options.allowTouchMove(_e))
            })
        },
        preventDefault = function _(_e) {
            var et = _e || window.event;
            return allowTouchMove(et.target) || et.touches.length > 1 ? !0 : (et.preventDefault && et.preventDefault(), !1)
        },
        setOverflowHidden = function _(_e) {
            if (previousBodyPaddingRight === void 0) {
                var et = !!_e && _e.reserveScrollBarGap === !0,
                    tt = window.innerWidth - document.documentElement.clientWidth;
                et && tt > 0 && (previousBodyPaddingRight = document.body.style.paddingRight, document.body.style.paddingRight = tt + "px")
            }
            previousBodyOverflowSetting === void 0 && (previousBodyOverflowSetting = document.body.style.overflow, document.body.style.overflow = "hidden")
        },
        restoreOverflowSetting = function _() {
            previousBodyPaddingRight !== void 0 && (document.body.style.paddingRight = previousBodyPaddingRight, previousBodyPaddingRight = void 0), previousBodyOverflowSetting !== void 0 && (document.body.style.overflow = previousBodyOverflowSetting, previousBodyOverflowSetting = void 0)
        },
        isTargetElementTotallyScrolled = function _(_e) {
            return _e ? _e.scrollHeight - _e.scrollTop <= _e.clientHeight : !1
        },
        handleScroll = function _(_e, et) {
            var tt = _e.targetTouches[0].clientY - initialClientY;
            return allowTouchMove(_e.target) ? !1 : et && et.scrollTop === 0 && tt > 0 || isTargetElementTotallyScrolled(et) && tt < 0 ? preventDefault(_e) : (_e.stopPropagation(), !0)
        },
        disableBodyScroll = function _(_e, et) {
            if (!_e) {
                console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
                return
            }
            if (!locks.some(function(nt) {
                    return nt.targetElement === _e
                })) {
                var tt = {
                    targetElement: _e,
                    options: et || {}
                };
                locks = [].concat(_toConsumableArray(locks), [tt]), isIosDevice ? (_e.ontouchstart = function(nt) {
                    nt.targetTouches.length === 1 && (initialClientY = nt.targetTouches[0].clientY)
                }, _e.ontouchmove = function(nt) {
                    nt.targetTouches.length === 1 && handleScroll(nt, _e)
                }, documentListenerAdded || (document.addEventListener("touchmove", preventDefault, hasPassiveEvents ? {
                    passive: !1
                } : void 0), documentListenerAdded = !0)) : setOverflowHidden(et)
            }
        },
        enableBodyScroll = function _(_e) {
            if (!_e) {
                console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
                return
            }
            locks = locks.filter(function(et) {
                return et.targetElement !== _e
            }), isIosDevice ? (_e.ontouchstart = null, _e.ontouchmove = null, documentListenerAdded && locks.length === 0 && (document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? {
                passive: !1
            } : void 0), documentListenerAdded = !1)) : locks.length || restoreOverflowSetting()
        };
    useDisableBodyScroll = function(_) {
        const _e = reactExports.useRef(!1);
        useIsomorphicEffect(() => {
            const et = _ && _.current;
            if (et && !_e.current) return _e.current = !0, disableBodyScroll(et), () => {
                _e.current = !1, enableBodyScroll(et)
            }
        })
    };

    function useDisableParentScroll(_) {
        reactExports.useEffect(() => {
            const _e = _ && _.current;
            if (_e) {
                const et = tt => {
                    (tt.deltaY > 0 && _e.scrollTop === _e.scrollHeight - _e.offsetHeight || _e.scrollTop === 0 && tt.deltaY < 0) && tt.preventDefault()
                };
                return _e.addEventListener("wheel", et), () => {
                    _e.removeEventListener("wheel", et)
                }
            }
        }, [_])
    }

    function useMergeRefs(..._) {
        return reactExports.useCallback(_e => {
            _.forEach(et => {
                typeof et == "function" ? et(_e) : et != null && (et.current = _e)
            })
        }, _)
    }
    useDelayHover = function(_) {
        const _e = reactExports.useRef(null),
            [et, tt] = reactExports.useState(!1);
        return reactExports.useEffect(() => {
            const nt = _e.current;
            if (!nt) return;
            let ot = 0;
            const at = lt => {
                    ot = window.setTimeout(() => tt(!0), _)
                },
                st = lt => {
                    clearTimeout(ot), tt(!1)
                };
            return nt.addEventListener("pointerenter", at), nt.addEventListener("pointerleave", st), () => {
                nt.removeEventListener("pointerenter", at), nt.removeEventListener("pointerleave", st)
            }
        }, [_e.current, _]), {
            ref: _e,
            isHover: et
        }
    };
    const isLocaleReg = /^\//;
    useLinkIntercept = function() {
        const _ = useNavigate();
        return reactExports.useCallback(_e => {
            let et = _e.target;
            for (; et;) {
                if (et.tagName === "A") {
                    const tt = et.getAttribute("href"),
                        nt = !et.hasAttribute("data-ignore-intercept");
                    isLocaleReg.test(tt) && nt && (_e.preventDefault(), _(tt));
                    break
                }
                et = et.parentElement === _e.currentTarget ? null : et.parentElement
            }
        }, [_])
    }, useRootClassName = isSSR ? function(_) {
        const _e = reactExports.useRef(),
            et = usePageContext();
        if (!_ || !et.rootClassName) return;
        const tt = _e.current;
        tt && tt !== _ && et.rootClassName.delete(_), et.rootClassName.add(_), _e.current = _
    } : function(_, _e = "root") {
        reactExports.useLayoutEffect(() => {
            if (_) {
                const et = document.getElementById(_e).classList;
                return et.add(_), () => {
                    et.remove(_)
                }
            }
        }, [_])
    }, useSmoothList = function(st) {
        var lt = st,
            {
                data: _,
                className: _e,
                renderItem: et,
                ref: tt,
                style: nt,
                loop: ot = 0
            } = lt,
            at = Wt(lt, ["data", "className", "renderItem", "ref", "style", "loop"]);
        const ut = useForceUpdate(),
            dt = reactExports.useRef(null),
            ct = useMergeRefs(dt, tt),
            pt = reactExports.useRef({
                index: 0,
                prevEnable: !1,
                nextEnable: !0
            }).current;
        useIsomorphicEffect(() => {
            const gt = dt.current;
            if (!gt || gt.children.length === 0) return;
            const vt = gt.children[pt.index];
            vt ? gt.scrollTo({
                left: vt.offsetLeft,
                behavior: "smooth"
            }) : ft(0)
        }, [pt.index]);
        const ft = reactExports.useCallback(gt => {
                gt != pt.index && (pt.index = gt, ut())
            }, []),
            ht = reactExports.useCallback(gt => {
                const vt = dt.current;
                if (!vt) return 0;
                const {
                    clientWidth: xt,
                    scrollWidth: yt
                } = vt, Et = [...vt.children];
                if (Et.length <= 0) return 0;
                const wt = Math.min(Math.max(gt, 0), yt - xt);
                return Math.max(Et.findIndex(St => Math.abs(St.offsetLeft - wt) < St.clientWidth), 0)
            }, []),
            mt = reactExports.useCallback((gt, vt = !1) => {
                const xt = dt.current;
                if (!xt) return;
                const {
                    scrollLeft: yt,
                    clientWidth: Et,
                    scrollWidth: wt
                } = xt;
                let St = yt + Et * gt;
                const $t = ht(St);
                vt && pt.index == $t ? gt > 0 ? ft(0) : ft(ht(wt)) : ft($t)
            }, []),
            [bt] = reactExports.useState(() => debounce(() => {
                const gt = dt.current;
                if (!gt || gt.children.length === 0) return;
                const vt = gt.children[0],
                    xt = gt.children[gt.children.length - 1],
                    {
                        scrollLeft: yt,
                        scrollWidth: Et,
                        clientWidth: wt
                    } = gt,
                    St = yt - (Et - wt) < -xt.clientWidth * .5,
                    $t = yt > vt.clientWidth * .5;
                ft(ht(gt.scrollLeft)), (St !== pt.nextEnable || $t !== pt.prevEnable) && (Object.assign(pt, {
                    nextEnable: St,
                    prevEnable: $t
                }), ut())
            }, 100));
        return reactExports.useEffect(() => {
            if (ot > 0) {
                const gt = setInterval(() => {
                    mt(1, !0)
                }, ot);
                return () => {
                    clearInterval(gt)
                }
            }
        }, [ot]), reactExports.useEffect(() => bt(), []), kt({
            scrollNode: reactExports.useMemo(() => jsxRuntimeExports.jsx("div", Bt(kt({
                ref: ct,
                className: cx$1(styleName, _e),
                style: nt
            }, at), {
                onScroll: bt,
                children: _.map((gt, vt) => et(gt, vt))
            })), [_, _e, nt]),
            slide: mt
        }, pt)
    };
    let styleName, LayoutSizeContext;
    styleName = "s138s2zu", LayoutSizeContext = reactExports.createContext(globalThis.innerWidth), LayoutSizeProvider = reactExports.memo(({
        children: _,
        root: _e,
        rootRef: et
    }) => {
        const [tt, nt] = reactExports.useState(globalThis.innerWidth);
        return useIsomorphicEffect(() => {
            const ot = et ? et.current : _e;
            if (ot) return SRObserver.add(ot, throttle(({
                width: at
            }) => nt(at), 500)), () => SRObserver.remove(ot)
        }, [_e, et]), jsxRuntimeExports.jsx(LayoutSizeContext.Provider, {
            value: tt,
            children: _
        })
    }), useLayoutSize = function() {
        return reactExports.useContext(LayoutSizeContext)
    }, SuspenseData = class {
        constructor(_) {
            de(this, "result", null), de(this, "promise"), _.then(_e => {
                this.result = _e
            }, _e => {
                this.result = _e
            }), this.promise = _
        }
        read() {
            if (this.result) {
                if (this.result instanceof Error) throw this.result;
                return this.result
            } else throw this.promise
        }
    }, SuspenseSource = class {
        constructor(_) {
            de(this, "source"), de(this, "suspensed"), this.source = _, this.suspensed = Object.entries(_).reduce((_e, [et, tt]) => (_e[et] = new SuspenseData(tt), _e), {})
        }
        async flat() {
            const _ = Object.entries(this.suspensed).map(([et, tt]) => [et, tt]),
                _e = _.map(([, et]) => et.promise);
            return await Promise.all(_e), _.reduce((et, [tt, nt]) => (et[tt] = nt.read(), et), {})
        }
        static fromStaticObject(_) {
            return new SuspenseSource(Object.entries(_).reduce((_e, [et, tt]) => (_e[et] = Promise.resolve(tt), _e), {}))
        }
    };
    let svgWrap, ActiveContext;
    Icon = React.memo(function _(nt) {
        var ot = nt,
            {
                name: _e,
                className: et
            } = ot,
            tt = Wt(ot, ["name", "className"]);
        const {
            assets: at
        } = usePageContext();
        return jsxRuntimeExports.jsx("svg", Bt(kt({
            className: cx$1(svgWrap, "icon", et)
        }, tt), {
            children: jsxRuntimeExports.jsx("use", {
                xlinkHref: `${at.icon}#icon_${_e}`
            })
        }))
    }), svgWrap = "s1ff97qc", ActiveContext = React.createContext(!0);
    class Active extends React.PureComponent {
        constructor(_e) {
            super(_e), this.state = {
                active: !0
            }
        }
        render() {
            return jsxRuntimeExports.jsx(ActiveContext.Provider, {
                value: this.state.active,
                children: this.props.children
            })
        }
    }
    const ActiveProvider = React.memo(function _({
        children: _e,
        value: et
    }) {
        const tt = useIsActive();
        return jsxRuntimeExports.jsx(ActiveContext.Provider, {
            value: tt && et,
            children: _e
        })
    });
    useIsActive = function() {
        return reactExports.useContext(ActiveContext)
    }, useActiveMemo = function(_) {
        const _e = useIsActive(),
            et = reactExports.useRef(_);
        return reactExports.useMemo(() => _e ? (et.current = _, _) : et.current, [_e, _])
    };
    class PortalManager extends EventEmitter$3 {
        constructor() {
            super(), de(this, "cache", new Map)
        }
        delNode(_e, et) {
            const tt = this.getCache(_e),
                nt = tt.indexOf(et);
            nt != -1 && (tt.splice(nt, 1), this.emit(_e, tt))
        }
        sendNode(_e, et) {
            const tt = this.getCache(_e);
            tt.push(et), this.emit(_e, tt)
        }
        getCache(_e) {
            let et = this.cache.get(_e);
            return et || (et = [], this.cache.set(_e, et)), et
        }
    }
    const PortalContext = reactExports.createContext(new PortalManager);

    function usePortalContext() {
        return reactExports.useContext(PortalContext)
    }

    function usePortalList(_) {
        const _e = usePortalContext(),
            [et, tt] = reactExports.useState([]);
        return reactExports.useEffect(() => {
            const nt = ot => {
                tt(ot.concat())
            };
            return nt(_e.getCache(_)), _e.on(_, nt), () => {
                _e.off(_, nt)
            }
        }, []), et
    }
    const PortalReceive = React.memo(function _({
            id: _e
        }) {
            const et = usePortalList(_e),
                tt = reactExports.useMemo(() => et.sort((nt, ot) => {
                    const at = nt.props.sort || 0;
                    return (ot.props.sort || 0) - at
                }), [et]);
            return reactExports.createElement(reactExports.Fragment, null, ...tt)
        }),
        ProtalSend = React.memo(function _({
            id: _e,
            children: et
        }) {
            const tt = usePortalContext();
            return reactExports.useEffect(() => (tt.sendNode(_e, et), () => tt.delNode(_e, et)), [et]), null
        });

    function PortalBase({
        id: _,
        children: _e
    }) {
        return _e ? jsxRuntimeExports.jsx(ProtalSend, {
            id: _,
            children: _e
        }) : jsxRuntimeExports.jsx(PortalReceive, {
            id: _
        })
    }
    const targetMap = new Map;

    function useCtx(_) {
        return reactExports.useMemo(() => {
            let _e = targetMap.get(_);
            if (!_e) {
                const et = {
                    ref: null,
                    sets: new Set,
                    setRef: tt => {
                        et.ref = tt, et.sets.forEach(nt => nt(tt))
                    },
                    destroy() {
                        et.sets.size == 0 && et.ref === null && targetMap.delete(_)
                    }
                };
                _e = et, targetMap.set(_, _e)
            }
            return _e
        }, [_])
    }

    function Target({
        id: _
    }) {
        const _e = useCtx(_),
            et = reactExports.useRef(null);
        return useIsomorphicEffect(() => (_e.setRef(et.current), () => {
            _e.setRef(null), _e.destroy()
        }), []), jsxRuntimeExports.jsx("div", {
            id: _,
            ref: et
        })
    }

    function Source({
        id: _,
        children: _e
    }) {
        const et = useCtx(_),
            [tt, nt] = reactExports.useState(et.ref);
        return useIsomorphicEffect(() => (et.sets.add(nt), () => {
            et.sets.delete(nt), et.destroy()
        }), [et]), tt ? reactDomExports.createPortal(_e, tt) : null
    }
    Portal = PortalBase, Portal.Target = React.memo(Target), Portal.Source = React.memo(Source);
    let springPower1, OverlayerContext;
    springPower1 = {
        type: "spring",
        damping: 80,
        stiffness: 900
    }, Overlayer = React.memo(function(ot) {
        var at = ot,
            {
                children: _,
                visible: _e,
                transparent: et = !1,
                className: tt
            } = at,
            nt = Wt(at, ["children", "visible", "transparent", "className"]);
        const st = reactExports.useRef(null);
        useDisableBodyScroll(_e && st);
        const lt = reactExports.useMemo(() => et ? [void 0, void 0] : [{
            backgroundColor: "#0000"
        }, {
            backgroundColor: "#000a"
        }], [et]);
        return jsxRuntimeExports.jsx(OverlayerContext.Provider, {
            value: !0,
            children: jsxRuntimeExports.jsx(AnimatePresence, {
                children: _e && jsxRuntimeExports.jsxs(motion.div, Bt(kt({
                    ref: st,
                    className: cx$1(wrapStyle$2, tt)
                }, nt), {
                    animate: lt[1],
                    initial: lt[0],
                    exit: lt[0],
                    transition: springPower1,
                    children: [jsxRuntimeExports.jsx(Portal, {
                        id: "overlayer"
                    }), _]
                }))
            })
        })
    }), OverlayerContext = React.createContext(!1);

    function useInOverlayer() {
        return reactExports.useContext(OverlayerContext)
    }
    let wrapStyle$2, ScrollViewCom, viewStyle;
    wrapStyle$2 = "wdcb8sn", ScrollViewCom = React.forwardRef(function _(st, at) {
        var lt = st,
            {
                children: _e,
                className: et = "",
                bodyLock: tt = !1,
                hideBar: nt = !1
            } = lt,
            ot = Wt(lt, ["children", "className", "bodyLock", "hideBar"]);
        const ut = reactExports.useRef(null),
            dt = reactExports.useRef(0),
            ct = useIsActive(),
            pt = useMergeRefs(at, ut),
            ft = useInOverlayer();
        return useDisableBodyScroll((tt || ft) && ut), useIsomorphicEffect(() => {
            ut.current && (ct ? ut.current.scrollTop = dt.current : dt.current = ut.current.scrollTop)
        }, [ct]), jsxRuntimeExports.jsx(motion.div, Bt(kt({
            ref: pt,
            className: cx$1("ui-scrollview", nt && " hide-bar", et)
        }, ot), {
            children: _e
        }))
    }), ScrollView = React.memo(ScrollViewCom), ToggleView = React.memo(function _({
        visible: _e = !0,
        className: et = "",
        minHeight: tt = 0,
        children: nt,
        style: ot
    }) {
        return jsxRuntimeExports.jsx(motion.div, {
            style: ot,
            initial: {
                height: _e ? "auto" : tt
            },
            animate: {
                height: _e ? "auto" : tt
            },
            transition: springPower1,
            className: cx$1(viewStyle, et),
            children: nt
        })
    }), viewStyle = "v1qcofba", Countdown$1 = React.memo(function _({
        endTime: _e,
        children: et,
        onEnd: tt
    }) {
        const [nt, ot] = reactExports.useState(Date.now()), at = reactExports.useRef(_e);
        _e !== at.current && ot(Date.now()), at.current = _e, reactExports.useEffect(() => {
            if (nt < _e) {
                const ut = setTimeout(() => ot(Date.now()), 1e3);
                return () => clearTimeout(ut)
            } else tt && tt()
        }, [nt, _e]);
        let st = (_e - nt) / 1e3,
            lt;
        return st > 0 ? lt = {
            days: Math.floor(st / 86400),
            hours: Math.floor(st / 3600 % 24),
            minutes: Math.floor(st / 60 % 60),
            seconds: Math.floor(st % 60)
        } : lt = {
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0
        }, jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: et(lt)
        })
    });

    function CircleCountdownInner({
        endTime: _,
        startTime: _e,
        onComplete: et,
        className: tt
    }) {
        const nt = useAnimationControls();
        return reactExports.useEffect(() => {
            nt.set({
                pathLength: 1
            }), nt.start({
                pathLength: 0
            })
        }, [_]), jsxRuntimeExports.jsx("svg", {
            className: classList(style$2, tt),
            viewBox: "25 25 50 50",
            children: jsxRuntimeExports.jsx(motion.circle, {
                animate: nt,
                transition: {
                    duration: (_ - _e) / 1e3,
                    ease: "linear"
                },
                onAnimationEnd: et,
                cx: "50",
                cy: "50",
                r: "20",
                fill: "none",
                strokeWidth: "8",
                strokeLinecap: "round"
            })
        })
    }
    let style$2, Text, textStyle, ButtonFoward;
    CircleCountdown = React.memo(function _({
        endTime: _e,
        startTime: et = Date.now(),
        onComplete: tt,
        className: nt
    }) {
        return jsxRuntimeExports.jsx(CircleCountdownInner, {
            endTime: _e,
            startTime: et,
            onComplete: tt,
            className: nt
        })
    }), style$2 = "s13v8tlr", Text = React.memo(function(nt) {
        var ot = nt,
            {
                children: _,
                align: _e = "center",
                className: et
            } = ot,
            tt = Wt(ot, ["children", "align", "className"]);
        const at = reactExports.useRef(null);
        return reactExports.useEffect(() => {
            const st = at.current;
            if (st && st.parentElement) {
                st.style.transform = "";
                const lt = Math.min(st.parentElement.clientWidth / st.clientWidth, 1);
                st.style.transform = `scale(${lt})`
            }
        }, [_]), jsxRuntimeExports.jsx("div", Bt(kt({
            className: cx$1(textStyle, et, `${textStyle}-${_e}`)
        }, tt), {
            children: jsxRuntimeExports.jsx("span", {
                ref: at,
                children: _
            })
        }))
    }), textStyle = "tlqf8r7", ButtonFoward = React.forwardRef(function _(ct, dt) {
        var pt = ct,
            {
                type: _e,
                loading: et = !1,
                disabled: tt = !1,
                className: nt = "",
                size: ot = "normal",
                children: at,
                loadingNode: st = jsxRuntimeExports.jsx(Loading$1, {
                    stroke: "#fff"
                }),
                onClick: lt
            } = pt,
            ut = Wt(pt, ["type", "loading", "disabled", "className", "size", "children", "loadingNode", "onClick"]);
        const ft = useMountedState(),
            [ht, mt] = reactExports.useState(!1),
            bt = vt => {
                if (lt) {
                    const xt = lt(vt);
                    if (xt instanceof Promise) {
                        mt(!0);
                        const yt = () => {
                            ft() && mt(!1)
                        };
                        xt.then(yt, yt)
                    }
                }
            };
        et = et || ht, et && (tt = et);
        const gt = cx$1("ui-button", `button-${ot}`, _e && `s-${_e}`, nt, et && "is-loading");
        return jsxRuntimeExports.jsx(motion.button, Bt(kt({
            className: gt,
            ref: dt,
            disabled: tt,
            onClick: bt
        }, ut), {
            children: jsxRuntimeExports.jsx("div", {
                className: "button-inner",
                children: et ? st : at
            })
        }))
    }), Button2 = React.memo(ButtonFoward);

    function ButtonGroup(et) {
        var tt = et,
            {
                className: _
            } = tt,
            _e = Wt(tt, ["className"]);
        return jsxRuntimeExports.jsx("div", kt({
            className: cx$1("button-group", _)
        }, _e))
    }
    let style$1, NUM_SCALE;
    Badge = React.memo(function({
        num: _,
        className: _e = ""
    }) {
        return _ == 0 ? null : jsxRuntimeExports.jsx("div", {
            className: `badge ${style$1} ${_e}`,
            children: Math.min(_, 99)
        })
    }), style$1 = "s1rp7ii5", NUM_SCALE = 1e8, AnimatedNumber = React.memo(function _({
        children: _e,
        className: et,
        format: tt = nt => String(nt)
    }) {
        const nt = reactExports.useRef({
                num: 0
            }),
            ot = reactExports.useRef(null);
        return reactExports.useEffect(() => (gsapWithCSS.to(nt.current, {
            num: _e * NUM_SCALE,
            duration: 1,
            onUpdate() {
                ot.current && (ot.current.innerText = tt(nt.current.num / NUM_SCALE))
            }
        }), () => gsapWithCSS.killTweensOf(nt.current)), [_e]), jsxRuntimeExports.jsx("span", {
            className: et,
            ref: ot
        })
    });

    function cx(..._) {
        return _.filter(Boolean).join(" ")
    }
    memoize(_ => murmurhash3_32_gc(_).toString(36));

    function memoize(_, _e) {
        if (typeof _ != "function" || _e != null && typeof _e != "function") throw new TypeError(FUNC_ERROR_TEXT);
        var et = function() {
            var tt = arguments,
                nt = _e ? _e.apply(this, tt) : tt[0],
                ot = et.cache;
            if (ot.has(nt)) return ot.get(nt);
            var at = _.apply(this, tt);
            return et.cache = ot.set(nt, at) || ot, at
        };
        return et.cache = new Map, et
    }

    function murmurhash3_32_gc(_, _e) {
        var et, tt, nt, ot, at, st, lt, ut;
        for (et = _.length & 3, tt = _.length - et, nt = _e, at = 3432918353, st = 461845907, ut = 0; ut < tt;) lt = _.charCodeAt(ut) & 255 | (_.charCodeAt(++ut) & 255) << 8 | (_.charCodeAt(++ut) & 255) << 16 | (_.charCodeAt(++ut) & 255) << 24, ++ut, lt = (lt & 65535) * at + (((lt >>> 16) * at & 65535) << 16) & 4294967295, lt = lt << 15 | lt >>> 17, lt = (lt & 65535) * st + (((lt >>> 16) * st & 65535) << 16) & 4294967295, nt ^= lt, nt = nt << 13 | nt >>> 19, ot = (nt & 65535) * 5 + (((nt >>> 16) * 5 & 65535) << 16) & 4294967295, nt = (ot & 65535) + 27492 + (((ot >>> 16) + 58964 & 65535) << 16);
        switch (lt = 0, et) {
            case 3:
                lt ^= (_.charCodeAt(ut + 2) & 255) << 16;
            case 2:
                lt ^= (_.charCodeAt(ut + 1) & 255) << 8;
            case 1:
                lt ^= _.charCodeAt(ut) & 255, lt = (lt & 65535) * at + (((lt >>> 16) * at & 65535) << 16) & 4294967295, lt = lt << 15 | lt >>> 17, lt = (lt & 65535) * st + (((lt >>> 16) * st & 65535) << 16) & 4294967295, nt ^= lt
        }
        return nt ^= _.length, nt ^= nt >>> 16, nt = (nt & 65535) * 2246822507 + (((nt >>> 16) * 2246822507 & 65535) << 16) & 4294967295, nt ^= nt >>> 13, nt = (nt & 65535) * 3266489909 + (((nt >>> 16) * 3266489909 & 65535) << 16) & 4294967295, nt ^= nt >>> 16, nt >>> 0
    }
    WithOutSsr = ({
        children: _
    }) => {
        const [_e, et] = reactExports.useState(!0);
        return useIsomorphicEffect(() => et(!1), []), _e ? null : _
    }, Link = React.memo(React.forwardRef(function _(at, ot) {
        var st = at,
            {
                href: _e,
                onClick: et,
                replace: tt = !1
            } = st,
            nt = Wt(st, ["href", "onClick", "replace"]);
        const {
            urlPathname: lt,
            lang: ut,
            Page: dt
        } = usePageContext(), ct = useNavigate(), pt = reactExports.useMemo(() => _e && getI18nPath(_e, ut), [_e, ut]), ft = reactExports.useMemo(() => _e && (!dt || _e.startsWith("#/") || _e.startsWith("/#/") || tt) ? wrapLinkClick(ht => {
            ct(_e, {
                replace: !0
            }), ht.stopPropagation(), ht.preventDefault()
        }, et) : et, [_e, et, tt]);
        return jsxRuntimeExports.jsx("a", Bt(kt({
            ref: ot,
            href: pt || void 0,
            "keep-scroll-position": "true",
            onClick: ft
        }, nt), {
            className: cx(nt.className, lt === _e && "is-active")
        }))
    }));

    function wrapLinkClick(_, _e) {
        return et => {
            _(et), _e && _e(et)
        }
    }
    let contentWrap, tagReg, tagRegSub;
    Content = React.memo(function _({
        content: _e
    }) {
        const et = formateContent(_e);
        let tt;
        if (et.length > 1) {
            const nt = et[0].args[0] || 0,
                ot = et[0].args[1] || "";
            tt = jsxRuntimeExports.jsxs("div", {
                className: contentWrap,
                children: [jsxRuntimeExports.jsxs(Link, {
                    href: `#/user/profile/${nt}`,
                    children: ["@", ot]
                }), jsxRuntimeExports.jsx("span", {
                    className: "content-msg",
                    style: {
                        whiteSpace: "pre-line"
                    },
                    children: unescape$2(et[1])
                })]
            })
        } else tt = jsxRuntimeExports.jsx("span", {
            className: "content-msg",
            style: {
                whiteSpace: "pre-line"
            },
            children: unescape$2(et[0])
        });
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [tt, " "]
        })
    }), contentWrap = "cghm3iz", tagReg = /(\[\w+=.+?\])/, tagRegSub = /(\[(\w+=.+?)\])/, formateContent = function(_) {
        let _e = [];
        return unescape$2(_).split(tagReg).forEach(et => {
            if (et === "") return;
            let tt = et.match(tagRegSub);
            if (tt) {
                let [nt, ot] = tt[2].split("="), at = ot.split(","), st = {
                    type: nt,
                    args: at
                };
                _e.push(st)
            } else _e.push(et)
        }), _e
    };
    const UIContext = React.createContext({
            onError(_) {}
        }),
        UIProvider = UIContext.Provider;
    ErrorBoundary = class extends React.PureComponent {
        static getDerivedStateFromError(_) {
            return {
                error: _
            }
        }
        constructor(_) {
            super(_), this.state = {
                error: null
            }
        }
        componentDidUpdate(_, _e) {
            _.children !== this.props.children && this.setState({
                error: null
            })
        }
        componentDidCatch(_, _e) {
            this.context.onError(_)
        }
        render() {
            return this.state.error ? this.props.errorComponent ? jsxRuntimeExports.jsx(this.props.errorComponent, {
                msg: String(this.state.error)
            }) : jsxRuntimeExports.jsx("div", {
                className: `error ${errorStyle}`,
                children: String(this.state.error)
            }) : this.props.children
        }
    }, de(ErrorBoundary, "contextType", UIContext);
    const errorStyle = "env4u6q";

    function Confirm(st) {
        var lt = st,
            {
                className: _,
                onConfirm: _e,
                cancelText: et,
                confirmText: tt,
                hasCancel: nt = !1,
                children: ot
            } = lt,
            at = Wt(lt, ["className", "onConfirm", "cancelText", "confirmText", "hasCancel", "children"]);
        const ut = useI18n();
        return et = et || ut("common.actions.cancel"), tt = tt || ut("common.actions.confirm"), jsxRuntimeExports.jsxs("div", Bt(kt({
            className: cx$1(style, _)
        }, at), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "message",
                children: ot
            }), jsxRuntimeExports.jsxs("div", {
                className: "btns",
                children: [nt && jsxRuntimeExports.jsx(Button2, {
                    type: "gray",
                    className: "cancle",
                    onClick: () => _e(!1),
                    children: et
                }), jsxRuntimeExports.jsx(Button2, {
                    type: "conic",
                    className: "light",
                    onClick: () => _e(!0),
                    children: tt
                })]
            })]
        }))
    }
    const style = "s1qim8vk",
        {
            useProxy: useProxy$7,
            proxy: proxy$7,
            ref: ref$3
        } = valtio;
    let ckey$2 = 0,
        popList;
    popList = proxy$7([]), pop = {
        popList,
        push(_, _e = {
            closeable: !0
        }) {
            return _e.closeable === void 0 && (_e.closeable = !0), new Promise(et => {
                const tt = ref$3({
                    node: _,
                    key: ckey$2++,
                    resolve: et,
                    config: _e
                });
                popList.push(tt)
            })
        },
        back(_) {
            const _e = popList.pop();
            _e && _e.resolve(_)
        },
        close() {
            popList.forEach(_ => _.resolve(null)), popList.splice(0, popList.length)
        },
        confirm(_, _e = {}) {
            return new Promise(et => {
                const tt = once$1(nt => {
                    pop.back(), et(nt)
                });
                pop.push(jsxRuntimeExports.jsx(Confirm, Bt(kt({
                    onConfirm: tt,
                    hasCancel: !0
                }, _e), {
                    children: _
                })), {
                    closeable: !1
                }).then(() => tt(!1))
            })
        },
        alert(_, _e = {}) {
            return pop.push(jsxRuntimeExports.jsx(Confirm, Bt(kt({
                onConfirm: pop.back
            }, _e), {
                children: _
            })), {
                closeable: !1
            })
        },
        prompt(_) {
            return new Promise(_e => {
                let et;
                const tt = ot => et = ot,
                    nt = once$1(ot => {
                        _e(ot ? et : null), pop.back()
                    });
                pop.push(jsxRuntimeExports.jsx(Confirm, {
                    onConfirm: nt,
                    hasCancel: !0,
                    children: jsxRuntimeExports.jsx(_, {
                        onChange: tt
                    })
                }), {
                    closeable: !1
                }).then(() => nt(!1))
            })
        }
    }, usePop = function() {
        return pop
    };

    function usePopList() {
        return useProxy$7(popList)
    }
    let aneFrom, aneFromWithHidden, aneEnter, PopProvider, PopWrap, PopContent, popStyle, useProxy$6, proxy$6, ref$2;
    aneFrom = {
        scale: .5,
        opacity: 0,
        visibility: "visible"
    }, aneFromWithHidden = Bt(kt({}, aneFrom), {
        transitionEnd: {
            visibility: "hidden"
        }
    }), aneEnter = {
        scale: 1,
        opacity: 1,
        visibility: "visible"
    }, PopProvider = React.memo(() => {
        const _ = usePopList().length > 0;
        return jsxRuntimeExports.jsx(Overlayer, {
            className: "ui-pop-overlayer",
            visible: _,
            children: jsxRuntimeExports.jsx(PopWrap, {})
        })
    }), PopWrap = React.memo(() => {
        const _ = usePopList(),
            _e = _.slice(-1)[0];
        return jsxRuntimeExports.jsx(AnimatePresence, {
            children: _.map((et, tt) => jsxRuntimeExports.jsx(PopContent, {
                active: et === _e,
                children: et
            }, et.key))
        })
    }), PopContent = React.memo(({
        active: _,
        children: _e
    }) => {
        const et = reactExports.useCallback(tt => {
            tt.target === tt.currentTarget && _e.config.closeable && pop.back()
        }, []);
        return jsxRuntimeExports.jsx(ActiveProvider, {
            value: _,
            children: jsxRuntimeExports.jsx(motion.div, {
                className: popStyle,
                animate: _ ? aneEnter : aneFromWithHidden,
                initial: aneFrom,
                exit: aneFrom,
                onClick: et,
                children: jsxRuntimeExports.jsx(ErrorBoundary, {
                    children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                        fallback: jsxRuntimeExports.jsx(Loading$1, {}),
                        children: _e.node
                    })
                })
            })
        })
    }), Pop = React.memo(({
        closeable: _,
        className: _e,
        id: et,
        title: tt,
        children: nt
    }) => jsxRuntimeExports.jsxs("div", {
        className: `pop ${_e||""}`,
        id: et || "",
        children: [tt && jsxRuntimeExports.jsx("div", {
            className: "pop-title",
            children: tt
        }), _ && jsxRuntimeExports.jsx("button", {
            onClick: pop.back,
            className: "pop-close",
            children: jsxRuntimeExports.jsx(Icon, {
                name: "Close"
            })
        }), nt]
    })), popStyle = "pfrl3ez", {
        useProxy: useProxy$6,
        proxy: proxy$6,
        ref: ref$2
    } = valtio;
    let ckey$1 = 0;
    const ignoredErrorCodes = [6002, 6005, 6008, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108, 6109, 6110, 6111],
        notifyList = proxy$6([]),
        ntf = {
            notifyList,
            push(_, nt = {}) {
                var ot = nt,
                    {
                        onClose: _e,
                        onClick: et
                    } = ot,
                    tt = Wt(ot, ["onClose", "onClick"]);
                if (!_) return;
                if (_ instanceof Error) {
                    if (!_.message || _ instanceof HttpResponseError && ignoredErrorCodes.indexOf(_.code) !== -1) return;
                    for (let lt of notifyList) {
                        const ut = lt.props.message;
                        if (ut instanceof Error && ut.message === _.message) return
                    }
                }
                const at = ckey$1++,
                    st = {
                        props: Object.assign(tt, {
                            message: _,
                            onClick: () => {
                                ntf.remove(at), et && et()
                            },
                            onClose: () => {
                                ntf.remove(at), _e && _e()
                            }
                        }),
                        key: at
                    };
                notifyList.push(ref$2(st))
            },
            remove(_) {
                const _e = notifyList.findIndex(et => et.key === _);
                _e !== -1 && notifyList.splice(_e, 1)
            }
        };

    function useNotifyList() {
        return useProxy$6(notifyList)
    }
    let supportNotifycation, NotifyProvider, heightAuto, height0, NotifyWrap;
    notify = ntf.push, supportNotifycation = "Notification" in globalThis, NotifyProvider = React.memo(({
        value: _ = ntf,
        className: _e
    }) => ReactDOM.createPortal(jsxRuntimeExports.jsx(NotifyWrap, {
        className: _e
    }), document.body)), heightAuto = {
        height: "auto"
    }, height0 = {
        height: 0
    }, NotifyWrap = React.memo(({
        className: _
    }) => {
        let _e = useNotifyList().concat();
        const et = useIsMobile();
        return et && _e.reverse(), jsxRuntimeExports.jsx("div", {
            className: cx$1(notifyWrapStyle, _, et && "is-reverse"),
            children: jsxRuntimeExports.jsx(AnimatePresence, {
                children: _e.map(tt => jsxRuntimeExports.jsx(motion.div, {
                    animate: heightAuto,
                    initial: height0,
                    exit: height0,
                    className: "notify-item",
                    children: jsxRuntimeExports.jsx(ErrorBoundary, {
                        children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                            fallback: jsxRuntimeExports.jsx(Loading$1, {}),
                            children: jsxRuntimeExports.jsx(Notify, kt({}, tt.props))
                        })
                    })
                }, tt.key))
            })
        })
    });

    function useShowSystemNotify() {
        const _ = useI18n();

        function _e() {
            return new Promise(et => {
                ntf.push(jsxRuntimeExports.jsxs("div", {
                    className: notifyConfirmStyle,
                    children: [jsxRuntimeExports.jsx("div", {
                        children: _("common.messages.notification_tip")
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "actions",
                        children: [jsxRuntimeExports.jsx("button", {
                            className: "later",
                            children: _("common.deny")
                        }), jsxRuntimeExports.jsx(Button2, {
                            onClick: () => et(Notification.requestPermission()),
                            type: "conic",
                            size: "small",
                            children: _("common.allow")
                        })]
                    })]
                }), {
                    duration: 0,
                    title: _("common.messages.notification_auth")
                })
            })
        }
        return async function(et, tt) {
            if (Notification.permission === "default" && await _e(), Notification.permission === "denied") throw new Error("No permission!");
            return new Notification(et, tt)
        }
    }
    const Notify = React.memo(reactExports.forwardRef(function _({
        title: _e,
        message: et,
        duration: tt = 3e3,
        icon: nt,
        onClick: ot,
        onClose: at,
        system: st = !1,
        className: lt
    }, ut) {
        const dt = reactExports.useRef(null),
            ct = reactExports.useRef(null),
            pt = useShowSystemNotify();
        et instanceof Error && (et = et.message), typeof et == "string" && (et = unescape$2(et));
        const ft = tt > 0;
        return reactExports.useEffect(() => {
            const ht = dt.current;
            if (supportNotifycation && st && ht) {
                let mt = ht.innerText,
                    bt, gt;
                typeof nt == "string" && (gt = nt), ct.current && (bt = mt, mt = ct.current.innerText), pt(mt, {
                    icon: gt,
                    body: bt
                }).then(vt => {
                    vt.onclick = ot, vt.onclose = at
                }).catch(() => {})
            }
        }, []), jsxRuntimeExports.jsx("div", {
            className: cx$1("notify-ins", lt),
            onClick: ot,
            ref: ut,
            children: jsxRuntimeExports.jsxs("div", {
                className: "notify-wrap",
                children: [jsxRuntimeExports.jsx(AnimatePresence, {
                    children: ft ? jsxRuntimeExports.jsx(Countdown, {
                        duration: tt,
                        onComplete: at
                    }) : jsxRuntimeExports.jsx("button", {
                        className: "notify-close",
                        onClick: ht => {
                            ht.stopPropagation(), at()
                        },
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: "Close"
                        })
                    })
                }), nt && jsxRuntimeExports.jsx("div", {
                    className: `notify-icon${_e?"":" is-small"}`,
                    children: typeof nt == "string" ? jsxRuntimeExports.jsx("img", {
                        className: "notify-icon-img",
                        src: nt
                    }) : nt
                }), jsxRuntimeExports.jsxs("div", {
                    className: "notify-content",
                    children: [_e && jsxRuntimeExports.jsx("div", {
                        ref: ct,
                        className: "notify-title",
                        children: _e
                    }), jsxRuntimeExports.jsx("div", {
                        ref: dt,
                        className: "notify-message",
                        children: et
                    })]
                })]
            })
        })
    }));

    function Countdown({
        duration: _,
        onComplete: _e
    }) {
        return useIsomorphicEffect(() => {
            setTimeout(_e, _ + 150)
        }, [_]), jsxRuntimeExports.jsx("div", {
            className: "notify-cd",
            children: jsxRuntimeExports.jsx("svg", {
                viewBox: "25 25 50 50",
                children: jsxRuntimeExports.jsx(motion.circle, {
                    initial: {
                        pathLength: 1
                    },
                    animate: {
                        pathLength: 0
                    },
                    transition: {
                        ease: "linear",
                        duration: _ / 1e3
                    },
                    cx: "50",
                    cy: "50",
                    r: "20",
                    fill: "none",
                    strokeWidth: "8"
                })
            })
        })
    }
    const notifyWrapStyle = "nfnfs0b",
        notifyConfirmStyle = "n1n0wcth";
    class State {
        constructor(_e) {
            de(this, "state"), this.state = _e
        }
        setState(_e) {
            Object.assign(this.state, _e)
        }
    }
    const {
        useProxy: useProxy$5,
        proxy: proxy$5,
        subscribeKey: subscribeKey$1
    } = valtio, defaultChatRoomPermission = {
        blockable: !1,
        deleteable: !1,
        vipable: !1,
        blockLevel: 0
    };
    class AccountStore extends State {
        constructor(_e) {
            super(_e), de(this, "initData"), de(this, "isInited", !1), this.initData = this.syncData(), this.initData.then(() => this.isInited = !0), userSocket.on("xp_change", socket.decodeBind(et => {
                const {
                    vipLevel: tt,
                    currXP: nt,
                    levelEndXP: ot,
                    levelStartXP: at
                } = et;
                Object.assign(this.state, {
                    vipLevel: tt,
                    currXP: nt,
                    levelEndXP: ot,
                    levelStartXP: at
                })
            }, "json")), subscribeKey$1(this.state, "login", et => {
                et && userSocket.emit("user-login")
            }), isSSR || setInterval(() => this.syncData(), 3e5)
        }
        waitLogin() {
            return new Promise(_e => {
                if (this.state.login) return _e();
                const et = subscribeKey$1(this.state, "login", tt => {
                    tt && (_e(), et())
                })
            })
        }
        async syncData() {
            const _e = await http.get("/account/get/");
            return Object.assign(this.state, _e), this.state
        }
    }
    accountStore = new AccountStore(proxy$5({
        name: "",
        userId: 0,
        uniqueUid: 0,
        uid: 0,
        createTime: 0,
        kyc: 1,
        gameable: !0,
        login: !1,
        email: "",
        bonusCurrencyName: "",
        avatarUpdateTime: Date.now(),
        vipLevel: 0,
        currXP: 0,
        levelEndXP: 0,
        levelStartXP: 0,
        safePwd: !1,
        google2StepAuth: !1,
        hasPhone: !1,
        chatRoomPermission: defaultChatRoomPermission,
        emailVerified: !1,
        channel: "",
        currentInvitationCode: "",
        areaCode: "UNKOWN",
        showable: !0,
        areaAlert: !1,
        acceptPromotion: !0,
        passwordExist: !1,
        invitationUrl: ""
    })), useAccount = function() {
        const _ = useProxy$5(accountStore.state);
        if (accountStore.isInited) return _;
        throw accountStore.initData
    };
    let iconStyle, useProxy$4, proxy$4, ref$1;
    CloseIcon = React.memo(function _({
        className: _e,
        onClick: et
    }) {
        return jsxRuntimeExports.jsx("button", {
            className: cx$1("close-icon", iconStyle, _e),
            onClick: () => {
                et && et()
            },
            children: jsxRuntimeExports.jsx(Icon, {
                name: "Close"
            })
        })
    }), iconStyle = "i1gm0mn8", {
        useProxy: useProxy$4,
        proxy: proxy$4,
        ref: ref$1
    } = valtio;
    let ckey = 0;
    const keyMap = new WeakMap,
        dialogList = proxy$4([]);

    function getKey(_) {
        if (typeof _ == "string") return Date.now(); {
            let _e = keyMap.get(_);
            return _e !== void 0 ? _e : (ckey++, keyMap.set(_, ckey), ckey)
        }
    }
    dialog = {
        dialogList,
        push(_, _e = {}) {
            let et = dialogList.findIndex(nt => nt.modal.type == _.type),
                tt;
            if (et != -1) {
                const nt = dialogList.splice(et, 1)[0];
                Object.assign(nt.config, _e), tt = Bt(kt({}, nt), {
                    modal: _
                })
            } else tt = {
                modal: _,
                config: _e,
                key: getKey(_.type)
            };
            dialogList.push(ref$1(tt))
        },
        back(_) {
            dialogList.length != 0 && dialogList.pop()
        },
        close() {
            dialogList.length !== 0 && dialogList.splice(0, dialogList.length)
        },
        replace(_, _e = {}) {
            let et = dialogList.findIndex(nt => nt.modal.type == _.type),
                tt;
            if (et != -1) {
                et !== dialogList.length - 1 && dialogList.pop();
                const nt = dialogList.splice(et, 1)[0];
                Object.assign(nt.config, _e), tt = Bt(kt({}, nt), {
                    modal: _
                })
            } else dialogList.pop(), tt = {
                modal: _,
                config: _e,
                key: getKey(_.type)
            };
            dialogList.push(ref$1(tt))
        }
    };

    function useDialogList() {
        return useProxy$4(dialogList)
    }
    const DialogProvider = React.memo(() => {
            const _ = useDialogList().length > 0,
                _e = useIsMobile(),
                et = useForceUpdate(),
                tt = reactExports.useRef({
                    width: 200,
                    height: 200
                }).current,
                {
                    width: nt,
                    height: ot
                } = tt,
                at = reactExports.useCallback(dt => {
                    (tt.width !== dt.width || tt.height !== dt.height) && (Object.assign(tt, dt), et())
                }, []),
                st = reactExports.useMemo(() => _e ? [{
                    x: 0
                }, {
                    x: "100%"
                }] : [{
                    scale: 1,
                    opacity: 1
                }, {
                    scale: .8,
                    opacity: 0
                }], [_e]),
                lt = reactExports.useMemo(() => {
                    if (!_e) return {
                        width: nt,
                        height: ot,
                        marginTop: -ot / 2,
                        marginLeft: -nt / 2
                    }
                }, [_e, nt, ot]),
                ut = reactExports.useCallback(dt => {
                    dt.target === dt.currentTarget && dialog.back()
                }, []);
            return jsxRuntimeExports.jsx(Overlayer, {
                className: "ui-dialog-overlayer",
                visible: _,
                transparent: _e,
                onClick: ut,
                children: jsxRuntimeExports.jsx(DialogWrapSizeContext.Provider, {
                    value: at,
                    children: jsxRuntimeExports.jsx(motion.div, {
                        style: lt,
                        animate: st[0],
                        initial: st[1],
                        exit: st[1],
                        transition: springPower1,
                        className: cx$1("ui-dialog-wrap", tt.parentClassName),
                        children: jsxRuntimeExports.jsx(DialogList, {})
                    })
                })
            })
        }),
        DialogHead = React.memo(_ => {
            const _e = useDialog(),
                et = reactExports.useContext(IndexContext),
                {
                    title: tt = "",
                    back: nt = et > 0,
                    closeable: ot
                } = _,
                at = reactExports.useCallback(() => _e.back(), []);
            return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [nt && jsxRuntimeExports.jsx("button", {
                    onClick: at,
                    className: "dialog-back",
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: "Arrow"
                    })
                }), jsxRuntimeExports.jsxs("div", {
                    className: cx$1("dialog-head", nt && "has-back", ot && "has-close"),
                    children: [tt !== "" && jsxRuntimeExports.jsx("div", {
                        className: "dialog-title",
                        children: tt
                    }, tt), _.children]
                })]
            })
        }),
        DialogList = React.memo(() => {
            const _ = useDialogList().concat(),
                _e = reactExports.useRef(_),
                et = _.length == 0 ? _e.current : _;
            return _e.current = _, jsxRuntimeExports.jsx(AnimatePresence, {
                children: et.map((tt, nt) => jsxRuntimeExports.jsx(ActiveProvider, {
                    value: nt === et.length - 1,
                    children: jsxRuntimeExports.jsx(IndexContext.Provider, {
                        value: nt,
                        children: jsxRuntimeExports.jsx(ErrorBoundary, {
                            errorComponent: ErrorView,
                            children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                                fallback: jsxRuntimeExports.jsx(Dialog, {
                                    className: "ui-dialog-loading",
                                    closeable: !1,
                                    children: jsxRuntimeExports.jsx(Loading$1, {})
                                }),
                                children: tt.modal
                            })
                        })
                    })
                }, tt.key))
            })
        }),
        DialogWrapSizeContext = React.createContext(null),
        IndexContext = React.createContext(0),
        DialogInjectContext = React.createContext(null);

    function useInFirstDialog() {
        return !!reactExports.useContext(DialogWrapSizeContext) && !reactExports.useContext(DialogInjectContext)
    }
    let ErrorView, initial, animate, animateUnActive, exit;
    ErrorView = React.memo(({
        msg: _
    }) => jsxRuntimeExports.jsx(Dialog, {
        title: "Error",
        children: jsxRuntimeExports.jsx(Empty, {
            type: "offline",
            children: _
        })
    })), DialogHeader = React.memo(function _({
        children: _e
    }) {
        const et = useIsActive(),
            tt = reactExports.useContext(DialogInjectContext);
        return useIsomorphicEffect(() => {
            if (et && tt) return tt(_e), () => {
                tt(null)
            }
        }, [et, _e]), null
    }), initial = {
        x: "100%",
        visibility: "visible"
    }, animate = {
        x: "0%",
        scale: 1,
        opacity: 1,
        visibility: "visible"
    }, animateUnActive = {
        x: "-10%",
        transitionEnd: {
            visibility: "hidden"
        }
    }, exit = {
        x: "100%",
        visibility: "visible"
    }, Dialog = React.memo(({
        children: _,
        className: _e,
        title: et,
        back: tt,
        closeable: nt = !0,
        parentClassName: ot,
        headChildren: at
    }) => {
        const st = useIsActive(),
            lt = reactExports.useRef(st),
            ut = useIsMobile(),
            dt = reactExports.useContext(IndexContext);
        lt.current = st;
        const ct = reactExports.useContext(DialogWrapSizeContext),
            [pt, ft] = reactExports.useState(null),
            ht = reactExports.useRef(null),
            mt = reactExports.useCallback(() => {
                const gt = lt.current,
                    vt = ht.current;
                if (gt && vt) {
                    const {
                        clientWidth: xt,
                        clientHeight: yt
                    } = vt;
                    ct({
                        width: xt,
                        height: yt,
                        parentClassName: ot
                    })
                }
            }, [ot]);
        useIsomorphicEffect(mt), useIsomorphicEffect(() => {
            const gt = throttle(mt, 200);
            return window.addEventListener("resize", gt), () => window.removeEventListener("resize", gt)
        }, [ot]);
        const bt = reactExports.useMemo(() => !ut && dt === 0 ? [animate, animate] : [initial, animate], [ut, dt]);
        return jsxRuntimeExports.jsx(DialogInjectContext.Provider, {
            value: ft,
            children: jsxRuntimeExports.jsxs(motion.div, {
                ref: ht,
                className: cx$1("ui-dialog", _e),
                initial: bt[0],
                animate: st ? bt[1] : animateUnActive,
                exit,
                transition: springPower1,
                children: [et && jsxRuntimeExports.jsx(DialogHead, {
                    title: et,
                    back: tt,
                    closeable: nt,
                    children: pt || at
                }), nt && jsxRuntimeExports.jsx(CloseIcon, {
                    className: "dialog-close",
                    onClick: dialog.close
                }), jsxRuntimeExports.jsx(reactExports.Suspense, {
                    fallback: jsxRuntimeExports.jsx(Loading$1, {}),
                    children: _
                })]
            })
        })
    }), useDialog = () => dialog;

    function useHashRouter() {
        const [_] = reactExports.useState(() => {
            const _e = parseDefaultHooks(app.dialogNodes),
                et = createHashRouter([{
                    element: jsxRuntimeExports.jsx(Layout, {}),
                    children: [..._e.map(tt => {
                        var nt;
                        return tt.path = (nt = tt.path) == null ? void 0 : nt.replace(/^#/, ""), tt
                    }), {
                        path: "*",
                        element: null
                    }]
                }]);
            return unsafeRouter = et, et
        });
        return _
    }
    let unsafeRouter = null;
    const unsafeHashNavigate = _ => {
        unsafeRouter == null || unsafeRouter.navigate(_, {
            replace: !0
        })
    };

    function Layout() {
        return jsxRuntimeExports.jsxs(ErrorBoundary, {
            errorComponent: () => "HashRouter error!",
            children: [jsxRuntimeExports.jsx(DialogProvider, {}), jsxRuntimeExports.jsx(AutoClear, {}), jsxRuntimeExports.jsx(Outlet, {})]
        })
    }

    function AutoClear() {
        const _ = useDialogList().length === 0;
        return reactExports.useEffect(() => {
            _ && history.replaceState({}, "", location.href.replace(/#.*/, ""))
        }, [_]), null
    }
    const createDialogType = memoize$1(_ => function({
            children: _e
        }) {
            return _e
        }),
        DialogPopHook = React.memo(function _({
            children: _e
        }) {
            const et = useDialog(),
                tt = reactExports.useContext(RouteContext),
                nt = createDialogType(_e.type),
                ot = jsxRuntimeExports.jsx(nt, {
                    children: jsxRuntimeExports.jsx(RouteContext.Provider, {
                        value: tt,
                        children: _e
                    })
                });
            return reactExports.useEffect(() => {
                et.push(ot)
            }), null
        }),
        AuthHook = React.memo(({
            children: _,
            isAuth: _e
        }) => {
            const et = useNavigate(),
                {
                    login: tt
                } = useAccount(),
                nt = _e && !tt;
            return reactExports.useEffect(() => {
                nt && et("#/login")
            }, [nt]), nt ? null : _
        });

    function parseDefaultHooks(_) {
        return _.map(_e => (_e.path = _e.path.replace(/^#/, ""), _e.isDialog && (_e.isHook = !0, _e.element = jsxRuntimeExports.jsx(DialogPopHook, {
            children: _e.element
        })), typeof _e.isAuth == "boolean" && (_e.element = jsxRuntimeExports.jsx(AuthHook, {
            isAuth: _e.isAuth,
            children: _e.element
        })), _e))
    }
    AppProvider = function({
        children: _,
        pageContext: _e,
        onError: et
    }) {
        const tt = reactExports.useRef(_e.lang);
        tt.current = _e.lang, app.unsafeNavigate = reactExports.useCallback((ot, at) => {
            const {
                lang: st = tt.current,
                replace: lt = !1
            } = at || {};
            ot = getI18nPath(ot, st), ot.startsWith("#") || app.history_navigate(ot, {
                replace: lt,
                lang: st
            });
            const ut = ot.split("#")[1];
            ut && unsafeHashNavigate(ut)
        }, []);
        const nt = reactExports.useMemo(() => ({
            onError: et || (() => {})
        }), [et]);
        return useMobileResize(_e), jsxRuntimeExports.jsx(Context.Provider, {
            value: _e,
            children: jsxRuntimeExports.jsxs(UIProvider, {
                value: nt,
                children: [jsxRuntimeExports.jsx(SyncI18n, {}), jsxRuntimeExports.jsxs(WithOutSsr, {
                    children: [jsxRuntimeExports.jsx(PopProvider, {}), jsxRuntimeExports.jsx(NotifyProvider, {}), jsxRuntimeExports.jsx(RootNodes, {}), jsxRuntimeExports.jsx(HashRouterProvider, {})]
                }), _]
            })
        })
    };

    function useDarkenSync() {
        const _ = useIsDarken();
        reactExports.useEffect(() => {
            _ ? (localStorage.removeItem("isBrighten"), document.body.classList.add("darken")) : (localStorage.setItem("isBrighten", "true"), document.body.classList.remove("darken"))
        }, [_])
    }

    function useMobileResize(_) {
        const _e = isSSR && _.mobile ? 1 / 0 : env.MAX_DESIGN_WIDTH,
            et = useGlobalState(),
            tt = () => globalThis.innerWidth <= _e,
            nt = tt();
        useIsomorphicEffect(() => {
            const ot = throttle(() => et.mobile = tt(), 500, {
                leading: !0
            });
            return globalThis.addEventListener("resize", ot), () => {
                globalThis.removeEventListener("resize", ot)
            }
        }, [_e]), et.mobile !== nt && (et.mobile = nt)
    }
    const RootNodes = React.memo(function _() {
        const _e = reactExports.useMemo(() => {
            const et = app.rootNodes.map(tt => jsxRuntimeExports.jsx(ErrorBoundary, {
                errorComponent: RootErrorCom,
                children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                    fallback: null,
                    children: tt
                })
            }));
            return React.createElement(reactExports.Fragment, {}, ...et)
        }, []);
        return useDarkenSync(), _e
    });

    function RootErrorCom({
        msg: _
    }) {
        return console.log("RootNodeError:", _), null
    }
    const HashRouterProvider = React.memo(function _() {
        const _e = useHashRouter();
        return app.hashRouter = _e, jsxRuntimeExports.jsx(RouterProvider, {
            router: _e
        })
    });

    function calibrationXY(_, _e, et, tt, nt) {
        const ot = _e - nt[1];
        let at = _ > et ? et : _ < 0 ? 0 : _,
            st = ot > tt ? tt : ot < 0 ? 0 : ot;
        return at + nt[0] > et && (at = et - nt[0]), st + nt[1] > tt && (st = tt - nt[1]), {
            x: at,
            y: st
        }
    }
    let getBounds, wrapStyle$1;
    getBounds = (_, _e, et, tt, nt) => ({
        left: -_,
        right: et - _ - nt[0],
        top: -_e,
        bottom: tt - _e - nt[1]
    }), DragDialog = React.memo(function({
        visible: _,
        children: _e,
        title: et,
        onClose: tt,
        className: nt = "",
        x: ot = 0,
        y: at = 0
    }) {
        const {
            width: st,
            height: lt
        } = useWindowSize(), ut = reactExports.useRef(null), [dt, ct] = reactExports.useState([0, 0]), pt = useAnimation(), ft = useDragControls();
        if (reactExports.useEffect(() => {
                const bt = ut.current;
                !_ || !bt || ct([bt.clientWidth, bt.clientHeight])
            }, [_]), !_) return null;
        const ht = calibrationXY(ot, at, st, lt, dt),
            mt = getBounds(ht.x, ht.y, st, lt, dt);
        return ReactDOM.createPortal(jsxRuntimeExports.jsxs(motion.div, {
            ref: ut,
            className: cx$1("dragpop", wrapStyle$1, nt),
            style: {
                left: ht.x,
                top: ht.y
            },
            animate: pt,
            drag: !0,
            dragMomentum: !1,
            dragConstraints: mt,
            dragControls: ft,
            dragListener: !1,
            children: [jsxRuntimeExports.jsx("div", {
                className: "dragpop-title",
                onPointerDown: bt => {
                    ft.start(bt)
                },
                children: et
            }), tt && jsxRuntimeExports.jsx("button", {
                className: "dragpop-close hover",
                onClick: tt,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: "Close"
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "dragpop-content",
                children: jsxRuntimeExports.jsx(ErrorBoundary, {
                    children: _e
                })
            })]
        }), document.body)
    }), wrapStyle$1 = "wx5m421";

    function defaultChildren({
        active: _,
        option: _e
    }) {
        return jsxRuntimeExports.jsxs("div", {
            className: `radio-item${_?" is-active":""}`,
            children: [jsxRuntimeExports.jsx("div", {
                className: "circle"
            }), jsxRuntimeExports.jsx("div", {
                children: _e.label
            })]
        })
    }
    RadioBase = React.memo(function _({
        value: _e,
        options: et,
        onChange: tt,
        disabled: nt,
        children: ot = defaultChildren
    }) {
        const at = st => {
            !nt && st != _e && tt(st)
        };
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: et.map((st, lt) => React.cloneElement(ot({
                option: st,
                active: st.value == _e
            }), {
                key: lt,
                onClick: () => at(st.value)
            }))
        })
    }), Radio = React.memo(function _(nt) {
        var ot = nt,
            {
                disabled: _e,
                className: et = ""
            } = ot,
            tt = Wt(ot, ["disabled", "className"]);
        return jsxRuntimeExports.jsx("div", {
            className: cx$1("ui-radio", et, _e && "is-disabled"),
            children: jsxRuntimeExports.jsx(RadioBase, Bt(kt({}, tt), {
                disabled: _e
            }))
        })
    });

    function Tabs(et) {
        var tt = et,
            {
                type: _ = "circle"
            } = tt,
            _e = Wt(tt, ["type"]);
        return _ === "circle" ? jsxRuntimeExports.jsx(TabStyle1, kt({}, _e)) : _ === "line" ? jsxRuntimeExports.jsx(TabStyle2, kt({}, _e)) : jsxRuntimeExports.jsx(NoStyle, kt({}, _e))
    }

    function TabStyle1(st) {
        var lt = st,
            {
                className: _,
                tabs: _e,
                value: et,
                onChange: tt,
                children: nt,
                disabled: ot = !1
            } = lt,
            at = Wt(lt, ["className", "tabs", "value", "onChange", "children", "disabled"]);
        const ut = _e[et].value,
            dt = useIsFirstRender();
        return jsxRuntimeExports.jsxs("div", Bt(kt({
            className: cx$1("ui-tabs", "tabs-circle", _)
        }, at), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "tabs-scroll",
                children: jsxRuntimeExports.jsx("div", {
                    className: "tabs-navs",
                    children: _e.map((ct, pt) => jsxRuntimeExports.jsx("button", {
                        className: cx$1("tabs-nav", pt === et && "is-active", ct.disabled && "tabs-nav-disabled"),
                        onClick: !ot && !ct.disabled ? () => tt(pt) : void 0,
                        children: ct.label
                    }, pt))
                })
            }), ut && jsxRuntimeExports.jsx(TabView, {
                component: ut,
                immediate: dt
            }, et), nt]
        }))
    }

    function TabStyle2(st) {
        var lt = st,
            {
                className: _,
                tabs: _e,
                value: et,
                onChange: tt,
                children: nt,
                disabled: ot = !1
            } = lt,
            at = Wt(lt, ["className", "tabs", "value", "onChange", "children", "disabled"]);
        const ut = _e[et].value,
            dt = useIsFirstRender();
        return jsxRuntimeExports.jsxs("div", Bt(kt({
            className: cx$1("ui-tabs", "tabs-line", _)
        }, at), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "tabs-navs",
                children: _e.map((ct, pt) => jsxRuntimeExports.jsx("button", {
                    className: `tabs-nav${pt===et?" is-active":""}`,
                    onClick: ot ? void 0 : () => tt(pt),
                    children: ct.label
                }, pt))
            }), ut && jsxRuntimeExports.jsx(TabView, {
                component: ut,
                immediate: dt
            }, et), nt]
        }))
    }

    function NoStyle(et) {
        var tt = et,
            {
                className: _
            } = tt,
            _e = Wt(tt, ["className"]);
        return null
    }

    function TabView({
        component: _,
        immediate: _e = !1
    }) {
        const et = _;
        return jsxRuntimeExports.jsx(motion.div, {
            animate: springConfig$1.to,
            initial: _e ? springConfig$1.to : springConfig$1.from,
            transition: springPower1,
            className: "tabs-view",
            children: jsxRuntimeExports.jsx(et, {})
        })
    }
    let springConfig$1;
    springConfig$1 = {
        from: {
            y: 30
        },
        to: {
            y: 0
        }
    }, Tabs$1 = React.memo(Tabs);

    function Switch({
        value: _,
        onChange: _e,
        className: et = "",
        type: tt
    }) {
        return tt === "checkbox" ? jsxRuntimeExports.jsx("div", {
            className: cx$1("ui-checkbox", et),
            onClick: () => _e && _e(!_),
            children: _ && jsxRuntimeExports.jsx(Icon, {
                name: "Check",
                className: "dot"
            })
        }) : jsxRuntimeExports.jsx("div", {
            className: cx$1("ui-switch", _ && "open", et),
            onClick: () => _e && _e(!_),
            children: jsxRuntimeExports.jsx("div", {
                className: "dot"
            })
        })
    }
    Switch$1 = React.memo(Switch), Input = function(_) {
        const _e = reactExports.useRef(null),
            $t = _,
            {
                label: et,
                after: tt,
                onChange: nt,
                validates: ot,
                className: at,
                type: st = "text",
                size: lt,
                children: ut,
                focus: dt,
                bold: ct,
                onFocus: pt,
                onBlur: ft,
                onKeyUp: ht,
                onEnter: mt
            } = $t,
            bt = Wt($t, ["label", "after", "onChange", "validates", "className", "type", "size", "children", "focus", "bold", "onFocus", "onBlur", "onKeyUp", "onEnter"]),
            [gt, vt] = reactExports.useState(!1),
            xt = reactExports.useCallback(Ct => {
                nt && nt(Ct.target.value)
            }, [nt]);
        reactExports.useEffect(() => {
            dt && setTimeout(() => {
                var Ct;
                (Ct = _e.current) == null || Ct.focus()
            }, 300)
        }, []);
        const yt = reactExports.useMemo(() => {
                if (ot)
                    for (let Ct of ot) {
                        const Rt = Ct(String(_.value));
                        if (Rt) return Rt
                    } else return !1
            }, [_.value, ot]),
            Et = reactExports.useCallback(Ct => {
                vt(!1), ft && ft(Ct)
            }, [ft]),
            wt = reactExports.useCallback(Ct => {
                vt(!_.readOnly), pt && pt(Ct)
            }, [ft, _.readOnly]),
            St = reactExports.useCallback(Ct => {
                mt && Ct.key === "Enter" && mt(), ht && ht(Ct)
            }, [mt]);
        return jsxRuntimeExports.jsx(InputWrap, {
            className: classList(at, !!yt && "is-error"),
            label: et,
            size: lt,
            disabled: _.disabled,
            after: tt,
            bold: ct,
            children: jsxRuntimeExports.jsxs("div", {
                className: classList("input-control", gt && "is-focus"),
                children: [jsxRuntimeExports.jsx("input", kt({
                    type: st,
                    ref: _e,
                    onChange: xt,
                    onFocus: wt,
                    onBlur: Et,
                    onKeyUp: mt || ht ? St : void 0
                }, bt)), ut, yt && jsxRuntimeExports.jsx("div", {
                    className: "input-validate",
                    children: yt
                })]
            })
        })
    }, InputWrap = React.memo(function _({
        size: _e,
        disabled: et,
        className: tt,
        label: nt,
        after: ot,
        children: at,
        bold: st
    }) {
        return jsxRuntimeExports.jsxs("div", {
            className: cx$1("ui-input", _e, tt, et && "is-disabled", st && "is-bold"),
            children: [nt && jsxRuntimeExports.jsx("div", {
                className: "input-label",
                children: nt
            }), at, ot && jsxRuntimeExports.jsx("div", {
                className: "input-after",
                children: ot
            })]
        })
    }), InputNumber = React.memo(function _(_e) {
        let gt = _e,
            {
                value: et,
                onChange: tt,
                min: nt = -1 / 0,
                max: ot = 1 / 0,
                precision: at,
                isInt: st = at == 0,
                formatter: lt
            } = gt,
            ut = Wt(gt, ["value", "onChange", "min", "max", "precision", "isInt", "formatter"]);
        ot = Math.max(nt, ot);
        const dt = reactExports.useCallback(vt => lt ? lt(vt) : precisional(vt, at), [lt, at]),
            [ct, pt] = reactExports.useState(() => dt(et));
        useIsomorphicEffect(() => ft(et), [et, nt, ot]);
        const ft = vt => {
                vt < nt ? vt = nt : vt > ot && (vt = ot), pt(dt(et)), vt !== et && tt(vt)
            },
            ht = vt => {
                let xt = parseFloat(ct);
                isNaN(xt) && (xt = et), ft(xt), ut.onBlur && ut.onBlur(vt)
            },
            mt = vt => {
                !_e.disabled && !_e.readOnly && (ct === "0" || ct === "\u221E") && pt(""), ut.onFocus && ut.onFocus(vt)
            },
            bt = reactExports.useCallback(vt => {
                vt !== "" && !(st ? /^-?(?:\d+)$/ : /^-?(?:\d+)?(\.)?(\d+)*$/).test(vt) || pt(vt)
            }, []);
        return jsxRuntimeExports.jsx(Input, Bt(kt({}, ut), {
            value: ct,
            onChange: bt,
            onFocus: mt,
            onBlur: ht
        }))
    });

    function precisional(_, _e) {
        const et = new Decimal$1(_);
        let tt = "";
        return et.lt(1e-6) ? tt = _e ? et.toFixed(_e) : et.toString() : tt = _e ? et.todp(_e).toNumber() + "" : et.toNumber() + "", tt
    }
    let passwordStyle;
    InputPassword = reactExports.memo(function _(nt) {
        var ot = nt,
            {
                autoSee: _e = !1,
                className: et
            } = ot,
            tt = Wt(ot, ["autoSee", "className"]);
        const [at, st] = reactExports.useState(_e || !1);
        return jsxRuntimeExports.jsx(Input, Bt(kt({
            className: cx$1(passwordStyle, et),
            type: at ? "text" : "password",
            autoComplete: "off"
        }, tt), {
            children: jsxRuntimeExports.jsx(Icon, {
                onClick: () => st(!at),
                name: at ? "Hide" : "View"
            })
        }))
    }), passwordStyle = "pjkqlcx", Slider = reactExports.memo(function _({
        min: _e = 0,
        max: et = 100,
        value: tt,
        step: nt = 0,
        vertical: ot = !1,
        onChange: at,
        className: st = "",
        noDebounce: lt = !1,
        onDragValue: ut
    }) {
        const [dt, ct] = reactExports.useState(void 0), pt = reactExports.useRef(null), ft = reactExports.useRef(tt), ht = reactExports.useRef({
            x: 0,
            y: 0
        }), mt = reactExports.useRef([]), bt = reactExports.useMemo(() => debounce($t => {
            ct(void 0), at && at($t)
        }, 200), [at]), gt = reactExports.useCallback($t => {
            lt ? at && at($t) : (ct($t), bt($t)), ut && ut($t)
        }, [at, bt, ut, lt]), vt = reactExports.useCallback($t => {
            if ($t.target.tagName.toLowerCase() == "button") return;
            const [Ct, Rt, Pt, Tt, It, Ot, Dt, jt] = calcDivPosition(pt.current), {
                clientX: Ht,
                clientY: Mt
            } = $t;
            let Ft = ot ? 1 - (Mt - Rt - It) / (Tt - It - Dt) : (Ht - Ct - jt) / (Pt - jt - Ot);
            Ft = Ft < 0 ? 0 : Ft > 1 ? 1 : Ft;
            const Vt = _e + Ft * (et - _e);
            gt(formatValueWithStep(Vt, nt, et))
        }, [ot, _e, et, nt, gt]), xt = reactExports.useCallback(() => {
            ft.current = tt, mt.current = calcDivPosition(pt.current)
        }, [tt]), yt = reactExports.useCallback(($t, Ct) => {
            const {
                x: Rt,
                y: Pt
            } = Ct.offset;
            if (Rt === ht.current.x && Pt === ht.current.y) return;
            ht.current = Ct.offset;
            const [, , Tt, It, Ot, Dt, jt, Ht] = mt.current;
            let Mt = ot ? -Pt / (It - Ot - jt) : Rt / (Tt - Ht - Dt),
                Ft = ft.current + Mt * (et - _e);
            Ft >= et ? Ft = et : Ft <= _e && (Ft = _e), gt(formatValueWithStep(Ft, nt, et))
        }, [ot, et, _e, nt]), Et = reactExports.useMemo(() => {
            const $t = ((dt === void 0 ? tt : dt) - _e) / (et - _e);
            return $t < 0 ? 0 : $t > 1 ? 1 : $t
        }, [lt, tt, dt, et, _e]), [wt, St] = reactExports.useMemo(() => ot ? ["scaleY", "translateY"] : ["scaleX", "translateX"], [ot]);
        return jsxRuntimeExports.jsxs("div", {
            className: cx$1("ui-slider", ot && "slider-vertical", st),
            ref: pt,
            onClick: vt,
            children: [jsxRuntimeExports.jsx("div", {
                style: {
                    transform: `${wt}(${Et})`
                },
                className: "slider-after"
            }), jsxRuntimeExports.jsx("div", {
                style: {
                    transform: `${St}(${(ot?1-Et:Et)*100}%)`
                },
                className: "slider-handler-wrap",
                children: jsxRuntimeExports.jsx(motion.button, {
                    className: "slider-handler",
                    drag: ot ? "y" : "x",
                    dragMomentum: !1,
                    dragConstraints: pt,
                    dragDirectionLock: !0,
                    dragElastic: 0,
                    animate: !1,
                    onDragStart: xt,
                    onDrag: yt
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "slider-before"
            })]
        })
    });

    function formatValueWithStep(_, _e, et) {
        if (_e === 0) return _;
        let tt = new Decimal$1(_).sub(new Decimal$1(_).modulo(_e)).toNumber();
        return new Decimal$1(_).modulo(_e).div(_e).gte(.5) && (tt += _e), tt > et ? et : tt
    }

    function calcDivPosition(_) {
        const {
            clientWidth: _e,
            clientHeight: et
        } = _, {
            x: tt,
            y: nt
        } = _.getBoundingClientRect(), ot = getComputedStyle(_), at = parseInt(ot.paddingLeft), st = parseInt(ot.paddingRight), lt = parseInt(ot.paddingTop), ut = parseInt(ot.paddingBottom);
        return [tt, nt, _e, et, lt, st, ut, at]
    }
    let MaxHeightTextarea, textareaStyle, springConfig;
    Textarea = React.memo(React.forwardRef(function _(ht, ft) {
        var mt = ht,
            {
                className: _e,
                label: et,
                size: tt,
                disabled: nt,
                after: ot,
                children: at,
                maxHeight: st,
                onChange: lt,
                focus: ut,
                onBlur: dt,
                onFocus: ct
            } = mt,
            pt = Wt(mt, ["className", "label", "size", "disabled", "after", "children", "maxHeight", "onChange", "focus", "onBlur", "onFocus"]);
        const [bt, gt] = reactExports.useState(!1), vt = reactExports.useRef(null), xt = reactExports.useCallback(wt => {
            lt && lt(wt.target.value)
        }, [lt]);
        reactExports.useEffect(() => {
            if (ut && setTimeout(() => {
                    var wt;
                    (wt = vt.current) == null || wt.focus()
                }, 300), ft) return typeof ft == "function" ? (ft(vt.current), () => ft(null)) : (ft.current = vt.current, () => ft.current = null)
        }, []);
        const yt = reactExports.useCallback(wt => {
                gt(!1), dt && dt(wt)
            }, [dt]),
            Et = reactExports.useCallback(wt => {
                gt(!pt.readOnly), ct && ct(wt)
            }, [dt, pt.readOnly]);
        return jsxRuntimeExports.jsx(InputWrap, {
            className: cx$1(textareaStyle, _e),
            label: et,
            size: tt,
            disabled: nt,
            after: ot,
            children: jsxRuntimeExports.jsxs("div", {
                className: classList("input-control", bt && "is-focus"),
                children: [st === void 0 ? jsxRuntimeExports.jsx("textarea", kt({
                    ref: vt,
                    onChange: xt,
                    onBlur: yt,
                    onFocus: Et
                }, pt)) : jsxRuntimeExports.jsx(MaxHeightTextarea, kt({
                    ref: vt,
                    onChange: xt,
                    maxHeight: st,
                    onBlur: yt,
                    onFocus: Et
                }, pt)), at]
            })
        })
    })), MaxHeightTextarea = React.memo(React.forwardRef(function _(_e, et) {
        const st = _e,
            {
                maxHeight: tt
            } = st,
            nt = Wt(st, ["maxHeight"]),
            ot = reactExports.useRef(null),
            at = reactExports.useCallback(lt => {
                ot.current = lt, et && (typeof et == "function" ? et(lt) : et.current = lt)
            }, []);
        return useIsomorphicEffect(() => {
            const lt = ot.current;
            tt && (lt.style.height = "", lt.style.height = Math.min(lt.scrollHeight, tt) + "px")
        }, [nt.value]), jsxRuntimeExports.jsx("textarea", kt({
            ref: at
        }, nt))
    })), textareaStyle = "tpnb05b", springConfig = {
        from: {
            y: -10,
            opacity: 0
        },
        enter: {
            y: 0,
            opacity: 1
        }
    };

    function Select(_) {
        const {
            value: _e,
            options: et,
            onChange: tt,
            disabled: nt,
            top: ot = !1,
            className: at,
            popNode: st,
            filter: lt,
            searchNoResult: ut,
            disableHover: dt = !0,
            renderLabel: ct = defaultLabel,
            renderOption: pt = defaultOption,
            getKey: ft
        } = _, [ht, mt] = reactExports.useState(""), bt = lt ? et.filter(Ct => lt(Ct, ht)) : et, gt = et.find(Ct => Ct.value == _e), vt = useIsMobile(), [xt, yt] = reactExports.useState(!1), Et = reactExports.useRef(null), wt = useOnClickOutside(() => yt(!1)), St = Ct => {
            tt(Ct), yt(!1)
        };
        let $t = () => yt(!xt);
        return jsxRuntimeExports.jsxs("div", {
            ref: wt,
            className: cx$1("ui-select", at, xt && "is-open", nt && "is-disabled"),
            children: [jsxRuntimeExports.jsxs("div", {
                className: "select-trigger",
                onClick: $t,
                children: [gt && ct(gt), jsxRuntimeExports.jsx("div", {
                    className: "arrow " + (ot ? "top" : ""),
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: "Arrow"
                    })
                })]
            }), jsxRuntimeExports.jsx(AnimatePresence, {
                children: xt && jsxRuntimeExports.jsxs(motion.div, {
                    className: "select-options-wrap",
                    animate: springConfig.enter,
                    initial: springConfig.from,
                    exit: springConfig.from,
                    transition: springPower1,
                    style: ot ? topStyle : bottomStyle,
                    children: [st, lt && jsxRuntimeExports.jsx(Input, {
                        autoComplete: "off",
                        focus: !0,
                        className: "search-input",
                        value: ht,
                        onChange: mt,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: "Search"
                        })
                    }), jsxRuntimeExports.jsx(ScrollView, {
                        ref: Et,
                        bodyLock: vt,
                        className: "select-options " + ("len-" + et.length),
                        children: bt.length <= 0 ? ut : bt.map(Ct => jsxRuntimeExports.jsx("div", {
                            onClick: () => !Ct.disabled && St(Ct.value),
                            className: ["select-option", Ct.value == (gt == null ? void 0 : gt.value) && "active", Ct.disabled && "disabled"].filter(Boolean).join(" "),
                            children: pt(Ct)
                        }, ft ? ft(Ct) : Ct.label))
                    })]
                })
            })]
        })
    }
    let defaultLabel, defaultOption, topStyle, bottomStyle;
    defaultLabel = _ => _.label, defaultOption = _ => _.label, Select$1 = React.memo(Select), topStyle = {
        bottom: "100%"
    }, bottomStyle = {
        top: "100%"
    };

    function SelectBaseFunc(at) {
        var st = at,
            {
                options: _,
                keydownRef: _e,
                onSelect: et,
                itemKey: tt,
                children: nt = defaultRenderOptions
            } = st,
            ot = Wt(st, ["options", "keydownRef", "onSelect", "itemKey", "children"]);
        const lt = reactExports.useRef({
                idx: 0,
                options: _,
                elRef: reactExports.useRef(null),
                itemRef: reactExports.useRef(null)
            }),
            ut = useIsMobile();
        lt.current.options !== _ && (lt.current.idx = 0, lt.current.options = _);
        const dt = useForceUpdate();
        reactExports.useEffect(() => {
            if (_e) return _e.current = pt => {
                const {
                    idx: ft,
                    options: ht
                } = lt.current;
                return pt == 38 ? (lt.current.idx = validLen(ft - 1, ht.length), dt(), !0) : pt == 40 ? (lt.current.idx = validLen(ft + 1, ht.length), dt(), !0) : (pt == 13 || pt == 9) && ht[ft] ? (et(ht[ft]), !0) : !1
            }, () => {
                _e.current = null
            }
        }), useIsomorphicEffect(() => {
            const pt = lt.current.elRef.current,
                ft = lt.current.itemRef.current;
            if (!ft || !pt) return;
            const ht = ft.offsetHeight,
                mt = lt.current.idx * ht;
            pt.scrollTop = Math.max(Math.min(mt, pt.scrollTop), ht + mt - pt.offsetHeight)
        }), useIsomorphicEffect(() => {
            if (ut) return disableBodyScroll(lt.current.elRef.current), () => enableBodyScroll(lt.current.elRef.current)
        }, [ut]);
        const ct = _.map((pt, ft) => {
            const ht = lt.current.idx == ft,
                mt = nt({
                    isSelected: ht,
                    option: pt
                }),
                bt = mt.props.className || "",
                gt = {
                    onClick() {
                        et(pt)
                    },
                    key: tt ? pt[tt] : ft,
                    className: ht ? `${bt} is-selected` : bt
                };
            return ft == 0 && (gt.ref = lt.current.itemRef), React.cloneElement(mt, gt)
        });
        return jsxRuntimeExports.jsx("div", Bt(kt({
            ref: lt.current.elRef
        }, ot), {
            children: ct
        }))
    }
    SelectBase = React.memo(SelectBaseFunc);

    function defaultRenderOptions({
        isSelected: _,
        option: _e
    }) {
        return jsxRuntimeExports.jsx("div", {
            className: "item",
            children: String(_e)
        })
    }

    function validLen(_, _e) {
        return _ < _e && (_ += _e), _ % _e
    }
    let LimitRange;
    Table = React.memo(React.forwardRef(function({
        hover: _ = !0,
        stripe: _e,
        className: et = "",
        children: tt
    }, nt) {
        return jsxRuntimeExports.jsx("table", {
            className: cx$1("ui-table", et, _ && "is-hover", _e && "is-stripe"),
            ref: nt,
            children: tt
        })
    })), LimitRange = [{
        value: 10,
        label: "10"
    }, {
        value: 20,
        label: "20"
    }, {
        value: 30,
        label: "30"
    }, {
        value: 40,
        label: "40"
    }, {
        value: 50,
        label: "50"
    }], Pagination = React.memo(function _(_e) {
        const et = useI18n(),
            {
                page: tt,
                onChange: nt,
                total: ot,
                limit: at = 20,
                onChangeLimit: st,
                bound: lt = 2,
                className: ut = "",
                type: dt = "pageConic"
            } = _e,
            ct = Math.ceil(ot / at),
            pt = getPages(tt, ct, lt);
        return jsxRuntimeExports.jsxs("div", {
            className: cx$1("ui-pagination", ut),
            children: [st && jsxRuntimeExports.jsx(Select$1, {
                top: !0,
                value: at,
                options: LimitRange,
                onChange: st
            }), jsxRuntimeExports.jsxs("div", {
                className: "total",
                children: [et("common.total"), " ", ct]
            }), jsxRuntimeExports.jsx("div", {
                className: cx$1("pages-box", "pages-wrap"),
                children: pt.map(ft => jsxRuntimeExports.jsx("button", {
                    className: ft == tt ? "active" : "",
                    onClick: () => nt(ft),
                    disabled: ft == tt,
                    children: ft
                }, ft))
            }), jsxRuntimeExports.jsxs("div", {
                className: cx$1("pages-box", "page-pn", dt),
                children: [jsxRuntimeExports.jsx("button", {
                    disabled: tt === 1,
                    className: tt === 1 ? "disabled previous-btn" : "previous-btn",
                    onClick: () => nt(tt - 1),
                    children: jsxRuntimeExports.jsx(Icon, {
                        className: "prev",
                        name: "Arrow"
                    })
                }), jsxRuntimeExports.jsx("button", {
                    disabled: tt >= ct,
                    className: tt >= ct ? "disabled next-page" : "next-page",
                    onClick: () => nt(tt + 1),
                    children: jsxRuntimeExports.jsx(Icon, {
                        className: "next",
                        name: "Arrow"
                    })
                })]
            })]
        })
    });

    function getPages(_, _e, et) {
        let tt = [_];
        for (let nt = 1; nt < et + 1; nt++) _ - nt >= 1 && tt.unshift(_ - nt), _ + nt <= _e && tt.push(_ + nt);
        return tt
    }
    Tooltip = React.memo(({
        title: _,
        delay: _e = 1e3,
        forceWrap: et = !1,
        children: tt
    }) => {
        const [nt, ot] = reactExports.useState(null), at = reactExports.useRef(0), st = dt => {
            const ct = dt.currentTarget.getBoundingClientRect();
            at.current = window.setTimeout(() => ot(ct), _e)
        }, lt = () => {
            window.clearTimeout(at.current), ot(null)
        };
        reactExports.useEffect(() => () => {
            window.clearTimeout(at.current)
        }, []);
        let ut;
        return isSupportTouch ? ut = {
            onTouchStart: st,
            onTouchEnd: lt,
            onTouchCancel: lt
        } : ut = {
            onMouseEnter: st,
            onMouseLeave: lt
        }, jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [bindTriggerElement(tt, ut), nt && _ && jsxRuntimeExports.jsx(TooltipBase, {
                forceWrap: et,
                rect: nt,
                children: _
            })]
        })
    });

    function bindTriggerElement(_, _e) {
        let et = null;
        return React.Children.map(_, tt => !et && React.isValidElement(tt) ? (et = React.cloneElement(tt, _e), et) : tt)
    }
    let tipsStyle, Carousel$1;
    TooltipBase = reactExports.memo(({
        padding: _ = 5,
        rect: _e,
        forceWrap: et,
        children: tt
    }) => {
        const nt = reactExports.useRef(null);
        return useIsomorphicEffect(() => {
            const ot = nt.current;
            if (ot) {
                let at = {
                        x: _e.x + _e.width * .5,
                        y: _e.y + _e.height * .5
                    },
                    st = {
                        x: ot.offsetWidth * .5 + _,
                        y: ot.offsetHeight * .5 + _
                    },
                    lt = Math.max(st.x, Math.min(window.innerWidth - st.x, at.x)),
                    ut = _e.y - st.y;
                _e.y < st.y * 2 && (ut = _e.y + _e.height + st.y), ot.style.left = `${lt}px`, ot.style.top = `${ut}px`
            }
        }, []), ReactDOM.createPortal(jsxRuntimeExports.jsx("div", {
            className: cx$1(tipsStyle, et && "force-wrap"),
            ref: nt,
            children: tt
        }), document.body)
    }), tipsStyle = "tt7l7b4", Carousel$1 = React.memo(function _({
        value: _e,
        onChange: et,
        duration: tt = 0,
        className: nt = "",
        drag: ot = !0,
        style: at,
        children: st
    }) {
        const lt = reactExports.useRef(null),
            [ut, dt] = useDimensions(),
            ct = reactExports.Children.toArray(st),
            pt = ct.length,
            ft = reactExports.useMemo(() => ct.map((xt, yt) => -yt * dt), [dt, ct]),
            ht = xt => (xt + ct.length * 1e8) % ct.length,
            mt = ht(_e),
            bt = useAnimationControls();
        useIsomorphicEffect(() => {
            if (pt > 0) {
                const xt = ht(_e);
                xt != _e ? et(xt) : bt.start({
                    x: ft[_e]
                })
            }
        }, [_e, pt]);
        const gt = dt * (ct.length - 1);

        function vt(xt, yt) {
            const Et = lt.current;
            if (!Et) return null;
            const wt = Et.getBoundingClientRect(),
                St = yt.offset.x + yt.velocity.x,
                $t = St > 0 ? 1 : -1,
                Ct = Math.min(Math.abs(St), dt * .9) * $t,
                Rt = wt.x + Ct,
                Pt = ft.reduce((It, Ot) => Math.abs(Ot - Rt) < Math.abs(It - Rt) ? Ot : It, 0),
                Tt = ft.indexOf(Pt);
            et(Tt), bt.start({
                x: Pt
            })
        }
        return jsxRuntimeExports.jsx("div", {
            ref: ut,
            className: classList("carousel", carouselStyle, nt, ot && "drag-enable"),
            style: at,
            children: jsxRuntimeExports.jsx(motion.div, {
                ref: lt,
                className: "carousel-list",
                animate: bt,
                drag: "x",
                style: {
                    width: dt * ct.length
                },
                dragConstraints: {
                    left: -gt,
                    right: 0
                },
                onDragEnd: vt,
                transition: springPower1,
                children: ct.map((xt, yt) => jsxRuntimeExports.jsx(ActiveProvider, {
                    value: mt === yt,
                    children: jsxRuntimeExports.jsx(motion.div, {
                        className: "carousel-item",
                        children: xt
                    })
                }, yt))
            })
        })
    });

    function useDimensions() {
        const _ = reactExports.useRef(null),
            [_e, et] = reactExports.useState(0);
        return useIsomorphicEffect(() => {
            const tt = _.current;
            tt && et(tt.clientWidth)
        }), [_, _e]
    }
    const carouselStyle = "c1ve37vw";

    function UpdateInView({
        children: _
    }) {
        const {
            ref: _e,
            inView: et
        } = useInView(), tt = reactExports.useRef();
        return (!tt.current || et) && (tt.current = React.cloneElement(_, {
            ref: _e
        })), tt.current
    }
    UpdateInView$1 = React.memo(UpdateInView), lazyLoad = function(_, _e = jsxRuntimeExports.jsx(Loading$1, {})) {
        let et = null,
            tt = null;
        const nt = ot => {
            ot.match && ot.match.params && (ot = ot.match.params);
            const at = useMountedState(),
                st = useForceUpdate(),
                lt = useInFirstDialog(),
                ut = () => at() && st();
            return reactExports.useEffect(() => {
                et || Promise.all([nt.preload(), delay(500)]).then(ut).catch(dt => {
                    console.log(dt), tt = new Error("Script not found!")
                })
            }), tt ? jsxRuntimeExports.jsx(Empty, {
                type: "offline"
            }) : et ? jsxRuntimeExports.jsx(et, kt({}, ot)) : lt ? jsxRuntimeExports.jsx(Dialog, {
                className: "ui-dialog-loading",
                closeable: !1,
                children: _e
            }) : _e
        };
        return nt.preload = async () => (et || (et = (await _()).default), et), nt
    };

    function pickLazyFunction(_, _e) {
        return async (...et) => {
            const tt = (await _())[_e];
            return tt instanceof Function ? tt(...et) : tt
        }
    }
    pickLazyComponent = function(_, _e) {
        return lazyLoad(async (...et) => ({
            default: (await _())[_e]
        }))
    };
    let wrapStyle, CodeSegment, codeStyle, LazyImage, Image$1, cache;
    FileSelect = reactExports.memo(function _({
        onChange: _e,
        className: et = "",
        children: tt,
        multiple: nt,
        disabled: ot,
        typeCheck: at = /\.(gif|jpg|jpeg|png|bmp|GIF|JPG|PNG)$/
    }) {
        const st = reactExports.useRef(null),
            lt = ut => {
                if (!ut.target.files || ut.target.files.length == 0) return;
                const dt = ut.target.files;
                for (let ct = 0; ct < dt.length; ct++)
                    if (!at.test(dt[ct].name)) return notify(new Error("File type is not supported"));
                _e(dt), ut.target.value = ""
            };
        return jsxRuntimeExports.jsxs("button", {
            className: cx$1("upload", wrapStyle, et),
            children: [tt, jsxRuntimeExports.jsx("input", {
                type: "file",
                onChange: lt,
                ref: st,
                multiple: nt,
                disabled: ot
            })]
        })
    }), wrapStyle = "w1tpi5js", CodeSegment = React.memo(function({
        children: _,
        style: _e,
        className: et = ""
    }) {
        return jsxRuntimeExports.jsx("div", {
            className: cx$1("code-area", codeStyle, et),
            style: _e,
            children: jsxRuntimeExports.jsx("pre", {
                children: _
            })
        })
    }), codeStyle = "c1xwx83c", LazyImage = React.memo(function _(st) {
        var lt = st,
            {
                src: _e,
                lazy: et,
                loading: tt,
                className: nt,
                children: ot
            } = lt,
            at = Wt(lt, ["src", "lazy", "loading", "className", "children"]);
        const ut = reactExports.useRef(null),
            {
                state: dt,
                fetch: ct
            } = useAsyncFn(() => loadImage(_e), [_e]);
        return reactExports.useEffect(() => {
            const pt = ut.current;
            if (pt && _e) {
                const ft = () => SIObserver.remove(pt);
                return SIObserver.add(pt, ht => {
                    ht && ct().then(ft)
                }), ft
            }
        }, [_e]), nt = classList("lazy-img", nt), dt.data ? jsxRuntimeExports.jsxs("div", Bt(kt({
            className: nt,
            ref: ut
        }, at), {
            children: [jsxRuntimeExports.jsx("img", {
                src: dt.data,
                alt: ""
            }), ot]
        })) : jsxRuntimeExports.jsxs("div", Bt(kt({
            className: nt,
            ref: ut
        }, at), {
            children: [tt, ot]
        }))
    }), Image$1 = React.memo(function _(ot) {
        var at = ot,
            {
                src: _e,
                lazy: et,
                fallback: tt
            } = at,
            nt = Wt(at, ["src", "lazy", "fallback"]);
        const st = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=",
            [lt, ut] = useLazyImg(_e, tt || st, st),
            [dt, ct] = reactExports.useState(st);
        return useIsomorphicEffect(() => {
            ct(et ? ut : _e)
        }, [ut, et]), jsxRuntimeExports.jsx("img", kt({
            ref: et ? lt : void 0,
            src: dt
        }, nt))
    }), cache = new Set;

    function useLazyImg(_, _e, et) {
        const tt = reactExports.useRef(null),
            [nt, ot] = useLoadImage(_e, et),
            [at, st] = useLoadImage(_, nt),
            lt = _ === at;
        return reactExports.useEffect(() => {
            const ut = tt.current;
            if (!lt && ut && _) {
                ot();
                const dt = () => {
                    SIObserver.remove(ut)
                };
                return SIObserver.add(ut, ct => {
                    ct && st().then(dt)
                }), dt
            }
        }, [tt, _]), lt ? [void 0, at] : [tt, nt]
    }

    function useLoadImage(_, _e) {
        const et = cache.has(_),
            {
                state: tt,
                fetch: nt
            } = useAsyncFn(() => {
                const ot = loadImage(_);
                return ot.then(() => cache.add(_)), ot
            }, [_]);
        return et || tt.data ? [_, () => Promise.resolve()] : [_e, nt]
    }
    let defaultArgs;
    defaultArgs = `auto=format&dpr=${isSSR?1:globalThis.devicePixelRatio}`, Imgix = React.memo(function _(st) {
        var lt = st,
            {
                src: _e,
                args: et,
                fallback: tt,
                lazy: nt = !0,
                fillbackArgs: ot = "w=100&auto=format&cs=tinysrgb&blur=100"
            } = lt,
            at = Wt(lt, ["src", "args", "fallback", "lazy", "fillbackArgs"]);
        const ut = [defaultArgs];
        return et && ut.push(et), jsxRuntimeExports.jsx(Image$1, Bt(kt({
            src: `${_e}?${ut.join("&")}`
        }, at), {
            lazy: nt,
            fallback: tt || `${_e}?${ot}`
        }))
    }), DialogTable = function(et) {
        var tt = et,
            {
                className: _
            } = tt,
            _e = Wt(tt, ["className"]);
        return jsxRuntimeExports.jsx("table", kt({
            className: cx$1(tableStyle, _)
        }, _e))
    };
    const tableStyle = "t1aku4jw",
        loadLottie = () => __vitePreload(() =>
            import ("./chunk-a8bd36dd.js").then(async _ => (await _.__tla, _)).then(_ => _.l), []);
    let lottie = null;
    async function getInstance() {
        return lottie || (lottie = (await loadLottie()).default), lottie
    }
    Lottie = class extends React.PureComponent {
        constructor(_) {
            super(_), de(this, "containerRef", React.createRef()), de(this, "instance", null)
        }
        componentDidMount() {
            const _ = this.containerRef.current,
                {
                    loop: _e = !1,
                    autoplay: et,
                    path: tt
                } = this.props;
            _ && (this.instance = getInstance().then(nt => nt.loadAnimation({
                container: _,
                renderer: "svg",
                loop: _e,
                autoplay: et,
                path: tt
            })).catch(nt => null), this.syncProps())
        }
        componentDidUpdate() {
            this.syncProps()
        }
        componentWillUnmount() {
            var _;
            (_ = this.instance) == null || _.then(_e => _e.destroy())
        }
        async runInstance(_) {
            this.instance && _(await this.instance)
        }
        play(_) {
            this.runInstance(_e => {
                typeof _ > "u" && (_ = _e.currentFrame), _e.goToAndPlay(_, !0)
            })
        }
        stop(_) {
            this.runInstance(_e => {
                typeof _ > "u" && (_ = _e.currentFrame), _e.goToAndStop(_, !0)
            })
        }
        addEventListener(_, _e) {
            this.runInstance(et => et.addEventListener(_, _e))
        }
        removeEventListener(_, _e) {
            this.runInstance(et => et.removeEventListener(_, _e))
        }
        syncProps() {
            const {
                speed: _ = 1
            } = this.props;
            this.runInstance(_e => {
                _e.setSpeed(_)
            })
        }
        render() {
            let nt = this.props,
                {
                    loop: _,
                    path: _e,
                    autoplay: et
                } = nt,
                tt = Wt(nt, ["loop", "path", "autoplay"]);
            return jsxRuntimeExports.jsx("div", Bt(kt({}, tt), {
                ref: this.containerRef
            }))
        }
    };
    const loadQRCode = () => __vitePreload(() =>
        import ("./chunk-54fcd4f6.js").then(_ => _.b), []);
    let qrcodeCache = null;

    function useLoadQrcode() {
        const [_, _e] = reactExports.useState(qrcodeCache);
        return useIsomorphicEffect(() => {
            qrcodeCache || loadQRCode().then(et => {
                qrcodeCache = et.default, _e(qrcodeCache)
            })
        }, [_]), _
    }
    useQrcode = function({
        url: _,
        qrimg: _e,
        className: et,
        options: tt = {
            margin: 4,
            width: 200
        }
    }) {
        const nt = useLoadQrcode(),
            [ot, at] = reactExports.useState(_e != null ? _e : "");
        return reactExports.useEffect(() => {
            !ot && nt && nt.toDataURL(_, {
                margin: tt.margin,
                width: app.relativePx(tt.width),
                errorCorrectionLevel: "L"
            }, function(st, lt) {
                at(st ? emptyPng : lt)
            })
        }, [nt, _, ot]), {
            qrnode: reactExports.useMemo(() => jsxRuntimeExports.jsx("div", {
                className: classList("qrcode-wrap", et),
                children: ot ? jsxRuntimeExports.jsx("img", {
                    alt: "qrcode",
                    src: ot
                }) : jsxRuntimeExports.jsx(Loading$1, {})
            }), [ot]),
            img: ot
        }
    };

    function _extends$1() {
        return _extends$1 = Object.assign || function(_) {
            for (var _e = 1; _e < arguments.length; _e++) {
                var et = arguments[_e];
                for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (_[tt] = et[tt])
            }
            return _
        }, _extends$1.apply(this, arguments)
    }

    function _objectWithoutPropertiesLoose(_, _e) {
        if (_ == null) return {};
        var et = {},
            tt = Object.keys(_),
            nt, ot;
        for (ot = 0; ot < tt.length; ot++) nt = tt[ot], !(_e.indexOf(nt) >= 0) && (et[nt] = _[nt]);
        return et
    }
    var props = ["bottom", "height", "left", "right", "top", "width"],
        rectChanged = function _(_e, et) {
            return _e === void 0 && (_e = {}), et === void 0 && (et = {}), props.some(function(tt) {
                return _e[tt] !== et[tt]
            })
        },
        observedNodes = new Map,
        rafId, run = function _() {
            var _e = [];
            observedNodes.forEach(function(et, tt) {
                var nt = tt.getBoundingClientRect();
                rectChanged(nt, et.rect) && (et.rect = nt, _e.push(et))
            }), _e.forEach(function(et) {
                et.callbacks.forEach(function(tt) {
                    return tt(et.rect)
                })
            }), rafId = window.requestAnimationFrame(_)
        };

    function observeRect(_, _e) {
        return {
            observe: function() {
                var et = observedNodes.size === 0;
                observedNodes.has(_) ? observedNodes.get(_).callbacks.push(_e) : observedNodes.set(_, {
                    rect: void 0,
                    hasRectChanged: !1,
                    callbacks: [_e]
                }), et && run()
            },
            unobserve: function() {
                var et = observedNodes.get(_);
                if (et) {
                    var tt = et.callbacks.indexOf(_e);
                    tt >= 0 && et.callbacks.splice(tt, 1), et.callbacks.length || observedNodes.delete(_), observedNodes.size || cancelAnimationFrame(rafId)
                }
            }
        }
    }
    var useIsomorphicLayoutEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect;

    function useRect(_, _e) {
        _e === void 0 && (_e = {
            width: 0,
            height: 0
        });
        var et = React.useState(_.current),
            tt = et[0],
            nt = et[1],
            ot = React.useReducer(rectReducer, _e),
            at = ot[0],
            st = ot[1],
            lt = React.useRef(!1);
        return useIsomorphicLayoutEffect(function() {
            _.current !== tt && nt(_.current)
        }), useIsomorphicLayoutEffect(function() {
            if (tt && !lt.current) {
                lt.current = !0;
                var ut = tt.getBoundingClientRect();
                st({
                    rect: ut
                })
            }
        }, [tt]), React.useEffect(function() {
            if (tt) {
                var ut = observeRect(tt, function(dt) {
                    st({
                        rect: dt
                    })
                });
                return ut.observe(),
                    function() {
                        ut.unobserve()
                    }
            }
        }, [tt]), at
    }

    function rectReducer(_, _e) {
        var et = _e.rect;
        return _.height !== et.height || _.width !== et.width ? et : _
    }
    var defaultEstimateSize = function _() {
            return 50
        },
        defaultKeyExtractor = function _(_e) {
            return _e
        },
        defaultMeasureSize = function _(_e, et) {
            var tt = et ? "offsetWidth" : "offsetHeight";
            return _e[tt]
        },
        defaultRangeExtractor = function _(_e) {
            for (var et = Math.max(_e.start - _e.overscan, 0), tt = Math.min(_e.end + _e.overscan, _e.size - 1), nt = [], ot = et; ot <= tt; ot++) nt.push(ot);
            return nt
        },
        useElementScroll = function _(_e) {
            var et = _e.parentRef,
                tt = _e.horizontal,
                nt = _e.useObserver,
                ot = _e.initialRect,
                at = tt ? "scrollLeft" : "scrollTop",
                st = React.useState(0),
                lt = st[0],
                ut = st[1],
                dt = React.useState(et.current),
                ct = dt[0],
                pt = dt[1];
            useIsomorphicLayoutEffect(function() {
                pt(et.current)
            }), useIsomorphicLayoutEffect(function() {
                if (!ct) {
                    ut(0);
                    return
                }
                var vt = function() {
                    ut(ct[at])
                };
                return vt(), ct.addEventListener("scroll", vt, {
                        capture: !1,
                        passive: !0
                    }),
                    function() {
                        ct.removeEventListener("scroll", vt)
                    }
            }, [ct, at]);
            var ft = React.useCallback(function(vt) {
                    et.current && (et.current[at] = vt)
                }, [et, at]),
                ht = nt || useRect,
                mt = tt ? "width" : "height",
                bt = ht(et, ot),
                gt = bt[mt];
            return {
                outerSize: gt,
                scrollOffset: lt,
                scrollToFn: ft
            }
        },
        useWindowRect = function _(_e, et) {
            et === void 0 && (et = {
                width: 0,
                height: 0
            });
            var tt = React.useState(et),
                nt = tt[0],
                ot = tt[1],
                at = React.useState(_e.current),
                st = at[0],
                lt = at[1];
            return useIsomorphicLayoutEffect(function() {
                lt(_e.current)
            }), useIsomorphicLayoutEffect(function() {
                if (!st) return;

                function ut() {
                    var dt = {
                        width: st.innerWidth,
                        height: st.innerHeight
                    };
                    ot(function(ct) {
                        return ct.height !== dt.height || ct.width !== dt.width ? dt : ct
                    })
                }
                return ut(), st.addEventListener("resize", ut),
                    function() {
                        st.removeEventListener("resize", ut)
                    }
            }, [st]), nt
        },
        useWindowScroll = function _(_e) {
            var et = _e.windowRef,
                tt = _e.parentRef,
                nt = _e.horizontal,
                ot = _e.useWindowObserver,
                at = _e.initialRect,
                st = React.useState(0),
                lt = st[0],
                ut = st[1],
                dt = React.useState(et.current),
                ct = dt[0],
                pt = dt[1],
                ft = React.useRef(0),
                ht = nt ? "left" : "top",
                mt = nt ? "scrollX" : "scrollY";
            useIsomorphicLayoutEffect(function() {
                pt(et.current)
            }), useIsomorphicLayoutEffect(function() {
                if (!ct) {
                    ft.current = 0, ut(0);
                    return
                }
                tt.current && (ft.current = ct[mt] + tt.current.getBoundingClientRect()[ht]);
                var Et = function() {
                    var wt = ct[mt] - ft.current;
                    ut(wt)
                };
                return Et(), ct.addEventListener("scroll", Et, {
                        capture: !1,
                        passive: !0
                    }),
                    function() {
                        ct.removeEventListener("scroll", Et)
                    }
            }, [ct, mt, ht, tt]);
            var bt = React.useCallback(function(Et, wt) {
                    if (et.current) {
                        var St, $t = ["ToIndex", "SizeChanged"].includes(wt) ? ft.current : 0;
                        et.current.scrollTo((St = {}, St[ht] = Et + $t, St))
                    }
                }, [et, ht]),
                gt = ot || useWindowRect,
                vt = nt ? "width" : "height",
                xt = gt(et, at),
                yt = xt[vt];
            return {
                outerSize: yt,
                scrollOffset: lt,
                scrollToFn: bt
            }
        },
        useDefaultScroll = function _(_e) {
            var et = _e.parentRef,
                tt = _e.windowRef,
                nt = tt !== void 0,
                ot = React.useRef(null),
                at = useElementScroll(_extends$1(_extends$1({}, _e), {}, {
                    parentRef: nt ? ot : et
                })),
                st = useWindowScroll(_extends$1(_extends$1({}, _e), {}, {
                    windowRef: nt ? tt : ot
                }));
            return nt ? st : at
        };

    function useVirtual(_) {
        var _e, et = _.size,
            tt = et === void 0 ? 0 : et,
            nt = _.estimateSize,
            ot = nt === void 0 ? defaultEstimateSize : nt,
            at = _.overscan,
            st = at === void 0 ? 1 : at,
            lt = _.paddingStart,
            ut = lt === void 0 ? 0 : lt,
            dt = _.paddingEnd,
            ct = dt === void 0 ? 0 : dt,
            pt = _.parentRef,
            ft = _.windowRef,
            ht = _.horizontal,
            mt = _.scrollToFn,
            bt = _.useObserver,
            gt = _.useWindowObserver,
            vt = _.initialRect,
            xt = _.keyExtractor,
            yt = xt === void 0 ? defaultKeyExtractor : xt,
            Et = _.measureSize,
            wt = Et === void 0 ? defaultMeasureSize : Et,
            St = _.rangeExtractor,
            $t = St === void 0 ? defaultRangeExtractor : St,
            Ct = _.useScroll,
            Rt = Ct === void 0 ? useDefaultScroll : Ct,
            Pt = React.useRef({
                scrollOffset: 0,
                measurements: []
            }),
            Tt = Rt({
                windowRef: ft,
                parentRef: pt,
                horizontal: ht,
                useObserver: bt,
                useWindowObserver: gt,
                initialRect: vt
            }),
            It = Tt.outerSize,
            Ot = Tt.scrollOffset,
            Dt = Tt.scrollToFn,
            jt = React.useRef(Ot);
        Pt.current.scrollOffset !== Ot && (jt.current = Ot), Pt.current.outerSize = It, Pt.current.scrollOffset = Ot;
        var Ht = React.useCallback(function(nr, ar) {
                var _t = mt || function(yr) {
                    return Dt(yr, ar)
                };
                _t(nr, Dt)
            }, [mt, Dt]),
            Mt = React.useState({}),
            Ft = Mt[0],
            Vt = Mt[1],
            Zt = React.useCallback(function() {
                return Vt({})
            }, []),
            Jt = React.useRef([]),
            qt = React.useMemo(function() {
                var nr = Jt.current.length > 0 ? Math.min.apply(Math, Jt.current) : 0;
                Jt.current = [];
                for (var ar = Pt.current.measurements.slice(0, nr), _t = nr; _t < tt; _t++) {
                    var yr = yt(_t),
                        fr = Ft[yr],
                        ir = ar[_t - 1] ? ar[_t - 1].end : ut,
                        vr = typeof fr == "number" ? fr : ot(_t),
                        $r = ir + vr;
                    ar[_t] = {
                        index: _t,
                        start: ir,
                        size: vr,
                        end: $r,
                        key: yr
                    }
                }
                return ar
            }, [ot, Ft, ut, tt, yt]),
            Kt = (((_e = qt[tt - 1]) == null ? void 0 : _e.end) || 0) + ct;
        Pt.current.measurements = qt, Pt.current.totalSize = Kt;
        var mr = calculateRange(Pt.current),
            pr = mr.start,
            xr = mr.end,
            er = React.useMemo(function() {
                return $t({
                    start: pr,
                    end: xr,
                    overscan: st,
                    size: qt.length
                })
            }, [pr, xr, st, qt.length, $t]),
            wr = React.useRef(wt);
        wr.current = wt;
        var kr = React.useMemo(function() {
                for (var nr = [], ar = function(fr, ir) {
                        var vr = er[fr],
                            $r = qt[vr],
                            br = _extends$1(_extends$1({}, $r), {}, {
                                measureRef: function(jr) {
                                    if (jr) {
                                        var Er = wr.current(jr, ht);
                                        if (Er !== br.size) {
                                            var Ar = Pt.current.scrollOffset;
                                            if (br.start < Ar) {
                                                var Br = Er - br.size;
                                                jt.current += Br, Dt(jt.current, "SizeChanged")
                                            }
                                            Jt.current.push(vr), Vt(function(Nr) {
                                                var Ir;
                                                return _extends$1(_extends$1({}, Nr), {}, (Ir = {}, Ir[br.key] = Er, Ir))
                                            })
                                        }
                                    }
                                }
                            });
                        nr.push(br)
                    }, _t = 0, yr = er.length; _t < yr; _t++) ar(_t);
                return nr
            }, [er, Dt, ht, qt]),
            Sr = React.useRef(!1);
        useIsomorphicLayoutEffect(function() {
            Sr.current && Vt({}), Sr.current = !0
        }, [ot]);
        var lr = React.useCallback(function(nr, ar, _t) {
                var yr = ar === void 0 ? {} : ar,
                    fr = yr.align,
                    ir = fr === void 0 ? "start" : fr;
                _t === void 0 && (_t = "ToOffset");
                var vr = Pt.current,
                    $r = vr.scrollOffset,
                    br = vr.outerSize;
                ir === "auto" && (nr <= $r ? ir = "start" : nr >= $r + br ? ir = "end" : ir = "start"), ir === "start" ? Ht(nr, _t) : ir === "end" ? Ht(nr - br, _t) : ir === "center" && Ht(nr - br / 2, _t)
            }, [Ht]),
            ur = React.useCallback(function(nr, ar) {
                var _t = ar === void 0 ? {} : ar,
                    yr = _t.align,
                    fr = yr === void 0 ? "auto" : yr,
                    ir = _objectWithoutPropertiesLoose(_t, ["align"]),
                    vr = Pt.current,
                    $r = vr.measurements,
                    br = vr.scrollOffset,
                    jr = vr.outerSize,
                    Er = $r[Math.max(0, Math.min(nr, tt - 1))];
                if (Er) {
                    if (fr === "auto")
                        if (Er.end >= br + jr) fr = "end";
                        else if (Er.start <= br) fr = "start";
                    else return;
                    var Ar = fr === "center" ? Er.start + Er.size / 2 : fr === "end" ? Er.end : Er.start;
                    lr(Ar, _extends$1({
                        align: fr
                    }, ir), "ToIndex")
                }
            }, [lr, tt]),
            Rr = React.useCallback(function() {
                for (var nr = arguments.length, ar = new Array(nr), _t = 0; _t < nr; _t++) ar[_t] = arguments[_t];
                ur.apply(void 0, ar), requestAnimationFrame(function() {
                    ur.apply(void 0, ar)
                })
            }, [ur]);
        return {
            virtualItems: kr,
            totalSize: Kt,
            scrollToOffset: lr,
            scrollToIndex: Rr,
            measure: Zt
        }
    }
    var findNearestBinarySearch = function _(_e, et, tt, nt) {
        for (; _e <= et;) {
            var ot = (_e + et) / 2 | 0,
                at = tt(ot);
            if (at < nt) _e = ot + 1;
            else if (at > nt) et = ot - 1;
            else return ot
        }
        return _e > 0 ? _e - 1 : 0
    };

    function calculateRange(_) {
        for (var _e = _.measurements, et = _.outerSize, tt = _.scrollOffset, nt = _e.length - 1, ot = function(lt) {
                return _e[lt].start
            }, at = findNearestBinarySearch(0, nt, ot, tt), st = at; st < nt && _e[st].end < tt + et;) st++;
        return {
            start: at,
            end: st
        }
    }

    function FlatList(_, _e) {
        const vt = _,
            {
                data: et,
                overscan: tt = 2,
                estimateSize: nt,
                paddingStart: ot,
                paddingEnd: at,
                windowScroll: st,
                renderItem: lt,
                keyExtractor: ut,
                children: dt,
                onRangeChange: ct,
                virtualRef: pt
            } = vt,
            ft = Wt(vt, ["data", "overscan", "estimateSize", "paddingStart", "paddingEnd", "windowScroll", "renderItem", "keyExtractor", "children", "onRangeChange", "virtualRef"]),
            ht = reactExports.useRef(null),
            mt = useMergeRefs(ht, _e),
            bt = useVirtual({
                size: et.length,
                parentRef: ht,
                overscan: tt,
                estimateSize: nt,
                paddingStart: ot,
                paddingEnd: at,
                keyExtractor: ut,
                useObserver,
                rangeExtractor: useBatchRange(ct)
            });
        pt && (pt.current = {
            scrollToIndex: bt.scrollToIndex,
            scrollToOffset: bt.scrollToOffset
        });
        const gt = usePool(bt.virtualItems, et, lt, nt);
        return reactExports.useMemo(() => {
            if (st) {
                const xt = ft,
                    {
                        className: yt
                    } = xt,
                    Et = Wt(xt, ["className"]);
                return jsxRuntimeExports.jsxs(motion.div, Bt(kt({
                    className: cx$1(flatContainerStyle, yt)
                }, Et), {
                    style: {
                        height: bt.totalSize
                    },
                    children: [dt, gt]
                }))
            }
            return jsxRuntimeExports.jsx(ScrollView, Bt(kt({}, ft), {
                ref: mt,
                children: jsxRuntimeExports.jsxs("div", {
                    className: flatContainerStyle,
                    style: {
                        height: bt.totalSize
                    },
                    children: [dt, gt]
                })
            }))
        }, [bt.totalSize, gt, st, _])
    }
    let VirtualItemWrap;
    FlatList$1 = React.memo(React.forwardRef(FlatList)), VirtualItemWrap = React.memo(function _({
        start: _e,
        children: et,
        used: tt,
        estimateSize: nt
    }) {
        const ot = {
            transform: `translateY(${_e}px)`
        };
        return tt || (ot.display = "none"), jsxRuntimeExports.jsx(ActiveProvider, {
            value: tt,
            children: jsxRuntimeExports.jsx("div", {
                className: "flat-item",
                style: ot,
                ref: nt,
                children: et
            })
        })
    }, (_, _e) => !(_.start !== _e.start || _.used !== _e.used));

    function useBatchRange(_) {
        const _e = reactExports.useRef({
            start: 0,
            end: -1,
            indexs: []
        });
        return reactExports.useCallback(et => {
            const tt = _e.current,
                nt = Math.max(et.start - et.overscan, 0),
                ot = Math.max(Math.min(et.end + et.overscan, et.size - 1), nt);
            if (nt < tt.start || ot > tt.end || nt === ot) {
                const at = Math.max(et.start - et.overscan * 2, 0),
                    st = Math.max(Math.min(et.end + et.overscan * 2, et.size - 1), at),
                    lt = [];
                for (let ut = at; ut <= st; ut++) lt.push(ut);
                tt.start = at, tt.end = st, tt.indexs = lt
            }
            return _ && setTimeout(() => _(et.start, et.end), 0), tt.indexs
        }, [])
    }

    function usePool(_, _e, et, tt) {
        const nt = reactExports.useRef(_e),
            [ot] = reactExports.useState(() => ({
                usedPool: new Set,
                pool: new Array,
                unUsedPool: new Map
            }));
        return nt.current !== _e && (ot.usedPool = new Set, ot.pool = new Array, ot.unUsedPool = new Map, nt.current = _e), reactExports.useMemo(() => {
            const at = _.reduce((st, lt) => st.set(lt.index, lt), new Map);
            return ot.pool.forEach(st => {
                const lt = st.item.index;
                if (st.used) {
                    const ut = at.get(lt);
                    (!ut || ut.size !== st.item.size || ut.start !== st.item.start) && (st.used = !1, ot.usedPool.delete(lt), ot.unUsedPool.get(st.element.type).push(st))
                }
            }), _.forEach(st => {
                const lt = st.index,
                    ut = ot.usedPool.has(lt),
                    dt = _e[st.index];
                if (!ut && dt) {
                    const ct = et(dt);
                    let pt = ot.unUsedPool.get(ct.type);
                    pt || (pt = [], ot.unUsedPool.set(ct.type, pt));
                    let ft = pt.pop();
                    ft || (ft = {
                        index: ot.pool.length,
                        used: !0,
                        item: st,
                        element: ct
                    }, ot.pool.push(ft)), ft.used = !0, ft.item = st, ft.element = ct, ot.usedPool.add(lt)
                }
            }), ot.pool.map(({
                index: st,
                item: lt,
                used: ut,
                element: dt
            }) => jsxRuntimeExports.jsx(VirtualItemWrap, {
                start: lt.start,
                children: dt,
                used: ut,
                estimateSize: tt ? void 0 : lt.measureRef
            }, st))
        }, [_, _e, et])
    }

    function useObserver(_) {
        const [_e, et] = reactExports.useState({
            height: 0,
            width: 0
        });
        return useIsomorphicEffect(() => {
            const tt = _.current;
            tt && et({
                width: tt.clientWidth,
                height: tt.clientHeight
            })
        }, [_]), _e
    }
    const flatContainerStyle = "fzzoavm",
        baseArrowStyle = {
            position: "absolute",
            width: "50px",
            height: "50px",
            backgroundColor: "rgba(0,0,0,0.5)",
            top: "50%",
            transform: "translateY(-50%)",
            borderRadius: "50%",
            color: "#fff",
            fontSize: "20px",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "pointer"
        },
        Arrow = ({
            left: _ = !1,
            children: _e,
            onClick: et
        }) => jsxRuntimeExports.jsx("div", {
            onClick: et,
            style: Bt(kt({}, baseArrowStyle), {
                left: _ ? "20px" : "initial",
                right: _ ? "initial" : "10px"
            }),
            children: _e
        }),
        dotWrapStyle = {
            position: "absolute",
            bottom: "10px",
            left: "50%",
            transform: "translateX(-50%)"
        },
        dotItemStyle = {
            width: "20px",
            height: "20px",
            borderRadius: "50%",
            margin: "0 10px",
            display: "inline-block",
            cursor: "pointer"
        },
        Dots = ({
            length: _,
            activeIndex: _e,
            setActiveIndex: et
        }) => jsxRuntimeExports.jsx("div", {
            style: dotWrapStyle,
            children: new Array(_).fill("").map((tt, nt) => jsxRuntimeExports.jsx("span", {
                onClick: () => et(nt),
                style: Bt(kt({}, dotItemStyle), {
                    background: nt === _e ? "#000" : "#999",
                    transform: `scale(${nt===_e?1.3:1})`
                })
            }, nt))
        });

    function useContainer() {
        const _ = reactExports.useRef(null);
        return reactExports.useEffect(() => {
            var _e;
            const et = ((_e = _.current) == null ? void 0 : _e.getElementsByTagName("*")) || [];
            for (const tt of et) tt.setAttribute("draggable", "false")
        }, [_.current]), _
    }
    const pageStyle = {
            display: "flex"
        },
        containerStyle = "c1mxe6k6",
        transition = {
            type: "spring",
            stiffness: 50
        },
        Carousel = reactExports.forwardRef(({
            children: _,
            renderArrowLeft: _e,
            renderArrowRight: et,
            renderDots: tt,
            autoPlay: nt = !0,
            interval: ot = 2e3,
            loop: at = !0,
            direction: st,
            className: lt = "",
            spaceBetween: ut = 0,
            slidesPerGroup: dt,
            pauseOnMouseEnter: ct,
            disableOnInteraction: pt
        }, ft) => {
            var ht, mt, bt, gt;
            const [vt, xt] = reactExports.useState(0), yt = useContainer(), Et = reactExports.useRef(null), [wt, St] = reactExports.useState(0), [$t, Ct] = reactExports.useState(nt), Rt = st === "horizontal", Pt = Rt ? ((ht = yt.current) == null ? void 0 : ht.clientWidth) || 0 : ((mt = yt.current) == null ? void 0 : mt.clientHeight) || 0, Tt = Rt ? ((bt = Et.current) == null ? void 0 : bt.clientWidth) || 0 : ((gt = Et.current) == null ? void 0 : gt.clientHeight) || 0, It = reactExports.Children.toArray(_), Ot = Tt / It.length, Dt = () => Tt > Pt && dt && jt ? xt(-wt * Ot) : xt(-wt * Pt), jt = dt ? Math.ceil((Tt - Pt) / Ot) + 1 : It.length, Ht = dt ? Ot : Tt, Mt = (er, wr) => {
                qt(!1);
                const {
                    point: kr,
                    offset: Sr
                } = wr, lr = Rt ? Sr.x : Sr.y;
                if (wt + 1 >= jt && lr < 0) {
                    Ft();
                    return
                }
                if (wt <= 0 && lr > 0) {
                    Vt();
                    return
                }
                if (!dt) {
                    if (lr > 0) {
                        Vt();
                        return
                    }
                    if (lr < 0) {
                        Ft();
                        return
                    }
                    return
                }
                if (lr > Ht / 4) {
                    const ur = wt - Math.ceil(lr / Ht),
                        Rr = at ? jt - 1 : 0;
                    St(ur < 0 ? Rr : ur)
                } else if (lr < -Ht / 4) {
                    const ur = wt + Math.ceil(-lr / Ht),
                        Rr = at ? 0 : jt - 1;
                    St(ur >= jt ? Rr : ur)
                } else Dt()
            }, Ft = () => {
                const er = at ? 0 : wt;
                St(wt + 1 >= jt ? er : wt + 1)
            }, Vt = () => {
                const er = at ? jt - 1 : 0;
                St(wt - 1 < 0 ? er : wt - 1)
            };
            reactExports.useEffect(() => {
                Dt()
            }, [wt]), reactExports.useEffect(() => {
                if (!$t) return;
                const er = setInterval(() => Ft(), ot);
                return () => clearInterval(er)
            }, [Ft, ot, $t]), reactExports.useImperativeHandle(ft, () => ({
                handleNext: Ft,
                handlePrev: Vt,
                setIndex: St
            }), [wt]);
            const Zt = Rt ? "x" : "y",
                [Jt, qt] = reactExports.useState(!1),
                Kt = reactExports.useMemo(() => Bt(kt({}, pageStyle), {
                    pointerEvents: Jt ? "none" : "auto",
                    width: `${It.length*100}%`
                }), [Rt, Jt, Et.current]),
                mr = reactExports.useCallback(() => {
                    ct && Ct(!1)
                }, [ct, Ct]),
                pr = reactExports.useCallback(() => {
                    !pt && ct && Ct(!0)
                }, [pt, ct, Ct]),
                xr = (er, wr) => {
                    qt(!0)
                };
            return jsxRuntimeExports.jsxs("div", {
                ref: yt,
                className: cx$1(containerStyle, st, lt),
                children: [jsxRuntimeExports.jsx(motion.div, {
                    style: Kt,
                    drag: jt > 1 && Zt,
                    onHoverStart: mr,
                    onHoverEnd: pr,
                    onPanEnd: Mt,
                    onPanStart: xr,
                    dragElastic: .3,
                    ref: Et,
                    animate: {
                        x: vt
                    },
                    transition,
                    initial: {
                        x: 0
                    },
                    children: It.map((er, wr) => {
                        const kr = reactExports.Children.count(er.children) > 0 || wr === It.length - 1 ? 0 : ut;
                        return jsxRuntimeExports.jsx("div", {
                            className: "swiper-slide",
                            style: dt ? Rt ? {
                                marginRight: kr
                            } : {
                                marginBottom: kr
                            } : {},
                            children: er
                        }, wr)
                    })
                }), _e ? _e({
                    handlePrev: Vt,
                    activeIndex: wt
                }) : jsxRuntimeExports.jsx(Arrow, {
                    left: !0,
                    onClick: Vt,
                    children: "\u2190"
                }), et ? et({
                    handleNext: Ft,
                    activeIndex: wt
                }) : jsxRuntimeExports.jsx(Arrow, {
                    onClick: Ft,
                    children: "\u2192"
                }), tt ? tt({
                    setActiveIndex: St,
                    activeIndex: wt
                }) : jsxRuntimeExports.jsx(Dots, {
                    length: jt,
                    setActiveIndex: St,
                    activeIndex: wt
                })]
            })
        });

    function Swiper(_) {
        const {
            autoplay: _e,
            spaceBetween: et,
            navigation: tt,
            children: nt,
            speed: ot,
            threshold: at,
            slidesPerView: st,
            pagination: lt,
            loop: ut = !1,
            direction: dt = "horizontal",
            className: ct = "",
            initialSlide: pt = 0,
            slidesPerGroup: ft
        } = _, {
            disableOnInteraction: ht = !0,
            pauseOnMouseEnter: mt = !1,
            delay: bt = 0
        } = _e || {}, gt = reactExports.useRef(), [vt, xt] = reactExports.useState(bt !== 0);
        reactExports.useEffect(() => {
            xt(bt !== 0)
        }, [bt]);
        const {
            prevEl: yt,
            nextEl: Et
        } = tt || {};
        return reactExports.useEffect(() => {
            const wt = St => {
                St.composedPath().forEach($t => {
                    var Ct, Rt;
                    (Ct = $t.classList) != null && Ct.contains(yt == null ? void 0 : yt.slice(1)) && gt.current.handlePrev(), (Rt = $t.classList) != null && Rt.contains(Et == null ? void 0 : Et.slice(1)) && gt.current.handleNext()
                })
            };
            return window.addEventListener("click", wt), () => {
                window.removeEventListener("click", wt)
            }
        }, [yt, Et]), reactExports.useEffect(() => {
            gt.current.setIndex(pt)
        }, []), jsxRuntimeExports.jsx(Carousel, {
            direction: dt,
            autoPlay: vt,
            interval: bt,
            loop: ut,
            ref: gt,
            renderArrowLeft: () => null,
            renderArrowRight: () => null,
            renderDots: ({
                activeIndex: wt,
                setActiveIndex: St
            }) => {
                if (lt) {
                    const $t = document.querySelector(lt.el);
                    return $t && reactDomExports.createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                        children: reactExports.Children.map(nt, (Ct, Rt) => jsxRuntimeExports.jsx("span", {
                            className: Rt === wt ? "swiper-pagination-bullet-active" : "",
                            onClick: () => {
                                lt.clickable && St(Rt)
                            }
                        }))
                    }), $t)
                }
            },
            className: ct,
            slidesPerGroup: ft,
            pauseOnMouseEnter: mt,
            disableOnInteraction: ht,
            spaceBetween: et,
            children: nt
        })
    }
    let navPathViews;
    Breadcrumb = React.memo(function _({
        list: _e
    }) {
        return jsxRuntimeExports.jsx("div", {
            className: `${navPathViews} ui-breadcrumb`,
            children: _e.map((et, tt) => jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [tt > 0 && jsxRuntimeExports.jsx(Icon, {
                    name: "Arrow"
                }), jsxRuntimeExports.jsx(Link, {
                    className: cx("path", tt === _e.length - 1 ? "active" : "hover"),
                    href: tt < _e.length - 1 ? et.path : "",
                    title: et.label,
                    children: et.label
                })]
            }, tt))
        })
    }), navPathViews = "n35pyk1";

    function _extends() {
        return _extends = Object.assign ? Object.assign.bind() : function(_) {
            for (var _e = 1; _e < arguments.length; _e++) {
                var et = arguments[_e];
                for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (_[tt] = et[tt])
            }
            return _
        }, _extends.apply(this, arguments)
    }
    var voidElements = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    };
    const e = getDefaultExportFromCjs(voidElements);
    var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;

    function n(_) {
        var _e = {
                type: "tag",
                name: "",
                voidElement: !1,
                attrs: {},
                children: []
            },
            et = _.match(/<\/?([^\s]+?)[/\s>]/);
        if (et && (_e.name = et[1], (e[et[1]] || _.charAt(_.length - 2) === "/") && (_e.voidElement = !0), _e.name.startsWith("!--"))) {
            var tt = _.indexOf("-->");
            return {
                type: "comment",
                comment: tt !== -1 ? _.slice(4, tt) : ""
            }
        }
        for (var nt = new RegExp(t), ot = null;
            (ot = nt.exec(_)) !== null;)
            if (ot[0].trim())
                if (ot[1]) {
                    var at = ot[1].trim(),
                        st = [at, ""];
                    at.indexOf("=") > -1 && (st = at.split("=")), _e.attrs[st[0]] = st[1], nt.lastIndex--
                } else ot[2] && (_e.attrs[ot[2]] = ot[3].trim().substring(1, ot[3].length - 1));
        return _e
    }
    var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
        i = /^\s*$/,
        s = Object.create(null);

    function a(_, _e) {
        switch (_e.type) {
            case "text":
                return _ + _e.content;
            case "tag":
                return _ += "<" + _e.name + (_e.attrs ? function(et) {
                    var tt = [];
                    for (var nt in et) tt.push(nt + '="' + et[nt] + '"');
                    return tt.length ? " " + tt.join(" ") : ""
                }(_e.attrs) : "") + (_e.voidElement ? "/>" : ">"), _e.voidElement ? _ : _ + _e.children.reduce(a, "") + "</" + _e.name + ">";
            case "comment":
                return _ + "<!--" + _e.comment + "-->"
        }
    }
    var c = {
        parse: function(_, _e) {
            _e || (_e = {}), _e.components || (_e.components = s);
            var et, tt = [],
                nt = [],
                ot = -1,
                at = !1;
            if (_.indexOf("<") !== 0) {
                var st = _.indexOf("<");
                tt.push({
                    type: "text",
                    content: st === -1 ? _ : _.substring(0, st)
                })
            }
            return _.replace(r, function(lt, ut) {
                if (at) {
                    if (lt !== "</" + et.name + ">") return;
                    at = !1
                }
                var dt, ct = lt.charAt(1) !== "/",
                    pt = lt.startsWith("<!--"),
                    ft = ut + lt.length,
                    ht = _.charAt(ft);
                if (pt) {
                    var mt = n(lt);
                    return ot < 0 ? (tt.push(mt), tt) : ((dt = nt[ot]).children.push(mt), tt)
                }
                if (ct && (ot++, (et = n(lt)).type === "tag" && _e.components[et.name] && (et.type = "component", at = !0), et.voidElement || at || !ht || ht === "<" || et.children.push({
                        type: "text",
                        content: _.slice(ft, _.indexOf("<", ft))
                    }), ot === 0 && tt.push(et), (dt = nt[ot - 1]) && dt.children.push(et), nt[ot] = et), (!ct || et.voidElement) && (ot > -1 && (et.voidElement || et.name === lt.slice(2, -1)) && (ot--, et = ot === -1 ? tt : nt[ot]), !at && ht !== "<" && ht)) {
                    dt = ot === -1 ? tt : nt[ot].children;
                    var bt = _.indexOf("<", ft),
                        gt = _.slice(ft, bt === -1 ? void 0 : bt);
                    i.test(gt) && (gt = " "), (bt > -1 && ot + dt.length >= 0 || gt !== " ") && dt.push({
                        type: "text",
                        content: gt
                    })
                }
            }), tt
        },
        stringify: function(_) {
            return _.reduce(function(_e, et) {
                return _e + a("", et)
            }, "")
        }
    };

    function warn() {
        if (console && console.warn) {
            for (var _ = arguments.length, _e = new Array(_), et = 0; et < _; et++) _e[et] = arguments[et];
            typeof _e[0] == "string" && (_e[0] = `react-i18next:: ${_e[0]}`), console.warn(..._e)
        }
    }
    const alreadyWarned = {};

    function warnOnce() {
        for (var _ = arguments.length, _e = new Array(_), et = 0; et < _; et++) _e[et] = arguments[et];
        typeof _e[0] == "string" && alreadyWarned[_e[0]] || (typeof _e[0] == "string" && (alreadyWarned[_e[0]] = new Date), warn(..._e))
    }
    const loadedClb = (_, _e) => () => {
        if (_.isInitialized) _e();
        else {
            const et = () => {
                setTimeout(() => {
                    _.off("initialized", et)
                }, 0), _e()
            };
            _.on("initialized", et)
        }
    };

    function loadNamespaces(_, _e, et) {
        _.loadNamespaces(_e, loadedClb(_, et))
    }

    function loadLanguages(_, _e, et, tt) {
        typeof et == "string" && (et = [et]), et.forEach(nt => {
            _.options.ns.indexOf(nt) < 0 && _.options.ns.push(nt)
        }), _.loadLanguages(_e, loadedClb(_, tt))
    }

    function oldI18nextHasLoadedNamespace(_, _e) {
        let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const tt = _e.languages[0],
            nt = _e.options ? _e.options.fallbackLng : !1,
            ot = _e.languages[_e.languages.length - 1];
        if (tt.toLowerCase() === "cimode") return !0;
        const at = (st, lt) => {
            const ut = _e.services.backendConnector.state[`${st}|${lt}`];
            return ut === -1 || ut === 2
        };
        return et.bindI18n && et.bindI18n.indexOf("languageChanging") > -1 && _e.services.backendConnector.backend && _e.isLanguageChangingTo && !at(_e.isLanguageChangingTo, _) ? !1 : !!(_e.hasResourceBundle(tt, _) || !_e.services.backendConnector.backend || _e.options.resources && !_e.options.partialBundledLanguages || at(tt, _) && (!nt || at(ot, _)))
    }

    function hasLoadedNamespace(_, _e) {
        let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return !_e.languages || !_e.languages.length ? (warnOnce("i18n.languages were undefined or empty", _e.languages), !0) : _e.options.ignoreJSONStructure !== void 0 ? _e.hasLoadedNamespace(_, {
            lng: et.lng,
            precheck: (tt, nt) => {
                if (et.bindI18n && et.bindI18n.indexOf("languageChanging") > -1 && tt.services.backendConnector.backend && tt.isLanguageChangingTo && !nt(tt.isLanguageChangingTo, _)) return !1
            }
        }) : oldI18nextHasLoadedNamespace(_, _e, et)
    }
    const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
        htmlEntities = {
            "&amp;": "&",
            "&#38;": "&",
            "&lt;": "<",
            "&#60;": "<",
            "&gt;": ">",
            "&#62;": ">",
            "&apos;": "'",
            "&#39;": "'",
            "&quot;": '"',
            "&#34;": '"',
            "&nbsp;": " ",
            "&#160;": " ",
            "&copy;": "\xA9",
            "&#169;": "\xA9",
            "&reg;": "\xAE",
            "&#174;": "\xAE",
            "&hellip;": "\u2026",
            "&#8230;": "\u2026",
            "&#x2F;": "/",
            "&#47;": "/"
        },
        unescapeHtmlEntity = _ => htmlEntities[_],
        unescape$1 = _ => _.replace(matchHtmlEntity, unescapeHtmlEntity);
    let defaultOptions = {
        bindI18n: "languageChanged",
        bindI18nStore: "",
        transEmptyNodeValue: "",
        transSupportBasicHtmlNodes: !0,
        transWrapTextNodes: "",
        transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
        useSuspense: !0,
        unescape: unescape$1
    };

    function setDefaults() {
        let _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        defaultOptions = kt(kt({}, defaultOptions), _)
    }

    function getDefaults() {
        return defaultOptions
    }
    let i18nInstance;

    function setI18n(_) {
        i18nInstance = _
    }

    function getI18n() {
        return i18nInstance
    }

    function hasChildren(_, _e) {
        if (!_) return !1;
        const et = _.props ? _.props.children : _.children;
        return _e ? et.length > 0 : !!et
    }

    function getChildren(_) {
        if (!_) return [];
        const _e = _.props ? _.props.children : _.children;
        return _.props && _.props.i18nIsDynamicList ? getAsArray(_e) : _e
    }

    function hasValidReactChildren(_) {
        return Object.prototype.toString.call(_) !== "[object Array]" ? !1 : _.every(_e => reactExports.isValidElement(_e))
    }

    function getAsArray(_) {
        return Array.isArray(_) ? _ : [_]
    }

    function mergeProps(_, _e) {
        const et = kt({}, _e);
        return et.props = Object.assign(_.props, _e.props), et
    }

    function nodesToString(_, _e) {
        if (!_) return "";
        let et = "";
        const tt = getAsArray(_),
            nt = _e.transSupportBasicHtmlNodes && _e.transKeepBasicHtmlNodesFor ? _e.transKeepBasicHtmlNodesFor : [];
        return tt.forEach((ot, at) => {
            if (typeof ot == "string") et += `${ot}`;
            else if (reactExports.isValidElement(ot)) {
                const lt = Object.keys(ot.props).length,
                    ut = nt.indexOf(ot.type) > -1,
                    dt = ot.props.children;
                if (!dt && ut && lt === 0) et += `<${ot.type}/>`;
                else if (!dt && (!ut || lt !== 0)) et += `<${at}></${at}>`;
                else if (ot.props.i18nIsDynamicList) et += `<${at}></${at}>`;
                else if (ut && lt === 1 && typeof dt == "string") et += `<${ot.type}>${dt}</${ot.type}>`;
                else {
                    const ct = nodesToString(dt, _e);
                    et += `<${at}>${ct}</${at}>`
                }
            } else if (ot === null) warn("Trans: the passed in value is invalid - seems you passed in a null child.");
            else if (typeof ot == "object") {
                const st = ot,
                    {
                        format: lt
                    } = st,
                    ut = Wt(st, ["format"]),
                    dt = Object.keys(ut);
                if (dt.length === 1) {
                    const ct = lt ? `${dt[0]}, ${lt}` : dt[0];
                    et += `{{${ct}}}`
                } else warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", ot)
            } else warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", ot)
        }), et
    }

    function renderNodes(_, _e, et, tt, nt, ot) {
        if (_e === "") return [];
        const at = tt.transKeepBasicHtmlNodesFor || [],
            st = _e && new RegExp(at.map(bt => `<${bt}`).join("|")).test(_e);
        if (!_ && !st && !ot) return [_e];
        const lt = {};

        function ut(bt) {
            getAsArray(bt).forEach(gt => {
                typeof gt != "string" && (hasChildren(gt) ? ut(getChildren(gt)) : typeof gt == "object" && !reactExports.isValidElement(gt) && Object.assign(lt, gt))
            })
        }
        ut(_);
        const dt = c.parse(`<0>${_e}</0>`),
            ct = kt(kt({}, lt), nt);

        function pt(bt, gt, vt) {
            const xt = getChildren(bt),
                yt = ht(xt, gt.children, vt);
            return hasValidReactChildren(xt) && yt.length === 0 || bt.props && bt.props.i18nIsDynamicList ? xt : yt
        }

        function ft(bt, gt, vt, xt, yt) {
            bt.dummy ? (bt.children = gt, vt.push(reactExports.cloneElement(bt, {
                key: xt
            }, yt ? void 0 : gt))) : vt.push(...reactExports.Children.map([bt], Et => {
                const wt = kt({}, Et.props);
                return delete wt.i18nIsDynamicList, React.createElement(Et.type, _extends({}, wt, {
                    key: xt,
                    ref: Et.ref
                }, yt ? {} : {
                    children: gt
                }))
            }))
        }

        function ht(bt, gt, vt) {
            const xt = getAsArray(bt);
            return getAsArray(gt).reduce((yt, Et, wt) => {
                const St = Et.children && Et.children[0] && Et.children[0].content && et.services.interpolator.interpolate(Et.children[0].content, ct, et.language);
                if (Et.type === "tag") {
                    let $t = xt[parseInt(Et.name, 10)];
                    vt.length === 1 && !$t && ($t = vt[0][Et.name]), $t || ($t = {});
                    const Ct = Object.keys(Et.attrs).length !== 0 ? mergeProps({
                            props: Et.attrs
                        }, $t) : $t,
                        Rt = reactExports.isValidElement(Ct),
                        Pt = Rt && hasChildren(Et, !0) && !Et.voidElement,
                        Tt = st && typeof Ct == "object" && Ct.dummy && !Rt,
                        It = typeof _ == "object" && _ !== null && Object.hasOwnProperty.call(_, Et.name);
                    if (typeof Ct == "string") {
                        const Ot = et.services.interpolator.interpolate(Ct, ct, et.language);
                        yt.push(Ot)
                    } else if (hasChildren(Ct) || Pt) {
                        const Ot = pt(Ct, Et, vt);
                        ft(Ct, Ot, yt, wt)
                    } else if (Tt) {
                        const Ot = ht(xt, Et.children, vt);
                        ft(Ct, Ot, yt, wt)
                    } else if (Number.isNaN(parseFloat(Et.name)))
                        if (It) {
                            const Ot = pt(Ct, Et, vt);
                            ft(Ct, Ot, yt, wt, Et.voidElement)
                        } else if (tt.transSupportBasicHtmlNodes && at.indexOf(Et.name) > -1)
                        if (Et.voidElement) yt.push(reactExports.createElement(Et.name, {
                            key: `${Et.name}-${wt}`
                        }));
                        else {
                            const Ot = ht(xt, Et.children, vt);
                            yt.push(reactExports.createElement(Et.name, {
                                key: `${Et.name}-${wt}`
                            }, Ot))
                        }
                    else if (Et.voidElement) yt.push(`<${Et.name} />`);
                    else {
                        const Ot = ht(xt, Et.children, vt);
                        yt.push(`<${Et.name}>${Ot}</${Et.name}>`)
                    } else if (typeof Ct == "object" && !Rt) {
                        const Ot = Et.children[0] ? St : null;
                        Ot && yt.push(Ot)
                    } else ft(Ct, St, yt, wt, Et.children.length !== 1 || !St)
                } else if (Et.type === "text") {
                    const $t = tt.transWrapTextNodes,
                        Ct = ot ? tt.unescape(et.services.interpolator.interpolate(Et.content, ct, et.language)) : et.services.interpolator.interpolate(Et.content, ct, et.language);
                    $t ? yt.push(reactExports.createElement($t, {
                        key: `${Et.name}-${wt}`
                    }, Ct)) : yt.push(Ct)
                }
                return yt
            }, [])
        }
        const mt = ht([{
            dummy: !0,
            children: _ || []
        }], dt, getAsArray(_ || []));
        return getChildren(mt[0])
    }

    function Trans$2(_) {
        let Tt = _,
            {
                children: _e,
                count: et,
                parent: tt,
                i18nKey: nt,
                context: ot,
                tOptions: at = {},
                values: st,
                defaults: lt,
                components: ut,
                ns: dt,
                i18n: ct,
                t: pt,
                shouldUnescape: ft
            } = Tt,
            ht = Wt(Tt, ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"]);
        const mt = ct || getI18n();
        if (!mt) return warnOnce("You will need to pass in an i18next instance by using i18nextReactModule"), _e;
        const bt = pt || mt.t.bind(mt) || (It => It);
        ot && (at.context = ot);
        const gt = kt(kt({}, getDefaults()), mt.options && mt.options.react);
        let vt = dt || bt.ns || mt.options && mt.options.defaultNS;
        vt = typeof vt == "string" ? [vt] : vt || ["translation"];
        const xt = nodesToString(_e, gt),
            yt = lt || xt || gt.transEmptyNodeValue || nt,
            {
                hashTransKey: Et
            } = gt,
            wt = nt || (Et ? Et(xt || yt) : xt || yt);
        mt.options && mt.options.interpolation && mt.options.interpolation.defaultVariables && (st = st && Object.keys(st).length > 0 ? kt(kt({}, st), mt.options.interpolation.defaultVariables) : kt({}, mt.options.interpolation.defaultVariables));
        const St = st ? at.interpolation : {
                interpolation: Bt(kt({}, at.interpolation), {
                    prefix: "#$?",
                    suffix: "?$#"
                })
            },
            $t = Bt(kt(kt(Bt(kt({}, at), {
                count: et
            }), st), St), {
                defaultValue: yt,
                ns: vt
            }),
            Ct = wt ? bt(wt, $t) : yt,
            Rt = renderNodes(ut || _e, Ct, mt, gt, $t, ft),
            Pt = tt !== void 0 ? tt : gt.defaultTransParent;
        return Pt ? reactExports.createElement(Pt, ht, Rt) : Rt
    }
    const initReactI18next = {
            type: "3rdParty",
            init(_) {
                setDefaults(_.options.react), setI18n(_)
            }
        },
        I18nContext = reactExports.createContext();
    class ReportNamespaces {
        constructor() {
            this.usedNamespaces = {}
        }
        addUsedNamespaces(_e) {
            _e.forEach(et => {
                this.usedNamespaces[et] || (this.usedNamespaces[et] = !0)
            })
        }
        getUsedNamespaces() {
            return Object.keys(this.usedNamespaces)
        }
    }

    function Trans$1(_) {
        let xt = _,
            {
                children: _e,
                count: et,
                parent: tt,
                i18nKey: nt,
                context: ot,
                tOptions: at = {},
                values: st,
                defaults: lt,
                components: ut,
                ns: dt,
                i18n: ct,
                t: pt,
                shouldUnescape: ft
            } = xt,
            ht = Wt(xt, ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"]);
        const {
            i18n: mt,
            defaultNS: bt
        } = reactExports.useContext(I18nContext) || {}, gt = ct || mt || getI18n(), vt = pt || gt && gt.t.bind(gt);
        return Trans$2(kt({
            children: _e,
            count: et,
            parent: tt,
            i18nKey: nt,
            context: ot,
            tOptions: at,
            values: st,
            defaults: lt,
            components: ut,
            ns: dt || vt && vt.ns || bt || gt && gt.options && gt.options.defaultNS,
            i18n: gt,
            t: pt,
            shouldUnescape: ft
        }, ht))
    }
    const usePrevious = (_, _e) => {
        const et = reactExports.useRef();
        return reactExports.useEffect(() => {
            et.current = _e ? et.current : _
        }, [_, _e]), et.current
    };

    function useTranslation$1(_) {
        let _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
            i18n: et
        } = _e, {
            i18n: tt,
            defaultNS: nt
        } = reactExports.useContext(I18nContext) || {}, ot = et || tt || getI18n();
        if (ot && !ot.reportNamespaces && (ot.reportNamespaces = new ReportNamespaces), !ot) {
            warnOnce("You will need to pass in an i18next instance by using initReactI18next");
            const xt = (Et, wt) => typeof wt == "string" ? wt : wt && typeof wt == "object" && typeof wt.defaultValue == "string" ? wt.defaultValue : Array.isArray(Et) ? Et[Et.length - 1] : Et,
                yt = [xt, {}, !1];
            return yt.t = xt, yt.i18n = {}, yt.ready = !1, yt
        }
        ot.options.react && ot.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
        const at = kt(kt(kt({}, getDefaults()), ot.options.react), _e),
            {
                useSuspense: st,
                keyPrefix: lt
            } = at;
        let ut = _ || nt || ot.options && ot.options.defaultNS;
        ut = typeof ut == "string" ? [ut] : ut || ["translation"], ot.reportNamespaces.addUsedNamespaces && ot.reportNamespaces.addUsedNamespaces(ut);
        const dt = (ot.isInitialized || ot.initializedStoreOnce) && ut.every(xt => hasLoadedNamespace(xt, ot, at));

        function ct() {
            return ot.getFixedT(_e.lng || null, at.nsMode === "fallback" ? ut : ut[0], lt)
        }
        const [pt, ft] = reactExports.useState(ct);
        let ht = ut.join();
        _e.lng && (ht = `${_e.lng}${ht}`);
        const mt = usePrevious(ht),
            bt = reactExports.useRef(!0);
        reactExports.useEffect(() => {
            const {
                bindI18n: xt,
                bindI18nStore: yt
            } = at;
            bt.current = !0, !dt && !st && (_e.lng ? loadLanguages(ot, _e.lng, ut, () => {
                bt.current && ft(ct)
            }) : loadNamespaces(ot, ut, () => {
                bt.current && ft(ct)
            })), dt && mt && mt !== ht && bt.current && ft(ct);

            function Et() {
                bt.current && ft(ct)
            }
            return xt && ot && ot.on(xt, Et), yt && ot && ot.store.on(yt, Et), () => {
                bt.current = !1, xt && ot && xt.split(" ").forEach(wt => ot.off(wt, Et)), yt && ot && yt.split(" ").forEach(wt => ot.store.off(wt, Et))
            }
        }, [ot, ht]);
        const gt = reactExports.useRef(!0);
        reactExports.useEffect(() => {
            bt.current && !gt.current && ft(ct), gt.current = !1
        }, [ot, lt]);
        const vt = [pt, ot, dt];
        if (vt.t = pt, vt.i18n = ot, vt.ready = dt, dt || !dt && !st) return vt;
        throw new Promise(xt => {
            _e.lng ? loadLanguages(ot, _e.lng, ut, () => xt()) : loadNamespaces(ot, ut, () => xt())
        })
    }
    const Ctx = reactExports.createContext(null),
        langsLocaleToISO6391 = {
            "en-US": "en",
            "vi-VN": "vi",
            "id-ID": "id",
            "ja-JP": "ja",
            "ko-KR": "ko",
            "fr-FR": "fr",
            "es-ES": "es",
            "fil-PH": "tl",
            "ar-SA": "ar",
            "hi-IN": "hi",
            "tr-TR": "tr",
            "fa-IR": "fa",
            "pt-BR": "pt",
            "ru-RU": "ru",
            "de-DE": "de",
            "th-TH": "th",
            "fi-FI": "fi",
            "pl-PL": "pl",
            "it-IT": "it",
            "my-MM": "my",
            "nl-NL": "nl",
            "ur-PK": "ur",
            "uk-UA": "uk",
            "ms-MY": "ms",
            "bn-BD": "bn",
            "mr-IN": "mr",
            "ta-IN": "ta",
            "te-IN": "te",
            "en-IN": "en-IN"
        },
        formatLocales = memoize$1((_, _e) => {
            const et = Object.entries(_).reduce((tt, [nt, ot]) => {
                const at = nt.split("/").find(lt => lt !== "front-end" && lt.includes("-")) || "en-US",
                    st = langsLocaleToISO6391[at] || at.split("-")[0];
                return tt[st] = ot, tt
            }, {});
            return instance.options.backend.sources[_e] = et, et
        }),
        I18nProvider = React.memo(({
            children: _,
            locales: _e,
            namespace: et
        }) => {
            const tt = reactExports.useMemo(() => ({
                namespace: et,
                locales: formatLocales(_e, et)
            }), [et, _e]);
            return jsxRuntimeExports.jsx(Ctx.Provider, {
                value: tt,
                children: _
            })
        });
    instance.use({
        type: "backend",
        options: {},
        init(_, _e = {}, et = {}) {
            this.options = _e
        },
        async read(_, _e, et) {
            const tt = this.options.sources[_e],
                nt = tt && tt[_] ? await tt[_]() : {};
            et(null, nt)
        }
    }).use(initReactI18next).init({
        lng: "en",
        fallbackLng: "en",
        backend: {
            sources: {}
        }
    });

    function useNamespace() {
        const _ = reactExports.useContext(Ctx);
        if (_) return _.namespace;
        console.error && console.error("i18n namespace error!")
    }

    function useTranslation() {
        const _ = useNamespace();
        return useTranslation$1(_)
    }
    const Trans = _ => {
            const _e = useNamespace();
            return jsxRuntimeExports.jsx(Trans$1, Bt(kt({}, _), {
                ns: _e
            }))
        },
        {
            useProxy: useProxy$3,
            proxy: proxy$3,
            subscribe: subscribe$1
        } = valtio;
    class SettingStore extends State {
        constructor(_e) {
            super(_e), de(this, "initData"), this.initData = this.sync(), this.initData.then(() => {
                subscribe$1(this.state, () => this.save())
            })
        }
        async sync() {
            if (await accountStore.initData, !accountStore.state.login) return accountStore.waitLogin().then(() => this.sync()), this.state;
            const _e = await http.get("/account/setting/ns_user/get/");
            if (_e) try {
                this.setState(JSON.parse(_e))
            } catch (et) {} else this.save();
            return this.state
        }
        async save() {
            if (await accountStore.initData, !!accountStore.state.login) return http.post("/account/setting/ns_user/reset/", this.state)
        }
    }
    settingStore = new SettingStore(proxy$3({
        currencyFullName: !1,
        localeCurrencyName: "USD",
        enableLocaleCurrency: !1,
        currencyName: "BTC",
        hideSmallCurrency: !1,
        lastFiatCurrency: "",
        lastCryptoCurrency: "",
        lastNftCurrency: "",
        soundEffectEnable: !0
    })), useSetting = function() {
        return useProxy$3(settingStore.state)
    };
    const {
        useProxy: useProxy$2,
        proxy: proxy$2
    } = valtio;
    class BcdStore extends State {
        constructor(_e) {
            super(_e), de(this, "initData"), de(this, "isInited", !1), this.initData = this.initFn(), this.initData.then(() => this.isInited = !0)
        }
        async initFn() {
            await accountStore.initData, accountStore.state.login || accountStore.waitLogin().then(() => this.initFn());
            try {
                const _e = await http.get("/activity/recharge-bonus/dashboard/");
                if (_e) {
                    const et = _e.expiredTime || 0;
                    let tt = _e.rechargeValidNum || 0;
                    et < serverTime().getTime() && (tt = 4);
                    try {
                        this.setState(Bt(kt({}, _e), {
                            bonusAmount: _e.bonusAmount || "0",
                            bonusThreshold: _e.bonusThreshold || "0",
                            expiredTime: et,
                            bonusLog: _e.bonusLog || [],
                            firstExpiredTime: _e.firstExpiredTime || 0,
                            maxBonusRatio: _e.maxBonusRatio || {},
                            registerTime: _e.registerTime || 0,
                            releaseAmount: _e.releaseAmount || "0",
                            totalAmount: _e.totalAmount || "0",
                            rechargeValidNum: tt
                        }))
                    } catch (nt) {}
                }
            } catch (_e) {}
            return this.state
        }
    }
    const bcdStore = new BcdStore(proxy$2({
        bonusAmount: "0",
        bonusThreshold: "10",
        bonusItems: [],
        bonusLog: [],
        expiredTime: 0,
        firstExpiredTime: 0,
        maxBonusRatio: {},
        rechargeValidNum: 0,
        registerTime: 0,
        releaseAmount: "0",
        totalAmount: "0",
        specialDeposit: null,
        currencyName: "",
        currencyPrice: "",
        wagerRatio: "20%",
        fiatRecharge: null
    }));

    function useBcd() {
        const _ = useProxy$2(bcdStore.state);
        if (bcdStore.isInited) return _;
        throw bcdStore.initData
    }
    const $Reader = $protobuf.Reader,
        $Writer = $protobuf.Writer;
    $protobuf.util;
    const $root = $protobuf.roots.user || ($protobuf.roots.user = {}),
        BalanceChange = $root.BalanceChange = (() => {
            function _(_e) {
                if (_e)
                    for (let et = Object.keys(_e), tt = 0; tt < et.length; ++tt) _e[et[tt]] != null && (this[et[tt]] = _e[et[tt]])
            }
            return _.prototype.frontgroundId = 0, _.prototype.amountLogId = "", _.prototype.currencyName = "", _.prototype.mixedBalance = "", _.prototype.generalBalance = "", _.prototype.bonusBalance = "", _.prototype.mixedChangeAmount = "", _.prototype.generalChangeAmount = "", _.prototype.bonusChangeAmount = "", _.encode = function(_e, et) {
                return et || (et = $Writer.create()), _e.frontgroundId != null && Object.hasOwnProperty.call(_e, "frontgroundId") && et.uint32(8).int32(_e.frontgroundId), _e.amountLogId != null && Object.hasOwnProperty.call(_e, "amountLogId") && et.uint32(18).string(_e.amountLogId), _e.currencyName != null && Object.hasOwnProperty.call(_e, "currencyName") && et.uint32(26).string(_e.currencyName), _e.mixedBalance != null && Object.hasOwnProperty.call(_e, "mixedBalance") && et.uint32(34).string(_e.mixedBalance), _e.generalBalance != null && Object.hasOwnProperty.call(_e, "generalBalance") && et.uint32(42).string(_e.generalBalance), _e.bonusBalance != null && Object.hasOwnProperty.call(_e, "bonusBalance") && et.uint32(50).string(_e.bonusBalance), _e.mixedChangeAmount != null && Object.hasOwnProperty.call(_e, "mixedChangeAmount") && et.uint32(58).string(_e.mixedChangeAmount), _e.generalChangeAmount != null && Object.hasOwnProperty.call(_e, "generalChangeAmount") && et.uint32(66).string(_e.generalChangeAmount), _e.bonusChangeAmount != null && Object.hasOwnProperty.call(_e, "bonusChangeAmount") && et.uint32(74).string(_e.bonusChangeAmount), et
            }, _.decode = function(_e, et) {
                _e instanceof $Reader || (_e = $Reader.create(_e));
                let tt = et === void 0 ? _e.len : _e.pos + et,
                    nt = new $root.BalanceChange;
                for (; _e.pos < tt;) {
                    let ot = _e.uint32();
                    switch (ot >>> 3) {
                        case 1:
                            nt.frontgroundId = _e.int32();
                            break;
                        case 2:
                            nt.amountLogId = _e.string();
                            break;
                        case 3:
                            nt.currencyName = _e.string();
                            break;
                        case 4:
                            nt.mixedBalance = _e.string();
                            break;
                        case 5:
                            nt.generalBalance = _e.string();
                            break;
                        case 6:
                            nt.bonusBalance = _e.string();
                            break;
                        case 7:
                            nt.mixedChangeAmount = _e.string();
                            break;
                        case 8:
                            nt.generalChangeAmount = _e.string();
                            break;
                        case 9:
                            nt.bonusChangeAmount = _e.string();
                            break;
                        default:
                            _e.skipType(ot & 7);
                            break
                    }
                }
                return nt
            }, _
        })(),
        {
            useProxy: useProxy$1,
            proxy: proxy$1
        } = valtio,
        Decimal1 = ref$4(new Decimal$1(1)),
        Decimal0$1 = ref$4(new Decimal$1(0));
    class SystemStore extends State {
        constructor(_e) {
            super(_e), de(this, "initData"), de(this, "getIntl", memoize$1((et, tt) => {
                var nt;
                tt = getDefaultLang(tt);
                const ot = Intl.NumberFormat(tt, {
                    style: "currency",
                    currency: et.replace("FIAT", "")
                });
                return [ot, ((nt = ot.formatToParts(0).find(at => at.type === "currency")) == null ? void 0 : nt.value) || "$"]
            }, (et, tt) => et + tt)), this.initData = this.syncData(), isSSR || setInterval(() => this.syncData(), 3e5)
        }
        amount2usd(_e, et) {
            return _e.mul(this.getUsdPrice(et))
        }
        convertCurrency(_e, et, tt = "USD") {
            const nt = this.getUsdPrice(tt) || Decimal0$1;
            return nt.eq(0) ? Decimal0$1 : _e.mul(this.getUsdPrice(et)).div(nt)
        }
        bn2amount(_e, et) {
            return new Decimal$1(_e.toNumber()).div(this.state.currency[et].unitAmount)
        }
        getUsdPrice(_e) {
            return this.state.usdPrice[_e] || Decimal0$1
        }
        getCurrency(_e) {
            return this.state.currency[_e]
        }
        getPrecision(_e) {
            var et;
            return ((et = this.state.currency[_e]) == null ? void 0 : et.precisionUnit) || 8
        }
        getAlias(_e) {
            var et;
            return ((et = this.state.currency[_e]) == null ? void 0 : et.aliasCurrencyName) || _e
        }
        getCurrencySymbol(_e, et) {
            return et = getDefaultLang(et), this.getIntl(_e, et)[1]
        }
        toFiatStr(_e, et, tt) {
            return tt = getDefaultLang(tt), et = et.replace(/FIAT$/, ""), this.getIntl(et, tt)[0].format(_e.toNumber())
        }
        toCryptoStr(_e, et) {
            return _e = _e.todp(this.getPrecision(et), Decimal$1.ROUND_DOWN), _e.decimalPlaces() < 2 ? _e.toFixed(2) : _e.toString()
        }
        async syncData() {
            const _e = await http.get("/game/support/system/conf/", {
                cache: !0
            });
            _e.currency = _e.currencyV2.reduce((st, lt) => (st[lt.currencyName] = lt, st), {});
            const {
                currency: et,
                redPackageLimits: tt,
                rewardTypes: nt,
                rainLimit: ot,
                usdPrice: at
            } = _e;
            return Object.assign(this.state, this.formatData({
                currency: et,
                redPackageLimits: tt,
                rewardTypes: nt,
                rainLimit: ot,
                usdPrice: at
            })), this.state
        }
        formatData(_e) {
            function et(tt) {
                for (let nt in tt) tt[nt] = ref$4(new Decimal$1(tt[nt]));
                return tt
            }
            return _e.rainLimit = et(_e.rainLimit), _e.redPackageLimits = et(_e.redPackageLimits), _e.usdPrice = et(_e.usdPrice), _e.usdPrice.USD = Decimal1, _e.usdPrice.USDFIAT = Decimal1, _e
        }
    }

    function getDefaultLang(_) {
        return _ || navigator.language || "en-US"
    }
    let system;
    systemStore = new SystemStore(proxy$1({
        currency: {},
        rewardTypes: {},
        usdPrice: {},
        redPackageLimits: {},
        rainLimit: {}
    })), system = systemStore;

    function useSystem() {
        return useProxy$1(systemStore.state)
    }

    function useCurrencyConfig(_) {
        return useSystem().currency[_]
    }
    const {
        useProxy,
        proxy,
        ref,
        subscribeKey,
        subscribe
    } = valtio, Decimal0 = ref(new Decimal$1(0)), Decimal_1 = ref(new Decimal$1(-1)), Ue = class zr {
        constructor(_e) {
            de(this, "preDeduId", 0), de(this, "deductions", {}), de(this, "state", {}), de(this, "initData"), this.state = _e, this.updateDisplay = debounce(this.updateDisplay, 5e3), this.initData = (async () => {
                const et = localStorage.getItem("amount"),
                    tt = this.syncData();
                if (et) {
                    const nt = JSON.parse(et);
                    this.syncDataDict(formatWalletData(nt))
                }
                return tt
            })(), accountStore.initData.then(() => {
                subscribeKey(accountStore.state, "login", et => {
                    et && this.syncData()
                })
            }), this.initData.then(() => {
                const et = new Map;
                Object.values(this.state).forEach(({
                    displayStatus: tt,
                    currencyName: nt
                }) => {
                    et.set(nt, tt)
                }), subscribe(this.state, () => {
                    let tt = !1;
                    if (Object.values(this.state).forEach(({
                            displayStatus: nt,
                            currencyName: ot
                        }) => {
                            et.get(ot) !== nt && (tt = !0, et.set(ot, nt), nt === 1 ? this.state[ot].display = !0 : nt === 2 && (this.state[ot].display = !1))
                        }), tt) {
                        let nt = [];
                        et.forEach((ot, at) => {
                            nt.push({
                                currencyName: at,
                                status: ot
                            })
                        }), this.updateDisplay(nt)
                    }
                })
            }), userSocket.on("balance-change-v2", socket.decodeBind(this.onBalanceChange.bind(this), BalanceChange))
        }
        createDeduction(_e, et, tt = "nomal", nt = 2e4) {
            let ot = Date.now() % zr.DEDU_MOD;
            ot == this.preDeduId && ot++;
            const at = {
                id: ot,
                amount: _e,
                currencyName: et,
                type: tt,
                solved: !1,
                balance: Decimal_1,
                timer: 0
            };
            return nt > 0 && (at.timer = window.setTimeout(() => this.deleteDeduction(ot), nt)), this.deductions[ot] = at, this.preDeduId = ot, this.addDeduction(et, _e), ot
        }
        createStaticDeduction(_e = 0) {
            return zr.DEDU_MOD + _e
        }
        onBalanceChange({
            mixedBalance: _e,
            currencyName: et,
            mixedChangeAmount: tt,
            generalBalance: nt,
            bonusBalance: ot,
            frontgroundId: at
        }) {
            let st = this.deductions[at];
            const lt = new Decimal$1(tt || 0),
                ut = new Decimal$1(_e || 0),
                dt = this.state[et];
            st ? (dt.deducting = ref(dt.deducting.add(lt)), st.amount = st.amount.add(lt), st.balance = ut, st.solved && this.deleteDeduction(st.id)) : at >= zr.DEDU_MOD && app.emit("deduction", {
                id: at,
                amount: lt,
                balance: ut,
                currency: et,
                type: "show",
                solved: !0,
                timer: 0
            }), Object.assign(dt, {
                amount: ref(ut.sub(dt.deducting)),
                generalAmount: ref(new Decimal$1(nt || 0)),
                bonusAmount: ref(new Decimal$1(ot || 0))
            })
        }
        resolveDeduction(_e, et = !0) {
            const tt = this.deductions[_e];
            tt && (et && (tt.solved = !0, tt.balance == Decimal_1) || this.deleteDeduction(tt.id, et))
        }
        cancelDeduction(_e) {
            Object.values(this.deductions).forEach(et => {
                et.type === _e && this.deleteDeduction(et.id, !1)
            })
        }
        deleteDeduction(_e, et = !0) {
            const tt = this.deductions[_e];
            tt && (delete this.deductions[tt.id], tt.timer > 0 && window.clearTimeout(tt.timer), this.addDeduction(tt.currencyName, tt.amount.negated()), et && app.emit("deduction", tt))
        }
        addDeduction(_e, et) {
            const tt = this.state[_e];
            tt.amount = ref(tt.amount.sub(et)), tt.deducting = ref(tt.deducting.add(et))
        }
        async syncData() {
            const _e = await http.get("/user/amount/");
            this.syncDataDict(formatWalletData(_e.reduce((et, tt) => (tt.deducting = Decimal0, et[tt.currencyName] = tt, et), {})))
        }
        async syncDataDict(_e) {
            const et = Object.entries(_e).reduce((tt, [nt, ot]) => (tt[nt] = ot, tt), {});
            Object.entries(this.state).forEach(([tt, nt]) => {
                et[tt] && delete et[tt]
            }), Object.entries(_e).forEach(([tt, nt]) => {
                const ot = this.state[tt];
                if (ot) {
                    let at = nt,
                        {
                            bonusAmount: st,
                            amount: lt,
                            generalAmount: ut,
                            deducting: dt
                        } = at,
                        ct = Wt(at, ["bonusAmount", "amount", "generalAmount", "deducting"]);
                    ot.bonusAmount.eq(st) || (ot.bonusAmount = ref(st)), ot.amount.eq(lt) || (ot.amount = ref(lt)), ot.generalAmount.eq(ut) || (ot.generalAmount = ref(ut)), Object.assign(this.state[tt], ct)
                } else this.state[tt] = nt
            })
        }
        updateDisplay(_e) {
            http.post("/user/amount/display/", {
                list: _e
            })
        }
    };
    de(Ue, "DEDU_MOD", 20736e5);
    let Wallet = Ue;

    function formatWalletData(_) {
        return Object.entries(_).forEach(([_e, et]) => {
            et.deducting = ref(new Decimal$1(et.deducting)), et.amount = ref(new Decimal$1(et.amount)), et.bonusAmount = ref(new Decimal$1(et.bonusAmount)), et.generalAmount = ref(new Decimal$1(et.generalAmount))
        }), _
    }
    let wallet;
    walletStore = new Wallet(proxy({})), wallet = walletStore, useWallet = function(_) {
        return useProxy(_ ? walletStore.state[_] : walletStore.state)
    }, useLocalCurrency = function(_ = !1) {
        let {
            localeCurrencyName: _e,
            enableLocaleCurrency: et
        } = useSetting();
        const {
            i18n: tt
        } = useTranslation$1(), nt = tt.language;
        return et = et || _, _e = et ? _e : "", reactExports.useMemo(() => {
            if (_e) {
                const ot = {
                    currencyName: _e,
                    local2amount: (at, st = "USD") => systemStore.convertCurrency(at, _e, st),
                    amount2local: (at, st = "USD") => systemStore.convertCurrency(at, st, _e),
                    amount2localStr: (at, st = "USD") => systemStore.toFiatStr(ot.amount2local(at, st), _e, nt)
                };
                return ot
            } else return {
                currencyName: _e,
                local2amount: (ot, at = "USD") => ot,
                amount2local: (ot, at = "USD") => ot,
                amount2localStr: (ot, at = "USD") => systemStore.toCryptoStr(ot, at)
            }
        }, [_e, nt])
    };
    async function requestRecaptcha(_) {
        return captchaClient || detectCaptcha(), (captchaClient == null ? void 0 : captchaClient.request(_)) || "No captcha!"
    }
    class Captcha {
        constructor(_e) {
            de(this, "key"), de(this, "inited"), de(this, "timeout", 0), this.key = _e, this.inited = delay(8e3).then(() => this.init())
        }
        async request(_e) {
            await this.inited;
            const et = [this.requestCode(_e)];
            return this.timeout > 0 && et.push(delay(this.timeout).then(() => "time out")), await Promise.race(et)
        }
    }
    class Recaptcha extends Captcha {
        constructor() {
            super(...arguments), de(this, "timeout", 8e3)
        }
        async init() {
            return await loadScript(`https://www.google.com/recaptcha/api.js?render=${this.key}`), new Promise(_e => {
                grecaptcha.ready(_e)
            })
        }
        async requestCode(_e) {
            return env.isDev ? "" : grecaptcha.execute(this.key, {
                action: _e
            })
        }
    }
    class Hcaptcha extends Captcha {
        async init() {
            await loadScript("https://js.hcaptcha.com/1/api.js");
            const _e = "hcaptcha_container",
                et = document.createElement("div");
            et.id = _e, et.style.display = "none", document.body.appendChild(et), hcaptcha.render(_e, {
                size: "invisible",
                sitekey: this.key
            })
        }
        async requestCode(_e) {
            return env.isDev ? "" : (await hcaptcha.execute({
                async: !0
            })).response
        }
    }
    let captchaClient = null;

    function detectCaptcha() {
        const _ = env.RECAPTCHA_V3_ID,
            _e = env.HCAPTCHA_ID;
        _e ? captchaClient = new Hcaptcha(_e) : _ && (captchaClient = new Recaptcha(_))
    }
    const CoinIcon = React.memo(function _(tt) {
            var nt = tt,
                {
                    name: _e
                } = nt,
                et = Wt(nt, ["name"]);
            const ot = `/coin/${systemStore.getAlias(_e)}.black.png`;
            return jsxRuntimeExports.jsx("img", kt({
                className: "coin-icon",
                src: ot
            }, et))
        }),
        defaultSignStr = ["+", ""],
        CoinFormat = React.memo(function _(dt) {
            var ct = dt,
                {
                    name: _e,
                    amount: et,
                    className: tt,
                    icon: nt = !1,
                    showName: ot = !1,
                    disableLocal: at = !1,
                    sign: st = !1,
                    signStrs: lt = defaultSignStr
                } = ct,
                ut = Wt(ct, ["name", "amount", "className", "icon", "showName", "disableLocal", "sign", "signStrs"]);
            const pt = useLocalCurrency();
            let ft = at ? systemStore.toCryptoStr(new Decimal$1(et), _e) : pt.amount2localStr(new Decimal$1(et), _e);
            return !nt && ot && (ft += ` ${systemStore.getAlias(_e)}`), jsxRuntimeExports.jsxs("div", Bt(kt({
                className: cx(coinFormatWrap, "coin", "notranslate", tt, st && "has-sign")
            }, ut), {
                children: [jsxRuntimeExports.jsx("div", {
                    className: "amount amount-str",
                    children: ft
                }), nt && jsxRuntimeExports.jsx(CoinIcon, {
                    name: _e
                })]
            }))
        }),
        coinFormatWrap = "cq8kbks";
    var VipLevelStatus = (_ => (_[_.None = 0] = "None", _[_.Bronze = 1] = "Bronze", _[_.Silver = 2] = "Silver", _[_.Gold = 3] = "Gold", _[_.Platinum_I = 4] = "Platinum_I", _[_.Platinum_II = 5] = "Platinum_II", _[_.Diamond_I = 6] = "Diamond_I", _[_.Diamond_II = 7] = "Diamond_II", _[_.Diamond_III = 8] = "Diamond_III", _))(VipLevelStatus || {});
    const vipLevelsList = [{
            level: 0,
            xp: 0,
            type: 0
        }, {
            level: 1,
            xp: 1,
            type: 0
        }, {
            level: 2,
            xp: 100,
            type: 1
        }, {
            level: 3,
            xp: 200,
            type: 1
        }, {
            level: 4,
            xp: 1e3,
            type: 1
        }, {
            level: 5,
            xp: 2e3,
            type: 1
        }, {
            level: 6,
            xp: 3e3,
            type: 1
        }, {
            level: 7,
            xp: 4e3,
            type: 1
        }, {
            level: 8,
            xp: 5e3,
            type: 2
        }, {
            level: 9,
            xp: 7e3,
            type: 2
        }, {
            level: 10,
            xp: 9e3,
            type: 2
        }, {
            level: 11,
            xp: 11e3,
            type: 2
        }, {
            level: 12,
            xp: 13e3,
            type: 2
        }, {
            level: 13,
            xp: 15e3,
            type: 2
        }, {
            level: 14,
            xp: 17e3,
            type: 2
        }, {
            level: 15,
            xp: 21e3,
            type: 2
        }, {
            level: 16,
            xp: 25e3,
            type: 2
        }, {
            level: 17,
            xp: 29e3,
            type: 2
        }, {
            level: 18,
            xp: 33e3,
            type: 2
        }, {
            level: 19,
            xp: 37e3,
            type: 2
        }, {
            level: 20,
            xp: 41e3,
            type: 2
        }, {
            level: 21,
            xp: 45e3,
            type: 2
        }, {
            level: 22,
            xp: 49e3,
            type: 3
        }, {
            level: 23,
            xp: 59e3,
            type: 3
        }, {
            level: 24,
            xp: 69e3,
            type: 3
        }, {
            level: 25,
            xp: 79e3,
            type: 3
        }, {
            level: 26,
            xp: 89e3,
            type: 3
        }, {
            level: 27,
            xp: 99e3,
            type: 3
        }, {
            level: 28,
            xp: 109e3,
            type: 3
        }, {
            level: 29,
            xp: 119e3,
            type: 3
        }, {
            level: 30,
            xp: 129e3,
            type: 3
        }, {
            level: 31,
            xp: 153e3,
            type: 3
        }, {
            level: 32,
            xp: 177e3,
            type: 3
        }, {
            level: 33,
            xp: 201e3,
            type: 3
        }, {
            level: 34,
            xp: 225e3,
            type: 3
        }, {
            level: 35,
            xp: 249e3,
            type: 3
        }, {
            level: 36,
            xp: 273e3,
            type: 3
        }, {
            level: 37,
            xp: 297e3,
            type: 3
        }, {
            level: 38,
            xp: 321e3,
            type: 4
        }, {
            level: 39,
            xp: 377e3,
            type: 4
        }, {
            level: 40,
            xp: 433e3,
            type: 4
        }, {
            level: 41,
            xp: 489e3,
            type: 4
        }, {
            level: 42,
            xp: 545e3,
            type: 4
        }, {
            level: 43,
            xp: 601e3,
            type: 4
        }, {
            level: 44,
            xp: 657e3,
            type: 4
        }, {
            level: 45,
            xp: 713e3,
            type: 4
        }, {
            level: 46,
            xp: 769e3,
            type: 4
        }, {
            level: 47,
            xp: 897e3,
            type: 4
        }, {
            level: 48,
            xp: 1025e3,
            type: 4
        }, {
            level: 49,
            xp: 1153e3,
            type: 4
        }, {
            level: 50,
            xp: 1281e3,
            type: 4
        }, {
            level: 51,
            xp: 1409e3,
            type: 4
        }, {
            level: 52,
            xp: 1537e3,
            type: 4
        }, {
            level: 53,
            xp: 1665e3,
            type: 4
        }, {
            level: 54,
            xp: 1793e3,
            type: 4
        }, {
            level: 55,
            xp: 2081e3,
            type: 4
        }, {
            level: 56,
            xp: 2369e3,
            type: 5
        }, {
            level: 57,
            xp: 2657e3,
            type: 5
        }, {
            level: 58,
            xp: 2945e3,
            type: 5
        }, {
            level: 59,
            xp: 3233e3,
            type: 5
        }, {
            level: 60,
            xp: 3521e3,
            type: 5
        }, {
            level: 61,
            xp: 3809e3,
            type: 5
        }, {
            level: 62,
            xp: 4097e3,
            type: 5
        }, {
            level: 63,
            xp: 4737e3,
            type: 5
        }, {
            level: 64,
            xp: 5377e3,
            type: 5
        }, {
            level: 65,
            xp: 6017e3,
            type: 5
        }, {
            level: 66,
            xp: 6657e3,
            type: 5
        }, {
            level: 67,
            xp: 7297e3,
            type: 5
        }, {
            level: 68,
            xp: 7937e3,
            type: 5
        }, {
            level: 69,
            xp: 8577e3,
            type: 5
        }, {
            level: 70,
            xp: 9217e3,
            type: 6
        }, {
            level: 71,
            xp: 10625e3,
            type: 6
        }, {
            level: 72,
            xp: 12033e3,
            type: 6
        }, {
            level: 73,
            xp: 13441e3,
            type: 6
        }, {
            level: 74,
            xp: 14849e3,
            type: 6
        }, {
            level: 75,
            xp: 16257e3,
            type: 6
        }, {
            level: 76,
            xp: 17665e3,
            type: 6
        }, {
            level: 77,
            xp: 19073e3,
            type: 6
        }, {
            level: 78,
            xp: 20481e3,
            type: 6
        }, {
            level: 79,
            xp: 23553e3,
            type: 6
        }, {
            level: 80,
            xp: 26625e3,
            type: 6
        }, {
            level: 81,
            xp: 29697e3,
            type: 6
        }, {
            level: 82,
            xp: 32769e3,
            type: 6
        }, {
            level: 83,
            xp: 35841e3,
            type: 6
        }, {
            level: 84,
            xp: 38913e3,
            type: 6
        }, {
            level: 85,
            xp: 41985e3,
            type: 7
        }, {
            level: 86,
            xp: 45057e3,
            type: 7
        }, {
            level: 87,
            xp: 51713e3,
            type: 7
        }, {
            level: 88,
            xp: 58369e3,
            type: 7
        }, {
            level: 89,
            xp: 65025e3,
            type: 7
        }, {
            level: 90,
            xp: 71681e3,
            type: 7
        }, {
            level: 91,
            xp: 78337e3,
            type: 7
        }, {
            level: 92,
            xp: 84993e3,
            type: 7
        }, {
            level: 93,
            xp: 91649e3,
            type: 7
        }, {
            level: 94,
            xp: 98305e3,
            type: 7
        }, {
            level: 95,
            xp: 112641e3,
            type: 7
        }, {
            level: 96,
            xp: 126977e3,
            type: 7
        }, {
            level: 97,
            xp: 141313e3,
            type: 7
        }, {
            level: 98,
            xp: 155649e3,
            type: 7
        }, {
            level: 99,
            xp: 169985e3,
            type: 7
        }, {
            level: 100,
            xp: 184321e3,
            type: 7
        }, {
            level: 101,
            xp: 198657e3,
            type: 7
        }, {
            level: 102,
            xp: 212993e3,
            type: 7
        }, {
            level: 103,
            xp: 243713e3,
            type: 7
        }, {
            level: 104,
            xp: 274433e3,
            type: 7
        }, {
            level: 105,
            xp: 305153e3,
            type: 7
        }, {
            level: 106,
            xp: 335873e3,
            type: 7
        }, {
            level: 107,
            xp: 366593e3,
            type: 8
        }, {
            level: 108,
            xp: 397313e3,
            type: 8
        }, {
            level: 109,
            xp: 428033e3,
            type: 8
        }, {
            level: 110,
            xp: 458753e3,
            type: 8
        }, {
            level: 111,
            xp: 524289e3,
            type: 8
        }, {
            level: 112,
            xp: 589825e3,
            type: 8
        }, {
            level: 113,
            xp: 655361e3,
            type: 8
        }, {
            level: 114,
            xp: 720897e3,
            type: 8
        }, {
            level: 115,
            xp: 786433e3,
            type: 8
        }, {
            level: 116,
            xp: 851969e3,
            type: 8
        }, {
            level: 117,
            xp: 917505e3,
            type: 8
        }, {
            level: 118,
            xp: 983041e3,
            type: 8
        }, {
            level: 119,
            xp: 1122305e3,
            type: 8
        }, {
            level: 120,
            xp: 1261569e3,
            type: 8
        }, {
            level: 121,
            xp: 1400833e3,
            type: 8
        }, {
            level: 122,
            xp: 1540097e3,
            type: 8
        }, {
            level: 123,
            xp: 1679361e3,
            type: 8
        }, {
            level: 124,
            xp: 1818625e3,
            type: 8
        }],
        overLevelXp = 139264e3,
        hiddenAvatar = "common/avatar.png",
        logoPng = "logo/black.png",
        Avatar = React.memo(function _(st) {
            var lt = st,
                {
                    userId: _e,
                    name: et,
                    className: tt = "",
                    size: nt = "s",
                    tooltip: ot = !1
                } = lt,
                at = Wt(lt, ["userId", "name", "className", "size", "tooltip"]);
            const ut = new User({
                    userId: _e,
                    name: et
                }),
                dt = useAccount();
            let ct = "";
            return isSSR || (ct = `//img2.${env.host}/avatar/${_e}/${nt}`, ut.userId === dt.userId && (ct += `?t=${dt.avatarUpdateTime}`)), et === User.hiddenName && (ct = app.assets(hiddenAvatar)), et === "BCGame" && (ct = app.assets(logoPng)), jsxRuntimeExports.jsx(WithOutSsr, {
                children: jsxRuntimeExports.jsx("img", kt({
                    className: `avatar ${tt}`,
                    src: ct
                }, at))
            })
        }),
        UserInfo = React.memo(function _(ct) {
            var pt = ct,
                {
                    userId: _e,
                    name: et,
                    avatar: tt = !0,
                    className: nt = "",
                    tooltip: ot = !1,
                    children: at,
                    onClick: st,
                    at: lt = !1,
                    showName: ut = !0
                } = pt,
                dt = Wt(pt, ["userId", "name", "avatar", "className", "tooltip", "children", "onClick", "at", "showName"]);
            let ft = `#/user/profile/${new User({userId:_e,name:et}).userId}`;
            return et === User.hiddenName && (ft = ""), jsxRuntimeExports.jsxs(Link, Bt(kt({
                href: ft,
                className: cx(userWrap, "user-info", nt),
                onClick: st
            }, dt), {
                children: [tt && jsxRuntimeExports.jsx(Avatar, {
                    tooltip: ot,
                    userId: _e,
                    name: et
                }), ut && jsxRuntimeExports.jsx(UserName, {
                    at: lt,
                    className: "name",
                    userId: _e,
                    name: et
                }), at]
            }))
        }),
        UserName = React.memo(function _(ot) {
            var at = ot,
                {
                    userId: _e,
                    name: et,
                    at: tt = !1
                } = at,
                nt = Wt(at, ["userId", "name", "at"]);
            const st = useAccount(),
                lt = new User({
                    userId: _e,
                    name: et
                });
            let ut;
            const dt = et === User.hiddenName;
            return dt ? ut = jsxRuntimeExports.jsxs("span", {
                className: "hidden-name",
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: "Hidden"
                }), app.unsafeTranslate("common.hidden")]
            }) : lt.userId === st.userId ? ut = jsxRuntimeExports.jsx(MyName, {}) : ut = et, jsxRuntimeExports.jsxs("div", Bt(kt({}, nt), {
                children: [tt && !dt && "@", ut]
            }))
        }),
        MyName = React.memo(function _() {
            const _e = useAccount();
            return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                children: _e.name
            })
        }),
        UserTitle = React.memo(function({
            code: _,
            desc: _e,
            className: et
        }) {
            if (_.length == 0) return null;
            const tt = _.find(st => st === 80),
                nt = Math.max(..._),
                ot = tt || nt,
                at = (st, lt) => lt === ot ? st : null;
            return jsxRuntimeExports.jsx("div", {
                className: cx(titleViews, et),
                children: _.map((st, lt) => {
                    let ut = null,
                        dt;
                    switch (st) {
                        case 1:
                            ut = jsxRuntimeExports.jsx(Icon_Badge, {}, lt);
                            break;
                        case 2:
                            ut = jsxRuntimeExports.jsx(Icon_Diamond, {}, lt);
                            break;
                        case 3:
                            ut = jsxRuntimeExports.jsx(Icon_Diamond, {}, lt);
                            break;
                        case 4:
                            ut = jsxRuntimeExports.jsx(Icon_Crown, {}, lt);
                            break;
                        case -1:
                            ut = jsxRuntimeExports.jsx(Icon, {
                                name: "Official",
                                className: "bc-game"
                            }, lt);
                            break;
                        case 97:
                            ut = at(jsxRuntimeExports.jsx("span", {
                                className: "xicon-mark xicon-mark-bot",
                                children: "BUGER BOT"
                            }, lt), 97);
                            break;
                        case 80:
                            if (dt = _e && _e[lt], !dt) ut = at(jsxRuntimeExports.jsx("span", {
                                className: "xicon-mark xicon-mark-mod",
                                style: {
                                    backgroundColor: "#bf6ba2"
                                },
                                children: "Host"
                            }, lt), 80);
                            else {
                                const {
                                    name: ct,
                                    color: pt
                                } = getTitleColor(dt);
                                ut = at(jsxRuntimeExports.jsx("span", {
                                    className: "xicon-mark xicon-mark-mod",
                                    style: {
                                        backgroundColor: pt || "#bf6ba2"
                                    },
                                    children: ct || "Host"
                                }, lt), 80)
                            }
                            break;
                        case 89:
                            dt = _e && _e[lt], ut = at(jsxRuntimeExports.jsx("span", {
                                className: "xicon-mark xicon-mark-admin",
                                children: dt || "Admin"
                            }, lt), 89);
                            break;
                        case 98:
                            dt = _e && _e[lt], ut = at(jsxRuntimeExports.jsx("span", {
                                className: "xicon-mark xicon-mark-mod",
                                children: dt || "Mod"
                            }, lt), 98);
                            break
                    }
                    return ut
                })
            })
        }),
        Icon_Badge = () => jsxRuntimeExports.jsx("svg", {
            viewBox: "0 0 32 32",
            xmlns: "http://www.w3.org/2000/svg",
            children: jsxRuntimeExports.jsx("path", {
                fill: "#eb5858",
                d: "M26.026 18.723c-0.16 0.333-0.328 0.661-0.477 0.999-0.197 0.447-0.329 0.909-0.355 1.405-0.027 0.526-0.294 0.922-0.778 1.144-0.141 0.062-0.294 0.094-0.448 0.096-0.635 0.011-1.272 0.007-1.907 0.005-0.201 0-0.219-0.026-0.114-0.205 0.197-0.338 0.419-0.642 0.795-0.822 0.46-0.22 0.699-0.909 0.561-1.433-0.109-0.415-0.345-0.754-0.579-1.1-0.368-0.544-0.641-1.131-0.601-1.806 0.017-0.274 0.112-0.544 0.178-0.815 0.018-0.075 0.057-0.144 0.086-0.216l-0.057-0.028c-0.099 0.186-0.217 0.365-0.294 0.561-0.26 0.666-0.129 1.305 0.178 1.92 0.097 0.193 0.227 0.37 0.334 0.558 0.034 0.060 0.072 0.145 0.054 0.203-0.177 0.584-0.323 1.184-0.565 1.743-0.166 0.382-0.309 0.77-0.455 1.158-0.075 0.2-0.215 0.29-0.435 0.288-0.699-0.008-1.398-0.002-2.096-0.003-0.217 0-0.24-0.024-0.164-0.225 0.072-0.198 0.158-0.391 0.257-0.577 0.111-0.203 0.291-0.324 0.521-0.388 0.386-0.107 0.571-0.404 0.598-0.776 0.031-0.432 0.011-0.868 0.015-1.302 0.001-0.14-0.092-0.133-0.189-0.127-0.674 0.043-1.348 0.112-2.022 0.123-0.766 0.011-1.533-0.029-2.299-0.048-0.116-0.003-0.154-0.049-0.101-0.164 0.217-0.472 0.312-0.978 0.392-1.486 0.009-0.065-0.001-0.131-0.031-0.19-0.079 0.173-0.152 0.349-0.24 0.518-0.168 0.323-0.32 0.661-0.528 0.958-0.189 0.271-0.228 0.579-0.325 0.873-0.149 0.45-0.251 0.923-0.462 1.342-0.223 0.444-0.544 0.842-0.834 1.251-0.12 0.168-0.306 0.223-0.515 0.221-0.687-0.005-1.374 0-2.061 0.001-0.232 0-0.248-0.026-0.133-0.232 0.177-0.318 0.378-0.616 0.703-0.802 0.078-0.044 0.174-0.056 0.253-0.098 0.127-0.068 0.289-0.121 0.362-0.23 0.278-0.415 0.311-0.904 0.375-1.38-0.131 0.306-0.246 0.621-0.396 0.919-0.152 0.301-0.388 0.523-0.73 0.604-0.355 0.084-0.555 0.34-0.724 0.637-0.164 0.289-0.383 0.516-0.728 0.573-0.106 0.017-0.217 0.009-0.325 0.009-0.602 0.001-1.203 0.002-1.804 0-0.24-0.001-0.257-0.020-0.17-0.239 0.183-0.46 0.468-0.806 0.973-0.96 0.42-0.128 0.71-0.45 0.964-0.797 0.331-0.451 0.594-0.936 0.708-1.491 0.029-0.141 0.005-0.249-0.117-0.346-0.487-0.388-0.975-0.775-1.446-1.182-0.333-0.287-0.637-0.608-0.957-0.91-0.416-0.393-0.93-0.598-1.472-0.737-0.575-0.148-1.161-0.21-1.754-0.163-0.221 0.017-0.44 0.069-0.659 0.109-0.356 0.066-0.712 0.121-1.057-0.045-0.014-0.007-0.024-0.020-0.056-0.046l0.268-0.026 0.002-0.039c-0.162-0.040-0.323-0.084-0.487-0.118-0.13-0.027-0.223-0.067-0.274-0.215-0.036-0.103-0.14-0.192-0.231-0.266-0.186-0.154-0.239-0.306-0.094-0.482 0.091-0.11 0.237-0.216 0.373-0.241 0.487-0.090 0.849-0.343 1.12-0.747 0.635-0.945 1.46-1.653 2.562-1.989 0.406-0.124 0.831-0.157 1.256-0.067 0.056 0.012 0.133-0.018 0.182-0.053 0.078-0.056 0.136-0.14 0.213-0.198 0.283-0.213 0.635-0.061 0.669 0.291 0.015 0.152 0.003 0.306 0.003 0.491 0.047-0.069 0.087-0.114 0.112-0.167 0.085-0.181 0.208-0.267 0.423-0.28 0.886-0.052 1.771-0.156 2.657-0.044 0.278 0.035 0.469-0.105 0.688-0.203 0.645-0.289 1.306-0.558 2.019-0.551 0.456 0.004 0.855-0.107 1.267-0.274 1.452-0.589 2.96-0.885 4.529-0.724 0.492 0.050 0.978 0.177 1.458 0.301 0.737 0.191 1.454 0.443 2.134 0.795 1.181 0.612 1.977 1.569 2.509 2.767 0.479 1.079 0.762 2.215 0.927 3.379 0.066 0.469 0.303 0.848 0.54 1.228 0.412 0.659 0.836 1.311 1.283 1.947 0.235 0.334 0.5 0.655 0.904 0.819 0.16 0.065 0.192 0.249 0.047 0.345-0.2 0.133-0.423 0.266-0.654 0.312-0.816 0.163-1.512-0.094-2.089-0.684-0.53-0.542-0.855-1.195-1.037-1.926-0.019-0.074-0.048-0.146-0.073-0.219l-0.053-0.007zM2.994 14.481c0.135 0.148 0.141 0.165 0.023 0.364-0.081 0.136-0.050 0.201 0.095 0.254 0.287 0.107 0.599 0.123 0.895 0.045 0.816-0.215 1.645-0.327 2.484-0.408 1.239-0.119 2.447 0.015 3.629 0.374 0.715 0.217 1.415 0.485 2.122 0.728 0.032 0.011 0.071 0.001 0.125 0.001-0.023-0.054-0.031-0.094-0.053-0.124-0.461-0.618-0.904-1.251-1.394-1.845-0.344-0.417-0.783-0.745-1.281-0.956-0.461-0.197-0.942-0.209-1.431-0.204-0.426 0.004-0.809 0.133-1.168 0.349-0.465 0.28-0.922 0.575-1.396 0.838-0.304 0.168-0.633 0.301-0.998 0.221-0.21-0.046-0.253-0.125-0.142-0.31 0.129-0.215 0.263-0.431 0.426-0.619 0.507-0.584 1.106-1.042 1.86-1.264 0.221-0.065 0.447-0.113 0.721-0.182-0.136-0.039-0.226-0.077-0.319-0.089-0.396-0.050-0.776 0.024-1.136 0.189-0.855 0.394-1.51 1.019-2.030 1.792-0.153 0.227-0.334 0.419-0.567 0.563-0.154 0.095-0.309 0.19-0.466 0.286zM5.235 13.597c0.123-0.051 0.233-0.082 0.325-0.142 0.060-0.039 0.090-0.121 0.077-0.168s-0.061-0.101-0.153-0.104c-0.108-0.002-0.215 0.025-0.308 0.080-0.070 0.043-0.115 0.117-0.121 0.199-0.004 0.075 0.046 0.168 0.181 0.134z"
            })
        }),
        Icon_Diamond = () => jsxRuntimeExports.jsx("svg", {
            viewBox: "0 0 32 32",
            xmlns: "http://www.w3.org/2000/svg",
            children: jsxRuntimeExports.jsx("path", {
                fill: "#d169e6",
                d: "M24.699 7.987h-17.489l-4.983 6.559 13.724 15.455 13.724-15.455-4.976-6.559zM25.41 14.969c-0.661 0.021-2.224 0.162-3.076 1.021-0.901 0.901-1.013 2.59-1.028 3.181-0.014-0.605-0.12-2.372-1.048-3.294-0.859-0.852-2.463-0.929-3.097-0.922-0.162 0.007-0.267 0.007-0.267 0.007s0.099-0.007 0.267-0.007c0.605-0.035 2.097-0.204 2.949-1.048 1.063-1.063 1.183-3.090 1.197-3.329v0c-0.007 0.239-0.056 2.372 0.985 3.406 0.852 0.859 2.449 0.971 3.118 0.985 0.19-0.007 0.31-0.007 0.31-0.007s-0.12 0.007-0.31 0.007zM21.828 1.998c0 0-0.078 1.506 0.633 2.217s2.217 0.633 2.217 0.633-1.478-0.049-2.189 0.661c-0.711 0.711-0.661 2.189-0.661 2.189s0.049-1.534-0.676-2.259c-0.697-0.697-2.175-0.584-2.175-0.584s1.379 0.014 2.076-0.683c0.732-0.739 0.774-2.175 0.774-2.175zM27.831 5.165c0 0-0.056 1.028 0.429 1.513s1.513 0.429 1.513 0.429-1.006-0.035-1.492 0.45c-0.485 0.486-0.451 1.492-0.451 1.492s0.035-1.049-0.465-1.541c-0.472-0.479-1.485-0.401-1.485-0.401s0.943 0.007 1.415-0.465c0.5-0.492 0.535-1.478 0.535-1.478z"
            })
        }),
        Icon_Crown = () => jsxRuntimeExports.jsx("svg", {
            viewBox: "0 0 32 32",
            xmlns: "http://www.w3.org/2000/svg",
            children: jsxRuntimeExports.jsx("path", {
                fill: "#ffd308",
                d: "M27.924 14.807l-4.892 11.74h-14.063l-4.892-11.74c-1.198-0.105-2.14-1.099-2.14-2.324 0-1.294 1.049-2.344 2.344-2.344s2.344 1.049 2.344 2.344c0 0.498-0.157 0.957-0.421 1.336 0.827 1.307 2.274 2.18 3.937 2.18 2.182 0 3.999-1.497 4.522-3.516l0.035-0.197 0.131-2.472c-0.698-0.406-1.172-1.153-1.172-2.019 0-1.295 1.049-2.344 2.344-2.344s2.344 1.049 2.344 2.344c0 0.866-0.474 1.613-1.172 2.019l0.082 2.434 0.084 0.235c0.523 2.018 2.341 3.516 4.522 3.516 1.663 0 3.109-0.873 3.937-2.18-0.264-0.379-0.421-0.839-0.421-1.336 0-1.294 1.049-2.344 2.344-2.344s2.344 1.049 2.344 2.344c0 1.225-0.942 2.218-2.14 2.324z"
            })
        });

    function getTitleColor(_) {
        if (_.search(/\$\[#.+/) !== -1) {
            const _e = _.match(/\$\[(#.+)\](.+)/);
            return {
                color: _e && _e[1],
                name: _e && _e[2]
            }
        } else return {
            color: null,
            name: _
        }
    }
    const levelColor = ["#B1CAEB", "#E09A6A", "#E1E1E1", "#FFC329", "#9D63F6", "#9D63F6", "#F450A9", "#F450A9", "#F450A9"],
        getLevelInfo = _ => {
            const _e = vipLevelsList.length;
            if (_ < 0) return vipLevelsList[0];
            if (_ >= _e) {
                const et = _ - _e + 1,
                    tt = vipLevelsList[_e - 1].xp + et * overLevelXp;
                return {
                    level: _,
                    xp: tt,
                    type: VipLevelStatus.Diamond_III
                }
            }
            return vipLevelsList[_]
        },
        getUserLevelInfo = _ => {
            const _e = _ > 69,
                et = _e ? "svip" : "vip",
                tt = _e ? _ - 69 : _,
                nt = getLevelInfo(_),
                ot = levelColor[nt.type];
            return {
                isSvip: _e,
                vipLevel: tt,
                vipType: et,
                vipLevelColor: ot,
                vipTypeNum: nt.type
            }
        },
        UserLevel = React.memo(function _({
            level: _e,
            className: et = ""
        }) {
            const {
                isSvip: tt,
                vipLevel: nt,
                vipLevelColor: ot
            } = getUserLevelInfo(_e);
            return jsxRuntimeExports.jsx("div", {
                className: cx(userLevelWrap, "user-level", et, tt && " svip"),
                style: {
                    backgroundColor: ot
                },
                children: jsxRuntimeExports.jsxs("div", {
                    className: "level-wrap",
                    children: [jsxRuntimeExports.jsx("span", {
                        children: tt ? "SV" : "V"
                    }), jsxRuntimeExports.jsx("span", {
                        children: nt
                    })]
                })
            })
        }),
        userLevelWrap = "u1xn5uyu",
        userWrap = "u12rvwmw",
        titleViews = "t8wsmvw",
        we = class dr {
            constructor(_e) {
                de(this, "userId", 0), de(this, "name", ""), de(this, "nameId", ""), de(this, "key", ""), de(this, "isCasino", !1), de(this, "isOnline", !1), de(this, "lastSyncOnlineTime", 0);
                let et = dr.userDict[_e.userId];
                return et || (this.userId = _e.userId, dr.addCache(this), et = this), _e.name == dr.hiddenName || _e.name && et.name !== _e.name && (et.name = _e.name, et.nameId = this.getNameId(et.name), et.key = this.nameId.toLowerCase()), et
            }
            async syncOnlineStatus() {
                const _e = Date.now();
                _e - this.lastSyncOnlineTime > 36e5 && (this.lastSyncOnlineTime = _e, dr.syncOnline(this))
            }
            getNameId(_e = "") {
                _e = _e.replace(/\s(\w?)/, (nt, ot) => ot.toUpperCase());
                let et = _e.toLowerCase(),
                    tt = 1;
                for (; dr.keyDict[et];) _e = _e + tt, et = _e.toLowerCase(), tt++;
                return _e
            }
            static search(_e) {
                return _e = _e.toLowerCase(), dr.userList.filter(et => et.userId != 0 && et.name && et.key.indexOf(_e) != -1)
            }
            static findByName(_e) {
                return dr.userList.find(et => et.userId != 0 && et.name === _e)
            }
            static findByKey(_e) {
                return _e = _e.toLowerCase(), dr.userList.find(et => et.userId != 0 && et.key === _e)
            }
            static isFirend(_e) {
                return dr.firendDict[_e]
            }
            static addCache(_e) {
                if (dr.userDict[_e.userId] = _e, dr.userList.push(_e), dr.keyDict[_e.nameId] = _e, dr.userList.length > dr.MAX) {
                    const et = dr.userList.shift();
                    if (et == null) return;
                    delete dr.userDict[et.userId], delete dr.keyDict[et.nameId]
                }
            }
            static getName(_e) {
                return _e === dr.hiddenName ? app.unsafeTranslate("common.hidden") : _e
            }
        };
    de(we, "MAX", 5e3), de(we, "userList", []), de(we, "userDict", {}), de(we, "keyDict", {}), de(we, "firendDict", {}), de(we, "hiddenName", "****"), de(we, "syncOnline", debounceQueue(_ => {
        const _e = _.map(et => et.userId);
        http.post("/account/online/status/", {
            userIds: _e
        }).then(et => {
            _.forEach(tt => {
                tt.isOnline = et.indexOf(tt.userId) != -1
            })
        })
    }, 2e3)), User = we;
    const getShareRes = memoize$1(() => http.get("/agent/invitation/code/custom/")),
        getShareLink = memoize$1((_, _e) => http.post(`/game/support/share/short-link/${_}/`, _e));

    function getAssets(_) {
        return app.assets(`/share/share_${_}.png`)
    }

    function getShareLinks(_) {
        const _e = [{
            name: "email",
            url: void 0,
            icon: getAssets(10)
        }, {
            name: "facebook",
            url: "https://www.facebook.com/sharer.php?u=",
            baseUrl: "https://www.facebook.com/sharer.php?",
            icon: getAssets(3)
        }, {
            name: "twitter",
            url: "https://twitter.com/share?url=",
            baseUrl: "https://twitter.com/share?",
            icon: getAssets(8)
        }, {
            name: "telegram",
            url: "https://t.me/share?url=",
            baseUrl: "https://t.me/share?",
            icon: getAssets(7)
        }, {
            name: "vk",
            url: "http://vk.com/share.php?",
            icon: getAssets(11)
        }, {
            name: "lineit",
            url: "https://lineit.line.me/share/ui?",
            icon: getAssets(12)
        }, {
            name: "vertical",
            url: void 0,
            icon: getAssets(6)
        }, {
            name: "skype",
            url: "https://web.skype.com/share?",
            icon: getAssets(13)
        }, {
            name: "connect",
            url: "https://connect.ok.ru/dk?st.cmd=WidgetSharePreview&st.shareUrl=",
            icon: getAssets(4)
        }, {
            name: "btc",
            url: void 0,
            icon: getAssets(1)
        }, {
            name: "pinterest",
            url: void 0,
            icon: getAssets(15)
        }, {
            name: "linkedin",
            url: "https://www.linkedin.com/sharing/share-offsite/?",
            icon: getAssets(16)
        }, {
            name: "whatsapp",
            url: "https://api.whatsapp.com/send?",
            icon: getAssets(17)
        }, {
            name: "reddit",
            url: void 0,
            icon: getAssets(18)
        }];
        return Promise.all(_e.map(et => shareLink(kt({
            platform: kt({}, et)
        }, _))))
    }
    async function shareLink({
        platform: _,
        title: _e,
        content: et = "",
        imgUrl: tt,
        shareUrl: nt,
        isGame: ot = !0
    }) {
        let at = {
            invitationUrl: `${location.protocol}://${env.host}`,
            invitationCode: ""
        };
        if (accountStore.state.login && (at = await getShareRes()), !_.url) return _;
        tt = tt || `${location.protocol}//${env.host}/share_image.jpg`;
        const st = nt ? `${at.invitationUrl}/?p=${nt}` : at.invitationUrl;
        if (_.name === "facebook" || _.name === "twitter" || _.name === "telegram") {
            const lt = {
                    title: _e,
                    desc: et,
                    image: tt
                },
                ut = _.name === "facebook";
            if (!ot || !accountStore.state.login) {
                const dt = `title=${encodeURIComponent(_e)}&text=${encodeURIComponent(et)}&${ut?"u":"url"}=${encodeURIComponent(st)}`;
                _.baseUrl + dt
            } else {
                const dt = await getShareLink(at.invitationCode, lt);
                _.url + dt
            }
        } else {
            let lt = `url=${encodeURIComponent(st)}&title=${encodeURIComponent(_e)}&text=${encodeURIComponent(et)}`;
            _.url + lt
        }
        return _
    }
    let ErrorCode, GoogleCode, googleCodeWrap;
    ErrorCode = {
        TWOFA_ERROR: 4002,
        INSUFFICIENT_BALANCE: 5002,
        SAME_EMAIL: 5801,
        IS_MUTE: 6001,
        NEED_LOGIN: 6002,
        SESSION_ERROR: 6003,
        NEED_VERIFY: 6004,
        IS_BLOCKED: 6005,
        LOCKED_BY_KYC: 6008,
        NEED_EMAIL_AND_BASIC_KYC: 6101,
        NEED_EMAIL_AND_ADVANCED_KYC: 6102,
        NEED_PHONE_AND_BASIC_KYC: 6103,
        NEED_PHONE_AND_ADVANCED_KYC: 6104,
        NEED_EMAIL_OR_PHONE_AND_BASIC_KYC: 6105,
        NEED_EMAIL_OR_PHONE_AND_ADVANCED_KYC: 6106,
        NEED_EMAIL_AND_PHONE_AND_BASIC_KYC: 6107,
        NEED_EMAIL_AND_PHONE_AND_ADVANCED_KYC: 6108,
        NEED_BASIC_KYC: 6109,
        NEED_ADVANCED_KYC: 6110,
        FINAL_REJECT_KYC: 6111,
        IS_UPDATING: 1999
    }, GoogleCode = React.memo(function _({
        value: _e,
        onChange: et,
        autoFocus: tt = !1,
        className: nt
    }) {
        const [ot, at] = reactExports.useState(tt), st = reactExports.useRef(null), lt = ut => [1, 2, 3, 4, 5, 6].map((dt, ct) => jsxRuntimeExports.jsx("li", {
            className: ut.length === ct ? "active" : "",
            children: ut.slice(ct, ct + 1)
        }, dt));
        return useIsomorphicEffect(() => {
            tt && st.current && setTimeout(() => {
                var ut;
                return (ut = st.current) == null ? void 0 : ut.focus()
            }, 300)
        }, []), jsxRuntimeExports.jsx("div", {
            className: cx(googleCodeWrap, nt),
            children: jsxRuntimeExports.jsxs("div", {
                className: "google-input",
                children: [jsxRuntimeExports.jsx("input", {
                    ref: st,
                    value: _e,
                    onBlur: () => {
                        at(!1)
                    },
                    onFocus: () => at(!0),
                    onChange: ut => {
                        ut.target.value.length > 6 || et(ut.target.value)
                    },
                    autoComplete: "off"
                }), jsxRuntimeExports.jsx("ul", {
                    className: ot ? "focus-list" : "",
                    onClick: () => {
                        var ut;
                        (ut = st.current) == null || ut.focus(), at(!0)
                    },
                    children: lt(_e)
                })]
            })
        })
    }), googleCodeWrap = "gmdcq1k", BC = {
        CoinIcon,
        CoinFormat,
        UserInfo,
        UserName,
        Avatar,
        ErrorCode,
        GoogleCode,
        getShareLinks,
        vipLevelsList,
        UserLevel,
        UserTitle,
        getUserLevelInfo,
        getLevelInfo,
        levelColor
    }, minimal$2.util.Long = Long, minimal$2.configure(), bc_ui = Object.freeze(Object.defineProperty({
        __proto__: null,
        Active,
        ActiveProvider,
        AnimatedNumber,
        AppProvider,
        BC,
        Badge,
        Breadcrumb,
        Button: Button2,
        ButtonGroup,
        Carousel: Carousel$1,
        CircleCountdown,
        CloseIcon,
        CodeSegment,
        Confirm,
        Content,
        Countdown: Countdown$1,
        Decimal: Decimal$1,
        DecimalUtils,
        Dialog,
        DialogHeader,
        DialogTable,
        DragDialog,
        Empty,
        ErrorBoundary,
        ErrorCode: ErrorCode$1,
        ErrorWithTip,
        EventEmitter: EventEmitter$3,
        FileSelect,
        FlatList: FlatList$1,
        Howl: howler.Howl,
        HttpResponseError,
        I18n,
        I18nItem,
        I18nManager,
        I18nProvider,
        Icon,
        Image: Image$1,
        Imgix,
        Input,
        InputNumber,
        InputPassword,
        InputWrap,
        LayoutSizeProvider,
        LazyImage,
        Link,
        Loading: Loading$1,
        Long,
        Lottie,
        Overlayer,
        Pagination,
        Pop,
        Portal,
        Radio,
        RadioBase,
        ScrollView,
        Select: Select$1,
        SelectBase,
        Slider,
        State,
        SuspenseData,
        SuspenseSource,
        Swiper,
        Switch: Switch$1,
        Table,
        Tabs: Tabs$1,
        Text,
        Textarea,
        ToggleView,
        Tooltip,
        TooltipBase,
        Trans,
        UpdateInView: UpdateInView$1,
        User,
        VipLevelStatus,
        WithOutSsr,
        accountStore,
        addUserReceiptEvent,
        app,
        asyncQueue: AsyncQueue$1,
        bcdStore,
        dialog,
        env,
        formateContent,
        http,
        i18n: instance,
        langsLocaleToISO6391,
        lazyLoad,
        notify,
        pickLazyComponent,
        pickLazyFunction,
        pop,
        protobuf: minimal$3,
        requestRecaptcha,
        settingStore,
        socket,
        supportSocket,
        system,
        systemStore,
        useAccount,
        useActiveMemo,
        useAnimatedFrames,
        useAsync,
        useAsyncFn,
        useAsyncNode,
        useAutoRemove,
        useBcd,
        useChangeLang,
        useCurrencyConfig,
        useDelayHover,
        useDialog,
        useDisableBodyScroll,
        useDisableParentScroll,
        useForceUpdate,
        useHover,
        useI18n,
        useInOverlayer,
        useInView,
        useIntersection,
        useIsActive,
        useIsDarken,
        useIsFirstRender,
        useIsMobile,
        useIsomorphicEffect,
        useLayoutSize,
        useLinkIntercept,
        useLocalCurrency,
        useLocation,
        useMergeRefs,
        useMountedState,
        useNavigate,
        useOnClickOutside,
        usePageContext,
        usePageProps,
        usePop,
        usePortalContext,
        usePortalList,
        usePrevious: usePrevious$1,
        useQrcode,
        useResize,
        useRootClassName,
        useSetSearch,
        useSetState,
        useSetting,
        useSmoothList,
        useSystem,
        useToggleDarken,
        useTranslation,
        useWallet,
        useWindowSize,
        userSocket,
        utils: index$1,
        valtio,
        wallet,
        walletStore,
        wrUtils: F
    }, Symbol.toStringTag, {
        value: "Module"
    }))
})();
export {
    baseIsMatch as $, baseGetAllKeys as A, getTag$1 as B, nodeUtil$1 as C, baseUnary as D, isBuffer$3 as E, Stack as F, getAllKeys as G, arrayMap as H, baseIteratee as I, isTypedArray$2 as J, isArguments$1 as K, isFunction$1 as L, SetCache as M, cacheHas as N, baseSlice as O, mapToArray as P, basePropertyOf as Q, arrayFilter as R, Symbol$2 as S, hasPath as T, Uint8Array$2 as U, toFinite as V, WeakMap$2 as W, baseGet as X, castPath as Y, baseKeys as Z, baseIsEqual as _, __tla, app as a, camelToDash as a$, getMatchData as a0, coreJsData$1 as a1, stubFalse as a2, baseIsNative as a3, baseMatches as a4, baseMatchesProperty as a5, setToArray as a6, arraySome as a7, baseProperty as a8, hasIn as a9, useForceUpdate$1 as aA, mix as aB, moveItem as aC, motion as aD, motionValue as aE, interpolate as aF, useIsomorphicLayoutEffect$2 as aG, cancelFrame as aH, frame as aI, collectMotionValues as aJ, isMotionValue as aK, createDomVisualElement as aL, animations as aM, gestureAnimations as aN, drag as aO, layout as aP, animateValue as aQ, frameData as aR, millisecondsToSeconds as aS, invariant$1 as aT, progress as aU, velocityPerSecond as aV, defaultOffset as aW, warning$1 as aX, MotionValue as aY, transformProps as aZ, isCSSVariableName as a_, baseSortedIndexBy as aa, baseTimes as ab, stringToPath$1 as ac, baseTrim as ad, trimmedEndIndex as ae, Set$2 as af, chunk as ag, sortedIndexBy as ah, now$1 as ai, before as aj, debounce as ak, memoize$1 as al, once$1 as am, throttle as an, isLength as ao, unescape$2 as ap, property as aq, createMotionProxy as ar, createDomMotionConfig as as, loadExternalIsValidProp as at, reactExports as au, MotionConfigContext as av, useConstant as aw, loadFeatures as ax, LazyContext as ay, LayoutGroupContext as az, baseToString as b, easeInOut as b$, addUniqueItem as b0, removeItem as b1, hasReducedMotionListener as b2, initPrefersReducedMotion as b3, prefersReducedMotion as b4, memo as b5, isSVGElement as b6, SVGVisualElement as b7, HTMLVisualElement as b8, visualElementStore as b9, DragControls as bA, FlatTree as bB, PresenceContext as bC, SwitchLayoutGroupContext as bD, addPointerEvent as bE, addPointerInfo as bF, addScaleCorrector as bG, animationControls as bH, anticipate as bI, backIn as bJ, backInOut as bK, backOut as bL, buildTransform as bM, calcLength as bN, circIn as bO, circInOut as bP, circOut as bQ, clamp as bR, color as bS, complex as bT, createDomMotionComponent as bU, createMotionComponent as bV, cubicBezier as bW, delay$1 as bX, distance as bY, distance2D as bZ, easeIn as b_, spring as ba, calcGeneratorDuration as bb, maxGeneratorDuration as bc, isEasingArray as bd, fillOffset as be, secondsToMilliseconds as bf, animateSingleValue as bg, animateTarget as bh, useUnmountEffect as bi, addDomEvent as bj, motionComponentSymbol as bk, rootProjectionNode as bl, instantAnimationState as bm, optimizedAppearDataId as bn, animateStyle as bo, noop$4 as bp, makeUseVisualState as bq, animateVisualElement as br, VisualElement as bs, createBox as bt, getOrigin as bu, checkTargetForNewValues as bv, MotionContext as bw, easingDefinitionToFunction as bx, stepsOrder as by, AnimatePresence as bz, identity as c, Dialog as c$, easeOut as c0, filterProps as c1, isBrowser$1 as c2, isDragActive as c3, isValidMotionProp as c4, mirrorEasing as c5, optimizedAppearDataAttribute as c6, pipe as c7, px as c8, resolveMotionValue as c9, bc_ui as cA, react_dom as cB, ReactDOM as cC, react as cD, react_jsx_runtime as cE, jsxRuntime as cF, gsap as cG, gsapWithCSS as cH, react_router_dom as cI, accountStore as cJ, systemStore as cK, walletStore as cL, settingStore as cM, SuspenseSource as cN, usePageContext as cO, Empty as cP, I18n as cQ, Link as cR, useIsMobile as cS, useLayoutSize as cT, useMountedState as cU, useLocalCurrency as cV, useSetState as cW, notify as cX, Decimal$1 as cY, BC as cZ, Icon as c_, reverseEasing as ca, steps as cb, useAnimation as cc, useAnimationControls as cd, useDragControls as ce, useIsPresent as cf, usePresence as cg, reactDomExports as ch, useI18n as ci, useNavigate as cj, Lottie as ck, CloseIcon as cl, Button2 as cm, lazyLoad as cn, React as co, useAsync as cp, AppProvider as cq, WithOutSsr as cr, useIsomorphicEffect as cs, index$1 as ct, env as cu, useIsDarken as cv, http as cw, HttpResponseError as cx, socket as cy, pop as cz, isObject$2 as d, howler as d$, Loading$1 as d0, ScrollView as d1, dialog as d2, ErrorBoundary as d3, ToggleView as d4, useAccount as d5, usePageProps as d6, useSetting as d7, Select$1 as d8, Pagination as d9, Routes as dA, Route as dB, parsePath as dC, Action as dD, Router as dE, createPath as dF, useParams as dG, CircleCountdown as dH, createMemoryHistory as dI, EventEmitter$3 as dJ, Badge as dK, commonjsGlobal$1 as dL, getDefaultExportFromCjs$1 as dM, Textarea as dN, useIsActive as dO, Linear as dP, useAnimatedFrames as dQ, useLocation$1 as dR, valtio as dS, LocationContext as dT, DragDialog as dU, I18nManager as dV, I18nItem as dW, getNative as dX, getAugmentedNamespace$1 as dY, PQueue as dZ, F as d_, Input as da, useOnClickOutside as db, Countdown$1 as dc, Pop as dd, usePop as de, useDialog as df, Tabs$1 as dg, useResize as dh, Portal as di, useSmoothList as dj, Imgix as dk, useForceUpdate as dl, UpdateInView$1 as dm, Table as dn, InputNumber as dp, useWallet as dq, Tooltip as dr, DialogHeader as ds, Breadcrumb as dt, useAsyncNode as du, useIsFirstRender as dv, DialogTable as dw, InputPassword as dx, useChangeLang as dy, Switch$1 as dz, isObjectLike as e, minimal$3 as e0, userSocket as e1, User as e2, useToggleDarken as e3, Radio as e4, useDelayHover as e5, TooltipBase as e6, useAsyncFn as e7, useRootClassName as e8, useWindowSize as e9, Overlayer as ea, SuspenseData as eb, useDisableBodyScroll as ec, useInView as ed, SelectBase as ee, FlatList$1 as ef, LayoutSizeProvider as eg, pickLazyComponent as eh, useQrcode as ei, useActiveMemo as ej, Content as ek, formateContent as el, AnimatedNumber as em, RadioBase as en, FileSelect as eo, InputWrap as ep, Slider as eq, useLinkIntercept as er, isIndex as f, eq as g, isIterateeCall as h, isSymbol as i, jsxRuntimeExports as j, isPrototype as k, isArrayLike as l, keys$1 as m, n0 as n, arrayLikeKeys as o, get$1 as p, overArg as q, root$1 as r, baseGetTag as s, toInteger as t, toKey as u, toNumber as v, toString$5 as w, getSymbols$1 as x, stubArray as y, arrayPush as z
};